[
    {
        "title": "3Sum Closest",
        "question_content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 7883,
                "title": "c-solution-o-n-2-using-sort",
                "content": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "solutionTags": [],
                "code": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 7871,
                "title": "python-o-n-2-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 7873,
                "title": "a-n-2-solution-can-we-do-better",
                "content": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "solutionTags": [],
                "code": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "codeTag": "Unknown"
            },
            {
                "id": 8026,
                "title": "python-solution-two-pointer",
                "content": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1042348,
                "title": "faster-solution-about-95-faster-and-easy-solution-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/9acbb0ae-649b-4891-bdb3-21d55ae09a3e_1612031949.8420494.png)\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```Hey Folk I\\'m using Two Pointer technique technique if you really want to appreciate and fount it batter*** please Up vote Thank You:)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778177,
                "title": "python3-runtime-52-ms-faster-than-99-77",
                "content": "Easy recursive solution, works for any k, not only for 3\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365626,
                "title": "c-python-two-pointers-clean-concise",
                "content": "**Idea**\\n- Sort `nums` in increasing order.\\n- Let\\'s fix `nums[i]` by iterating `i` in range `[0..n-2]`, we using 2 pointers to find 2 elements in range `[i+1..n-1]`, so that `nums[i] + nums[l] + nums[r]` will have minimum difference with our `target`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^3` is number of elements in array `nums`.\\n- Space: from `O(sorting)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147500,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352747,
                "title": "java-3-pointers-explained",
                "content": "**Idea:** Similar to [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n* If sum of numbers at these 3 pointers equals target, then exit with target\\n* Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n* Else move the end pointer backwards because the sum is too high\\n* Keep a running minimum difference to find the closest the sum gets to target\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\nArrays.sort uses dual pivot quick sort which takes extra O(n) space\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7987,
                "title": "12-lines-concise-and-easy-understand-c-solultion",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2194572,
                "title": "python-accepted-solution-getting-tle-now",
                "content": "It seems like ~250 new test cases have been added to the problem recently which are now causing TLEs to previously accepted programs. See this submission of mine from March 2022 - https://leetcode.com/submissions/detail/666408027/. The same is now getting a TLE even after adding the optimization of skipping computations for duplicate elements.  \\n\\n**Solution which got accepted before but now giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\\n\\n\\n**Optimized solution - also giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7913,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**3Sum Closest** https://leetcode.com/problems/3sum-closest/\\n\\n**Brute-force: O(N^3)**\\n* Brute force solution will be O(N^3). We end up testing every subset and update the closest sum in every iteration.\\n\\n**Two Pointer Solution: O(N^2)**\\n* We can use the two pointer method to reduce complexity to O(N^2). We begin by sorting the array.\\n* Now we use three indices i,j and k. We iterate i from 0 to N (actually till N-2 is fine). We initialize j to i+1 and k to N-1.\\n* Now we compute curr_sum = nums[i]+nums[j]+nums[k]. If this equals target, we have the closest sum.\\n* Otherwise update closest_sum using the rule abs(curr_sum-target) < abs(closest_sum-target).\\n* Now what if curr_sum is less than target. Should we test (nums[i]+nums[j]+nums[k-1]), (nums[i]+nums[j]+nums[k-2]), (nums[i]+nums[j]+nums[k-3]) ? The answer is NO. All of these triplets will be less than curr_sum. And curr_sum is less than target - so there is no point testing these triplets. We must move forward by advancing j to j + 1 in the hope to get a larger triplet. This is the main intuition in this problem.\\n* You can visualize (6) by thinking all possible triplet sums sorted and arranged on a number line. When you find a curr_sum less than target, you increase curr_sum by increasing j. When you find a curr_sum less more than target, you reduce curr_sum by reducing k\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365711,
                "title": "c-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481580,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Sort the input array\\n2. Use two pointers `left` & `right` to calculate a local sum, compare the target with the local sum\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736495,
                "title": "java-fastest-and-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/5c5c0ba7-1c0d-4826-9c1e-c86de4dcb9db_1688821081.4729018.png)\\n\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164611,
                "title": "logical-thinking-with-code-beats-99-33",
                "content": "**Logical Thinking**\\nIf a candidate number `nums[pre]` is given, the problem is decreased to the **Two-sum Closest** problem -  find two integers in nums such that the sum is closest to `target - nums[pre]`. We need to try all possible `nums[pre]`.\\nWe\\'d better sort `nums[]` first. In this way, we can apply **Binary Search** in `2Sum Closest` rather than **Exhaustive Search**.\\n\\n**Trick**\\nThe condition to terminate **Binary Search** is not \\'`no searching space`\\' but \\'`not enough searching space`\\' for we need to maintain two valid candidates in the searching space `[lo, hi]` both inclusive.\\n\\n**Clear Code**\\n```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179560,
                "title": "c-two-pointer-approach-3-sum-variation",
                "content": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3116265,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159984,
                "title": "something-wrong-with-python3-interpreter",
                "content": "Something is wrong with the way the leetcode environment is processing python3 code! It is executing most code in far longer than it should.\\n\\nAt first I thought I just had a poor solution, but then I noticed that mine was functionally identical to the \\'correct\\' ones. I then copy and pasted previous examples of middle of the road times (~300ms): now they are exceeding time limit or are in the 9000ms+ range!\\n\\nConsider the following - its not my code, but an \"example 290ms\" one:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```\\n\\nThis code copy pasted in exceeds the time limit, rather than being in the ~300ms range.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7963,
                "title": "u3010python-u3011beating-95-solution-with-two-pointers-u3010o-n-2-u3011",
                "content": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2674627,
                "title": "java-sorting-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938326,
                "title": "most-efficient-python-code-that-beats-90-submissions-with-easiest-explanation",
                "content": "**Intution:**\\nWe\\'ll use **Three-pointer** approach in this question.\\nSort the given list in ascending order.\\nA pointer lets say \\'i\\' will be used to iterate through the given list nums.\\nWithin that loop, two more pointers lets say \\'start\\' and \\'end\\' would be initialised as follows:\\n\\tstart=i+1\\n\\tend=len(nums)-1\\nNow within this loop we will run another loop until the value of start in less than end.\\nTake a variable lets say \\'sum\\' to store value of nums[i]+nums[start]+nums[end].\\nIn this loop we would be checking for **3 conditions**.\\n**Condition 1:**\\nif **sum==target**, the sum contains the required answer as the minimum possible difference between any two numbers is 0 and sum-target will also give 0 in this case.\\n**Condition 2:**\\nif difference in target and sum is less than value contained by our \\'diff\\' variable(initialized with maximum possible value) the the diff would become equal to the absolute difference in target and sum and answer variable \\'ans\\' would be assigned the value of \\'sum\\', as this sum gives the minimum difference till now.\\n**Condition 3:\"**\\nWe\\'ll check if the value of sum is greater than target then the end will be decremented by one or else the start in incremented by one in case the sum is less than target.\\n**Code:**\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n^2)\\nSpace Complexity:\\nO(1) [constant]\\n**PLEASE UPVOTE THE ANSWER TO MOTIVATE ME FOR CONTINUING THE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493316,
                "title": "c-java-python-javascript-o-n-2logn-using-two-pointers",
                "content": "# Intuition:\\n\\nThe problem requires us to find a triplet of numbers in the given array, such that their sum is closest to the given target. We can use the two-pointer approach along with sorting the array to solve this problem.\\n\\n# Approach:\\n\\n1. Sort the given array in non-descending order.\\n2. Initialize a variable closest_sum to store the closest sum found so far. Set it initially to the sum of first three elements in the sorted array.\\n3. Loop over the array from i=0 to i=n-3, where n is the size of the array.\\n4. For each i, initialize two pointers, left and right, to i+1 and n-1 respectively.\\n5. While left < right, calculate the sum of the current triplet, sum = nums[i] + nums[left] + nums[right].\\n6. If sum is equal to the target, we have found the closest sum possible, so we can return it immediately.\\n7. If sum is less than target, increment left by 1. This will increase the sum, and we may get a closer sum.\\n8. If sum is greater than target, decrement right by 1. This will decrease the sum, and we may get a closer sum.\\n9. After each iteration of the inner loop, check if the absolute difference between sum and target is less than the absolute difference between closest_sum and target. If it is, update closest_sum to sum.\\n10. Return closest_sum after the loop ends.\\n# Complexity:\\n- Time Complexity: Sorting the array takes O(nlogn) time. The two-pointer approach runs in O(n^2) time. Therefore, the overall time complexity of the solution is O(n^2logn).\\n\\n- Space Complexity: We are not using any extra space in the solution. Therefore, the space complexity of the solution is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365598,
                "title": "3sum-closest-easy-w-approach-c-java",
                "content": "# **APPROACH:**\\n* Given an `array nums with n integers` and `one target`. We have to find `three integers` in nums such that the **sum is closest to the target**. We will return the sum of the three integers. \\n* We can take one assumption that each input would have exactly one solution. \\n\\n**TESTCASE:**\\nIf the given array is like `[-1,2,1,-4]` and the target is `1`, then the triplet will be `[-1,2,1]` this has the closest sum, that is `2`.\\n\\n# **ALGORITHM:**\\n\\n* Sort the array nums, ans := 0, diff := Infinity, n := size of nums\\n* for i in range 0 to n \\u2013 1\\n\\t* left := i + 1, right := n \\u2013 1\\n\\t* while left < right\\n\\t\\t* temp := nums[left] + nums[right] + nums[i]\\n\\t\\t* If `|target \\u2013 temp| < diff`, then ans := temp and diff := |target \\u2013 temp|\\n\\t\\t* If `temp = target`, then return temp, \\n\\t\\t* Otherwise when `temp > target`, then decrease right by 1, else increase left by 1\\n* return ans\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n`In Java`\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848622,
                "title": "java-simple-and-readable-solution-two-pointer",
                "content": "We can regard this quesiton as : \\na+b+c+min(difference) ? target \\nsum = a+b+c\\nthen we transferred the question sucessfully as Two Pointers.\\n\\nSo what we need now is the minimum diff and return sum(which is target - diff) at last\\nWatch out that diff could be both positive and negative, thus just comparing diff is meaningless.\\nWe can slove this by updating the diff original value IFF its absolute value smaller.\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430115,
                "title": "7-lines-code-with-detailed-explanation-of-approach-for-beginners-o-n-2-beginner-coders",
                "content": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 7906,
                "title": "7ms-and-o-n-2-java-solution",
                "content": "My solution does not need compare each sum ,just need to compare possible sum ,so can save time.\\n\\n    public class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }\\n                else{\\n                    while(low<high&&nums[low]+nums[high]<target-nums[i]) low++;\\n                    if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low-1]+nums[high];\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067315,
                "title": "faster-c-solution-o-n-3-o-n-2-40ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a variation of 2Sum and especially 3Sum problem. In 3Sum, we choose a triplet and checks its sum equal to 0(target). here we have to find the sum of triplet closest to target. so use the same approach as we have used in 3Sum problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst thing is to think how you can get closest sum. For this sort the vector for easiness. \\nif sum is greater then target, but we need sum closest, that is ,**the minimum sum greater than equal to target** declare min1 variable with **min1 = INT_MAX - 10000;** we did -10000 so that we can get rid of TLE.  and same for when sum is smaller than target , that is, **the greatest sum smaller than equal to target** for this declare, **max1 = INT_MIN + 10000** . if sum is equal to target return the sum. \\n\\nnow the question is which variale min1, max1 we have to return, for this, find the absolute difference of min1, max1 with target and return min1 or max1 as per the minimum diff obtained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173514,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Fix one var\\n- iterate the other two pointers nested\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899603,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675008,
                "title": "c-solution-with-explanations-brute-force-to-optimal-solution-explained",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- A basic approach using 3loops.\\n- We calculate the sum of 3 elements & store the difference of sum and target.\\n- If the difference is less than the minimum value we expected, then we\\u2019ll store the sum as ans.\\n- **Time complexity:** O(n^3).\\n\\n### Solution 02\\n\\n- Here we sort the array & will use 2 pointers to get the sum.\\n- Fix an index ***i*** & ***left=i+1, right=n-1.***\\n- If the sum of the 3 elements is less than the target, then we\\u2019ll shift the left pointer which will increase the value.\\n- Else we will shift right to decrease sum value.\\n- Also, we\\u2019ll calculate the difference and store in ***mn*** & update ***ans.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365863,
                "title": "python3-detailed-explanation-of-naive-2-pointer-solutions",
                "content": "## 0. Understanding the Problem\\nGiven:\\n- an array `nums`\\n- an integer `target`\\n\\nGoal: To find the sum of 3 numbers in `nums` that is closest to `target`.\\n\\nExample explaination:\\nnums = [-1,2,1,-4], target = 1\\n\\nThere are multiple possible combinations of which we have to find the minimum summing case. Infact there are nC3 total combinations.\\n\\nFor the given case, 2 is the solution, given by (-1, 2, 1).\\n\\n\\n## 1. Naive Solution\\nSince there are 3 numbers we need to take the sum of, we can simply loop and find the answer.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\\n\\n## 2. Observations\\n- The question asks for the `sum` and not the three numbers/indices themselves, this means operations like **sorting** could help us.\\n- The sort function takes `O(Nlog(N))` time. (The space complexity depends on what algorithm you choose to use. Heap sort takes `O(1)` space (its in-place). Merge sort takes `O(N)` space.) This time is also lesser than `O(N^3)` and `O(N^2)`.\\n- Considering the array sorted, what more can we derive?\\n\\nOne possible Solution:\\nInstead of 3 nested loops, we can have two nested loops and one binary search running, taking time complexity `O(N^2log(N) + Nlog(N))`. Which is the same as `O(N^2log(N))`. This is clearly better than `O(N^3).`\\n\\nThere\\'s one last observation needed for the best solution. \\nThe purpose of the loop is to \"specify\" one variable. When we do `for i in range(n)`, we specify the value for `i` for the loops nested inside of it (think about it, its trivial). Once we specify three of the values, we can make a comparison with `target` and decide whether to make it answer or not. This is the logic behind the three nested loops of the naive solution.\\n\\nBUT, note how once the array is sorted, we have a definite measurement of how the elements are palced. We can reuse this fact and have **two pointers**. One from `i+1`, called `l` and the other from `n-1`, called `r`, both going in the opposite directions. `l` goes to the right and `r` to the left. We can **greedily search for the answer**!\\n\\n*Since the array is sorted, we can always decide whether to move the `l` or the `r` pointer.*\\n\\nHow? Let\\'s see below!\\n\\n## 3. Optimal Solution\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```\\n\\nTime complexity: `O(Nlog(N) + N^2)`. `Nlog(N)` for the merge sort operation and `N^2` for the for loop & then the search from `l` to `r` (this will take up the entire range from `[i+1, n-1]`).\\n\\nSpace complexity: `O(N)` for the merge sort.\\n\\nQuestions? Feel free to ask below! Comments and criticisms are greatly appreciated. An upvote means this explaination helped you out :D\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7972,
                "title": "share-my-24-line-java-code-beats-94-57-run-times",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }\\n                    else if (sum > target) {\\n                        if (sum-target < diff) {\\n                            diff = sum-target;\\n                            closest = sum;\\n                        }\\n                        --j;\\n                    } else {\\n                        if (target-sum < diff) {\\n                            diff = target-sum;\\n                            closest = sum;\\n                        }\\n                        ++i;\\n                    }\\n                }\\n            }\\n            return closest;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }",
                "codeTag": "Java"
            },
            {
                "id": 3471166,
                "title": "beats-93-beginner-friendly-cpp-and-python-code-easy-to-understand",
                "content": "# Intuition\\nPLZ upvote if you like this\\n\\n# Python Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381792,
                "title": "easy-java-approach-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the input array nums to enable the two-pointer approach, which helps in efficiently finding the three integers with the closest sum to the target value.\\n\\nInitialize closestSum and minDiff to large values, as placeholders for the closest sum and minimum difference between sum and target, respectively.\\n\\nLoop through the array from index 0 to nums.length - 2, as the three-pointer approach requires at least three elements to find a sum.\\n\\nInside the loop, set up two pointers, left and right, to the elements immediately after the current element and the last element of the array, respectively.\\n\\nUse a while loop to continuously move the left and right pointers towards each other until they meet or cross each other.\\n\\nCalculate the current sum by adding the values at the current element, nums[left], and nums[right].\\n\\nCalculate the absolute difference between the current sum and the target value, and update minDiff and closestSum if the current difference is smaller than the previous minimum difference.\\n\\nIf the current sum is less than the target, increment the left pointer to consider a larger value.\\n\\nIf the current sum is greater than the target, decrement the right pointer to consider a smaller value.\\n\\nIf the current sum is equal to the target, return it as the closest sum.\\n\\nAfter the loop completes, return the closestSum as the final result, which represents the three integers in the array whose sum is closest to the target value. Note that the returned value may be greater or smaller than the target, depending on the input array and target value. Thus, the caller can check the actual difference between the returned sum and the target value if needed. Also, note that this code assumes that the input array nums has at least three elements. If that\\'s not guaranteed, appropriate error handling or input validation should be added. Additionally, the code assumes that the\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070001,
                "title": "easiest-c-solution-using-for-loop-and-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297535,
                "title": "python-two-pointer-solution-sped-up-with-binary-search-avoiding-tle",
                "content": "This solution runs in around 250ms to 300ms (faster than 80%) https://leetcode.com/submissions/detail/749879788/. Other two two-pointer solutions tend to be TLE since the new test cases were added. \\nIn the 3sum solution the update rule starts with\\n```\\nk = i+1\\nj = len(nums) - 1\\n```\\nand then increments these:\\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```\\nHowever, instead of updating these incrementally we can directly fast-forward them using binary search. i.e. at minimum nums[k] would have to be to flip the if statement is target - num[i] - nums[j]. The same logic can be applied to update j using binary search. \\n```\\ndef threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n \\n        best = None\\n        \\n        # The window is: [i, k, j]\\n        # Valid range for i:\\n        for i in range(0, len(nums) - 2):\\n            # Instead of incrementaly updating the j and k,\\n            # we can use binary search to find the next viable value\\n            # for each.\\n            # We pingpong between updating j and k\\n            pingpong = 0\\n            \\n            # Pick a k (j will be overriden on first pass)\\n            k = i+1\\n            j = len(nums)\\n\\n            while j > i + 2:\\n                if pingpong%2 == 0:\\n                    # Decrease j until sum can be less than target\\n                    targetVal = target - nums[i] - nums[k]\\n                    newj = bisect_left(nums, targetVal, k+1, j-1)\\n                    # There is no possible update to j, can stop\\n                    # searching\\n                    if newj == j:\\n                        break\\n                    j = newj\\n                    pingpong += 1\\n                else:\\n                    # Increase k until sum can exceed target\\n                    targetVal = target - nums[i] - nums[j]\\n                    k = bisect_left(nums, targetVal, i+1, j-1)\\n                    if nums[k] > targetVal and k > i+1:\\n                        k = k - 1\\n                    pingpong += 1\\n\\n                new = nums[i] + nums[k] + nums[j]\\n                if best is None or (abs(best - target) > abs(target - new)):\\n                    best = new\\n\\n                if best == target:\\n                    return target\\n\\n        return best",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nk = i+1\\nj = len(nums) - 1\\n```\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674384,
                "title": "python-solution-defeat-the-new-test-cases",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467590,
                "title": "javascript-99",
                "content": "Doing the Blind 75 List and posting all solutions.\\n\\n```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365667,
                "title": "python-two-pointers-2sum-explained",
                "content": "Very similar to the problem **15**, also 2 pointers idea. Now, instead of looking for sums equal to `target`, we perform 2 pointers and look for sums which are around `target`, that is if sum becomes bigger than `target` we move end pointer and in opposite case we move beg pointer. \\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n)` or `O(log n)` depening on sort function.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```\\n\\n#### Remark\\nThere are couple of optimization to make it work faster: `if ans == target: break` before the last return statement, and not using lambda functions to get min.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317287,
                "title": "c-solution-with-proper-explaination",
                "content": "This problem is variation of **2 sum**  poblem where we need to find the pairs equivalent to the given target.\\nThe 2 sum problem is further extended to **3 sum** where we need to return the tripet of array which is equal to 0.\\nHow this problem 3 sum closest is extension of 3 sum : \\nhere we just need to find three integers of nums vector that has closest sum to the given target.**\\n\\n**Steps to find closest 3 sum to the given target:**\\n1) sort the array(through sorting we can increase the efficiency of the solution)\\n   unless and until the array is sorted applying two pointer doesn\\'t make sense.\\n2)  use two pointer approach \\n3)  make a left pointing next to i and a right pointer at the end of it\\n4)  make a curr_sum variable \\n5)  check for the condition if target - curr_sum < min_diff\\n6)  if curr_sum > target than decrement the right pointer \\n7)  else increment left pointer.\\n **Time complexity - O(N^2)** \\n **space complexity - O(1)** as no extra space required\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```\\n**please upvote if you like the  solution and do comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159459,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8022,
                "title": "4-ms-c-solution-sample",
                "content": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "solutionTags": [],
                "code": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448416,
                "title": "c-very-easy-solution-beginner-friendly-two-pointers",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404344,
                "title": "java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678631,
                "title": "this-brute-force-solution-is-fast-and-here-is-why",
                "content": "## The solution\\n\\nMost solutions in the discussion are O(n^2) and take about 500ms+ in python3, some even got TLE if it lacks some early-stopping checks. However, the solution from here https://leetcode.com/problems/3sum-closest/discuss/778177/Python3-%3A-Runtime%3A-52-ms-faster-than-99.77, while using a brute-force approach, can reach under 200ms, which is significantly faster than other theoretically better O(n^2) solutions. His solution is as follow:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\\n\\n## Why on earth it is so fast ?\\nThe reason is smart prunning, more specifially these 2 checks speed up the code significantly:\\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\\nAnd to understand this, let\\'s look at some math. \\n\\nMathematically, if elements in nums are uniformly distributed then the distribution of all possible 3sum would be a bell curve that looks look like this. This is called [Irwin\\u2013Hall distribution or uniform sum distribution.](https://en.wikipedia.org/wiki/Irwin\\u2013Hall_distribution)\\n\\n![image](https://assets.leetcode.com/users/images/9349442b-52d4-4d30-80c5-e82f93ffd73e_1665281362.0298378.png)\\n \\nSo a random target would likely to be close to the mean of all possible 3sum, which means it would lie near the middle of the bell curve. So these 2 above checks essentially bypass many candidates that are too big (sum of numbers near the end) or too small (sum of numbers near the start). And by using recursion, this logic is applied at every k, effectively pruning a lot of cases. \\n\\nYou can check this by counting the number of times these 2 checks help the function return early.\\n\\n## Make it even faster\\n\\nBut that\\'s not all, the solution can be further optimized by changing the linear search in the base case\\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\\nto binary search\\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```\\nThis in theory is faster than the original solution. However for `len(nums) < 1000` which is small, the improvement is neligible.  \\n\\n## Final words\\nI think it is important to understand thoroughly why a solution is fast, rather than just judging it based solely on the big-O upper bound. \\n\\nIf you find this helpful, please leave  an upvote. Thank you",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677097,
                "title": "java-sort-and-two-pointers",
                "content": "# Intuition\\nWe need to find the closest triplet that sums to target.\\n\\nThe brute force way is to iterate `O(n^3)` and to try all triplets. We can do better.\\n\\nIf we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is `[-2,0,1,3,4,6,7]` and our target is `2` we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in `O(n)`.\\n\\nWe can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element `i` at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\nTo make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810579,
                "title": "c-easy-to-understand-simple-tc-o-n-2-sc-o-1-100",
                "content": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451359,
                "title": "python-easy-approach-beats-100-memory",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 278202,
                "title": "c-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083996,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nSorting & Two Pointer \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812696,
                "title": "c-java-python-javascript",
                "content": "![Screenshot 2023-07-25 at 10.14.24 AM.png](https://assets.leetcode.com/users/images/7c652887-773d-4629-8591-0183ac74f26b_1690260281.8217592.png)\\n\\n\\n## \\uD83C\\uDF38\\uD83E\\uDDE9 Problem Statement \\uD83E\\uDDE9\\uD83C\\uDF38\\n- Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\\n\\n- Return the sum of the three integers.\\n\\n- *You may assume that each input would have **exactly one solution**.*\\n\\n#### \\uD83D\\uDD2E Example 1 :- \\n```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\\n#### \\uD83D\\uDD2E Example 2 :- \\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\\n\\n## \\uD83E\\uDDE0 Optimal Approach Based on Sorting and Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n- The threeSumClosest function takes a vector nums and an integer target as input and returns an integer representing the sum of three elements closest to the target.\\n- It starts by sorting the input vector nums in ascending order using sort.\\n- Then, it iterates through the vector using a for-loop for each index i from 0 to n - 2, where n is the size of the vector.\\n- Inside the loop, it calls the Solve function, which uses a two-pointer approach to find the closest sum for the current index i.\\n- The Solve function uses two pointers, L and R, initialized to i + 1 and n - 1, respectively. It moves the pointers towards each other while calculating the sum of three elements (nums[x] + nums[L] + nums[R]) and updating the ans and mx variables based on the difference from the target.\\n- After iterating through all possible combinations of three elements, the function returns the final ans, which represents the sum of three elements closest to the target value.\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB Code \\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\\n\\n#### \\uD83C\\uDF38 Complexity\\n- Time complexity : $$O(n^2)$$\\n- Space complexity : $$O(1)$$\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB All Code \\n\\n- Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n- Python\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\\n- Javascript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675029,
                "title": "optimal-o-n-2-o-n-two-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282243,
                "title": "to-avoid-tle-in-python-optimization-tricks",
                "content": "You can optimize the classic approach to avoid TLE in Python. \\n\\nGiven the value of k, I pick the two rightmost numbers (which means it\\'s the largest value possible given k) and see if it\\'s still less than target. Ff it is, we use continue to avoid having the while loop run because it won\\'t get closer to the target than that.\\nSame logic can be applied to the other case where we pick the two left most points and if it\\'s greater than the target, we continue, but we can actually use break this time because we don\\'t need to even check larger values of k.\\n```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109008,
                "title": "python-easy-o-n-2",
                "content": "We assign the max and minimum value that we need to get.\\n**Sort the array.**\\n\\nWe iterate once to get one value. Then we put tw pointers , one at start and other at end.\\n\\n* If present value is in between min and max values we take that as answer and update min max.\\n* If value is less than min , increase the starting pointer\\n* If value is more than max, decrease the end pointer.\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2af13d6a-eaf0-491c-b710-ce227b31a353_1654332780.6307957.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498887,
                "title": "c-8-ms-faster-than-82-29",
                "content": "**Runtime: 8 ms, faster than 82.29% of C++ online submissions for 3Sum Closest.\\nMemory Usage: 8.7 MB, less than 77.36% of C++ online submissions for 3Sum Closest.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }\\n            \\n            fix += 1;\\n            \\n        }\\n        return tmp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 7961,
                "title": "simple-code-c",
                "content": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "solutionTags": [],
                "code": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7915,
                "title": "sharing-my-java-optimized-solution-5ms-beats-99-9",
                "content": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "solutionTags": [],
                "code": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678639,
                "title": "shortest-sol-using-python-professional-code",
                "content": "\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953872,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792491,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693054,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\n// We need to find the closest triplet that sums to target.\\n\\n// The brute force way is to iterate O(n^3) and to try all triplets. We can do better.\\n\\n// If we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is [-2,0,1,3,4,6,7] and our target is 2 we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in O(n).\\n\\n// We can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element i at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\n// To make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }\\n            \\n        }\\n        \\n        return closest;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2674362,
                "title": "python-implementation-with-two-pointers-open-question-about-runtime",
                "content": "**Python Implementation**\\nTwo pointers approach, similar with the solution of Question [_**3Sum**_](https://leetcode.com/problems/3sum/)\\n\\n```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\\n\\nBefore post this solution, I want to use the block if-statement to improve the readibility of the one-line statement. But it failed with TLE.\\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```\\n\\n### Open questions\\n - Do you have any idea on this?\\n - What\\'s the difference between the runtime of one-line if-statement and block if-statement in Python?\\n\\n![image](https://assets.leetcode.com/users/images/940686eb-abbd-42e0-91e3-cff4d8f88682_1665191244.2602255.png)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674295,
                "title": "daily-leetcoding-challenge-october-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2253091,
                "title": "c-fully-explained-with-intuition-and-steps",
                "content": "**Intuition** \\n\\nThe first thing which comes to our mind is taking the sum of all possible triplets and finding which sum is nearest to the target. However, this method is brute force and hence time consuming. It has a time complexity of O(n^3).\\n\\nNow, let\\'s try to optimise it. \\n\\nForget about 3 sum closest, think about 2 sum closest first. If we had to find pair whose sum is closest to target, what would we have done? Again the brute force approach would have been to find all possible pairs and comparing the sums with the target. It will have time complexity  of O(n^2). However, we could solve it by just sorting the array and using double pointer approach. We could take 2 pointers and find the sum of those and then change the position of pointers by comparing the sum with target. This will cost us O(nlogn) time complexity. \\n\\nBetter, isn\\'t it?\\n\\nWhy not do the same thing in 3 sum closest? The worst time it could take is O(n^2)\\n\\n**Steps**\\n1. Sort the nums vector\\n2. Fix a particular element say ```nums[i]```\\n2. Now every time you fix one element in nums, take a starting pointer ```i+1``` and ending pointer ```nums.size()-1```\\n3. While the starting pointer is less than ending pointer, keep comparing the absolute difference of sum (```sum = nums[i] + nums[start] + nums[end]```) with target.\\n3. If  ```sum > target``` decrement end pointer ```end--```\\n4. If  ```sum < target``` increment start pointer ```start++```\\n5. If ```sum==target``` just return target\\n6. Keep a variable ans to store the sum which is closest to target and keep updating the ans in each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```nums[i]```\n```i+1```\n```nums.size()-1```\n```sum = nums[i] + nums[start] + nums[end]```\n```sum > target```\n```end--```\n```sum < target```\n```start++```\n```sum==target```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227046,
                "title": "python-tle-for-o-n2-new-test-cases",
                "content": "Last time I did this question was on 16-06-2022, there were 132 cases. Leetcode has added new cases (current total = 381) since then and now my same solution is TLE.\\n\\nI am using the sort + two-pointer approach, and there is proof by contradiction, there is no better solution possible. The question is giving TLE for other submitted (top-votes discussion) solutions as well.\\nMy Python Solution\\n```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2193901,
                "title": "python-modified-3sum-approach",
                "content": "![image](https://assets.leetcode.com/users/images/10e73d09-7878-4a90-867d-fdf00e56ebc2_1656379823.6041436.jpeg)\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169868,
                "title": "python-solution-beats-83-240ms",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "codeTag": "Java"
            },
            {
                "id": 1447243,
                "title": "c-solution-4ms-98-63-5-7mb-92-88",
                "content": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366451,
                "title": "c-3-clean-approaches-go-from-naive-to-best",
                "content": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362223,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 447655,
                "title": "java-6ms-o-n-2-solution",
                "content": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260076,
                "title": "python-clear-solution-with-comments-o-n-2",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7885,
                "title": "12-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8004,
                "title": "self-explanatory-java-solution-using-two-pointers",
                "content": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7921,
                "title": "my-enhanced-n-2-answer-could-be-n-logn-minimum-time-12ms",
                "content": "The outer loop is same as most people;\\nFor the inner while loop, instead of gradually doing left++, right--, I use binary search to find the closest match.  Binary search interval should be [left+1, right-1].  I use STL <algorithm> lower_bound function.\\n\\nIf current num[left]+num[right] is greater than target, then we want to move \"right\" to the left, because num[right] is too big.\\n\\nWe use lower_bound to find a number that is closest to the \"final target\". i.e., target - num[i] - num[left], \\nIf lower_bound return  the iterator points to num[right], then we simply do right--, because that means the biggest number we can try next is num[right-1]\\n\\nIf current num[left]+num[right] is less than target, then we want to move \"left\" to the right, because num[left] is too small. \\nSearch  the \"final target\". i.e., target - num[i] - num[right], \\nIf lower_bound return  the iterator points to num[right], then that means all numbers in interval [left+1, right-1] are all too small to meet the target. Thus, we only need to calculate num[i]+num[right-1]+num[right] and see how close it is to the target. Then we break the while loop.\\n\\n    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    } \\n                    if(sum > new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[left]);\\n                        if (it == num.begin()+right) {\\n                            right--;\\n                        } else {\\n                          right = distance(num.begin(), it);\\n                        }\\n                      //  right--;     //original code\\n                    } else if (sum < new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[right]);\\n                        if( it == num.begin()+right) {  //cannot find anything big enough\\n                            left = right -1;\\n                            if ( std::abs(num[left]+num[right]+num[i] - target) < std::abs(closest-target) ) {\\n                                closest = num[left]+num[right]+num[i];\\n                            }                         \\n                            break;\\n                        } else {\\n                            left = distance(num.begin(), it);\\n                        }\\n                        \\n                        //  left++;   //original code\\n                    }\\n                    \\n                }\\n            }\\n            return closest;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3938010,
                "title": "swift-c-python-java-easy-to-understand-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|ans|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Swift\\n```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\\n# Java\\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889785,
                "title": "simple-solution-beats-95-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586091,
                "title": "three-sum-closest-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is same as the three sum which is by using three pointers,the only difference here to find the closest sum to target is to check if the absolute difference between the sum and the target is smaller than the absolute difference between closest and the target. If so, update closest to the current sum.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335232,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695684,
                "title": "c-binary-search-o-nlogn-faster-than-99",
                "content": "* Firstly, sort the vector.\\n* Then, take first and last pointers(here, i and j) as first and last elements of the vector.\\n* Now, binary search over the remaining vector and find when the difference of the target and the sum -- (nums[i] + nums[j] + nums[mid] ), where mid is from the binary search. \\n* Now, likewise increase or decrease the mid acc to requirement (less or more than target).\\n* Fix, where the abs dif. is least. Store it. \\n* Now, acc to the sign of dif., increment or decrement i or j. Continue until i>j. \\n\\nThe code - \\n\\n```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676920,
                "title": "python-99-62-faster-with-comments",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676452,
                "title": "c-two-pointer-o-n-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676281,
                "title": "java-98-23-two-pointers-binary-search",
                "content": "**Upvote  if you\\'re not greedy)))**\\n# Complexity\\n- Time complexity: n*log(n)\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675165,
                "title": "python-95-fast-with-binary-search-fewer-steps-in-the-inner-loop-still-o-n-2-in-time",
                "content": "Determine the initial pointers at the value of half of \\'target\\' - \\'nums[i]\\' by binary search, instead of two edges. This should have fewer inner loop steps.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674477,
                "title": "java-98-faster-code-easy-solution",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674375,
                "title": "c-python-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546678,
                "title": "python-beginner-friendly-fast-two-pointers",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431292,
                "title": "python-c-java-kotlin-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q16. 3Sum Closest***\\nGiven an integer array `nums` of length `n` and an integer `targe`t, find three integers in nums such that the sum is closest to `target`.\\n\\nReturn the sum of the three integers.\\n\\nYou may assume that each input would have exactly one solution.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\\n**Runtime:**  53 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n**Runtime:**  174 ms\\t\\n**Memory Usage:**  48.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:**  247 ms\\t\\n**Memory Usage:**  16.4 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Kotlin  Code** :\\n**Your runtime beats 89.21 % of kotlin submissions.**\\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```\\n**Runtime:**  971 ms\\t\\n**Memory Usage:**  51.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424972,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125533,
                "title": "easy-c-solution-0-n-2-two-pointer-approach",
                "content": "The Naive approach of this is used a three pointers and calculate the diff i.e` target-(nums[i] +nums[j] +nums[k])` and check if this is closet to target if yes then `update `else check another index...\\nIn this way We take 0(n^3) time complexity...\\n\\nCan We do better?? .......\\nYes We can\\n\\nNow suppose if i give u a problem to find the two integer which is closest to target and the array is sorted then how can you solve.......?\\n**Ans**- Obviously first thing come in my mind is use of two pointer `si,ei` where `si=0` and` ei=n-1`\\nand it takes 0(n) time complexity;...................Algo(1)\\n\\nNow we use two pointer approach in given array for every array index element how.? Lets understand..\\n\\nsuppose `target=x`\\nand i want to find three integers sum which is closest to target..\\nnow we break this into subproblem..\\nie. if at` index i` then our new target is find` target-(nums[i)` from `si=i+1` to `ei=n-1` by using Algo(1) we disscused previously \\nInitially our global` clsdiff `variable is used update when we find` diff` which is less than our` clsdiff` \\nand when we update then we store three integers in `a,b,c`\\n\\nHere is code...\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```\\n** Time Complextiy-0(n^2) space complexity-0(1)**\\n\\n***Please upvote if you find helpful***\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899763,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1541433,
                "title": "c-simple-solution-beats-90",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1453442,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186601,
                "title": "javascript-beats-99-60",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 553528,
                "title": "java-o-n-2-solution-using-sort-adds-on-twosum",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550566,
                "title": "python-o-n-2-easy-to-follow-solution",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419093,
                "title": "multiple-approaches-with-explanation",
                "content": "##### Approach 1: Brute Force Solution\\n```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n#####\\tAssumption: \\n- The min value is the sum of the first three elements in the given array and we use this as our starting point to look for the minimum value that is closest to the target\\n##### Complexity\\n- Time Complexity: O(n^3)\\n- Space Complexity: O(n)\\n\\n##### Approach 2:  Two Pointer Solution\\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n##### Complexity\\n- Time Complexity: O(n^2)\\n- Space Complexity: O(n)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395240,
                "title": "python-2-pointer-solution",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301562,
                "title": "python-solution-40ms-beat-99",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229111,
                "title": "rust-0ms",
                "content": "Unfortunately with range iterators it\\'s much slower.\\n\\n```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128797,
                "title": "python-44ms-beats-100-00",
                "content": "In each loop,\\nI judge if current number plus two largest numbers less than target,\\nor current number plus two lowest numbers greater than target.\\n\\n```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "solutionTags": [],
                "code": "```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7971,
                "title": "a-12ms-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }\\n            \\n            int left, right;\\n            sort(nums.begin(),nums.end());\\n            \\n            for(int i = 0; i < (len - 2); i++) {\\n                left = i + 1;\\n                right = len - 1;\\n                while(left < right) {\\n                    sum = nums[i] + nums[left] + nums[right];\\n                    if(abs(sum - target) <= dif) {\\n                        dif = abs(sum - target);\\n                        minsum = sum;\\n                    }\\n                    if(sum > target) right--;\\n                    if(sum < target) left++;\\n                    if(sum == target) return minsum;\\n                }\\n            }\\n            return minsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8011,
                "title": "java-o-n-2-clean-and-clear-solution",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }\\n            }\\n            return target + min_diff;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 8044,
                "title": "my-aceepted-o-n-2-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n        \\t\\t\\tif(sum>(target-num[i]))\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\thigh--;\\n    \\t\\t\\t\\t}\\n        \\t\\t\\telse\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\tlow++;\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn clostSum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3823730,
                "title": "java-python-c-js-solution-simple-and-explained-commented-multiple-language",
                "content": "# Intuition\\nOur aim is to find the three integers whose sum is closest to the given target value. To achieve this, the array is first sorted in ascending order, and then two pointers (j and k) are used to scan the array from the start and end while maintaining a variable closestSum to track the closest sum found so far.\\n\\n# Approach\\n1. Sort the input array nums in ascending order using Arrays.sort(nums).\\n2. Initialize the variable closestSum to store the closest sum of three integers found so far. Set it to the sum of the first three elements of the sorted array (nums[0] + nums[1] + nums[2]).\\n3. Iterate through the array using a loop with an index variable \\'i\\'. The loop runs from index 0 to \\'nums.length - 2\\' to ensure enough elements are available for forming triplets.\\n4. For each \\'i\\' index, initialize two pointers \\'j\\' and \\'k\\'. \\'j\\' starts from \\'i+1\\', and \\'k\\' starts from \\'nums.length - 1\\'.\\n5. Use a while loop with conditions \\'j < k\\' to explore all possible combinations of triplets.\\n6. Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n7. Check if the current sum is closer to the target than the previous closest sum using the helper function compare.\\n8. If the current sum is closer to the target, update the closestSum to the current sum.\\n9. If the sum is less than the target, increment \\'j\\' to move towards higher values and potentially get closer to the target sum.\\n10. If the sum is greater than the target, decrement \\'k\\' to move towards lower values and potentially get closer to the target sum.\\n11. Continue this process until \\'j\\' becomes greater than or equal to \\'k\\'.\\n12. The process is repeated for all \\'i\\' indices to find the three integers whose sum is closest to the target.\\n13. Return the closestSum, which represents the sum of the three integers that have the closest sum to the given target value.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\nwhere n is number of elements in array\\n\\n- Space complexity:\\nO(1)\\n\\n# Request\\n![LeetCode Upvote Request.webp](https://assets.leetcode.com/users/images/2798aaa4-6440-43bb-9d13-a925e5491c2f_1690459953.7107084.webp)\\n\\n\\n# Code\\n- JAVA\\n```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\\n\\n- Python\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\\n\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\\n\\n- JavaScript\\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748757,
                "title": "easy-solution-using-sorting-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682363,
                "title": "c-easy-solutions-simple-explanation-two-pointer-approach",
                "content": "# Intuition\\n- Sorting the array is crucial for applying the two-pointer technique. It allows us to efficiently move the pointers towards each other, converging on the closest sum to the target.\\n- By iterating over each element as the first element of the triplet, we ensure that we explore all possible combinations and find the closest sum.\\n- The two-pointer technique helps us explore different combinations of elements without having to consider every possible triplet, significantly reducing the time complexity.\\n- By updating the minimum difference (diff) and the closest sum (ans) whenever a closer sum is found, we ensure that we have the correct answer when the algorithm finishes.\\n- Overall, the intuition behind this approach is to use the sorted nature of the array and the two-pointer technique to efficiently explore different combinations of elements and find the closest sum to the target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the array in ascending order.\\n- Initialize variables for the minimum difference (diff) and the closest triplet sum (ans).\\n- Iterate over each element in the array.\\n- Use two pointers (left and right) to find the closest triplet sum to the target.\\n- Calculate the current triplet sum.\\n- Update diff and ans if the current sum is closer to the target.\\n- Adjust the pointers based on the value of the current sum.\\n- Repeat steps 5-7 until the pointers meet.\\n- Return the closest triplet sum (ans).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n^2) due to the nested loops, where n is the size of the input array.\\n{ Sorting the array using sort(nums.begin(), nums.end()) takes O(n log n) time, where n is the size of the input array nums.\\nThe main part of the code consists of nested loops. The outer loop iterates n times, and the inner while loop, in the worst case, iterates n/2 times (when j and k start from the opposite ends of the array).\\nThus, the overall time complexity is O(n log n + n^2), which simplifies to O(n^2) since n^2 dominates n log n. }\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(1) because the code uses a constant amount of additional space to store variables (diff, ans, n, i, j, k, and sum). The space required does not depend on the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633271,
                "title": "easy-to-understand-c-solution-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567201,
                "title": "bruteforce-o-n-3-to-optimized-o-nlog-n-n-2-code",
                "content": "# 1. Brute Force Code\\n### Approach\\nBrute Force Approach - Checking for all the possible triplets and then finding the closestSum be analysing the closeness of the currentSum by target. \\n\\n### Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\\n\\n# 2. Optimized 2 Pointers Code\\n### Approach\\n- Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n- If sum of numbers at these 3 pointers equals target, then exit with target\\n- Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n- Else move the end pointer backwards because the sum is too high\\n- Keep a running minimum difference to find the closest the sum gets to target \\n\\n### Complexity\\n- Time complexity: O(nlog(n) + n^2)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282146,
                "title": "java-runtime-17ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275736,
                "title": "easy-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237073,
                "title": "javascript-best-way-explanation-easy-to-solve",
                "content": "\\n# Approach\\n i Use a two-pointer approach to find the three integers in nums that add up to the closest sum to target. The algorithm first sorts the input array in ascending order. It then initializes the closest sum to the sum of the first three elements in the sorted array.\\n\\nThe algorithm then iterates through each element of the array, treating it as the first element of a possible three-sum combination. For each first element, it uses two pointers, left and right, to search for the two other elements that sum to the closest possible value to target. The pointers start at the first element after the first element and at the last element of the array, respectively. The pointers move towards each other until they meet. For each combination of `nums[i]`, `nums[left`], and `nums[right]`, the algorithm computes the sum and checks if it is closer to target than the current closest sum. If it is, the closest sum is updated. Finally, the algorithm returns the closest sum found.\\n\\ni assume that the input array nums has at least three elements. If the input array has fewer than three elements, the implementation may produce incorrect results. To handle this case, additional logic would be needed to check the length of the input array before attempting to find the closest three-sum.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220908,
                "title": "triple-threat-finding-the-closest-three-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use a similar approach to the three sum problem. We first sort the input array and fix the first element in the triplet. Then, we use two pointers to search for the remaining two elements such that the sum is closest to the target.\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the input array nums.\\n\\n- Initialize a variable diff to store the difference between the target and the sum of the triplet. Initialize a variable res to store the sum of the closest triplet found so far.\\n\\n- Loop over the input array nums from the first element to the second last element.\\n\\n- Initialize two pointers left and right to search for the remaining two elements such that the sum is closest to the target.\\n\\n- While left < right, calculate the sum of the triplet nums[i] + nums[left] + nums[right].\\n\\n- If the absolute difference between the target and the sum is less than the absolute difference between the target and the current value of res, update res to the sum.\\n\\n- If the sum is less than the target, increment the left pointer. Otherwise, decrement the right pointer.\\n- Return the value of res.\\n# Complexity\\n- Time complexity: The time complexity of the above algorithm is $$O(n^2)$$, where n is the length of the input array nums. This is because we have two nested loops to search for the remaining two elements such that the sum is closest to the target.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the above algorithm is $$O(1)$$ because we are using constant extra space to store the variables diff and res.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811774,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811445,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2753073,
                "title": "python-solution-two-pointers",
                "content": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 2677030,
                "title": "brute-force-optimized-faster-than-98",
                "content": "## Brute Force Solution: O(n^3)\\n```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\\n\\n## Optimized Solution. Break problem into two sum. O(n^2)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```\\n\\n**Do give a rep if you find the solution helpful ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676496,
                "title": "python",
                "content": "**The Logic**:\\nFirst we sort `nums` in O(nLogn).\\nThen, we fix one number by looping through the `nums`. As soon as one number is fixed - we can iterate two other numbers simultaneously. How? Let `hi = len(nums) - 1` and `lo = i + 1` where `i` is fixed (first out of three numbers).\\nWe sum the numbers - `s`. If it is lower than the `target` - what can we do? We can only increase `lo` by one - because `nums` are sorted. By that, we are trying to increase the sum `s`. We keep moving `lo` by one until `s` is lower than the `target`. As soon as we got a number higher than the `target`, we can try to decrease it. Either we decrease `lo` by one - but we already had it before. Or we can decrease `hi` by one. So, the total sum should be decreased, because the array is sorted.\\nThus we have one loop and one nested loop - O(N^2).\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675865,
                "title": "rust-33-ms-fastest-100-two-pointers-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/817764364/) employs a two-pointers approach with sorting. It demonstrated **33 ms runtime (100.00%)** and used **2.2 MB memory (15.46%)**. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675826,
                "title": "easy-cpp-2-pointer-simple-approach",
                "content": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2675529,
                "title": "python-two-pointer-solution-with-explanation",
                "content": "sort ```nums``` first, we can check the largest three and smallest three values,\\n\\nif the sum of smallest three values is greater than or equal to ```target```, return it\\nif the sum of largest three values is smaller than or equal to ```target```, return it\\n\\nand fix one value```pivot```, and find the other two value is the closet to the ``` target ``` in the ```[l, r]```.\\n\\nbecause ```nums``` is sorted,\\n\\nif the sum of the smallest two value ```nums[l] + nums[l+1]``` is greater than or equal to ```delta```, which means all the pair in the current and next iteration are greater than ```delta```, no need to check them, just return ```ans```\\n\\nif the sum of the largest two value ```nums[r-1] + nums[r]``` is smaller than or equal to ```delta```, which means all the pair in the current iteration are smaller than ```delta```, no need to check them, just go to the next iteration\\n\\ntc is ```O(N^2)```, sc is ```O(1)```\\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```target```\n```target```\n```pivot```\n``` target ```\n```[l, r]```\n```nums```\n```nums[l] + nums[l+1]```\n```delta```\n```delta```\n```ans```\n```nums[r-1] + nums[r]```\n```delta```\n```delta```\n```O(N^2)```\n```O(1)```\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675440,
                "title": "python-easy-o-n-2-solution-with-removed-iteration-for-same-set-of-3-values",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675018,
                "title": "cpp-solution-notes-video-explanation-how-to-approach-this-problem",
                "content": "Please visit my channel, and support me by liking, sharing, and subscribing my channel.\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CclNyWEnp2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n# Notes:\\n\\n![image](https://assets.leetcode.com/users/images/d40168a9-8bde-4a33-a0a6-cf43e25fa7b2_1665209465.7496073.png)\\n![image](https://assets.leetcode.com/users/images/6af06b4f-60f2-4326-afb0-114902c92b05_1665209488.0175567.png)\\n** second ++;\\n\\n\\n# Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674491,
                "title": "c-python-short-concise-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674469,
                "title": "daily-leetcode-solution-3-sum-closest",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674460,
                "title": "16-python-java-c-javascript-solutions",
                "content": "Python:\\n```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\\nJava:\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\\nC++:\\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\\nJavascript:\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674413,
                "title": "c-two-pointer-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1;\\n            int k=n-1;\\n        \\n            while(j<k)\\n            {\\n                 int sum=nums[i]+nums[j]+nums[k];\\n                \\n                if(abs(sum-target) < diff)\\n                {\\n                    diff=abs(sum-target);\\n                    Res=sum;\\n                }\\n                \\n                if(sum > target) k--;\\n                \\n                else j++;\\n            }\\n        }        \\n        \\n       return Res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2594279,
                "title": "python-2-pointer-binary-search-beats-95",
                "content": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2540163,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "codeTag": "Unknown"
            },
            {
                "id": 2437125,
                "title": "easy-to-understand-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372577,
                "title": "c-two-pointers-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361234,
                "title": "easy-c-solution-with-explanation-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319319,
                "title": "java-runtime-6ms-faster-than-99-65",
                "content": "When we add two mathematical properties, we can shorten the time to reach the target.\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/4e41cbb9-f0db-441d-bd5d-bb8847d546d1_1658521667.3858693.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257327,
                "title": "c-n-2-two-pointer",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2227280,
                "title": "python-solution-for-381-test-cases",
                "content": "I got around 960 ms runtime for this solution with 381 test cases. I tried to handle some edge cases such as if target is less than sum of first 3 digits and if target is greater than sum of last 3 digits.\\nMy solution:\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183372,
                "title": "go-o-n-2-clean-with-explanation",
                "content": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138304,
                "title": "simple-c-solution-using-two-pointer",
                "content": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137805,
                "title": "javascript-solution",
                "content": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2133259,
                "title": "best-solution-fastest-easy-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989154,
                "title": "java-two-pointers-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985131,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957202,
                "title": "c-easy-to-understand-solution-o-n-2-two-pointer",
                "content": "***Please upvote if you find the solution helpful to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955777,
                "title": "clean-commented-java-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619838,
                "title": "python-3-pointer-solution-simple-explanation-96-faster-96-ms",
                "content": "![image](https://assets.leetcode.com/users/images/5c780459-a159-4be4-978c-72a4ec4609ab_1639058651.4989543.png)\\nFix one of the pointers at index `i` then do the typical two-sum problem with indices `j` and `k` on the remaining elements that is not at index `i`. After `i` loops through the entire array once or when you find a difference of `0`, then you have the 3sum solution.\\n```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609485,
                "title": "c-similar-to-3sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546228,
                "title": "simple-to-understand-using-2-pointer-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542595,
                "title": "very-easy-js-solution",
                "content": "TC: O(N*N)\\nSC: O(1)\\n\\n```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402681,
                "title": "3sum-closest-two-pointers-python3",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366055,
                "title": "3sum-closest-easy-to-understand-c",
                "content": "Store all possible sum and then find the answer\\'s index using upperbound.\\nTime Complexity O(n^2)\\nwhere n = size of the nums vector.\\n\\nclass Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }\\n    }\\n    sort(store.begin(),store.end());\\n    int ind = upper_bound(store.begin(),store.end(),target)-store.begin();\\n\\t\\n    if(ind==store.size())  return store[ind-1];\\n    if(ind==0) return store[0];\\n    int dif1 = abs(store[ind]-target);\\n    int dif2 = abs(target-store[ind-1]);\\n    if(min(dif1,dif2)==dif1) return store[ind];\\n    return store[ind-1];\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1744801,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1729330,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2017604,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2010783,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1946972,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1838611,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1749948,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1746883,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1733038,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1576653,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2039112,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2018257,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2008595,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2005976,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1975228,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1965422,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1902008,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1900256,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1898570,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1835746,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1819662,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807387,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807374,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798513,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798512,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1797041,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1779724,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1767723,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1761945,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1753078,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1752585,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1715276,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1714059,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1713632,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1701042,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1696065,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1671256,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1648663,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1637889,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1636388,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            }
        ]
    },
    {
        "title": "Populating Next Right Pointers in Each Node",
        "question_content": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 37472,
                "title": "a-simple-accepted-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1654181,
                "title": "c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs",
                "content": "We are given a perfect binary tree and we need to populate next pointers in each node of the tree\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (BFS - Right to Left)***\\n\\nIt\\'s important to see that the given tree is a **perfect binary tree**. This means that each node will always have both children and only the last level of nodes will have no children.\\n\\n<p align=middle><img src=https://assets.leetcode.com/uploads/2019/02/14/116_sample.png width=500 />\\n\\nNow, we need to populate next pointers of each node with nodes that occur to its immediate right on the same level. This can easily be done with BFS. Since for each node, we require the right node on the same level, we will perform a **right-to-left BFS** instead of the standard left-to-right BFS.\\n\\nBefore starting the traversal of each level, we would initialize a `rightNode` variable set to NULL. Then, since we are performing right-to-left BFS, we would be starting at rightmost node of each level. We set the next node of `cur` as `rightNode` and update `rightNode = cur`. This would ensure that each node would be assigned its `rightNode` properly while traversing from right to left. \\nAlso, if `cur` has a child, we would first push its right child and only then its left child (since we are doing right-to-left BFS). Once BFS is completed (after queue becomes empty), all next node would be populated and we can finally return `root`.\\n\\nThe process is illustrated below -\\n\\n<table>\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/01e68f51-4905-4f58-b2dd-061aa64c8a91_1640764834.4913242.png width=350   />\\n</p>\\n</td>\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e2a49b2c-1493-4e3f-bb36-28b89153bf73_1640768916.6068268.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/67ff2271-2b5d-4b5f-8e31-6e14809146ad_1640765277.2783518.png  width=350   />\\n</p>\\n</td>\\n\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e1067d5d-3c94-4efc-b202-f4d18b93a0ac_1640765388.5706594.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/d8a07cf0-aa8c-44b9-ab35-98a2e1422d43_1640765420.4366648.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/ce1046fb-3212-46a5-b2f7-445ab32df816_1640765451.180103.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/bd5a4aff-19fe-4aad-b4e6-5dee5156536f_1640765483.7865818.png  width=350  />\\n</p>\\n\\n</tr>\\n\\n</table>\\n\\n\\n\\n\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, where `N` is the number of nodes in the given tree. We only traverse the tree once using BFS which  requires `O(N)`.\\n***Space Complexity :*** `O(W) = O(N)`, where `W` is the width of given tree. This is required to store the nodes in queue. Since the given tree is a perfect binary tree, its width is given as `W = (N+1)/2 \\u2248 O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (DFS)***\\n\\nWe can also populate the next pointers recursively using DFS. This is slightly different logic than above but relies on the fact that the given tree is a perfect binary tree.\\n\\nIn the above solution, we had access to right nodes since we traversed in level-order. But in DFS, once we go to the next level, we cant get access to right node. So, we must update next pointers of the child of each node from the its parent\\'s level itself. Thus at each recursive call -\\n* If child node exists:\\n\\t* assign next of left child node as right child node: `root -> left -> next = root -> right`. Note that, if once child exists, the other exists as well.\\n\\t* assign next of right child node as left child of root\\'s next (if root\\'s next exists): `root -> right -> next = root -> next -> left`. \\n\\t**How?** We need right immediate node of right child. This wont exist if current root\\'s next node doesnt exists. If next node of current root is present (the next pointer of root would already be populated in above level) , the right immediate node of root\\'s right child must be root\\'s next\\'s left child because if child of root exists, then the child of root\\'s next must also exist.\\n\\n* If child node doesn\\'t exist, we have reached the last level, we can directly return since there\\'s no child nodes to populate their next pointers\\n\\nThe process is very similar to the one illustrated in the image below with just the difference that we are traversing with DFS instead of BFS shown below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, each node is only traversed once\\n***Space Complexity :*** `O(logN)`, required for recursive stack. The maximum depth of recursion is equal to the height of tree which in this case of perfect binary tree is equal to `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BFS - Space-Optimized Appraoch)***\\n\\nThis is a combination of logic of above logics- we will traverse in BFS manner but populate the next pointers of bottom level just as we did in the DFS solution.\\n\\nUsually standard DFS/BFS takes `O(N)` space, but since we are given the next pointers in each node, we can use them to space-optimize our traversal to `O(1)`. \\n* We first populate the next pointers of child nodes of current level. This makes it possible to traverse the next level without using a queue. To populate next pointers of child, the exact same logic as above is used\\n* We simply traverse to root\\'s left child and repeat the process - traverse current level, fill next pointers of child nodes and then again update `root = root -> left`. So, we are basically performing standard BFS traversal in `O(1)` space by using next pointers to our advantage\\n* The process continues till we reach the last level of tree\\n\\n\\nThe process is illustrated in images below -\\n\\n\\n<table>\\n  <tr>\\n    <th>Image</th>\\n    <th>Description</th>\\n  </tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/b681da39-4c99-4e52-8cb8-779583022898_1640761933.124148.png  width=500 /></td>\\n    <td>We start with a perfect binary tree with all next pointers initially NULL</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td>\\n<img src=https://assets.leetcode.com/users/images/ebbbfada-bd94-4432-ac4b-e0326fc34fd4_1640761979.3636644.png  width=500 /></td>\\n    <td>We start traversal level-by-level, from left to right on each level</br>\\n\\t\\n```cpp\\ncur = root\\n```\\t\\n\\nEvery iteration, the next pointers of a node\\'s child will be updated</br> \\n\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\n</td>\\n\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/4935430e-af1b-4fe1-9fc7-c5d35be45b90_1640761999.0506494.png  width=500 /></td>\\n    <td>Move to next level</br>\\n\\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\\n\\n& repeat:</br>\\n\\t\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/9ada5f9e-34f7-4c0b-b513-2bd6ff758cbc_1640762014.5024235.png  width=500 /></td>\\n    <td>Continue the same process with all nodes on current level</br>\\n\\t\\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/8656dc5e-93fb-4260-87a7-a2261171b70d_1640762030.292751.png  width=500 /></td>\\n    <td>No child node exists</br>\\n\\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\\n\\nSo, we break here. On the next iteration, root becomes NULL as well and we stop the process.\\n</td>\\n  </tr>\\n</table>\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, we only traverse each node once, basically doing a standard BFS.\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\n```cpp\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37461,
                "title": "java-solution-with-o-1-memory-o-n-time",
                "content": "\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }\\n                level_start=level_start.left;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37484,
                "title": "7-lines-iterative-real-o-1-space",
                "content": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "codeTag": "Python3"
            },
            {
                "id": 37473,
                "title": "my-recursive-solution-java",
                "content": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37578,
                "title": "my-simple-non-iterative-c-code-with-o-1-memory",
                "content": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1653846,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run",
                "content": "> # **Behold the legendary battle between Recursive and Interative Approaches** \\n***\\n***Fight!!!***\\n***\\n**Intuition:-**\\n* We are given a prefect binary tree that means every parent has two children and all the    leaves are on the same level . \\n* This question is an superior version of binary level order traversal .\\n* In level order traversal you will traverse each level of binary tree while outputting the data in that form . So the only difference is that somehow we need to connect the previous levels rightmost node to the next level\\'s leftmost node and that\\'s it .\\n\\n**Algorithm:-**\\n1. Base case: if the root is null than return null\\n2. Now to connect the left subtree of same level with right subtree of that level \\n3. The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n4. Now just repeat the steps over and over for every level of tree . \\n\\n![image](https://assets.leetcode.com/users/images/6a41f9e5-3ba0-4116-ac09-f7e4a4bfdb19_1640748379.9406984.png) *Image credit goes to @Stargarth*\\n\\n**We can code this approach by two methods:**\\n1. By recursive \\n2. Iterative\\n<mark>Both solution has time complexity and space complexity as O(n) and O(1) in a virtual manner but if we consider in a true sense than in recursion we use a recursive stack which has some space complexity .<mark>\\nSo in a real sense the iterative solution is the best since it has truly O(1) space complexity .\\n***\\n**Recursive Approach Code:-**\\n```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\\n***\\n**Iterative Approach:-**\\nIn iterative approach we will be needing two more pointers named as `curr` and `prev` for linking of left and right nodes\\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**That was a intense battle and the winner is our iterative approach!!!** \\uD83C\\uDF8A\\uD83C\\uDF8A\\n***\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n\\n>**Feel free to comment or upvote if you liked my post ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37715,
                "title": "python-solutions-recursively-bfs-queue-dfs-stack",
                "content": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "codeTag": "Python3"
            },
            {
                "id": 37465,
                "title": "python-solution-with-explaintion",
                "content": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "solutionTags": [
                    "Python"
                ],
                "code": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "codeTag": "Java"
            },
            {
                "id": 37503,
                "title": "c-iterative-recursive",
                "content": "**Recursive**\\n\\nSimilar to a level-order traversal, even you are not allowed to use a `queue`, the `next` pointer provides you with a way to move to the next node in the same level.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Recursive**\\n\\nRecursively connect the left and right subtrees.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962728,
                "title": "java-0ms-with-visual-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a3197575-43d6-474a-b6b7-f7005723828e_1607299930.3256361.png)\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934111,
                "title": "c-bfs-iterative-queue",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654101,
                "title": "python-two-solutions-bfs-and-dfs-image-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* **Solution 1**\\n\\t* Standard BFS with mantaining `pre_level` and `pre_node` as the previous node in BFS sequence\\n\\t\\t* `level == pre_level` means current `node` is not the first node of `level`, then `pre_node.next = node` and update `pre_node = node`\\n\\t\\t* `else` means `pre_level < level` and `node` is the first node of `level`, then no need to update `pre_node.next`, leave it as `None`, update `pre_node = node` only.\\n\\t\\t* standard BFS, append `node.left` and `node.right` to the queue\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\\n\\n* **Solution 2**\\n\\t* Recursive DFS, the current root node is responsible for linking the nodes on both sides closest to the central axis for all levels.\\n\\t![image](https://assets.leetcode.com/users/images/4e546a8b-d11e-49a9-859d-6c7e5092e8cb_1640762771.0732064.jpeg)\\n\\n\\t\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```\\n\\t\\n**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\n```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 934066,
                "title": "python-o-n-time-o-log-n-space-recursion-explained",
                "content": "In this problem we are given that our tree is perfect binary tree, which will help us a lot. Let us use recursion: imagine, that for left and right subtees we already make all connections, what we need to connect now? See the image and it will become very clear: we need to connect just `O(log n)` pairs now: we go the the left and to the right children. Then from left children we go as right as possible and from right children we go as left as possible.\\n\\n![image](https://assets.leetcode.com/users/images/b838445a-d58e-420b-889e-208d6813beec_1605257150.2922277.png)\\n\\n\\n**Complexity**: time complexity can be found, using Master theorem: `F(n) = 2*F(n/2) + log n`, from here `F(n) = O(n)`. Space complexity is `O(log n)`, because we use recursion. Note, that space complexity can be reduced to `O(1)`, because we know the structure of our tree!\\n\\n```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37603,
                "title": "java-solution-traversing-by-level-without-extra-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }\\n                cur=nextLeftmost;  // point to next level \\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 420632,
                "title": "javascript-bfs-dfs-solution",
                "content": "#### The Idea - BFS\\n1. BFS using queue\\n2. as we are shifing node, connect it to the next in queue\\n``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\\n#### The Idea - DFS\\n1. pre order scan \\n2. set child nodes arrangement before resursion\\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515985,
                "title": "python-3-approaches-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(N/2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(logN)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Using previously established next pointers**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195108,
                "title": "bfs-c-iterative-explanation-level-order-traversal",
                "content": "\\nBasically this is purely level order travsersal code with slight modification for the  root -> next value \\n\\nYou just have to think 2 things in this question.\\n\\n1.How to get the last val to NULL ?.\\n2.How to get connect with the current node to previous one ?.\\n\\nIf you are able to find the ans of these two questions mentioned above then you will reach the solution \\nalso if you are here to see the solution i would recommend you to pause for a while \\nand think about these questions i am sure you willl find the ans otherwise ans \\nis just right below you can see anytime you want just give it a though for a whlle.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```\\n**In an interview there will be a follow up question in which you might be asked to solve this question with recursion so better be prepared for this bomb !!!!**\\n```\\n\\n\\nBefore you see the solution as per rituals please please please think of a solution by yourself you might be right or wrong doesn\\'t matter you fought hard with the question !!!\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        \\n        //now part-1 - connect Left node with right node\\n        if(root->left!=NULL) root->left->next = root->right;\\n        \\n        //now part-2 - connect right node with next subtree left node\\n        if(root->right!=NULL && root->next!=NULL) root->right->next = root->next->left;\\n        \\n        //Now do the same job for subtrees\\n        connect(root->left); \\n        connect(root->right);\\n        \\n        return root; \\n        // every time return is made, but at last the same root is retured to main\\n    }\\n\\n\\n*** IF YOU LOVED THE SOLUTION PLEASE CLICK ON THE UPVOTE BUTTON ***\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37520,
                "title": "simple-recursive-java-solution-o-1-space-o-n-time",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 379177,
                "title": "python3-bfs-and-dfs",
                "content": "* BFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\\n* DFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634140,
                "title": "java-step-by-step-explanation",
                "content": "## Please upvote if this helps! Thx :D\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934042,
                "title": "java-clean-code-o-n-time-complexity-100-faster-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059966,
                "title": "c-short-recursive-solution-no-extra-space-needed",
                "content": "Key points:\\n* Use parent\\'s next arrow to find right children\\'s next buddy in the neighboring tree.\\n* In short: root->right->next = root->next->left.\\n* Take care of current level\\'s children\\'s next arrow problem before move down to children subtree.\\n```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37703,
                "title": "5-lines-c-simple-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 758779,
                "title": "javascript-o-1-space-o-n-time",
                "content": "We iteratively move from each node to the next node, while fixing the next pointers of their children. \\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37469,
                "title": "another-simple-javascript-solution",
                "content": "Since it's a full binary tree, our job is much simpler, at each node, connects its left and right child, and try to connect the right child with the left child of node's next. A simple preorder traversal should be able to help us solve this problem.\\n```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747756,
                "title": "very-easy-to-understand-recursive-method",
                "content": "Simple recursive solution accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153086,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 37458,
                "title": "c-recursive-solution",
                "content": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37705,
                "title": "python-accepted-code",
                "content": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "solutionTags": [],
                "code": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "codeTag": "Python3"
            },
            {
                "id": 37663,
                "title": "an-iterative-java-solution",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1480173,
                "title": "javascript-dfs-extremely-simple-and-understandable",
                "content": "DFS, pass down rightnode\\'s left pointer if it exists, otherwise null.\\n```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156384,
                "title": "javascript-bfs",
                "content": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37600,
                "title": "5-line-1ms-java-iterative-solution-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }\\n            for (TreeLinkNode head=root; head.left!=null; head=head.left) {\\n                for (TreeLinkNode parent=head; parent!=null; parent=parent.next) {\\n                    parent.left.next = parent.right;\\n                    if (parent.next != null) { parent.right.next = parent.next.left; }\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }",
                "codeTag": "Java"
            },
            {
                "id": 1932092,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653811,
                "title": "python-solution-recursive-elegant-solution",
                "content": "I thought that this solution was a little different to the others posted, most of them doing a level order search using the next pointer. However here, I have recursively split the tree into \\'pincer\\' segments (this is what I call them because I don\\'t know the name), at each level the pair is made up of 1. the right most node of that level in the left node\\'s subtree & 2. the left most node of that level in the right node\\'s subtree - and then connected node 1 to node 2 at each level.\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```\\n\\t\\nThe idea being, that I could simply connect a node\\'s left child to it\\'s right child, with the only difficulty being to find the \\'next\\' node of a right child. The \\'pincer\\' segments help resolve this issue, as the \\'next\\' node of a right child is simply the other node in that level of the \\'pincer\\'\\n\\nI\\'m not quite sure the if there is a specific name for this general idea, and would be very appreciative if anyone knows what it is Hope this helps!\\n\\nEDIT: A diagram illustrating the \\'pincer segments\\' of each of the first three nodes, and the pointers created by each - in red, blue and green respectively. Note that each node not on the left or right \\'boundary\\' is visited by two other \\'pincer segments\\', as is necessary since each node should have a pointer coming in and one coming out.\\n\\n![image](https://assets.leetcode.com/users/images/3e380898-de6f-4ab5-89e6-8a618ff56199_1640908417.4581368.jpeg)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37719,
                "title": "accepted-java-recursive-solution",
                "content": "The recursive solution of my last post, although the space is not O(1) (due to recursion), the solution is still elegant.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }\\n            \\n            if (root.right != null) {\\n                root.right.next = root.next != null ? root.next.left : null;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 37744,
                "title": "a-concise-o-1-space-complexity-solution",
                "content": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191294,
                "title": "java-solution-simple-bfs-traversal-very-easy-iterative-solution",
                "content": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040150,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\n```\\n```\n```\\n```\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719347,
                "title": "python-solution-o-1-and-o-n-memory",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\\n\\nO(1) Memory solution:\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37606,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3617528,
                "title": "o-1-space-simple-bfs-java-solution-and-without-recursion",
                "content": "Intution: Treating level of tree is as linked list.\\n1. From parent level connect children level node as linked list and parent level is already connected so we can move to next node of parent to connect other children node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954109,
                "title": "c-java-python-bfs-o-n-time-o-1-space",
                "content": "I hope the comments are explicit enough to tell about the iterative BFS approach that is used here.\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\nC++ \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nPython\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```\\n\\n\\uD83D\\uDE80 Thanks for reading. \\nAn upvote would be appreciated.  ^_^\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934059,
                "title": "c-99-100-memory-5-liner-recursively-crispy-af",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nExplanation -\\n1. Traverse tree\\n2. Make given connections\\n3. ???\\n4. Profit!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956337,
                "title": "c-beats-97-explained-using-level-order-traversal",
                "content": "# Best Solution for Beginners\\nWe can solve this using Level order Traversal.\\n\\n    Runtime - 97.14%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly We will do Level Order Travesal.\\n2. Then at Each Level we will join all nodes present at that Level.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779810,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720678,
                "title": "0ms-100-faster-java-code",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764851,
                "title": "java-bfs-and-dfs-4-solutions",
                "content": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```\\n```\\n\\t//BFS using Queue\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(n), for queue\\n\\tpublic Node connect3(Node root) {\\n\\t\\tif(root == null)\\n\\t\\t\\treturn root;\\n\\t\\tQueue<Node> q = new LinkedList<>();\\n\\t\\tq.offer(root);\\n\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\tNode prev = q.poll();\\n\\t\\t\\tif(prev.left != null) {\\n\\t\\t\\t\\tq.offer(prev.left);\\n\\t\\t\\t\\tq.offer(prev.right);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<size; i++) {\\n\\t\\t\\t\\tNode curr = q.poll();\\n\\t\\t\\t\\tprev.next = curr;\\n\\t\\t\\t\\tif(curr.left != null) {\\n\\t\\t\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\t\\t\\tq.offer(curr.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934355,
                "title": "populating-next-right-pointer-in-each-node-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934184,
                "title": "python-time-o-n-space-o-1-concise-real-o-1-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561417,
                "title": "go-recursive-and-iterative",
                "content": "Recursive:\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n\\nIterative (BFS with Queue):\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991023,
                "title": "c-2-methods-with-logic-bfs-traversal-clean-code",
                "content": "***Method -1 [Naive Method]***\\n\\n![image](https://assets.leetcode.com/users/images/c1e0a6f5-6652-42c9-be2d-d4dd6b797b16_1672731185.2271147.png)\\n\\n**n==Number of Nodes \\nT->O(n) && S->O(n) [For storing all the Nodes after BFS] + O(n/2) [For queue, worst Case as it\\'s a Perfect Binary Tree]**\\n\\n***Logic -> Level Order Traversal and connect adjacent Nodes!***\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttemp.push_back(NULL);\\n\\t\\t\\t\\t\\tlvl.push_back(temp);\\n\\t\\t\\t\\t} \\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < lvl.size() ; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0 ; j < lvl[i].size() - 1 ; j++) lvl[i][j] -> next = lvl[i][j + 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**Method - 2 [Optimized]**\\n\\n![image](https://assets.leetcode.com/users/images/2bedfde0-1ab4-4a19-b754-0fb7656b6c84_1672755793.910553.png)\\n\\n**n==Number of Nodes\\nT->O(n) && S->O(n) [Recursive Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(Node* l,Node* r){\\n\\t\\t\\tif(!l && !r) return;\\n\\n\\t\\t\\tl -> next = r;\\n\\t\\t\\tr -> next = NULL;\\n\\n\\t\\t\\tdfs(l -> left , l -> right);\\n\\t\\t\\tdfs(l -> right , r -> left);\\n\\t\\t\\tdfs(r -> left , r -> right);\\n\\t\\t}\\n\\n\\t\\tNode* connect(Node* root) {\\n\\t\\t\\tif(!root) return NULL;\\n\\t\\t\\tdfs(root -> left , root -> right);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1466306,
                "title": "c-o-n-time-o-1-space-no-recursion-space-0ms-faster-than-100",
                "content": "The idea is to fix the next pointer for child nodes while traversing through parent node. \\nOnce you fixed the next pointer then you can traverse this level in O(1) space.\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```\\nFeel free to ask doubt in comments and please don\\'t forget to upvote if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357656,
                "title": "python-simple-solution-easy-to-understand-o-n-and-constant-memory",
                "content": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```\\nplease upvote !",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 934979,
                "title": "easy-bfs-python-solution",
                "content": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934124,
                "title": "python-constant-space",
                "content": "Use the already-populated next pointers of the row above to fill the row below:\\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557405,
                "title": "2-different-simple-recursion-o-n-time-beats-100",
                "content": "The first solution\\'s idea is only on about the fact that `root.right.next = root.next.left`\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\\n\\nThe 2nd solution is as simple as stiching nodes recursively, 3 pairs at a time\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37622,
                "title": "share-my-loop-java-1ms-solution-easy-understand",
                "content": "    //Just remember to use result from the last step\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }\\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37675,
                "title": "c-easy-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3689095,
                "title": "easy-bfs-java-python-c",
                "content": "# * Extra space but clean code\\n---\\n```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```\\n---\\n>### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577380,
                "title": "java-100-fast-0ms-easy-recursion-node",
                "content": "If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community,\\nif you have any queries or any improvements please feel free to comment and share your views.\\n\\n       class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        connect(root.left);\\n        connect (root.right);\\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2534439,
                "title": "python-with-simple-recursion-explanation-with-drawing",
                "content": "I divide the code into four part, check out the hashtag. \\n`#part1`: if root is None, we want to just return None.\\n`#part2:` : if cur.left is not None, we want to build a connection between cur.left and cur.right. See pic:\\n![image](https://assets.leetcode.com/users/images/cfeb76d0-09c7-4598-bc2f-2b366fe46eca_1662378412.3597903.png)\\n`#part3`:we want to build connection between node 5 and 6(see pic), if cur.next and cur.left not None.\\n![image](https://assets.leetcode.com/users/images/a315abd7-21a7-43cf-ad9b-31ab3af73219_1662378740.7180765.png)\\n`#part4` call left node and right node do the same thing\\n\\nIf this is helpful, don\\'t forget give me a star and vote\\n\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774841,
                "title": "c-efficient-recursive-iterative-using-queue-2-solutions",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n##### Recursive Approach :-\\n* Base case: if the root is null than return null\\n* Now to connect the left subtree of same level with right subtree of that level\\n* The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n* Now just repeat the steps over and over for every level of tree .*\\n##### Recursive Code:-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\\n\\n##### Iterative Approach using Queue(like level-order-traversal):-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360246,
                "title": "simple-preorder-traversal",
                "content": "```class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1114796,
                "title": "python-recursion-constant-space-beats-98-short-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934104,
                "title": "c-easy-iterative-solution",
                "content": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508672,
                "title": "java-recursive-solution-100-o-n-time-o-1-space-o-n-stack-call",
                "content": "Feel free to discuss Big-O analysis :)\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286540,
                "title": "c-while",
                "content": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163183,
                "title": "java-c-c-solutions-elegant-iterative-solutions-4-lines-and-recursive-solutions-5-lines",
                "content": "# **C++**\\n## Recursive\\nSetting the _next_ pointer from the parent node makes for a clean solution. The only thing to worry about is how to handle the far right node of each level, which doesn\\'t have a _next_. This is easy to check for too, just check if the parent node has a _next_ pointer, if it doesn\\'t, then you\\'re at the far right.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\\t\\n## Iterative\\nSet the _next_ pointer starting from the left of each level, then you can use the _next_ pointer to progress from left to right to complete the level. Once a level is finshed, advance down the left branch and do it again.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\\t\\n# **Java**\\n## Recursive\\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\\n## Iterative\\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\\n# **C**\\nSince a c solution would look very much like the c++ solution, I did it slightly differently, but is essentially the same.\\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```\\n\\n**Note that all solutions abuse the fact that the tree is by definition a perfect binary tree. [Solutions that don\\'t require perfect tree can be found here](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/163809/C++-iterative-O(1)-space.-Short-and-easy-to-understand-with-detail.-Bonus-2-line-solution-for-fun)**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37642,
                "title": "a-simple-0-ms-recursive-solution-without-helper-function",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37720,
                "title": "another-accepted-java-solution",
                "content": "Basically, we use the next pointer to help level traversal. No recursion is needed, O(1) constant space, O(n) running time.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }\\n                \\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37749,
                "title": "sharing-my-java-o-1-extra-space-code",
                "content": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37787,
                "title": "simple-iterative-solution",
                "content": "Populate the levels one by one. curLevel points to node whose children will be linked, nextLevel points to the first node in the next level.\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }\\n                else {\\n                    curLevel->right->next=NULL;\\n                    curLevel=nextLevel;\\n                    nextLevel=nextLevel->left;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37793,
                "title": "my-recursive-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3687361,
                "title": "2-ms-easy-to-understand-using-queue-level-order-traversal-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach used here is based on level-order traversal of the tree using a queue. The intuition behind the solution is that by traversing the tree level by level, we can keep track of the next right node for each node in the current level and establish the connections.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA while loop processes each level. Inside the loop, a for loop iterates through each node, connecting it to the next node in the same level if applicable. Nodes with children are added to the queue for the next level. The process continues until all nodes in the current level are processed.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n    (n is number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$ \\n  (m is maximum number of nodes in a level)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```\\nPLease upvote if u found it useful :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753478,
                "title": "java-beauty-and-easy-solution-explained-visualized-o-n-algo-o-1-memo",
                "content": "The task boils down to understanding the structure of the tree and how to traverse it.\\nThe solution is that we create a method that **contains the right and left nodes of the same level**.\\n1. We connect the left node with the right one using the `next` field.\\n2. The **next** left node of the current left one is combined with the **next** right one.\\n3. The **next** left node of the current right node is combined with the **next** right node.\\n4. And we also take **the next right node of the left one** and combine it with **the left node of the right one**. This is the most difficult step and is the key to solving the problem.\\n\\n**See the image below!** It turns out that we first connected two nodes and then connected their next level. Moreover, first they combined the \"children\" of the left, then the \"children\" of the right, and then they were united.\\n\\n```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1f554560-3085-44a7-b2e8-b16c0958a069_1666979901.3168855.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424026,
                "title": "python-c-java-beginner-level-solution-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q116. Populating Next Right Pointers in Each Node***\\n\\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\\n```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\\nInitially, all next pointers are set to NULL.\\n____________________________________________________________________________________________________________________\\n\\n***Time complexity*** - O(n)\\n***Space complexity*** - O(1)\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Populating Next Right Pointers in Each Node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  42.2 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\\n**Runtime:**  131ms\\n**Memory Usage:**  13.8 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**Runtime:**  41ms\\n**Memory Usage:**  69.7MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808896,
                "title": "c-5-lines-code-very-easy-dfs-simple-explanation",
                "content": "This solution implements a recursive function - it takes a node, connects the NEXT pointers of it\\'s left & right children, and repeats the process for the children. So the algorithm is :\\nFor each non-leaf node, we do -\\n(1) NEXT of Left child is pointed to Right child. Easy.\\n(2) NEXT of Right child is pointed to NEXT node in the same level (i.e., parent\\'s NEXT\\'s left child).\\n\\nLet\\'s consider the below example. Assume we are at the node \"2\".\\n```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\\n\\nSince we\\'re at 2, we would already have our NEXT pointer pointing to the node 3 (should have been done at node 1).\\nNow, we need to correctly set NEXT pointers of our children, i.e, 3 and 4. We follow the said algorithm here.\\nStep 1 : 3\\'s NEXT pointer should simply be set to 4.\\nStep 2 : We know 4\\'s NEXT pointer should now be set to 5. How do we do that? Remember we have 2\\'s NEXT set to 3 already? We\\'re going to use that to get reference of 3, and then reference of 5 - then we just use it! 4\\'s NEXT is set to 2\\'s NEXT\\'s left, which is 5.\\n\\nSo the tree now becomes -\\n\\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\\n\\nWe repeat this process until all NEXT nodes are set. \\n\\nIn case of last node of a level (for ex: 6), we don\\'t have NEXT of our parent (3) anyway, so it\\'s defaulted to NULL as required already.\\nFor leaf nodes, we don\\'t have children to set so we return.\\n\\n\\nSolution Code in C++ \\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```\\n\\nThanks! Upvote if this helped you!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783750,
                "title": "level-order-easy-implementation",
                "content": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653771,
                "title": "java-o-1-memory-solution-recursive-iterative-faster-than-100",
                "content": "**1. Recurisve**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**2. Iterative**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600990,
                "title": "very-easy-bfs-solution-c-hint-for-constant-space",
                "content": "Hint for constant space -> is to use the next links that you just created \\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497972,
                "title": "c-o-1-space-o-n-time-7-lines-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136720,
                "title": "java-solution-10-lines-code-o-n-time-and-constant-space",
                "content": "Idea here to take advantage of already set values of next. When going to child, parent will already have their next value. We can take advantage of that. This is the minimize solution.\\n\\n```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 953162,
                "title": "python-jump-game-iii-with-queue-deque-visited-set",
                "content": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "solutionTags": [],
                "code": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 935186,
                "title": "c-constant-space-iterative-recursive",
                "content": "Iteraitve Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nRecursive Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762896,
                "title": "5-lines-recursive-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629881,
                "title": "go-golang-dfs-bfs",
                "content": "1. DFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n2. BFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504940,
                "title": "easy-understand-python-solution",
                "content": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 307621,
                "title": "simple-recursive-preorder-traversal",
                "content": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291622,
                "title": "python-recursive-solution",
                "content": "\\u5728\\u8FD9\\u4E2Arecursion chapter\\u5B66\\u4E60\\u81EA\\u5DF1\\u609F\\u51FA\\u6765\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\u3002\\n\\u4ECEexample\\u53EF\\u4EE5\\u53D1\\u73B0\\u7ED9\\u7684\\u89C4\\u5F8B\\u5C31\\u662F\\n\\u6BCF\\u4E2A\\u8282\\u70B9\\uFF08\\u975E\\u53F6\\u5B50\\u7ED3\\u70B9\\uFF09\\u5FC5\\u6709\\u4E24\\u4E2A\\u5B50\\u8282\\u70B9\\n\\u5BF9\\u6BCF\\u4E00level\\u7684\\u8282\\u70B9\\u90FD\\u8FDB\\u884C\\u5982\\u4E0B\\u64CD\\u4F5C\\nleft.next = right\\nright.next = None\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u53EA\\u662F\\u8FDE\\u63A5\\u4E86\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u4E00\\u5C42level\\u91CC\\u9762\\u8282\\u70B9\\u4E0D\\u6B62\\u8FD9\\u4E48\\u591A\\uFF0C\\u8FD8\\u6709\\u4E2D\\u95F4\\u7684\\uFF0C\\u5C31\\u662F\\u5DE6\\u5B50\\u6811\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u4E4B\\u95F4\\u7684\\u5DE6\\u5B50\\u6811\\u7684\\u53F3\\u8282\\u70B9\\uFF0C\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u5DE6\\u8282\\u70B9\\u8981\\u8FDE\\u63A5\\u8D77\\u6765\\uFF0C\\u6240\\u4EE5\\u9012\\u5F52\\u5199\\u4E86\\u4E2D\\u95F4\\u7684\\nconnect(left.right,right,left)\\n\\u867D\\u7136\\u6700\\u540E\\u5B9E\\u73B0\\u4E86\\u7A0B\\u5E8F\\uFF0C\\u4F46\\u662F\\u6539\\u8FDB\\u7684\\u5730\\u65B9\\u8FD8\\u662F\\u6709\\u5E8F\\u591A\\n\\u5C31\\u6BD4\\u5982\\uFF0C\\u8FD9\\u4E2Aright.next = None\\uFF0C\\u8FD9\\u91CC\\u64CD\\u4F5C\\u4E86\\u591A\\u6B21\\uFF0C\\u5982\\u679C\\u53EF\\u4EE5\\u53EA\\u8981\\u8FDE\\u63A5\\u4E00\\u6B21\\u5C31\\u8FDE\\u4E0A\\u7684\\u8BDD\\u662F\\u6700\\u597D\\u7684\\u4E86\\u3002\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\\n\\u5F88\\u660E\\u663E\\u8FD9\\u4E2A\\u4E5F\\u53EF\\u4EE5\\u7528BFS\\u6765\\u505A\\uFF0C\\u540C\\u6837\\uFF0C\\u4E5F\\u662F\\u4E4B\\u524D\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684queue\\u5B9E\\u73B0\\u7684BFS\\u6765\\u89E3\\u51B3\\u8FD9\\u91CC\\u7684\\u95EE\\u9898\\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\\n\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF0C\\u786E\\u5B9E\\uFF0CBFS\\u53EF\\u4EE5\\u4F7F\\u7528\\uFF0C\\u4F46\\u662F\\u6211\\u4EEC\\u6CA1\\u6709\\u5FC5\\u8981\\u7528\\u4E00\\u4E2Aqueue\\u6765\\u5B58\\u50A8node\\uFF0C\\n\\u56E0\\u4E3Anode\\u6709next\\u8282\\u70B9\\uFF0C\\u5F53\\u6211\\u4EEC\\u6709\\u4E00\\u4E2A\\u5934\\u7ED3\\u70B9\\u4E4B\\u540E\\uFF0C\\u5C31\\u53EF\\u4EE5\\u50CF\\u94FE\\u8868\\u4E00\\u6837\\u53BB\\u8BBF\\u95EE\\u4E86\\u3002\\nreference\\uFF1A\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37465/Python-Solution-With-Explaintion\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37658,
                "title": "a-simple-java-recursive-solution-in-6-lines",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37668,
                "title": "9-line-fast-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }\\n                    a=a->next;\\n                }\\n                root=root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3482395,
                "title": "easy-o-n-intutive-c-solution-by-bfs-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298937,
                "title": "python-4-diffrent-solutions-bfs-dfs",
                "content": "# 1. Iterative BFS | Space:O(n)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\\n\\n# 2.Recursive DFS | Space: O(n)\\n\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\\n\\n# 3.Recusive DFS | Space:O(logn)\\n\\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\\n\\n# 4. Iterative Optimized BFS or Level order traversal | O(1)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3195670,
                "title": "beats-96-94-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a level-order traversal of the binary tree and a queue to keep track of the nodes. For each level, it sets the next pointers of the nodes to the next node in the queue, except for the last node in the level. It then adds the node\\'s children to the queue if they exist, and continues with the next level. The function returns the root node of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301718,
                "title": "c-both-recursive-and-iterative-solution",
                "content": "**Iterative approach - same concept as level order traversal**\\n```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\\n**Recursive code**\\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598642,
                "title": "simplest-solution-you-can-find-java-beats-100",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510637,
                "title": "dfs-bfs-approach-java-easy-to-understand-commented-explanation",
                "content": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "codeTag": "Unknown"
            },
            {
                "id": 1424191,
                "title": "easy-java-solution-o-1-space-100-fastest",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326340,
                "title": "c-16ms-16-7mb-easy-recursive-solution",
                "content": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1317964,
                "title": "c-solution-easy-o-n-time-o-1-space",
                "content": "***Please Upvote the solution, if you like it.***\\n```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234428,
                "title": "c-self-explanatory-code",
                "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        root->left->next = root->right;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1019039,
                "title": "c-two-approaches-bfs-using-queue-recursive",
                "content": "## Iterative BFS approach using Queue\\n***Level Order Traversal***\\n### T = O(n) & S = O(n) where n is total number of nodes\\n```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\\n## Recursive approach\\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955215,
                "title": "iterative-go-w-comments",
                "content": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934256,
                "title": "java-2-approaches-bfs-recursion",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\\n\\nMore Optimal approach. Inspired by this post - https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/934042/JAVA-Clean-Code-O(N)-Time-Complexity-100-Faster-Solution\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745081,
                "title": "java-recursive-and-iterative-solutions-clear",
                "content": "- Recursive\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n- Iterative\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678158,
                "title": "java-3-different-solutions-without-queue-recursion-using-queue",
                "content": "**Using Queue(Breadth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Using Recursion(Depth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\\n**Without Queue(Breadth-First Traversal) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439405,
                "title": "c-simple-recursive-solution",
                "content": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232382,
                "title": "c-well-commented-solution-o-n-time-o-1-space-100-works-for-all-binary-trees",
                "content": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231526,
                "title": "c-well-commented-solution",
                "content": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163181,
                "title": "easy-java-solution",
                "content": "a lot of solution is over killed here.\\nPlease realize this is full binary tree\\n```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37706,
                "title": "o-n-java-solution-very-easy-to-understand",
                "content": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "codeTag": "Unknown"
            },
            {
                "id": 37518,
                "title": "java-a-5-line-iterative-space-o-1-and-a-short-iterative-bfssolution",
                "content": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "solutionTags": [],
                "code": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37728,
                "title": "4ms-c-solution-in-4loc",
                "content": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "solutionTags": [],
                "code": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37782,
                "title": "my-java-recursive-solution",
                "content": "I like recursive \\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }\\n\\n        public void connect(TreeLinkNode left, TreeLinkNode right) {\\n            while (left != null) {\\n                left.next = right;\\n                left = left.right;\\n                right = right.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3858980,
                "title": "easy-c-level-order-traversal-bfs",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple level Order traverse BFS \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424002,
                "title": "beats-100-recursion",
                "content": "\\n\\n# Approach\\n\\n![WhatsApp Image 2023-04-16 at 21.05.32.jpeg](https://assets.leetcode.com/users/images/f2599a43-e066-47aa-a828-c886d4b357f5_1681659374.0166218.jpeg)\\n\\nThe nodes will point to :-\\n\\nRoot -> null\\n\\nRoot.left -> Root.right\\n\\nRoot.right(Right subtree) -> null\\n\\nRoot.right(Left subtree) -> Root.left(Right subtree)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401091,
                "title": "java-binary-tree-connect",
                "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966856,
                "title": "python-simple-bfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I used a BFS to explore the tree.\\n- At the step *n* of the loop, the queue will contain all the nodes of the level *n* of the tree.\\n- We can then easily connect all the nodes of the same level by iterating over the queue **at the beginning of the loop** (before running the next step of the BFS).\\n\\n\\nUpvote if it helps! \\uD83D\\uDE42 \\n\\n# Code\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953919,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795148,
                "title": "o-1-space-and-o-n-time-simple-code-in-python",
                "content": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "codeTag": "Java"
            },
            {
                "id": 2750019,
                "title": "java-100-faster-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```\\n## PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661106,
                "title": "c-o-n-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2424367,
                "title": "c-three-recursive-solutions-with-visual-explanation",
                "content": "**Solution 1**\\n![image](https://assets.leetcode.com/users/images/11f92bfd-f5a6-4de1-b904-6e5806ec1d38_1660477598.609047.jpeg)\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n**Solution 2**\\n![image](https://assets.leetcode.com/users/images/edff067d-eb96-4e06-a970-2c6f16008f75_1660477773.2009048.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/951f8263-5bba-450e-b649-8ed5b3c7d401_1660478186.5010526.jpeg)\\n\\n**Solution 3**\\n![image](https://assets.leetcode.com/users/images/486cc146-7333-499b-9666-2d43882065a5_1660900827.6746473.jpeg)\\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\\n\\nPlease let me know if anything could be improved. Happy coding!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384432,
                "title": "c-solution-o-n-comments-explained-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359491,
                "title": "simple-recursion-o-1-space-o-n-time-c",
                "content": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177257,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003544,
                "title": "c-recursive-approach-faster-than-97",
                "content": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718160,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605783,
                "title": "python3-elegant-implementation",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516608,
                "title": "easy-recursive-python-solution-with-o-1-space-and-no-helper-function",
                "content": "There\\'s no official recursive solution, but it\\'s quite simple and doesn\\'t require a helper function. The main thing to keep in mind is that the recursion operates on the children *after* the parents have already been previously connected, if necessary.\\n\\n```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1395379,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333044,
                "title": "c-bfs",
                "content": "You may find this code extremely similar to level order traversal.\\n```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147102,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126811,
                "title": "java-recursive-with-comments-0ms-faster-than-100",
                "content": "Observation : The tree is **Perfect**. This means all nodes have 2 childs or no childs, across the tree. \\nWe will use this observation to make changes to **next** based on state of the node itself or both its children\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```\\n\\n*Thank you for reading my post!\\nIf you found it helpful, please upvote or comment.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065116,
                "title": "java-easy-to-understand-o-n-time-and-o-1-space-solution-with-explanations",
                "content": "Algorithm:\\n1. We have to travel all cells by recursion\\n2. If the node is null then we return, that will be the base case.\\n2. Then we will check if the node have a parent or not, if it doesn\\'t have parent then we know it is root and the next will be null\\n3. Then we check if it is left or right\\n4. If it is left then the next will be the parent\\'s right\\n5. If it is right then we check if parent\\'s next is null or not if it is null then it is means it is the rightmost then it\\'s next will also be null\\n6. And if the parent\\'s next is not null then the next will be paren\\'t next left.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976388,
                "title": "c-solution-o-1-space-o-n-time",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934830,
                "title": "go-golang-clean-solutions",
                "content": ">Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.2 MB, less than 8.12% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\\n\\n>Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.1 MB, less than 25.38% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934260,
                "title": "java-shortest-clean-solution-o-n-time-and-o-1-space-beats-100-easy-to-understand",
                "content": "The code is self explaining.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934232,
                "title": "from-zero-to-hero-three-approaches-python-3",
                "content": "Hi there! I would like to share my thoughts and solutions to that great problem. As I pointed in the title I will present you with three solutions that take ```O(n)``` time, but different amount of space.\\n\\n\\n**Breadth-first search: O(n) time/space**\\nFrom the beginning I had two thoughts:\\n1. I have to traverse the tree and I am quite happy to know how to do that\\n2. I have to connect all the nodes on the same level\\n\\nAnd after those thoughts, I immediately come up with the idea to use a Deque data structure to collect all the nodes. So the first solution is quite straightforward:\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\\n\\n\\n**Recursion: O(n) time, O(log (n)) space**\\nThe second step was to try to solve the problem by using recursion. One thing I mentioned is that without checking if there is an already existing link between two nodes the algorithm repeats the work he already did before. So pay attention to that!\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\\n\\n\\n**With Linked List in mind: O(n) time, O(1) space**\\nAnd here is the last one! I should admit this is remarkably elegant and clean code. The way I came up with this algorithm is by observing that actually in the first solution I have used unnecessary space to collect the nodes. But the thing is that when we come to a certain level all the nodes on this level are already connected with the ```next``` link. That gives us the possibility to iterate through the level as if it were a Linked List.\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```\\n\\n*\\uD83D\\uDCE2 If you think these solutions are good enough to be recommended to other LeetCoders then upvote.*",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Queue"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\n```next```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934097,
                "title": "c-easy-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923575,
                "title": "easy-cpp-8-line-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```\\n\\nExplanation:\\n![image](https://assets.leetcode.com/users/images/58c720ed-0429-42e0-8590-04d9022b0caa_1604770737.4726672.png)\\n\\n\\nFor each node:\\n1. Connect left child of its left child with right child of its left child (green)\\n2. Connect right child of its left child with left child of its right child (blue)\\n3. Connect left child of its right child with right child of its right child (red)\\n4. Connect left child to the right child (black)\\n\\nMain trick is that we iterate over two subtrees at the same time (left and right). This trivializes whole problem into four cases mentioned above. \\nFor base case we check if left node is null, since we can\\'t link null node. Due to the fact that trees are guaranteed to be perfectly balanced, we might as well check if right node is null. It doesn\\'t matter.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821882,
                "title": "a-small-recursive-solution-c",
                "content": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 710100,
                "title": "c-bfs-solution-easy",
                "content": "Just playing around with the pointers.Here is the code\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507105,
                "title": "python-bfs-image-attached",
                "content": "#### 116 | Populating Next Right Pointers in Each Node\\n\\n#### BFS Solution\\n\\n```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363006-88872e00-4d7e-11ea-8091-ab49e4a3efc3.png)\\n\\n----\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363019-8f15a580-4d7e-11ea-87d4-a4181f22de05.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433945,
                "title": "easy-java-solution-runtime-0ms-beat-100",
                "content": "For each node, it has two subtree, left subtree and right subtree. At every level, connect the rightmost node of left subtree to the leftmost node of right subtree. \\nAnd do this loop for each node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405732,
                "title": "java-simple-recursive-solution-beat-100",
                "content": "You just need to iterate the tree from right to left.\\n\\t1. If current node is not leaf node then\\n\\t\\t- set root.left.next = root.right\\n\\t\\t- if root.next is not null, we will set root.right.next = root.next.left\\n\\n```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```\\nTime Complexity O(N) \\nSpace Complexity O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346354,
                "title": "my-easy-to-understand-recursive-solution-cpp-beat-97",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339375,
                "title": "simple-java-recursive-solution-beats-100",
                "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1766045,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1729331,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1673798,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1574581,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1572733,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2062298,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2045129,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2002558,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1995070,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1953589,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1950680,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1879520,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1872271,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1869170,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863726,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863718,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1848647,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1833871,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1825265,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1785371,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1761008,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749449,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749358,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1726567,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1723359,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1717320,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1693207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1682295,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1673850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1671845,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            }
        ]
    },
    {
        "title": "Combination Sum III",
        "question_content": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 60614,
                "title": "simple-and-clean-java-code-backtracking",
                "content": "     public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        combination(ans, new ArrayList<Integer>(), k, 1, n);\\n        return ans;\\n    }\\n\\n\\tprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\t\\tif (comb.size() == k && n == 0) {\\n\\t\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\t\\tans.add(li);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = start; i <= 9; i++) {\\n\\t\\t\\tcomb.add(i);\\n\\t\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\t\\tcomb.remove(comb.size() - 1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "     public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        combination(ans, new ArrayList<Integer>(), k, 1, n);\\n        return ans;\\n    }\\n\\n\\tprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\t\\tif (comb.size() == k && n == 0) {\\n\\t\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\t\\tans.add(li);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = start; i <= 9; i++) {\\n\\t\\t\\tcomb.add(i);\\n\\t\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\t\\tcomb.remove(comb.size() - 1);\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 60805,
                "title": "easy-to-understand-python-solution-backtracking",
                "content": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ret = []\\n        self.dfs(list(range(1, 10)), k, n, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, n, path, ret):\\n        if k < 0 or n < 0:\\n            return \\n        if k == 0 and n == 0:\\n            ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k-1, n-nums[i], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ret = []\\n        self.dfs(list(range(1, 10)), k, n, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, n, path, ret):\\n        if k < 0 or n < 0:\\n            return \\n        if k == 0 and n == 0:\\n            ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k-1, n-nums[i], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60621,
                "title": "my-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n      void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n        if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n        if (sol.size() < k) {\\n          for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n            if (n - i < 0) break;\\n            sol.push_back(i);\\n            combination(result, sol, k, n - i);\\n            sol.pop_back();\\n          }\\n        }\\n      }\\n    \\n      vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> sol;\\n        combination(result, sol, k, n);\\n        return result;\\n      }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n      void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n        if (sol.size() == k && n == 0) { result.push_back(sol); return ; }",
                "codeTag": "Java"
            },
            {
                "id": 60624,
                "title": "clean-1-6-7-liners-ac",
                "content": "**Batteries Included**  \\nAC in 44ms\\n\\nFirst the obligatory *\"use the darn library\"* solution. Create all k-combinations of digits and keep those with sum n:\\n\\n    from itertools import combinations\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in combinations(range(1, 10), k) if sum(c) == n]\\n\\n---\\n\\n**Recursive**  \\nAC in 48 ms\\n\\nBut it's more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            def combs(k, n, cap):\\n                if not k:\\n                    return [[]] * (not n)\\n                return [comb + [last]\\n                        for last in range(1, cap)\\n                        for comb in combs(k-1, n-last, last)]\\n            return combs(k, n, 10)\\n\\n---\\n\\n**Iterative**  \\nAC in 56 ms\\n\\nAnd an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap.\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[first] + comb\\n                         for comb in combs\\n                         for first in range(1, comb[0] if comb else 10)]\\n            return [c for c in combs if sum(c) == n]\\n\\n---\\n\\n**Reduce**  \\nAC in 44 ms\\n\\nAnd here's a \"one-liner\" version of the iterative solution using `reduce` instead of the loop:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in\\n                    reduce(lambda combs, _: [[first] + comb\\n                                             for comb in combs\\n                                             for first in range(1, comb[0] if comb else 10)],\\n                           range(k), [[]])\\n                    if sum(c) == n]\\n\\n---\\n\\nI note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesn't test those).",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Batteries Included**  \\nAC in 44ms\\n\\nFirst the obligatory *\"use the darn library\"* solution. Create all k-combinations of digits and keep those with sum n:\\n\\n    from itertools import combinations\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in combinations(range(1, 10), k) if sum(c) == n]\\n\\n---\\n\\n**Recursive**  \\nAC in 48 ms\\n\\nBut it's more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            def combs(k, n, cap):\\n                if not k:\\n                    return [[]] * (not n)\\n                return [comb + [last]\\n                        for last in range(1, cap)\\n                        for comb in combs(k-1, n-last, last)]\\n            return combs(k, n, 10)\\n\\n---\\n\\n**Iterative**  \\nAC in 56 ms\\n\\nAnd an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap.\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[first] + comb\\n                         for comb in combs\\n                         for first in range(1, comb[0] if comb else 10)]\\n            return [c for c in combs if sum(c) == n]\\n\\n---\\n\\n**Reduce**  \\nAC in 44 ms\\n\\nAnd here's a \"one-liner\" version of the iterative solution using `reduce` instead of the loop:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in\\n                    reduce(lambda combs, _: [[first] + comb\\n                                             for comb in combs\\n                                             for first in range(1, comb[0] if comb else 10)],\\n                           range(k), [[]])\\n                    if sum(c) == n]\\n\\n---\\n\\nI note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesn't test those).",
                "codeTag": "Java"
            },
            {
                "id": 2024061,
                "title": "c-faster-than-100-implementation-explained",
                "content": "* This is a simple backtracking problem.\\n* Try every k length combination for having sum equal to n.\\n* For this try including each number from 1 to 9 to be or not be in a combination. If at any point length of combination equal to k, check for its sum.\\n* If sum == n, include this combination in your answer otherwise backtrack.\\n* To check sum either you can pass a variable in your arguments or decrement n or check sum of elements in the combination vector at the end (like I have done).\\n```\\nclass Solution {\\n    \\n    vector<vector<int>> ansArr;\\n    \\npublic:\\n    \\n    int sum(vector<int>& combination){\\n        int ans = 0;\\n        for(auto x: combination){\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n    \\n    void combinationSumHelper(int k, int n, vector<int>& combination, int num){\\n        \\n        if(k == 0){\\n            if(sum(combination) == n ){\\n                ansArr.push_back(combination);\\n            }\\n            return;\\n        }\\n        \\n        if(num > 9) return;\\n        \\n        combination.push_back(num);  // Including num in combination\\n        combinationSumHelper(k - 1, n, combination, num + 1);\\n        combination.pop_back(); // Not including num in combination\\n        combinationSumHelper(k, n, combination, num + 1);    \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> combination;\\n        combinationSumHelper(k, n, combination, 1);\\n        return ansArr;\\n        \\n    }\\n};\\n```\\n\\nOther Similiar Problems : \\n1. https://leetcode.com/problems/combinations/\\n2. https://leetcode.com/problems/combination-sum/\\n3. https://leetcode.com/problems/combination-sum-ii/\\n4. https://leetcode.com/problems/combination-sum-iv/",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> ansArr;\\n    \\npublic:\\n    \\n    int sum(vector<int>& combination){\\n        int ans = 0;\\n        for(auto x: combination){\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n    \\n    void combinationSumHelper(int k, int n, vector<int>& combination, int num){\\n        \\n        if(k == 0){\\n            if(sum(combination) == n ){\\n                ansArr.push_back(combination);\\n            }\\n            return;\\n        }\\n        \\n        if(num > 9) return;\\n        \\n        combination.push_back(num);  // Including num in combination\\n        combinationSumHelper(k - 1, n, combination, num + 1);\\n        combination.pop_back(); // Not including num in combination\\n        combinationSumHelper(k, n, combination, num + 1);    \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> combination;\\n        combinationSumHelper(k, n, combination, 1);\\n        return ansArr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60631,
                "title": "fast-easy-java-code-with-explanation",
                "content": "Used backtracking to solve this.\\nBuild an array to apply to \"subset\" template. Each time we add an element to the \"list\", for the next step, target= target - num[i]. Since we have already added one element, for the next step, we can only add k-1 elements. Since no duplicated elements accept, for the next loop, the \"start\" should point to the next index of current index. The `list.remove(list.size() - 1)` here means, we need to change the element here. I know it is hard to understand it, let me give you an example.\\nWhen `k=3, n=9`, my answer works like this:\\n[1]->[1,2]->[1,2,3]. Since now sum is not 9, no more backtracking, so after  `list.remove(list.size() - 1)`, it is [1,2]. Then next follows [1,2,4], sum is not 9, repeat process above untill [1,2,6]. When go to next backtracking, the list will be added to `result`, and for this list, no more backtracking.\\nNow we can go back to a previous backtracking, which is [1,3]->[1,3,4], fail. [1,4,]->[1,4,5], fail. And so one.\\nSo the point of  `list.remove(list.size() - 1)` is, after each \"fail\" or \"success\", since we don't need to do further attempts given such a condition, we delete the last element, and then end current backtracking. Next step is, add the next element to the deleted index, go on attempting. \\n\\nIf you have other questions, just reply me. \\n\\n\\n\\n\\n  \\n\\n    public class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] num = {1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        helper(result, new ArrayList<Integer>(), num, k, n,0);\\n        return result;\\n        }\\n    \\n    public void helper(List<List<Integer>> result, List<Integer> list, int[] num, int k, int target, int start){\\n        if (k == 0 && target == 0){\\n            result.add(new ArrayList<Integer>(list));\\n        } else {\\n            for (int i = start; i < num.length && target > 0 && k >0; i++){\\n                list.add(num[i]);\\n                helper(result, list, num, k-1,target-num[i],i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] num = {1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 60719,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2024085,
                "title": "combinations-all-types-solution-meme",
                "content": "The code is almost similar, for all combinations problem pattern. \\nNow you may think about the in-order of problem. I have arranged in a perfect order, practice in this way all these problems because they relates to each other.\\n\\n[**77. Combinations**](https://leetcode.com/problems/combinations/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for(int i = start; i <= n; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\nTime/Space complexity:\\n\\nFirst if in combine will be called exactly **c(n, k)** times, which is a binomial coefficient - number of ways you can pick **k** elements from set of sizen. Then it has to perform k size job, of creating new result entry. Time complexity - `O(k * c(n, k)).`\\nFor loop fragment, will be called exactly **c(n, k - 1)** times and (in improved solution which only iterates on **i <= n - k + 1)** there will ben/k iterations on average. Time complexity - `O(n/k * c(n, k - 1))` .\\n\\n* **Final time complexity :-** **`O(k * c(n, k)) + O(n/k * c(n, k - 1))) = O(k * c(n, k))`**\\n\\n\\n* **Space complexity :-** **`O(k * c(n, k))`** - if we exclude the result collection it will be **`O(k)`**.\\n\\n[**216. Combination Sum III**](https://leetcode.com/problems/combination-sum-iii/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(n == 0 && temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n        }\\n        for(int i = start; i <= 9; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n - i, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`O(K * 9^K)`**\\n\\n\\n* **Space Complexity :-** **`O(K)`**\\n\\n\\n[**39. Combination Sum**](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                solve(i, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time complexity :-**  **`O(len(nums)^target)`** or **`O(N^M)`**\\n\\n* **Space Complexity :-** **`O(length of longest combination)`**\\n\\n\\n[**40. Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i - 1]) continue;\\n                temp.add(nums[i]);\\n                solve(i + 1, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time complexity :-**  **`O(N x 2^N)`**\\n\\n* **Space Complexity :-** **`O(N x 2^N)`**\\n\\n```\\nMEME Time :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/82a169c2-7cef-4871-b8a0-4f2aba9ee45e_1652153023.149258.gif)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for(int i = start; i <= n; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(n == 0 && temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n        }\\n        for(int i = start; i <= 9; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n - i, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                solve(i, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i - 1]) continue;\\n                temp.add(nums[i]);\\n                solve(i + 1, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nMEME Time :-\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60629,
                "title": "use-backtrack-c-solution-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        backtrack(result, path, 1, k, n);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target){\\n        if(target==0&&k==0){\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<=10-k&&i<=target;i++){\\n            path.push_back(i);\\n            backtrack(result,path,i+1,k-1,target-i);\\n            path.pop_back();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        backtrack(result, path, 1, k, n);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target){\\n        if(target==0&&k==0){\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<=10-k&&i<=target;i++){\\n            path.push_back(i);\\n            backtrack(result,path,i+1,k-1,target-i);\\n            path.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 842733,
                "title": "c-clean-backtracking-0-ms-beats-100-easy-to-understand",
                "content": "**Explanation**\\nThe key to this question is backtracking, that is, generate possible combinations and see which one fulfills the conditions.\\nWe choose a number for 1,2..kth position in ascending order, and for each position, we only iterate through [current_number, 9].\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void f(vector<int>& cur, int cnum, int k, int n) {\\n        if(n < 0 || cur.size() > k) return;\\n        if(n == 0 && cur.size() == k) {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=cnum; i<=9; ++i) {\\n            cur.push_back(i);\\n            f(cur, i+1, k, n-i);\\n            cur.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> cur;\\n        f(cur, 1, k, n);\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any doubts, feel free to comment. If you like the solution and the explanation, please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void f(vector<int>& cur, int cnum, int k, int n) {\\n        if(n < 0 || cur.size() > k) return;\\n        if(n == 0 && cur.size() == k) {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=cnum; i<=9; ++i) {\\n            cur.push_back(i);\\n            f(cur, i+1, k, n-i);\\n            cur.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> cur;\\n        f(cur, 1, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024574,
                "title": "python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.\\n\\nIf you have any doubts, feel free to comment. If you like the solution and the explanation, please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842764,
                "title": "python-backtrack-solution-explained",
                "content": "If in problem we need to return all possible options with some property, usually it means that we need to do backtracking. Let us use `BackTr` function with parameters:\\n\\n1. `k` is number of numbers we need to take to build our number.\\n2. `n` is number we need to build\\n3. `curr_sol` built solution so far.\\n\\nThen if `n<0` of `k<0` we need to go back; if `n==0` and `k==0` means that we found solution, so we add it to our `self.sol`. Then we just run our `BackTr` with parameters: `k-1`: we need to take one less number, `n-i`, where `i` is the last digit we added: it is either starts with `1` or with `curr_sol[-1] + 1` and `curr_sol + [i]` will be our built solution so far.\\n\\nFinally, we run ` self.BackTr(k, n, [])` and return `self.sol`.\\n\\n**Comlexity**: For first digit we have not more than `9` options, for second one no more than `8` and so on, so there will be `9*8*...*(9-k+1)` possible options, for each of which we need `O(k)`. We can improve this bound if we take into account that there is 2^9 possible combinations at all, so complexity is `O(2^9*k)`, because of all dead-ends we can have. Space complexity is `O(k)`, if we do not take into account output solution.\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k, n):\\n        self.sol = []\\n        self.BackTr(k, n, [])\\n        return self.sol\\n        \\n    def BackTr(self, k, n, curr_sol):\\n        if n < 0 or k < 0: return\\n        if n == 0 and k == 0:\\n            self.sol.append(curr_sol)\\n            \\n        start = curr_sol[-1] + 1 if curr_sol else 1\\n            \\n        for i in range(start, 10):\\n            self.BackTr(k - 1, n - i, curr_sol + [i])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k, n):\\n        self.sol = []\\n        self.BackTr(k, n, [])\\n        return self.sol\\n        \\n    def BackTr(self, k, n, curr_sol):\\n        if n < 0 or k < 0: return\\n        if n == 0 and k == 0:\\n            self.sol.append(curr_sol)\\n            \\n        start = curr_sol[-1] + 1 if curr_sol else 1\\n            \\n        for i in range(start, 10):\\n            self.BackTr(k - 1, n - i, curr_sol + [i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024145,
                "title": "simple-easy-c-solution",
                "content": "```\\n void solve(int st,int k,int n,vector<int> &ds,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=st;i<=9;i++)    \\n        {\\n            ds.push_back(i);\\n            solve(i+1,k-1,n-i,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(1,k,n,ds,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void solve(int st,int k,int n,vector<int> &ds,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=st;i<=9;i++)    \\n        {\\n            ds.push_back(i);\\n            solve(i+1,k-1,n-i,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(1,k,n,ds,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843394,
                "title": "python-simple-solution-explained-video-code-backtracking",
                "content": "[](https://www.youtube.com/watch?v=J2hcPZRpbMk)\\nhttps://www.youtube.com/watch?v=J2hcPZRpbMk\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        def backtrack(num, stack, target):\\n            if len(stack) == k:\\n                if target == 0:\\n                    res.append(stack)\\n                return\\n            \\n            for x in range(num + 1, 10):\\n                if x <= target:\\n                    backtrack(x, stack + [x], target - x)\\n                else:\\n                    return\\n        \\n        backtrack(0, [], n)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        def backtrack(num, stack, target):\\n            if len(stack) == k:\\n                if target == 0:\\n                    res.append(stack)\\n                return\\n            \\n            for x in range(num + 1, 10):\\n                if x <= target:\\n                    backtrack(x, stack + [x], target - x)\\n                else:\\n                    return\\n        \\n        backtrack(0, [], n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844197,
                "title": "javascript-clean-code-72-ms",
                "content": "```javascript\\nvar combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546449,
                "title": "java-optimized-backtracking-w-detailed-time-complexity-explanation",
                "content": "```java\\n/**\\n * Backtracking\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(9,0) + C(9,1) + ... + C(9,K-1))   +   K * C(9,K)\\n * In our solution, the worst case will happen when k = 8. Then Total Time Complexity = O(574) which is O(1)\\n *\\n * Space Complexity = O(k) -> Depth of Recursion tree + Size of TempList\\n *\\n * K = Input size of each combination.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        if (k <= 0 || k > 9 || n <= 0 || n > 45 || (k == 1 && n > 9) || (k == 9 && n != 45) || (n < k * (k + 1) / 2)) {\\n            return result;\\n        }\\n        if (k == 1) {\\n            result.add(List.of(n));\\n            return result;\\n        }\\n        if (k == 9) {\\n            result.add(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9));\\n            return result;\\n        }\\n\\n        combinationSum3(1, k, n, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum3(int start, int k, int n, List<Integer> tempList, List<List<Integer>> result) {\\n        if (k == 0) {\\n            if (n == 0) {\\n                result.add(new ArrayList<>(tempList));\\n            }\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            if (i > n) {\\n                break;\\n            }\\n            tempList.add(i);\\n            combinationSum3(i + 1, k - 1, n - i, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(9,0) + C(9,1) + ... + C(9,K-1))   +   K * C(9,K)\\n * In our solution, the worst case will happen when k = 8. Then Total Time Complexity = O(574) which is O(1)\\n *\\n * Space Complexity = O(k) -> Depth of Recursion tree + Size of TempList\\n *\\n * K = Input size of each combination.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        if (k <= 0 || k > 9 || n <= 0 || n > 45 || (k == 1 && n > 9) || (k == 9 && n != 45) || (n < k * (k + 1) / 2)) {\\n            return result;\\n        }\\n        if (k == 1) {\\n            result.add(List.of(n));\\n            return result;\\n        }\\n        if (k == 9) {\\n            result.add(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9));\\n            return result;\\n        }\\n\\n        combinationSum3(1, k, n, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum3(int start, int k, int n, List<Integer> tempList, List<List<Integer>> result) {\\n        if (k == 0) {\\n            if (n == 0) {\\n                result.add(new ArrayList<>(tempList));\\n            }\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            if (i > n) {\\n                break;\\n            }\\n            tempList.add(i);\\n            combinationSum3(i + 1, k - 1, n - i, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60636,
                "title": "concise-python-solution-using-dfs",
                "content": "    class Solution:\\n        # @param {integer} k\\n        # @param {integer} n\\n        # @return {integer[][]}\\n        def combinationSum3(self, k, n):\\n            if n > sum([i for i in range(1, 11)]):\\n                return []\\n    \\n            res = []\\n            self.sum_help(k, n, 1, [], res)\\n            return res\\n    \\n    \\n        def sum_help(self, k, n, curr, arr, res):\\n            if len(arr) == k:\\n                if sum(arr) == n:\\n                    res.append(list(arr))\\n                return\\n    \\n            if len(arr) > k or curr > 9:\\n                return\\n            \\n            for i in range(curr, 10):\\n                arr.append(i)\\n                self.sum_help(k, n, i + 1, arr, res)\\n                arr.pop()",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 2024072,
                "title": "c-backtrack-take-it-or-leave-it",
                "content": "**Solved live on stream.  Come join us 6pm PT.  Link in profile**\\n\\n```\\nclass Solution {\\n    void dfs(int num, int sum, int count, vector<int>& path, vector<vector<int>>& ans) {\\n        if(sum == 0 && count == 0) {\\n            ans.push_back(path);\\n            return;\\n        }\\n        if(sum == 0 || count == 0) {\\n            return;\\n        }\\n        if(num > 9) return;\\n        \\n        //take it\\n        if(sum >= num && count > 0) {\\n            path.push_back(num);\\n            dfs(num+1, sum-num, count-1, path, ans);\\n            path.pop_back();\\n        }\\n        \\n        //leave it\\n        dfs(num+1, sum, count, path, ans);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) { \\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(1, n, k, path, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(int num, int sum, int count, vector<int>& path, vector<vector<int>>& ans) {\\n        if(sum == 0 && count == 0) {\\n            ans.push_back(path);\\n            return;\\n        }\\n        if(sum == 0 || count == 0) {\\n            return;\\n        }\\n        if(num > 9) return;\\n        \\n        //take it\\n        if(sum >= num && count > 0) {\\n            path.push_back(num);\\n            dfs(num+1, sum-num, count-1, path, ans);\\n            path.pop_back();\\n        }\\n        \\n        //leave it\\n        dfs(num+1, sum, count, path, ans);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) { \\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(1, n, k, path, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450921,
                "title": "simple-backtracking-solution-in-c",
                "content": "Here is my solution this problem.\\nIf you **LIKE** the solution then **Upvote** it!!\\nThank you !!\\n\\n### **Solution:**\\n```\\nclass Solution {\\npublic:\\n    void  combinations(int k,int idx, int n,vector<int>temp,vector<vector<int>>&ans)\\n    {\\n        if(n<0 || temp.size()>k)\\n            return;\\n        if(n==0 && temp.size()==k)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            temp.push_back(i);\\n            combinations(k,i+1,n-i,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        combinations(k,1,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void  combinations(int k,int idx, int n,vector<int>temp,vector<vector<int>>&ans)\\n    {\\n        if(n<0 || temp.size()>k)\\n            return;\\n        if(n==0 && temp.size()==k)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            temp.push_back(i);\\n            combinations(k,i+1,n-i,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        combinations(k,1,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026135,
                "title": "python-diagrammatically-explained-for-beginners-backtracking-tree-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8ed8590d-5f69-4bab-9d1a-e0d128e0c3ba_1652194276.2071493.png)\\n\\n**Algorithm for the recursive backtracking function**:\\n***BASE CONDITION:*** \\n1. Check if sum(arr) exceeds the value of n, the simply return.\\n2. Check if k == 0, if sum(arr) == n then one of our answer is found, append it to the final answer list, else simply return as we have no more elements left to place in array as k == 0.\\n\\n***RECURSIVE STEP:***\\n1. Run a loop through the max element in array (as we dont want duplicates, and elements less that the max element would have been already considered in the previous recursive calls) to minimum of (n, 10) as we want only single digit as each of the array elements, so go upto n (as anyways we cannot exceed n) or less than 10 which ever is minimum as we just want a single digit.\\n2. for each iteration of the loop, append the iterator value to the existing array and call the recursive function reducing the value of k (saying we have added another element to the array, hence we used up one more space).\\nNow, when this recursive function is called again same base conditions will be checked and ans will be added if found.\\n\\nHope this explanation helps to the people who are just beginning with backtracking problems.\\n\\nAlso see this, if you are new to backtracking problems: https://leetcode.com/problems/generate-parentheses/discuss/1276417/python-explained-easy-backtracking-with-time-and-space-complexity\\n\\n\\n\\n\\n\\n**Time Complexity = O(9^k)** owing to Height/depth of the tree in worst case O(k) and for each height there are 9 possible splits.\\n**Space Complexity = O(k^2)** as at any instance of time the max height of the tree is O(k) and for each level we store an array of size k.\\n\\nKindly, correct me if I am wrong! (I too have some doubts here, yet this seems logical).\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        def recur(k, n, arr):\\n            s = sum(arr)\\n            if k == 0 or s > n:\\n                if s == n:\\n                    self.ans.append(arr.copy())\\n                return\\n            \\n            max_e = max(arr) if arr else 0\\n            for i in range(max_e + 1, min(n + 1, 10)):\\n                temp = arr.copy()\\n                temp.append(i)\\n                recur(k-1, n, temp)\\n            return\\n        \\n        \\n        self.ans = []\\n        recur(k, n, [])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        def recur(k, n, arr):\\n            s = sum(arr)\\n            if k == 0 or s > n:\\n                if s == n:\\n                    self.ans.append(arr.copy())\\n                return\\n            \\n            max_e = max(arr) if arr else 0\\n            for i in range(max_e + 1, min(n + 1, 10)):\\n                temp = arr.copy()\\n                temp.append(i)\\n                recur(k-1, n, temp)\\n            return\\n        \\n        \\n        self.ans = []\\n        recur(k, n, [])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60787,
                "title": "non-recursive-c-0ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n            vector<vector<int>> ret;\\n            vector<int> path(k);\\n            int i = 0;\\n            int curSum = 0;\\n            \\n            while(i!=-1){\\n                path[i]++;\\n                curSum++;\\n                if(path[i]>9 || curSum > n || (i!=k-1 && curSum+path[i] >= n) ){\\n                    curSum -= path[i];\\n                    i--;\\n                }else if(i == k-1){\\n                    if(curSum == n) ret.push_back(path);\\n                }else if(curSum+path[i] < n){\\n                    path[i+1] = path[i];\\n                    curSum += path[i];\\n                    i++;\\n                }\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n            vector<vector<int>> ret;\\n            vector<int> path(k);\\n            int i = 0;\\n            int curSum = 0;\\n            \\n            while(i!=-1){\\n                path[i]++;\\n                curSum++;\\n                if(path[i]>9 || curSum > n || (i!=k-1 && curSum+path[i] >= n) ){\\n                    curSum -= path[i];\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2024468,
                "title": "easy-c-solution-2-approaches-bit-manipulation-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\npublic:\\n    /*\\n        BACKTRACKING BASED SOLUTION:\\n        ===========================        \\n    */\\n    \\n    \\n    int sum(const vector<int>& combo) {\\n        int temp = 0;\\n        for (int x : combo)\\n            temp += x;\\n        return temp;\\n    }\\n    \\n    void helper(vector<int>& combo, int k, int n, int num) {\\n        if (!k) {\\n            if (sum(combo) == n)\\n                ans.push_back(combo);\\n            return;\\n        }\\n        \\n        if (num > 9) return;\\n        \\n        combo.push_back(num);\\n        helper(combo, k - 1, n, num + 1);\\n        combo.pop_back();\\n        helper(combo, k, n, num + 1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combo;\\n        helper(combo, k, n, 1);\\n        return ans;\\n    }\\n};\\n```\\n```    \\n/*\\n    BRUTE FORCE | BIT MANIPULATION\\n    ==============================\\n\\n\\tThis solution involves checking all possible combinations possible :\\n\\t- \"int bits = __builtin_popcount(i);\" here we check if their are K numbers or not\\n\\t- if there are K numbers present, then we just check the sum of all \\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < (1 << 9); i++) {\\n            vector<int> combo;\\n            int bits = __builtin_popcount(i);\\n            if (bits != k) continue;\\n            \\n            int temp = 0;\\n            for (int j = 0; j < 9; j++) {\\n                if (i & (1 << j)) {\\n                    temp += (j + 1);\\n                    combo.push_back(j + 1);\\n                }\\n            }\\n            \\n            if (temp == n)\\n                ans.push_back(combo);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\npublic:\\n    /*\\n        BACKTRACKING BASED SOLUTION:\\n        ===========================        \\n    */\\n    \\n    \\n    int sum(const vector<int>& combo) {\\n        int temp = 0;\\n        for (int x : combo)\\n            temp += x;\\n        return temp;\\n    }\\n    \\n    void helper(vector<int>& combo, int k, int n, int num) {\\n        if (!k) {\\n            if (sum(combo) == n)\\n                ans.push_back(combo);\\n            return;\\n        }\\n        \\n        if (num > 9) return;\\n        \\n        combo.push_back(num);\\n        helper(combo, k - 1, n, num + 1);\\n        combo.pop_back();\\n        helper(combo, k, n, num + 1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combo;\\n        helper(combo, k, n, 1);\\n        return ans;\\n    }\\n};\\n```\n```    \\n/*\\n    BRUTE FORCE | BIT MANIPULATION\\n    ==============================\\n\\n\\tThis solution involves checking all possible combinations possible :\\n\\t- \"int bits = __builtin_popcount(i);\" here we check if their are K numbers or not\\n\\t- if there are K numbers present, then we just check the sum of all \\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < (1 << 9); i++) {\\n            vector<int> combo;\\n            int bits = __builtin_popcount(i);\\n            if (bits != k) continue;\\n            \\n            int temp = 0;\\n            for (int j = 0; j < 9; j++) {\\n                if (i & (1 << j)) {\\n                    temp += (j + 1);\\n                    combo.push_back(j + 1);\\n                }\\n            }\\n            \\n            if (temp == n)\\n                ans.push_back(combo);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025415,
                "title": "easy-java-recursive-backtracking-clean-code-fast-simple",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Combination Sum III.\\nMemory Usage: 39.7 MB, less than 89.81% of Java online submissions for Combination Sum III.**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        combi(res,new ArrayList<>(),1,0,k,n);\\n        return res;\\n    }\\n    public void combi(List<List<Integer>> res,List<Integer> ds,int num,int sum,int k,int n){\\n        if(k==0 && n==sum){\\n            res.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i=num;i<=9;i++){\\n            sum+=i;\\n            ds.add(i);\\n            combi(res,ds,i+1,sum,k-1,n);\\n            sum-=i;\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        combi(res,new ArrayList<>(),1,0,k,n);\\n        return res;\\n    }\\n    public void combi(List<List<Integer>> res,List<Integer> ds,int num,int sum,int k,int n){\\n        if(k==0 && n==sum){\\n            res.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i=num;i<=9;i++){\\n            sum+=i;\\n            ds.add(i);\\n            combi(res,ds,i+1,sum,k-1,n);\\n            sum-=i;\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023978,
                "title": "java-backtracking",
                "content": "\\n\\n\\n```\\n\\nclass Solution {\\n    List<List<Integer>> allComb = new ArrayList<>();                     \\n    List<Integer> comb = new ArrayList<>();                              \\n    \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        findComb(k, n, 1);                                              \\n        return allComb;\\n    }\\n    \\n    private void findComb(int k, int n, int start) {                      \\n        if(k == 0 && n == 0){                                             \\n            allComb.add(new ArrayList<>(comb));\\n            return;\\n        }\\n        for(int i = start; i < 10; i++){\\n            comb.add(i);\\n            findComb(k - 1, n - i, i + 1);\\n            comb.remove(comb.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<List<Integer>> allComb = new ArrayList<>();                     \\n    List<Integer> comb = new ArrayList<>();                              \\n    \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        findComb(k, n, 1);                                              \\n        return allComb;\\n    }\\n    \\n    private void findComb(int k, int n, int start) {                      \\n        if(k == 0 && n == 0){                                             \\n            allComb.add(new ArrayList<>(comb));\\n            return;\\n        }\\n        for(int i = start; i < 10; i++){\\n            comb.add(i);\\n            findComb(k - 1, n - i, i + 1);\\n            comb.remove(comb.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099458,
                "title": "java-0ms-backtracking-extremely-easy",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] nums = {1,2,3,4,5,6,7,8,9};\\n        Set<List<Integer>> set = new HashSet<>();\\n        combinationSum3Helper(nums,set,new ArrayList<>(),k,n,0);\\n\\n        return new ArrayList<>(set);\\n    }\\n\\n    static private void combinationSum3Helper(int[] nums,Set<List<Integer>> set,List<Integer> list,\\n                                              int k,int target,int start){\\n        if(target < 0)\\n            return;\\n        else if(target == 0 && list.size() == k)\\n            set.add(new ArrayList<>(list));\\n        else{\\n            for(int i =start;i<nums.length;i++){\\n                if(target - nums[i] < 0) //  Optimisation\\n                    break;;\\n                list.add(nums[i]);\\n                combinationSum3Helper(nums,set,list,k,target - nums[i],i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] nums = {1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 772273,
                "title": "general-approach-to-backtracking-questions-in-java",
                "content": "## [Subsets](https://leetcode.com/problems/subsets/)\\n\\nGiven a set of **distinct** integers, return all possible subsets.\\n\\n``` java\\nclass Solution {    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n## [SubSets II](https://leetcode.com/problems/subsets-ii/)\\n\\nGiven a set of **some duplicate** integers, return all possible subsets.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n## [Permutation](https://leetcode.com/problems/permutations/)\\n\\nGiven a collection of **distinct** integers, return all possible permutations.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (temp.contains(nums[i])) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Permutation II](https://leetcode.com/problems/permutations-ii/)\\n\\nGiven a collection of **some duplicate** integers, return all possible permutations.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] used) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) { continue; } // skip duplicates\\n                used[i] = true;\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, used);\\n                used[i] = false;\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum](https://leetcode.com/problems/combination-sum/)\\n\\nGiven a set of candidate numbers (candidates) **(without duplicates)** and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The **same** repeated number may be chosen from candidates **unlimited** number of times.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\\n\\nGiven a set of candidate numbers (candidates) **(with some duplicates)** and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number may be chosen from candidates **once**. \\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums); // easy to compare\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i + 1); \\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\\n\\nFind all possible combinations of ***k*** numbers that add up to a number ***n***, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), k, n, 1);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int k, int remain, int start) {\\n        if (temp.size() > k) { \\n            return; \\n        } else if (temp.size() == k && remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{\\n            for (int i = start; i <= 9; i++) {\\n                temp.add(i);\\n                backtrack(ans, temp, k, remain - i, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "``` java\\nclass Solution {    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (temp.contains(nums[i])) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] used) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) { continue; } // skip duplicates\\n                used[i] = true;\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, used);\\n                used[i] = false;\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums); // easy to compare\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i + 1); \\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), k, n, 1);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int k, int remain, int start) {\\n        if (temp.size() > k) { \\n            return; \\n        } else if (temp.size() == k && remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{\\n            for (int i = start; i <= 9; i++) {\\n                temp.add(i);\\n                backtrack(ans, temp, k, remain - i, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388941,
                "title": "0ms-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefault backtracking solution, but here we have ```bool``` return type. It here for decrease amount of iterations. If target become less than zero it means that in other iterations has no sense, because of ```std::iota``` nums contains numbers from 1 to 9 and next itarations will make target smalle and smaller. So if target less then zero we return false that means that we shoudl return from previous call of backtrack method and try another ```nums[i]```.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> combinationSum3(int k, int n) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currentSeq;\\n        std::vector<int> nums(9);\\n        std::iota(nums.begin(), nums.end(), 1);\\n\\n        combination(nums, 0, n, k, currentSeq, output);\\n\\n\\n        return output;\\n    }\\n\\nprivate:\\n    bool combination(std::vector<int>& nums, int pos, int target, int length, std::vector<int>& currentSeq, std::vector<std::vector<int>>& output) {\\n        if(currentSeq.size() > length) {\\n            return false;\\n        }\\n        if(target == 0 && currentSeq.size() == length) {\\n            output.push_back(currentSeq);\\n            return true;\\n        }\\n        else if(target < 0) {\\n            return false;\\n        }\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            currentSeq.push_back(nums[i]);\\n\\n            auto result = combination(nums, i+1, target-nums[i], length, currentSeq, output);\\n\\n            currentSeq.pop_back();\\n\\n            if(!result) {\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```\\n\\n![fotor_2023-4-7_9_8_42.jpg](https://assets.leetcode.com/users/images/59e934fa-ccde-424c-a884-d4397fe3df0c_1680847781.015317.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```bool```\n```std::iota```\n```nums[i]```\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> combinationSum3(int k, int n) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currentSeq;\\n        std::vector<int> nums(9);\\n        std::iota(nums.begin(), nums.end(), 1);\\n\\n        combination(nums, 0, n, k, currentSeq, output);\\n\\n\\n        return output;\\n    }\\n\\nprivate:\\n    bool combination(std::vector<int>& nums, int pos, int target, int length, std::vector<int>& currentSeq, std::vector<std::vector<int>>& output) {\\n        if(currentSeq.size() > length) {\\n            return false;\\n        }\\n        if(target == 0 && currentSeq.size() == length) {\\n            output.push_back(currentSeq);\\n            return true;\\n        }\\n        else if(target < 0) {\\n            return false;\\n        }\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            currentSeq.push_back(nums[i]);\\n\\n            auto result = combination(nums, i+1, target-nums[i], length, currentSeq, output);\\n\\n            currentSeq.pop_back();\\n\\n            if(!result) {\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997421,
                "title": "easy-backtracking-code-beats-100-amazon-sde-1-interview",
                "content": "![Screenshot (11).png](https://assets.leetcode.com/users/images/59178fb1-7b74-4b5c-8e7c-fdf7238dd0f5_1672830655.1942635.png)\\n\\n### **It is one of the Pick only type of Backtracking problems.**\\n\\n### **Doing Combination Sum 1 and 2 is mandatory before solving this problem.**\\n\\n### **Also this problem has been asked for FAANG interview multiple times.**\\n### **My friend recently gave Microsoft SDE-1 Interview and faced this question!** \\n\\n#### **Code is self explainatory ! If you don\\'t understand this code then plz do check out the following solutions to make it more clear.**\\n# Combination Sum 1 :-\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/\\n\\n# Combination Sum 2 :-\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/2980945/easiest-faang-method-ever/\\n\\n\\n# ***Please Upvote if it helps \\uD83D\\uDE4F\\u2764\\uFE0F***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void CombinationSum(int ind, vector<int> &ds, vector<vector<int>> &ans, int target, int k, int n){\\n        if(ds.size()==k){\\n            if(target==0){\\n                ans.emplace_back(ds);\\n                return;\\n            }\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(ds.size()>=k && target!=0) break;\\n            if(i>target) break;\\n            ds.emplace_back(i);\\n            CombinationSum(i+1, ds, ans, target-i, k, n);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        if(n<k){\\n            return ans;\\n        }\\n        CombinationSum(1, ds, ans, n, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void CombinationSum(int ind, vector<int> &ds, vector<vector<int>> &ans, int target, int k, int n){\\n        if(ds.size()==k){\\n            if(target==0){\\n                ans.emplace_back(ds);\\n                return;\\n            }\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(ds.size()>=k && target!=0) break;\\n            if(i>target) break;\\n            ds.emplace_back(i);\\n            CombinationSum(i+1, ds, ans, target-i, k, n);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        if(n<k){\\n            return ans;\\n        }\\n        CombinationSum(1, ds, ans, n, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774445,
                "title": "combinations-sum-iii-java-solution-simple-approach-as-combination-sum-i",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,9,k,n,sum,ans,subset);\\n        return ans;\\n    }\\n     void helper(int start, int end, int k, int n, int sum, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n    \\n         if(k==0){\\n                if(sum==n){\\n                 ans.add(new ArrayList(subset));\\n                return;\\n                }\\n                return;\\n           }\\n\\t\\t   \\n         if(start>end)\\n             return;\\n\\t\\t\\t \\n         if(sum>n)\\n             return;\\n        \\n        //include\\n        sum+=start;\\n        subset.add(start);\\n        helper(start+1,end,k-1,n,sum,ans,subset);\\n        \\n        //exclude\\n         sum-=start;\\n        subset.remove(subset.size()-1);\\n        helper(start+1,end,k,n,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,9,k,n,sum,ans,subset);\\n        return ans;\\n    }\\n     void helper(int start, int end, int k, int n, int sum, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n    \\n         if(k==0){\\n                if(sum==n){\\n                 ans.add(new ArrayList(subset));\\n                return;\\n                }\\n                return;\\n           }\\n\\t\\t   \\n         if(start>end)\\n             return;\\n\\t\\t\\t \\n         if(sum>n)\\n             return;\\n        \\n        //include\\n        sum+=start;\\n        subset.add(start);\\n        helper(start+1,end,k-1,n,sum,ans,subset);\\n        \\n        //exclude\\n         sum-=start;\\n        subset.remove(subset.size()-1);\\n        helper(start+1,end,k,n,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029286,
                "title": "c-solution-recursion-and-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // base condition to reached the answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n\\n        // if any one of them (k,n) gets 0 it means no valid combination found then we return\\n        if(sum==0 || count==0)\\n            return;\\n\\n        // if value cross 9 then we also return as given in the condition\\n        if(start>9)\\n            return;\\n        \\n        //if current value lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n\\n        //skipping the current value if it is not is the bound and check for\\n        helper(res, ds, count, sum, start+1);\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n\\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // base condition to reached the answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n\\n        // if any one of them (k,n) gets 0 it means no valid combination found then we return\\n        if(sum==0 || count==0)\\n            return;\\n\\n        // if value cross 9 then we also return as given in the condition\\n        if(start>9)\\n            return;\\n        \\n        //if current value lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n\\n        //skipping the current value if it is not is the bound and check for\\n        helper(res, ds, count, sum, start+1);\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n\\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025355,
                "title": "c-easy-understanding-comments-explanation-daily-leetcoding-challenge-may-day-10",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // if we reached to our answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        // if any one of them (k,n) gets 0 then return\\n        if(sum==0 or count==0)\\n            return;\\n        \\n        // if value cross 9 then also return\\n        if(start>9)\\n            return;\\n        \\n        // if currentvalue lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n        \\n        // else skipping the current value if it is not is the bound\\n        helper(res, ds, count, sum, start+1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n        \\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // if we reached to our answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        // if any one of them (k,n) gets 0 then return\\n        if(sum==0 or count==0)\\n            return;\\n        \\n        // if value cross 9 then also return\\n        if(start>9)\\n            return;\\n        \\n        // if currentvalue lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n        \\n        // else skipping the current value if it is not is the bound\\n        helper(res, ds, count, sum, start+1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n        \\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024527,
                "title": "c-clean-backtracking",
                "content": "```\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> stack = new();\\n        FindSum(1, k, n);\\n        return results;\\n\\n        void FindSum(int startingValue, int numberOfNumbers, int targetSum)\\n        {\\n            if (targetSum is 0 && numberOfNumbers is 0) results.Add(stack.ToArray());\\n            if (targetSum is 0 || numberOfNumbers is 0) return;\\n\\n            for (int value = startingValue; value < 10; value++)\\n            {\\n                stack.Push(value);\\n                FindSum(value + 1, numberOfNumbers - 1, targetSum - value);\\n                stack.Pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> stack = new();\\n        FindSum(1, k, n);\\n        return results;\\n\\n        void FindSum(int startingValue, int numberOfNumbers, int targetSum)\\n        {\\n            if (targetSum is 0 && numberOfNumbers is 0) results.Add(stack.ToArray());\\n            if (targetSum is 0 || numberOfNumbers is 0) return;\\n\\n            for (int value = startingValue; value < 10; value++)\\n            {\\n                stack.Push(value);\\n                FindSum(value + 1, numberOfNumbers - 1, targetSum - value);\\n                stack.Pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024203,
                "title": "backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(target, k, result, 1, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(int target, int k, List<List<Integer>> result, int index, List<Integer> currList,\\n                           int currSum) {\\n        if (currSum > target) return;\\n        if (currSum == target && currList.size() == k) result.add(new ArrayList<>(currList));\\n        for (int i = index; i < 10 && currList.size() <= k; ++i) {\\n            currList.add(i);\\n            backtrack(target, k, result, i + 1, currList, currSum + i);\\n            currList.remove(currList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(target, k, result, 1, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(int target, int k, List<List<Integer>> result, int index, List<Integer> currList,\\n                           int currSum) {\\n        if (currSum > target) return;\\n        if (currSum == target && currList.size() == k) result.add(new ArrayList<>(currList));\\n        for (int i = index; i < 10 && currList.size() <= k; ++i) {\\n            currList.add(i);\\n            backtrack(target, k, result, i + 1, currList, currSum + i);\\n            currList.remove(currList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60652,
                "title": "combinations-v-s-combination-sum-iii-java",
                "content": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       } \\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       } \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60746,
                "title": "accepted-recursive-java-solution-easy-to-understand",
                "content": "The idea is to choose proper number for 1,2..kth position in ascending order, and for each position, we only iterate through (prev_num, n/k]. Time comlexity O(k)\\n\\n    public class Solution {\\n        private List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        public List<List<Integer>> combinationSum3(int k, int n) {\\n            findCombo( k, n, 1, new LinkedList<Integer>() );\\n            return res;\\n        }\\n        public void findCombo(int k, int n, int start, List<Integer> list){\\n            if( k == 1 ){\\n                if( n < start || n > 9 ) return;\\n                list.add( n );\\n                res.add( list );\\n                return;\\n            }\\n            for( int i = start; i <= n / k && i < 10; i++ ){\\n                List<Integer> subList = new LinkedList<Integer>( list );\\n                sub.add( i );\\n                findCombo( k - 1, n - i, i + 1, subList );\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        private List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        public List<List<Integer>> combinationSum3(int k, int n) {\\n            findCombo( k, n, 1, new LinkedList<Integer>() );\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3535660,
                "title": "backtracking-c-tc-o-k-9-k-sc-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every combination we try out, we get an option of either selecting a digit from 1 to 9, or rejecting it and moving to the next one. Once we\\'ve made that choice, we have to continue making that decision for digits succeeding the current one.\\n\\nThis process is repeated till we either run out of the number of digits we can select, or the current sum becomes equal to the required sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare a function `generateCombos` with the parameters `idx` that indicates the number current number whose selection/rejection is to be decided, `k` that represents the number of digits we can select, `n` that represents the required sum, `temp` that stores the possible combination generated and `sol` that contains all possible solutions.\\n\\nIterate from `idx` to 9, selecting/rejecting values to be added to the possible solution. If the value to be selected is greater than the required sum `n`, return to the function call.\\n\\nIn all other cases, select the current value and recursively call the function with the next digit and the new, reduced values of `k` and `n`. Finally, reject the current value and move on the the subsequent values to generate all possible subcases.\\n\\nIf at any point in the function calls the number of moves become zero and the required sum is obtained, push it into the `sol` solution vector.\\n\\n# Complexity\\n- Time complexity: $$O(k*9^k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, int k, int n, vector<int>& temp, vector<vector<int>>& sol){\\n        if(!k||!n){\\n            if(!k&&!n) sol.push_back(temp);\\n            return;\\n        }\\n\\n        for(int i=idx;i<=9;i++){\\n            if(n<i) return;\\n            \\n            temp.push_back(i);\\n            generateCombos(i+1, k-1, n-i, temp, sol);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        generateCombos(1, k, n, temp, sol);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, int k, int n, vector<int>& temp, vector<vector<int>>& sol){\\n        if(!k||!n){\\n            if(!k&&!n) sol.push_back(temp);\\n            return;\\n        }\\n\\n        for(int i=idx;i<=9;i++){\\n            if(n<i) return;\\n            \\n            temp.push_back(i);\\n            generateCombos(i+1, k-1, n-i, temp, sol);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        generateCombos(1, k, n, temp, sol);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460726,
                "title": "bet-me-no-one-can-beat-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(9^k)\\nbecause we\\'re generating all possible combinations of numbers from 1 to 9 with length k\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(k)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/a66e19ac-9823-407c-b176-b5f22dbbd7e5_1682601634.5993307.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        // create a list to store all subsets that satisfy the conditions\\n        List<List<Integer>> subset = new ArrayList<>();\\n\\n        // create an array list to store the current subset\\n        ArrayList<Integer> current = new ArrayList<>();\\n\\n        // generate the subsets\\n        generateSubset(1,9,current,subset,k,n);\\n\\n        // return the list of subsets\\n        return subset;\\n    }\\n\\n    // helper method to generate the subsets\\n    public void generateSubset(int start,int end,ArrayList<Integer> current, List<List<Integer>> subset,int k, int target){\\n\\n        // if target is reached and the size of current subset is k, add current subset to the list of subsets\\n        if(target == 0 && current.size() == k){\\n            subset.add(new ArrayList(current));\\n        }\\n\\n        // recursively generate subsets by trying all possible numbers from start to end\\n        for(int i = start; i <= end; i++){\\n            current.add(i);\\n\\n            // recursively call generateSubset with updated current subset and target\\n            generateSubset(i+1, end, current,subset,k,target-i);\\n\\n            // remove the last element from current subset before trying the next number\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        // create a list to store all subsets that satisfy the conditions\\n        List<List<Integer>> subset = new ArrayList<>();\\n\\n        // create an array list to store the current subset\\n        ArrayList<Integer> current = new ArrayList<>();\\n\\n        // generate the subsets\\n        generateSubset(1,9,current,subset,k,n);\\n\\n        // return the list of subsets\\n        return subset;\\n    }\\n\\n    // helper method to generate the subsets\\n    public void generateSubset(int start,int end,ArrayList<Integer> current, List<List<Integer>> subset,int k, int target){\\n\\n        // if target is reached and the size of current subset is k, add current subset to the list of subsets\\n        if(target == 0 && current.size() == k){\\n            subset.add(new ArrayList(current));\\n        }\\n\\n        // recursively generate subsets by trying all possible numbers from start to end\\n        for(int i = start; i <= end; i++){\\n            current.add(i);\\n\\n            // recursively call generateSubset with updated current subset and target\\n            generateSubset(i+1, end, current,subset,k,target-i);\\n\\n            // remove the last element from current subset before trying the next number\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387485,
                "title": "runtime-0-sec-faster-than-100-very-simple-beginner-friendly-approach",
                "content": "**Intution:** We need to create distinct subsequences, hence we can make use of recursion. We can start by pushing 1 in the ds(data structure used to store the vectors) , i.e if i am presently at 1, i have options for 2,3,4 uptill 9. \\n    After the recursive call, we  increase the i by 1 (for the next stage) and add i to the sum(s).\\nBase case is easy when the size of ds == k and s == n ,we push the ds in ans, else we simply return. \\t\\n\\n**Time Complexity** - 2^n * k  (where k is the avg size of the ds)\\n**Space  Complexity** - k*x (auxillary space is ignored)\\n\\n```\\nvoid generate_combinations(int i, int s, int k, int n, vector<vector<int>> &ans, vector<int>&ds){\\n        \\n        if(ds.size() == k){\\n            \\n            if(s == n){\\n            ans.push_back(ds);\\n            }\\n           return;\\n        } \\n        \\n        for(i; i<=9; i++){\\n            \\n            ds.push_back(i);\\n            generate_combinations(i+1, s+i, k, n, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans; \\n        vector<int> ds;\\n        \\n        generate_combinations(1,0, k, n, ans, ds);\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\nIf you liked my Solution, do upvote. Happy Leetcoding !",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid generate_combinations(int i, int s, int k, int n, vector<vector<int>> &ans, vector<int>&ds){\\n        \\n        if(ds.size() == k){\\n            \\n            if(s == n){\\n            ans.push_back(ds);\\n            }\\n           return;\\n        } \\n        \\n        for(i; i<=9; i++){\\n            \\n            ds.push_back(i);\\n            generate_combinations(i+1, s+i, k, n, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans; \\n        vector<int> ds;\\n        \\n        generate_combinations(1,0, k, n, ans, ds);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3215401,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements. where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    void combinationSum3(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start, int sum){\\n        if(temp.size() == k){\\n            if(n == sum){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=start; i<=9; i++){\\n            temp.push_back(i); \\n            combinationSum3(n, k, output, temp, i+1, sum+i);\\n            temp.pop_back(); \\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum3(n, k, output, temp, 1, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    void combinationSum3(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start, int sum){\\n        if(temp.size() == k){\\n            if(n == sum){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=start; i<=9; i++){\\n            temp.push_back(i); \\n            combinationSum3(n, k, output, temp, i+1, sum+i);\\n            temp.pop_back(); \\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum3(n, k, output, temp, 1, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211811,
                "title": "100-submission-time-taken-0ms-c-solution-using-simple-recursion-with-backtracing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst of all we have to check for all the number from 1-9 and no number should repeat itself so we will have a loop from 1 to 9.\\n\\nWhenever we choose a number we use recursion and see for the value ahead of that number by replacing value of s by i+1.this will remove the possibility of any repetition of a number.\\n\\neg : if the number choose is 2 then the recursion will see for the other number ahead of it i.e 3,4... so on and the code will not see for 1 as it would be checked first and if the recursion is going for 2 that means that 1 was not suitable for the give condition. \\n\\n# Complexity\\n- Time complexity:O(k*9^k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define vii vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\nclass Solution {\\npublic:\\nvii ans;\\nvoid solve(vi &x,int k,int t,int s){\\n\\n    //base case\\n    if(t==0){ // here we have to push value when the target is zero\\n        if(k==0){   // but the condition is that the size should be k \\n        ans.pb(x); //so we will only push the vector when k is zero i.e the size of the give answer is k\\n        }\\n        return;\\n    }\\n    //recursive case\\n    for(int i=s;i<=9;++i){\\n        if(t>=i and k>0){   // here we will perform only when the target is greater than the value we are taking as well as the k should be +ve which means that the condition of having k element is not yet completed\\n            x.pb(i);\\n            k--; // whenever a value is inserted k is reduced \\n            solve(x,k,t-i,i+1);\\n            x.pop_back();\\n            k++;    // whenever a value is removed k is incremented again\\n        }\\n    }\\n\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vi x;\\n        solve(x,k,n,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n#define vii vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\nclass Solution {\\npublic:\\nvii ans;\\nvoid solve(vi &x,int k,int t,int s){\\n\\n    //base case\\n    if(t==0){ // here we have to push value when the target is zero\\n        if(k==0){   // but the condition is that the size should be k \\n        ans.pb(x); //so we will only push the vector when k is zero i.e the size of the give answer is k\\n        }\\n        return;\\n    }\\n    //recursive case\\n    for(int i=s;i<=9;++i){\\n        if(t>=i and k>0){   // here we will perform only when the target is greater than the value we are taking as well as the k should be +ve which means that the condition of having k element is not yet completed\\n            x.pb(i);\\n            k--; // whenever a value is inserted k is reduced \\n            solve(x,k,t-i,i+1);\\n            x.pop_back();\\n            k++;    // whenever a value is removed k is incremented again\\n        }\\n    }\\n\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vi x;\\n        solve(x,k,n,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025671,
                "title": "2-solution-using-backtracking-dp-c",
                "content": "**1) BACKTRACKING SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int k , int n,int sum , vector<int> v , int start)\\n    {\\n        if(k == 0)\\n        {\\n            if(sum == n)\\n                ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            v.push_back(i);\\n            solve(k - 1 , n , sum+i , v , i + 1);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(k , n , 0, v , 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n**2) DP SOLUTION**\\nSimilar to 0-1 knapsack o(n) optimizattion\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<vector<int>>> dp(n+1);\\n        dp[0] = {{}};\\n        for(int i=1;i<=9;i++)\\n        {\\n            for(int j = n ; j >=i ; j--)\\n            {\\n                for(auto v : dp[j - i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int k , int n,int sum , vector<int> v , int start)\\n    {\\n        if(k == 0)\\n        {\\n            if(sum == n)\\n                ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            v.push_back(i);\\n            solve(k - 1 , n , sum+i , v , i + 1);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(k , n , 0, v , 1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<vector<int>>> dp(n+1);\\n        dp[0] = {{}};\\n        for(int i=1;i<=9;i++)\\n        {\\n            for(int j = n ; j >=i ; j--)\\n            {\\n                for(auto v : dp[j - i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024233,
                "title": "c-easy-solution-with-explaination-backtracking",
                "content": "This problem is very simmilar to it\\'s previous versions ([Combination Sum I](https://leetcode.com/problems/combination-sum/) and [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)).\\nWe will apply backtracking approach to solve this problem.\\n**Following are the steps to follow:**\\n1. Maintain two vectors (vector<vector<int>> and vector<int>),\\n2. Start with \\'1\\' and move to \\'9\\'.\\n3. Put every number in temp vector and include that number into sum property.\\n4. If number of elements in temp vector are more than k i.e k==0, check for sum and take action accordingly.\\n5. Then backtrack everytime for another solution.\\n6. Finally, return the solution.\\n\\n**Simple c++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int prev,int k,int sum,int n,vector<int> temp,vector<vector<int>>&ans){\\n        if(k==0){\\n            if(sum==n){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=prev;i<=9;i++){\\n            temp.push_back(i);\\n            solve(i+1,k-1,sum+i,n,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(1,k,0,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int prev,int k,int sum,int n,vector<int> temp,vector<vector<int>>&ans){\\n        if(k==0){\\n            if(sum==n){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=prev;i<=9;i++){\\n            temp.push_back(i);\\n            solve(i+1,k-1,sum+i,n,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(1,k,0,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843430,
                "title": "python-crazy-simple-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        all_combinations = list(combinations(range(1,10), k))\\n        sum_n = [c for c in all_combinations if sum(c)==n]\\n        return sum_n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        all_combinations = list(combinations(range(1,10), k))\\n        sum_n = [c for c in all_combinations if sum(c)==n]\\n        return sum_n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671391,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n    const solArr = [];\\n    \\n    const recurse = (currArr, target, index) => {\\n        if (target < 0 || currArr.length > k) return;\\n        if (currArr.length === k) return target === 0 && solArr.push(currArr.slice())\\n        \\n        for (let i = index; i <= 9; i++) {\\n            currArr.push(i);\\n            recurse(currArr, target - i, i + 1);\\n            currArr.pop();\\n        }\\n    };\\n\\n    recurse([], n, 1);\\n    \\n    return solArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n    const solArr = [];\\n    \\n    const recurse = (currArr, target, index) => {\\n        if (target < 0 || currArr.length > k) return;\\n        if (currArr.length === k) return target === 0 && solArr.push(currArr.slice())\\n        \\n        for (let i = index; i <= 9; i++) {\\n            currArr.push(i);\\n            recurse(currArr, target - i, i + 1);\\n            currArr.pop();\\n        }\\n    };\\n\\n    recurse([], n, 1);\\n    \\n    return solArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60717,
                "title": "java-easy-to-understand-recursive-solution",
                "content": "        \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> nums = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            nums.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, k, n, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(List<Integer> nums, int k, int n, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        if (k <= 0 && n <= 0) {\\n            if (k == 0 && n == 0) {\\n                ret.add(path);\\n            }\\n            return; // backtracking\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums.get(i));\\n            dfs(nums, k-1, n-nums.get(i), i+1, p, ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> nums = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            nums.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, k, n, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(List<Integer> nums, int k, int n, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        if (k <= 0 && n <= 0) {\\n            if (k == 0 && n == 0) {\\n                ret.add(path);\\n            }\\n            return; // backtracking\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums.get(i));\\n            dfs(nums, k-1, n-nums.get(i), i+1, p, ret);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60732,
                "title": "simple-dfs-solution",
                "content": "    def combinationSum3(self, k, n):\\n        res = []\\n        self.dfs(range(1,10), 0, [], k, n, res)\\n        return res\\n    \\n    def dfs(self, nums, idx, path, k, n, res):\\n        if n < 0:\\n            return\\n        if len(path) == k and n == 0:\\n            res.append(path)\\n            return\\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, i+1, path+[nums[i]], k, n-nums[i], res)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def combinationSum3(self, k, n):\\n        res = []\\n        self.dfs(range(1,10), 0, [], k, n, res)\\n        return res\\n    \\n    def dfs(self, nums, idx, path, k, n, res):\\n        if n < 0:\\n            return\\n        if len(path) == k and n == 0:\\n            res.append(path)\\n            return\\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, i+1, path+[nums[i]], k, n-nums[i], res)",
                "codeTag": "Python3"
            },
            {
                "id": 3224641,
                "title": "216-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe backtrack() function returns a list of lists, where each inner list is a valid combination of numbers that sum up to n. The start parameter represents the smallest number that can be added to the combination, and it starts at 1 initially. The target parameter is the remaining sum that we need to reach. The k parameter is the number of values we still need to add to the combination. The res parameter is not used anymore, so we can remove it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def backtrack(start, target, k, res):\\n            if k == 0 and target == 0:\\n                return [[]]\\n            if k == 0 or target < 0:\\n                return []\\n            ans = []\\n            for i in range(start, 10):\\n                for combo in backtrack(i+1, target-i, k-1, res):\\n                    ans.append([i] + combo)\\n            return ans\\n        \\n        return backtrack(1, n, k, [])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def backtrack(start, target, k, res):\\n            if k == 0 and target == 0:\\n                return [[]]\\n            if k == 0 or target < 0:\\n                return []\\n            ans = []\\n            for i in range(start, 10):\\n                for combo in backtrack(i+1, target-i, k-1, res):\\n                    ans.append([i] + combo)\\n            return ans\\n        \\n        return backtrack(1, n, k, [])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140812,
                "title": "easy-c-backtracking-code-beats-100",
                "content": "# Intuition\\nIntuition is same as that of Combination Sum 1 and 2 but the only difference is we are given with a range of numbers(1-9) instead of an array to iterate through.\\n\\n# Approach\\n- Write the Base Case which is if size of ds gets > than k and target is achieved then store that ds in ans vector.\\n- Run loop from 1 to 9 as it is the range given.\\n- Add the sum and do recursion and after completing recursion subract the i from that sum to its original state.\\n\\n# To Avoid getting duplicates if we use stack then it will increase space and time complexity that is why we use for loop to avoid using duplicates.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>> &ans, vector<int> &ds, int sum,int ind,int k,int n)\\n    {\\n        if(ds.size() == k)\\n        {\\n            if(sum == n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;               \\n        }\\n           for(int i =ind ;i<=9;i++)\\n           {\\n               if(i>n) \\n               {\\n                   break;\\n               }\\n               sum = sum + i;\\n               ds.push_back(i);\\n               solve(ans,ds,sum,i+1,k,n);\\n               ds.pop_back();\\n               sum = sum - i;\\n           }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int sum = 0;\\n        solve(ans,v,sum,1,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>> &ans, vector<int> &ds, int sum,int ind,int k,int n)\\n    {\\n        if(ds.size() == k)\\n        {\\n            if(sum == n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;               \\n        }\\n           for(int i =ind ;i<=9;i++)\\n           {\\n               if(i>n) \\n               {\\n                   break;\\n               }\\n               sum = sum + i;\\n               ds.push_back(i);\\n               solve(ans,ds,sum,i+1,k,n);\\n               ds.pop_back();\\n               sum = sum - i;\\n           }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int sum = 0;\\n        solve(ans,v,sum,1,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437048,
                "title": "c-simple-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        \\n        //take this element \\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        \\n\\t\\t//dont take this element\\n        solve(num + 1 , target , temp) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        \\n        //take this element \\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        \\n\\t\\t//dont take this element\\n        solve(num + 1 , target , temp) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027170,
                "title": "python3-3-lines-of-code",
                "content": "\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums = [i for i in range(1,10)]\\n        \\n        comb = itertools.combinations(nums,k)\\n        \\n        return [c for c in comb if sum(c) == n]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums = [i for i in range(1,10)]\\n        \\n        comb = itertools.combinations(nums,k)\\n        \\n        return [c for c in comb if sum(c) == n]",
                "codeTag": "Python3"
            },
            {
                "id": 2024735,
                "title": "short-c-100-fastest-explaination-o-n-o-1",
                "content": "**100% faster Easy Backtracking Solution** \\nThis problem is very simmilar to it\\'s previous versions (Combination Sum I and Combination Sum II).\\nWe will apply backtracking approach to solve this problem.\\n**Following are the steps to follow:**\\n\\n* Maintain two vectors (vector<vector> and vector),\\n* Start with \\'1\\' and move to \\'9\\'.\\n* Put every number in temp vector and include that number into sum property.\\n* If number of elements in temp vector are more than k i.e k==0, check for sum and take action accordingly.\\n* Then backtrack everytime for another solution.\\n* Finally, return the solution.\\n\\n**Simple c++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    void combinationSumHelper( int start, int k, int n, vector<int> &ds, vector<vector<int>> &ans ){\\n        \\n        if( k<= 0 ){\\n            // We have got our combination \\n            if( n == 0 ) ans.push_back( ds );\\n            return ;\\n        }\\n        \\n        for( int i=start ; i<=9 ; i++ ){\\n            \\n\\t\\t\\t// Push the element \\n            ds.push_back( i );\\n\\t\\t\\t// Find out the combinations possible with this number \\n            combinationSumHelper( i+1, k-1, n-i, ds, ans );\\n\\t\\t\\t// Backtracking \\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans ;\\n        vector<int> ds ;\\n        \\n        combinationSumHelper( 1, k , n, ds, ans );\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSumHelper( int start, int k, int n, vector<int> &ds, vector<vector<int>> &ans ){\\n        \\n        if( k<= 0 ){\\n            // We have got our combination \\n            if( n == 0 ) ans.push_back( ds );\\n            return ;\\n        }\\n        \\n        for( int i=start ; i<=9 ; i++ ){\\n            \\n\\t\\t\\t// Push the element \\n            ds.push_back( i );\\n\\t\\t\\t// Find out the combinations possible with this number \\n            combinationSumHelper( i+1, k-1, n-i, ds, ans );\\n\\t\\t\\t// Backtracking \\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans ;\\n        vector<int> ds ;\\n        \\n        combinationSumHelper( 1, k , n, ds, ans );\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686893,
                "title": "golang-0ms",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tcurrent := make([]int, k)\\n\\n\\tdfs216(&ans, current, n, k-1, 1)\\n\\n\\treturn ans\\n}\\n```\\n\\n```\\nfunc dfs216(ans *[][]int, current []int, target, index, start int) {\\n\\tif index < 0 {\\n\\t\\tif target == 0 {\\n\\t\\t\\t*ans = append(*ans, append([]int{}, current...))\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := start; i <= 9 && target >= i; i++ {\\n\\t\\tcurrent[index] = i\\n\\t\\tdfs216(ans, current, target-i, index-1, i+1)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tcurrent := make([]int, k)\\n\\n\\tdfs216(&ans, current, n, k-1, 1)\\n\\n\\treturn ans\\n}\\n```\n```\\nfunc dfs216(ans *[][]int, current []int, target, index, start int) {\\n\\tif index < 0 {\\n\\t\\tif target == 0 {\\n\\t\\t\\t*ans = append(*ans, append([]int{}, current...))\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := start; i <= 9 && target >= i; i++ {\\n\\t\\tcurrent[index] = i\\n\\t\\tdfs216(ans, current, target-i, index-1, i+1)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312061,
                "title": "c-easy-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx,int cnt){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            if(cnt==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1,cnt-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<int> candidates;\\n        for(int i=0;i<9;i++){\\n            candidates.push_back(i+1);\\n        }\\n        makesum(candidates,n,0,temp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx,int cnt){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            if(cnt==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1,cnt-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<int> candidates;\\n        for(int i=0;i<9;i++){\\n            candidates.push_back(i+1);\\n        }\\n        makesum(candidates,n,0,temp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312030,
                "title": "elegant-python-iterative-recursive",
                "content": "#### Iterative\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        current_combination, combinations = [], []\\n        integer, combination_sum = 1, 0\\n        queue = [(integer, current_combination, combination_sum)]\\n        while queue:\\n            integer, current_combination, combination_sum = queue.pop()\\n            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)\\n            else:\\n                for i in range(integer, 10):\\n                    if combination_sum + i > n: break\\n                    queue.append((i+1, current_combination + [i], combination_sum + i))\\n        \\n        return combinations\\n```\\n#### Recursive\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        combinations = []\\n        counter = [(integer, 1) for integer in range(1, 10)]\\n        \\n        def recursion(integer = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > n or len(current_combination) > k or integer not in range(9): return\\n            elif combination_sum == n and len(current_combination) == k: combinations.append(current_combination.copy())\\n            else:\\n                candidate, frequency = counter[integer]\\n                if frequency == 1:\\n                    counter[integer] = (candidate, 0)\\n                    recursion(integer, current_combination + [candidate], combination_sum + candidate)\\n                counter[integer] = (candidate, frequency)\\n                recursion(integer+1, current_combination, combination_sum)\\n                \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        current_combination, combinations = [], []\\n        integer, combination_sum = 1, 0\\n        queue = [(integer, current_combination, combination_sum)]\\n        while queue:\\n            integer, current_combination, combination_sum = queue.pop()\\n            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)\\n            else:\\n                for i in range(integer, 10):\\n                    if combination_sum + i > n: break\\n                    queue.append((i+1, current_combination + [i], combination_sum + i))\\n        \\n        return combinations\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        combinations = []\\n        counter = [(integer, 1) for integer in range(1, 10)]\\n        \\n        def recursion(integer = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > n or len(current_combination) > k or integer not in range(9): return\\n            elif combination_sum == n and len(current_combination) == k: combinations.append(current_combination.copy())\\n            else:\\n                candidate, frequency = counter[integer]\\n                if frequency == 1:\\n                    counter[integer] = (candidate, 0)\\n                    recursion(integer, current_combination + [candidate], combination_sum + candidate)\\n                counter[integer] = (candidate, frequency)\\n                recursion(integer+1, current_combination, combination_sum)\\n                \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872958,
                "title": "c-dp-solution-o-m-9-n-combinatorics-solution",
                "content": "**DP Solution**\\n\\nRuntime: 4 ms, faster than 43.49% of C++ online submissions for Combination Sum III.\\nMemory Usage: 7.3 MB, less than 11.17% of C++ online submissions for Combination Sum III.\\n\\nSolution similar to [Coin Change 2](https://leetcode.com/problems/coin-change-2/), [Combination Sum](https://leetcode.com/problems/combination-sum/) \\nand 0-1 KnapSack problem (Candidates are considered once only), just need to track the combination sums in different vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // If k>=n then no combination sum is possible Ex: k = 2, n = 1 => not possible, k = 2, n = 2 => not possible\\n        // Also largest possible combination sum = [1+2+3+4+5+6+7+8+9] = 45 and so if n>45 then no combination sum possible\\n        if(k>=n || n>45)return vector<vector<int>>{};\\n        \\n        // combination track 3D vector holds the combination sum vectors of nums from 1 to target\\n        vector<vector<vector<int>>>result(n+1,vector<vector<int>>(1,vector<int>(0)));     \\n        \\n        // dp vector holds all possible combination sum count for range 1 to target\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;\\n        \\n        // combination candidate limit 1 to 9 and so we take min(9,n)\\n        int lim = min(9,n);\\n        \\n        // Loop through candidates 1 to limit\\n        for(int i=1;i<=lim;i++)\\n        {\\n            // calculate the contribution of candidates in the range target to candidates\\n            // as we can only take each candidate once in each combination sum\\n            for(int j=n;j>=i;j--)\\n            {\\n                // combination sum count for number j\\n                dp[j]+= dp[j-i];\\n                \\n                // If combination sum possible for number j and i; and j is not the target  \\n                if(dp[j-i]>=1 && j<n)\\n                {\\n                    // get all combination sum vectors from number j-i  and add to number j\\'s combination sum vector \\n                    result[j].insert(result[j].end(),result[j-i].end()-dp[j-i],result[j-i].end());\\n\\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=0;p<dp[j-i];p++)\\n                        result[j][result[j].size()-1-p].push_back(i);\\n                }\\n                \\n                // If combination sum possible for number j and i; and j is the target\\n                else if(dp[j-i]>=1 && j==n)\\n                {\\n                    // get all combination sum vectors from number j-i whose vector size k-1 and add to number j\\'s combination sum vector  \\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=result[j-i].size()-dp[j-i];p<result[j-i].size();p++)\\n                        if(result[j-i][p].size()==k-1)\\n                            result[j].push_back(result[j-i][p]),result[j].back().push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // remove blank vector at front\\n        result[n].erase(result[n].begin());\\n        return result[n];\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return vector<vector<int>>();\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        // dp vector to hold all the combinations of target from 1 to target\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>());\\n        \\n        // loop through 1 to limit and check the contribution of candidates from 1 to n\\n        for(int i=1;i<=limit;i++)\\n        {\\n            // loop from n to i to check contribution of candidate i cause we consider each item once only\\n            for(int j=n;j>=i;j--)\\n            {\\n                // add candidate if compliment is 0\\n                if(j-i==0)dp[j].push_back({i});\\n                \\n                // otherwise add ith candidate to all compliment combinations and add those to dp[i]\\n                else if(dp[j-i].size()>0)\\n                {\\n                    for(auto t : dp[j-i])\\n                    {\\n                        t.push_back(i);\\n                        dp[j].push_back(t);\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        // add only the k size combinations in to result\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Combination Solution**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum III.\\nMemory Usage: 6.4 MB, less than 83.25% of C++ online submissions for Combination Sum III.\\n\\n```\\nGenerate all mCk combinations where m = min (9,n) and check the sum of the\\ncombination. Take only those combinations where sum == n.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void combination(int start, int limit, int n, int k, int sum, int &target, vector<vector<int>>&res, vector<int>&vals)\\n    {\\n        // check sum == target\\n        if(k==0)\\n        {\\n            if(sum==target)\\n            {\\n                res.push_back(vals);\\n            }\\n            \\n            return;\\n        }\\n        \\n        if(n==0) return;\\n        \\n        // take and ignore value from start to limit-k+1\\n        for(int i=start;i<=limit-k+1;i++)\\n        {\\n            vals.push_back(i);\\n            combination(i+1,limit,n-1,k-1,sum+i,target,res,vals);\\n            vals.pop_back();\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return {};\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        vector<int>vals;\\n        vector<vector<int>>res;\\n        \\n        // generate all mCk combinations\\n        combination(1,limit,limit,k,0,n,res,vals);\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // If k>=n then no combination sum is possible Ex: k = 2, n = 1 => not possible, k = 2, n = 2 => not possible\\n        // Also largest possible combination sum = [1+2+3+4+5+6+7+8+9] = 45 and so if n>45 then no combination sum possible\\n        if(k>=n || n>45)return vector<vector<int>>{};\\n        \\n        // combination track 3D vector holds the combination sum vectors of nums from 1 to target\\n        vector<vector<vector<int>>>result(n+1,vector<vector<int>>(1,vector<int>(0)));     \\n        \\n        // dp vector holds all possible combination sum count for range 1 to target\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;\\n        \\n        // combination candidate limit 1 to 9 and so we take min(9,n)\\n        int lim = min(9,n);\\n        \\n        // Loop through candidates 1 to limit\\n        for(int i=1;i<=lim;i++)\\n        {\\n            // calculate the contribution of candidates in the range target to candidates\\n            // as we can only take each candidate once in each combination sum\\n            for(int j=n;j>=i;j--)\\n            {\\n                // combination sum count for number j\\n                dp[j]+= dp[j-i];\\n                \\n                // If combination sum possible for number j and i; and j is not the target  \\n                if(dp[j-i]>=1 && j<n)\\n                {\\n                    // get all combination sum vectors from number j-i  and add to number j\\'s combination sum vector \\n                    result[j].insert(result[j].end(),result[j-i].end()-dp[j-i],result[j-i].end());\\n\\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=0;p<dp[j-i];p++)\\n                        result[j][result[j].size()-1-p].push_back(i);\\n                }\\n                \\n                // If combination sum possible for number j and i; and j is the target\\n                else if(dp[j-i]>=1 && j==n)\\n                {\\n                    // get all combination sum vectors from number j-i whose vector size k-1 and add to number j\\'s combination sum vector  \\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=result[j-i].size()-dp[j-i];p<result[j-i].size();p++)\\n                        if(result[j-i][p].size()==k-1)\\n                            result[j].push_back(result[j-i][p]),result[j].back().push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // remove blank vector at front\\n        result[n].erase(result[n].begin());\\n        return result[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return vector<vector<int>>();\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        // dp vector to hold all the combinations of target from 1 to target\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>());\\n        \\n        // loop through 1 to limit and check the contribution of candidates from 1 to n\\n        for(int i=1;i<=limit;i++)\\n        {\\n            // loop from n to i to check contribution of candidate i cause we consider each item once only\\n            for(int j=n;j>=i;j--)\\n            {\\n                // add candidate if compliment is 0\\n                if(j-i==0)dp[j].push_back({i});\\n                \\n                // otherwise add ith candidate to all compliment combinations and add those to dp[i]\\n                else if(dp[j-i].size()>0)\\n                {\\n                    for(auto t : dp[j-i])\\n                    {\\n                        t.push_back(i);\\n                        dp[j].push_back(t);\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        // add only the k size combinations in to result\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nGenerate all mCk combinations where m = min (9,n) and check the sum of the\\ncombination. Take only those combinations where sum == n.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void combination(int start, int limit, int n, int k, int sum, int &target, vector<vector<int>>&res, vector<int>&vals)\\n    {\\n        // check sum == target\\n        if(k==0)\\n        {\\n            if(sum==target)\\n            {\\n                res.push_back(vals);\\n            }\\n            \\n            return;\\n        }\\n        \\n        if(n==0) return;\\n        \\n        // take and ignore value from start to limit-k+1\\n        for(int i=start;i<=limit-k+1;i++)\\n        {\\n            vals.push_back(i);\\n            combination(i+1,limit,n-1,k-1,sum+i,target,res,vals);\\n            vals.pop_back();\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return {};\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        vector<int>vals;\\n        vector<vector<int>>res;\\n        \\n        // generate all mCk combinations\\n        combination(1,limit,limit,k,0,n,res,vals);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842861,
                "title": "java-solution-simplified-with-video-explanation",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/BPeyMvNc_b4\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n           Set<List<Integer>>  set = new HashSet<>();\\n        combinationSum3Helper(set, k, n, new HashSet<>());\\n        return new ArrayList<>(set);\\n    }\\n    \\n    private void combinationSum3Helper(Set<List<Integer>> ans, int noOfElements, int remainingSum, Set<Integer> runningSet) {\\n        if(noOfElements ==0){\\n            if(remainingSum==0){\\n                ans.add(new ArrayList<>(runningSet));  \\n                return ;\\n            } else {\\n                return ;\\n            }\\n        }\\n        \\n        if(remainingSum<0){\\n            return ;\\n        }\\n        \\n        for(int i=1;i<=9;i++) {\\n            if(!runningSet.contains(i)){\\n                runningSet.add(i);\\n                combinationSum3Helper(ans,noOfElements-1, remainingSum- i, runningSet);\\n                runningSet.remove(i);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n           Set<List<Integer>>  set = new HashSet<>();\\n        combinationSum3Helper(set, k, n, new HashSet<>());\\n        return new ArrayList<>(set);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 842726,
                "title": "combination-sum-iii-python-99-13",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        output=[]\\n        def dfs(depth,cur,start):\\n            nonlocal output\\n            if n-sum(cur)<sum([i for i in range(start,start+depth)]):\\n                return\\n            if depth==1 and start<=n-sum(cur)<10:\\n                output.append(cur+[n-sum(cur)])\\n                return\\n            for i in range(start,10):\\n                dfs(depth-1,cur+[i],i+1)\\n        \\n        dfs(k,[],1)\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        output=[]\\n        def dfs(depth,cur,start):\\n            nonlocal output\\n            if n-sum(cur)<sum([i for i in range(start,start+depth)]):\\n                return\\n            if depth==1 and start<=n-sum(cur)<10:\\n                output.append(cur+[n-sum(cur)])\\n                return\\n            for i in range(start,10):\\n                dfs(depth-1,cur+[i],i+1)\\n        \\n        dfs(k,[],1)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842694,
                "title": "c-ugly-bruteforce-solution-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n   \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if (1+2+3+4+5+6+7+8+9 < n || k > 9)\\n            return {};\\n        \\n        vector<vector<int>> result;\\n        \\n        for(int i_1 = 0; i_1 < 2; i_1++) {\\n            for(int i_2 = 0; i_2 < 2; i_2++) {\\n                for(int i_3 = 0; i_3 < 2; i_3++) {\\n                    for(int i_4 = 0; i_4 < 2; i_4++) {\\n                        for(int i_5 = 0; i_5 < 2; i_5++) {\\n                            for(int i_6 = 0; i_6 < 2; i_6++) {\\n                                for(int i_7 = 0; i_7 < 2; i_7++) {\\n                                    for(int i_8 = 0; i_8 < 2; i_8++) {\\n                                        for(int i_9 = 0; i_9 < 2; i_9++) {\\n                                            if (i_1+i_2+i_3+i_4+i_5+i_6+i_7+i_8+i_9 != k) continue;\\n                                            if (i_1+2*i_2+3*i_3+4*i_4+5*i_5+6*i_6+7*i_7+8*i_8+9*i_9 != n) continue;\\n                                            vector<int> res;\\n                                            if(i_1 > 0) res.push_back(1);\\n                                            if(i_2 > 0) res.push_back(2);\\n                                            if(i_3 > 0) res.push_back(3);\\n                                            if(i_4 > 0) res.push_back(4);\\n                                            if(i_5 > 0) res.push_back(5);\\n                                            if(i_6 > 0) res.push_back(6);\\n                                            if(i_7 > 0) res.push_back(7);\\n                                            if(i_8 > 0) res.push_back(8);\\n                                            if(i_9 > 0) res.push_back(9);\\n                                            result.push_back(res);\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n   \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if (1+2+3+4+5+6+7+8+9 < n || k > 9)\\n            return {};\\n        \\n        vector<vector<int>> result;\\n        \\n        for(int i_1 = 0; i_1 < 2; i_1++) {\\n            for(int i_2 = 0; i_2 < 2; i_2++) {\\n                for(int i_3 = 0; i_3 < 2; i_3++) {\\n                    for(int i_4 = 0; i_4 < 2; i_4++) {\\n                        for(int i_5 = 0; i_5 < 2; i_5++) {\\n                            for(int i_6 = 0; i_6 < 2; i_6++) {\\n                                for(int i_7 = 0; i_7 < 2; i_7++) {\\n                                    for(int i_8 = 0; i_8 < 2; i_8++) {\\n                                        for(int i_9 = 0; i_9 < 2; i_9++) {\\n                                            if (i_1+i_2+i_3+i_4+i_5+i_6+i_7+i_8+i_9 != k) continue;\\n                                            if (i_1+2*i_2+3*i_3+4*i_4+5*i_5+6*i_6+7*i_7+8*i_8+9*i_9 != n) continue;\\n                                            vector<int> res;\\n                                            if(i_1 > 0) res.push_back(1);\\n                                            if(i_2 > 0) res.push_back(2);\\n                                            if(i_3 > 0) res.push_back(3);\\n                                            if(i_4 > 0) res.push_back(4);\\n                                            if(i_5 > 0) res.push_back(5);\\n                                            if(i_6 > 0) res.push_back(6);\\n                                            if(i_7 > 0) res.push_back(7);\\n                                            if(i_8 > 0) res.push_back(8);\\n                                            if(i_9 > 0) res.push_back(9);\\n                                            result.push_back(res);\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310040,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 306068,
                "title": "combination-sum-i-ii-and-iii-iterative-dp-solutions",
                "content": "Basically we are using bottom-up DP, and notice that the outer loop is looping through the elements, not the DP table. Use `reversed(range())` to ensure that we do not reuse elements. (Reason is given in the code for Combination Sum II).\\n\\n---\\n### Combination Sum\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in range(target - c + 1):\\n                # this ascending loop from 0 to target - c (inclusive) allows reuse of elements\\n                dp[subtarget + c] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list(dp[-1])\\n```\\n\\n---\\n### Combination Sum II\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]   # set to ensure unique result\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(target - c + 1)):\\n                # If we do not use `reversed()`, when we are building dp[subtarget2] and \\n                # have already built dp[subtarget1] (where subtarget2 > subtarget1),\\n                # then we will use the new results we enter into dp[subtarget1] (i.e., use the same element more than once)\\n                dp[c + subtarget] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list( dp[-1])\\n```\\n---\\n### Combination Sum III\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        dp = [set() for _ in range(n + 1)]\\n        dp[0].add(())\\n        for cand in range(1, 10):\\n            for subtarget in reversed(range(n - cand + 1)):\\n                dp[subtarget + cand] |= {prev_list + (cand,) for prev_list in dp[subtarget]}\\n        \\n        return [L for L in map(list, dp[-1]) if len(L) == k]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in range(target - c + 1):\\n                # this ascending loop from 0 to target - c (inclusive) allows reuse of elements\\n                dp[subtarget + c] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list(dp[-1])\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]   # set to ensure unique result\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(target - c + 1)):\\n                # If we do not use `reversed()`, when we are building dp[subtarget2] and \\n                # have already built dp[subtarget1] (where subtarget2 > subtarget1),\\n                # then we will use the new results we enter into dp[subtarget1] (i.e., use the same element more than once)\\n                dp[c + subtarget] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list( dp[-1])\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        dp = [set() for _ in range(n + 1)]\\n        dp[0].add(())\\n        for cand in range(1, 10):\\n            for subtarget in reversed(range(n - cand + 1)):\\n                dp[subtarget + cand] |= {prev_list + (cand,) for prev_list in dp[subtarget]}\\n        \\n        return [L for L in map(list, dp[-1]) if len(L) == k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60789,
                "title": "simple-python-code-using-generator",
                "content": "    def combination(self, k, n, left):\\n        if k == 1 and n in left:\\n            yield [n]\\n        for i in range(len(left)):\\n            for rest in self.combination(k-1, n-left[i], left[i+1:]):\\n                rest.insert(0, left[i])\\n                yield rest\\n    \\n    def combinationSum3(self, k, n):\\n        return list(self.combination(k, n, range(1, 10)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combination(self, k, n, left):\\n        if k == 1 and n in left:\\n            yield [n]\\n        for i in range(len(left)):\\n            for rest in self.combination(k-1, n-left[i], left[i+1:]):\\n                rest.insert(0, left[i])\\n                yield rest\\n    \\n    def combinationSum3(self, k, n):\\n        return list(self.combination(k, n, range(1, 10)))",
                "codeTag": "Python3"
            },
            {
                "id": 60838,
                "title": "share-my-128-ms-javascript-solution",
                "content": "    var combinationSum3 = function(k, n) {\\n      var result = [];\\n      search(1, [], k, n);\\n      return result;\\n    \\n      function search(from, prefix, k, n) {\\n        if (k === 0 && n === 0) return result.push(prefix);\\n        if (from > 9) return;\\n        prefix.push(from);\\n        search(from + 1, prefix.slice(0), k - 1, n - from);\\n        prefix.pop();\\n        search(from + 1, prefix.slice(0), k, n);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var combinationSum3 = function(k, n) {\\n      var result = [];\\n      search(1, [], k, n);\\n      return result;\\n    \\n      function search(from, prefix, k, n) {\\n        if (k === 0 && n === 0) return result.push(prefix);\\n        if (from > 9) return;\\n        prefix.push(from);\\n        search(from + 1, prefix.slice(0), k - 1, n - from);\\n        prefix.pop();\\n        search(from + 1, prefix.slice(0), k, n);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3467536,
                "title": "python-simple-clean-solution-using-combinations",
                "content": "\\n# Code\\n\\n## Using Recursion / DFS:\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(nums, k, n, path, ans):\\n            if k < 0 or n < 0:    return\\n            if k == 0 and n == 0: ans.append(path)\\n\\n            for i in range(len(nums)):\\n                dfs(nums[i + 1:], k - 1, n - nums[i], path + [nums[i]], ans)\\n        \\n        ans = []\\n        dfs(list(range(1,10)), k, n, [], ans)\\n        return ans\\n```\\n\\n## Using Functool Library\\'s combinations:\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        ans = []\\n        for c in combinations(range(1,10),k):\\n            if sum(c)==n:\\n                ans.append(c)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(nums, k, n, path, ans):\\n            if k < 0 or n < 0:    return\\n            if k == 0 and n == 0: ans.append(path)\\n\\n            for i in range(len(nums)):\\n                dfs(nums[i + 1:], k - 1, n - nums[i], path + [nums[i]], ans)\\n        \\n        ans = []\\n        dfs(list(range(1,10)), k, n, [], ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        ans = []\\n        for c in combinations(range(1,10),k):\\n            if sum(c)==n:\\n                ans.append(c)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346965,
                "title": "efficient-solution-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCombination is needed so \"Pick\" and \"Not Pick\" method is going to be used.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Base Case Explanation\\n```\\nif(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n```\\nAs per the problem statement \\nSize of each combination must be equal to k (given in the problem)\\nand sum of the elements of the combination must be \\'n\\'(given in the problem) \\nIf both the condition are full-filled then the combination will be inserted in the ans (vector of vector).\\n\\nIf combination\\'s sum becomes more than n\\n ```\\nif(n<0) // Elements of combination are being subtracted from the required sum\\n```\\nthen, it will return.\\n\\nand if index which are being \"Pick\" or \"Not pick\" are equal to the size of nums \\n```\\nif(i==nums.size()){\\n            return;\\n        }\\n```\\n\\nthen it means there are no more elements left in the nums to take decision of picking it or not picking it, so it will return.\\n\\n# Recursive call Explanation\\n\\nIt is same as Combination Sum -->\\n\\nMy Combination sum solution link\\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(2^n)*\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n*O(n^2)*\\n\\nPlease upvote if you find it helpful\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int i,int k,int n,vector<int>&vec,vector<vector<int>>&ans,vector<int>&nums){\\n        if(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n        \\n        vec.push_back(nums[i]);\\n        help(i+1,k,n-nums[i],vec,ans,nums);\\n        vec.pop_back();\\n        help(i+1,k,n,vec,ans,nums);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>nums{1,2,3,4,5,6,7,8,9};\\n        vector<int>vec;\\n        vector<vector<int>> ans;\\n        help(0,k,n,vec,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n```\n```\\nif(n<0) // Elements of combination are being subtracted from the required sum\\n```\n```\\nif(i==nums.size()){\\n            return;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    void help(int i,int k,int n,vector<int>&vec,vector<vector<int>>&ans,vector<int>&nums){\\n        if(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n        \\n        vec.push_back(nums[i]);\\n        help(i+1,k,n-nums[i],vec,ans,nums);\\n        vec.pop_back();\\n        help(i+1,k,n,vec,ans,nums);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>nums{1,2,3,4,5,6,7,8,9};\\n        vector<int>vec;\\n        vector<vector<int>> ans;\\n        help(0,k,n,vec,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222235,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        solve(num + 1 , target , temp) ;\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        solve(num + 1 , target , temp) ;\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084198,
                "title": "beats-100-conventional-backtrackting-approach-c",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<vector<int>> ans; \\n    void solve(vector<int>& v,int i, int n, int k, int s){\\n        if(s==0){\\n           if(k==0) ans.push_back(v);\\n            return;\\n        }\\n        if(i==n){\\n            return;\\n        }\\n        if(i<=s){\\n            v.push_back(i);\\n            solve(v,i+1, n, k-1, s-i );\\n            v.pop_back();\\n        }\\n        solve(v,i+1, n, k, s);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(v, 1, 10, k ,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans; \\n    void solve(vector<int>& v,int i, int n, int k, int s){\\n        if(s==0){\\n           if(k==0) ans.push_back(v);\\n            return;\\n        }\\n        if(i==n){\\n            return;\\n        }\\n        if(i<=s){\\n            v.push_back(i);\\n            solve(v,i+1, n, k-1, s-i );\\n            v.pop_back();\\n        }\\n        solve(v,i+1, n, k, s);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(v, 1, 10, k ,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071688,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid f(int i,int tar,vector<int>&can,vector<vector<int>>&res,vector<int>&temp,int k){\\n     if(tar==0){\\n         if(temp.size()==k)\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,tar-can[j],can,res,temp,k);\\n            temp.pop_back();\\n        }\\n}\\n    vector<vector<int>> combinationSum3(int k, int tar) {\\n        vector<int>can;\\n        for(int i=0;i<9;i++){\\n            can.push_back(i+1);\\n        }\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,tar,can,res,temp,k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid f(int i,int tar,vector<int>&can,vector<vector<int>>&res,vector<int>&temp,int k){\\n     if(tar==0){\\n         if(temp.size()==k)\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,tar-can[j],can,res,temp,k);\\n            temp.pop_back();\\n        }\\n}\\n    vector<vector<int>> combinationSum3(int k, int tar) {\\n        vector<int>can;\\n        for(int i=0;i<9;i++){\\n            can.push_back(i+1);\\n        }\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,tar,can,res,temp,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025761,
                "title": "java-c-100-solution-using-backtracking-combination-sum-iii",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> currCombination = new ArrayList<>();\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    public void makeCombination(int k,int n,int start)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.add(new ArrayList<>(currCombination));\\n            return;\\n        }\\n        for(int i=start;i<10;++i)\\n        {\\n            currCombination.add(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.remove(currCombination.size()-1);\\n        }\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> currCombination;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    void makeCombination(int k,int n,int start){\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(currCombination);\\n            return;\\n        }\\n        for(int i = start;i<10;++i)\\n        {\\n            currCombination.push_back(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.pop_back();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> currCombination = new ArrayList<>();\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    public void makeCombination(int k,int n,int start)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.add(new ArrayList<>(currCombination));\\n            return;\\n        }\\n        for(int i=start;i<10;++i)\\n        {\\n            currCombination.add(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.remove(currCombination.size()-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> currCombination;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    void makeCombination(int k,int n,int start){\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(currCombination);\\n            return;\\n        }\\n        for(int i = start;i<10;++i)\\n        {\\n            currCombination.push_back(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994199,
                "title": "easy-solution-well-explained-understandable",
                "content": "**Please give an upvote if you like the solution**\\n\\n*#6Companies30days #ReviseWithArsh Challenge 2023\\n*Day1*\\nQ2. Combination Sum with a twist.*\\n\\n# Approach\\nBacktracking Recursive \\n\\n![2.combination-sum-iii.jpg](https://assets.leetcode.com/users/images/bdf748fd-7f97-4f81-a9a1-a538278db186_1672774338.4305134.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>> &ans, vector<int>cur, int n, int k, int start){\\n        if(n==0 and k==0){ //base condition\\n        ans.push_back(cur); //append this combination in final ans\\n        return; //we can\\'t go further, bcuz if we go further k & n becomes negative\\n    }\\n    if(k==0){// when we reached the limit of takingelement into account\\n    return;// some amount left in n\\n    }\\n    for(int i=start;i<=9;i++){\\n        cur.push_back(i); //append i into current vector | push 1\\n        help(ans, cur, n-i, k-1, i+1); // as start=1, so n=n-i i.e., 4, as we have consider an element so k=k-1 i.e., 1, and i=i+1 cuz we had taken i=1 into our account , so for finding combinations for 1 we have to take 2, 3, 4...9 into consideration, we cannot take 1 again into consideration\\n        cur.pop_back(); // we have to find all combinations which are starting i i.e., intial i which was 1, now we have to find all combinations from next i i.e., i+1 i.e.,2, so we have  to pop 1\\n        //Now current vector is empty\\n        //now this process continuous further for 2, 3....9\\n    }\\n    return; //return the value\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector <vector<int>> ans; //return 2D array\\n        vector<int>cur; //store a current combination: we will see that current combination follows a given condition or not\\n        help(ans, cur, n, k, 1); //call a recursive function\\n        return ans;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>> &ans, vector<int>cur, int n, int k, int start){\\n        if(n==0 and k==0){ //base condition\\n        ans.push_back(cur); //append this combination in final ans\\n        return; //we can\\'t go further, bcuz if we go further k & n becomes negative\\n    }\\n    if(k==0){// when we reached the limit of takingelement into account\\n    return;// some amount left in n\\n    }\\n    for(int i=start;i<=9;i++){\\n        cur.push_back(i); //append i into current vector | push 1\\n        help(ans, cur, n-i, k-1, i+1); // as start=1, so n=n-i i.e., 4, as we have consider an element so k=k-1 i.e., 1, and i=i+1 cuz we had taken i=1 into our account , so for finding combinations for 1 we have to take 2, 3, 4...9 into consideration, we cannot take 1 again into consideration\\n        cur.pop_back(); // we have to find all combinations which are starting i i.e., intial i which was 1, now we have to find all combinations from next i i.e., i+1 i.e.,2, so we have  to pop 1\\n        //Now current vector is empty\\n        //now this process continuous further for 2, 3....9\\n    }\\n    return; //return the value\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector <vector<int>> ans; //return 2D array\\n        vector<int>cur; //store a current combination: we will see that current combination follows a given condition or not\\n        help(ans, cur, n, k, 1); //call a recursive function\\n        return ans;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795587,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n  void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n    if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n    if (sol.size() < k) {\\n      for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n        if (n - i < 0) break;\\n        sol.push_back(i);\\n        combination(result, sol, k, n - i);\\n        sol.pop_back();\\n      }\\n    }\\n  }\\n\\n  vector<vector<int>> combinationSum3(int k, int n) {\\n    vector<vector<int>> result;\\n    vector<int> sol;\\n    combination(result, sol, k, n);\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n    if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n    if (sol.size() < k) {\\n      for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n        if (n - i < 0) break;\\n        sol.push_back(i);\\n        combination(result, sol, k, n - i);\\n        sol.pop_back();\\n      }\\n    }\\n  }\\n\\n  vector<vector<int>> combinationSum3(int k, int n) {\\n    vector<vector<int>> result;\\n    vector<int> sol;\\n    combination(result, sol, k, n);\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783759,
                "title": "100-faster-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int k,int n,vector<int> tmp,vector<vector<int>> &ans,int s){\\n        if(n==0&&k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(n==0)return;\\n        if(k==0)return;\\n        for(int i = s; i <= 9; i++){\\n            tmp.push_back(i);\\n            solve(k-1,n-i,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(k>=n || n==1){\\n            return ans;\\n        }\\n        vector<int> tmp;\\n        solve(k,n,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int k,int n,vector<int> tmp,vector<vector<int>> &ans,int s){\\n        if(n==0&&k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(n==0)return;\\n        if(k==0)return;\\n        for(int i = s; i <= 9; i++){\\n            tmp.push_back(i);\\n            solve(k-1,n-i,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(k>=n || n==1){\\n            return ans;\\n        }\\n        vector<int> tmp;\\n        solve(k,n,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774421,
                "title": "java-c-easy-to-understand-backtracking",
                "content": "# // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combin(k, n, 1, ans, res);\\n        return res;\\n        \\n    }\\n    public static void combin(int k, int n, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<10;i++)\\n        {\\n            ans.add(i);\\n            combin(k-1, n-i, i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combin(k, n, 1, ans, res);\\n        return res;\\n        \\n    }\\n    public static void combin(int k, int n, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<10;i++)\\n        {\\n            ans.add(i);\\n            combin(k-1, n-i, i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637057,
                "title": "c-100-fast-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(vector<int> &ans,int j,int k,int n)\\n    {\\n        if(n==0 && k==0)\\n        {\\n            res.push_back(ans);\\n            return;         \\n        }\\n        if(k==0)return;\\n        for(int i=j;i<10;i++)\\n        {\\n            if(n>=i && k>0 )\\n            {\\n                ans.push_back(i);\\n                solve(ans,i+1,k-1,n-i);\\n                ans.pop_back();\\n                \\n            }\\n        \\n            \\n        }\\n        if(n!=0)\\n            return;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n       \\n      \\n        vector<int> ans;\\n        solve(ans,1,k,n);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(vector<int> &ans,int j,int k,int n)\\n    {\\n        if(n==0 && k==0)\\n        {\\n            res.push_back(ans);\\n            return;         \\n        }\\n        if(k==0)return;\\n        for(int i=j;i<10;i++)\\n        {\\n            if(n>=i && k>0 )\\n            {\\n                ans.push_back(i);\\n                solve(ans,i+1,k-1,n-i);\\n                ans.pop_back();\\n                \\n            }\\n        \\n            \\n        }\\n        if(n!=0)\\n            return;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n       \\n      \\n        vector<int> ans;\\n        solve(ans,1,k,n);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586629,
                "title": "javascript-backtracking-solution-59-ms",
                "content": "### Solution\\n```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nconst backtrack = (remain, k,arr, next_start, results) => {\\n  if (remain === 0 && arr.length === k) {\\n        results.push(new Array(...arr));\\n        return;\\n  } else if (remain < 0 || arr.length === k) {\\n        return;\\n  }\\n\\n  // Iterate through the reduced list of candidates.\\n  for (let i = next_start; i < 9; ++i) {\\n        arr.push(i + 1);\\n        backtrack(remain - i - 1, k, arr, i + 1, results);\\n        arr.pop();\\n  }\\n}\\n\\nvar combinationSum3 = function(k, n) {\\n    let results = [];\\n    \\n    if (k > n) {\\n        return [];\\n    }\\n    \\n    backtrack(n, k, [], 0, results);\\n    return results;\\n};\\n```\\n\\n\\n### LeetCode Output\\nRuntime: **59 ms**, faster than **97.46%** of JavaScript online submissions for Combination Sum III.\\nMemory Usage: 41.9 MB, less than **82.79%** of JavaScript online submissions for Combination Sum III.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/801878999/)",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nconst backtrack = (remain, k,arr, next_start, results) => {\\n  if (remain === 0 && arr.length === k) {\\n        results.push(new Array(...arr));\\n        return;\\n  } else if (remain < 0 || arr.length === k) {\\n        return;\\n  }\\n\\n  // Iterate through the reduced list of candidates.\\n  for (let i = next_start; i < 9; ++i) {\\n        arr.push(i + 1);\\n        backtrack(remain - i - 1, k, arr, i + 1, results);\\n        arr.pop();\\n  }\\n}\\n\\nvar combinationSum3 = function(k, n) {\\n    let results = [];\\n    \\n    if (k > n) {\\n        return [];\\n    }\\n    \\n    backtrack(n, k, [], 0, results);\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523560,
                "title": "go-backtracking",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    var result [][]int\\n    \\n    combination , visit:= make([]int, k), make([]bool, 10)\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, target int) {\\n        if target < 0 {\\n            return\\n        }\\n        \\n        if index == k {\\n            if target == 0 {\\n                copiedCombination := make([]int, k)\\n                copy(copiedCombination, combination)\\n                result = append(result, copiedCombination)\\n            } \\n            \\n            return\\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for num := begin; num <= 9; num++ {\\n            if visit[num] == false {\\n                visit[num] = true\\n                combination[index] = num\\n                backtrack(index + 1, target - num)\\n                visit[num] = false\\n            }\\n        }\\n    }\\n    \\n    backtrack(0, n)\\n    \\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    var result [][]int\\n    \\n    combination , visit:= make([]int, k), make([]bool, 10)\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, target int) {\\n        if target < 0 {\\n            return\\n        }\\n        \\n        if index == k {\\n            if target == 0 {\\n                copiedCombination := make([]int, k)\\n                copy(copiedCombination, combination)\\n                result = append(result, copiedCombination)\\n            } \\n            \\n            return\\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for num := begin; num <= 9; num++ {\\n            if visit[num] == false {\\n                visit[num] = true\\n                combination[index] = num\\n                backtrack(index + 1, target - num)\\n                visit[num] = false\\n            }\\n        }\\n    }\\n    \\n    backtrack(0, n)\\n    \\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2026763,
                "title": "c-pick-not-pick-backtracking-dlc-may11",
                "content": "```\\nclass Solution {\\npublic:\\n    //PICK- NOT PICK (backtracking)\\n    \\n    vector<vector<int>> ans;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combination;\\n        helper(combination, 0, k, n, 0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& combi, int sum, int k, int n, int num){\\n        if(combi.size() >k || sum > n) return;\\n        \\n        if(combi.size()==k && sum==n)\\n            ans.push_back(combi);\\n        \\n        for(int i= num+1; i<=9; i++){\\n            combi.push_back(i);\\n            helper(combi, sum+i, k, n, ++num);\\n            combi.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //PICK- NOT PICK (backtracking)\\n    \\n    vector<vector<int>> ans;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combination;\\n        helper(combination, 0, k, n, 0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& combi, int sum, int k, int n, int num){\\n        if(combi.size() >k || sum > n) return;\\n        \\n        if(combi.size()==k && sum==n)\\n            ans.push_back(combi);\\n        \\n        for(int i= num+1; i<=9; i++){\\n            combi.push_back(i);\\n            helper(combi, sum+i, k, n, ++num);\\n            combi.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026270,
                "title": "short-clean-code-with-explanation-recursion",
                "content": "**If (n > 45)** : Suppose, we take k (*i.e. no of numbers*)  = 9 (*k\\'s max value*) and we are allowed to take one occurence of each number, then the maximum sum will 45. So, in any case, if n is given greater than 45, then it is not possible to give any answer.\\n\\n-----------------------------\\n\\n**Variables used :**\\n```vector<vector<int>> res;```            : to store the result whose sum will be equal to n\\n```vector<int> temp;```                       : to store every value on which we are iterating and comparing the sum with n\\n```int index = 0;```                               : to keep a check on the index of array arr[ ]\\n```int arr[9] = {1,2,3,4,5,6,7,8,9};```  : To iterate on the values\\n\\n-----------------------------\\n\\n**picknotpick( ) function :** \\nExample : k = 3 , n = 7 || Answer : [ [ 1, 2, 4 ] ]\\n\\nThere are two aspects. To choose that element or not to choose that element. And we are taking considering both the situations. \\nThis code is choosing / picking up the element.\\n```\\ntemp.push_back(arr[index]);\\nsum += arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\\nBelow, three lines of code are not choosing the element and skipping it.\\n```\\ntemp.pop_back();\\nsum -= arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\\n-----------------------\\n```if(index == 9) return;``` : is used to stop *index + 1* called in the functions throwing exception index out of bound.\\n\\n---------------------------\\n\\n**Complete code :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(n > 45) return {};\\n        \\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        int index = 0;\\n        int arr[9] = {1,2,3,4,5,6,7,8,9};\\n        picknotpick(arr, res, temp, k, n, index, 0);\\n        return res;\\n    }\\n    void picknotpick(int arr[], vector<vector<int>> &res, vector<int> temp, int k, int n, int index, int sum)\\n    {\\n        if(temp.size() == k)\\n        {\\n            if(sum == n) res.push_back(temp);\\n            return;\\n        }\\n        if(index == 9) return;\\n        temp.push_back(arr[index]);\\n        sum += arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n        \\n        temp.pop_back();\\n        sum -= arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n    }\\n};\\n```\\n\\n*Dry run the code manually in a notebook for better understanding :)*",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```vector<vector<int>> res;```\n```vector<int> temp;```\n```int index = 0;```\n```int arr[9] = {1,2,3,4,5,6,7,8,9};```\n```\\ntemp.push_back(arr[index]);\\nsum += arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\n```\\ntemp.pop_back();\\nsum -= arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\n```if(index == 9) return;```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(n > 45) return {};\\n        \\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        int index = 0;\\n        int arr[9] = {1,2,3,4,5,6,7,8,9};\\n        picknotpick(arr, res, temp, k, n, index, 0);\\n        return res;\\n    }\\n    void picknotpick(int arr[], vector<vector<int>> &res, vector<int> temp, int k, int n, int index, int sum)\\n    {\\n        if(temp.size() == k)\\n        {\\n            if(sum == n) res.push_back(temp);\\n            return;\\n        }\\n        if(index == 9) return;\\n        temp.push_back(arr[index]);\\n        sum += arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n        \\n        temp.pop_back();\\n        sum -= arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025297,
                "title": "js-backtracking-i-m-so-awesome-i-learned-backtracking-how-cool-am-i-p",
                "content": "Faster than 94%\\n\\nSome backtracking points:\\n\\n- We need to step over all remaining numbers in a loop otherwise we will not try them (and we need to).\\n- We can end a branch early if length > k or sum > n\\n- We make an array from current to add it to results `[...cur]` so that this result snapshot does not get changed by subsequent push and pop calls.\\n- The backtracking steps are `return` and `cur.pop()`. Also the sum is implicitly correct because it is a recursion local variable at each recursive call (rather than a global which we would need to keep a stack of and calculate through addition). \\n\\nAll in all backtracking recursion is an elegant and fast solution for what is essentially a simple problem (if viewed correctly as a backtracking recursion), but what can be a subtle and complex problem if you think about it in general. \\n\\n**What is the time complexity?**\\n\\nIf you run the data for `k = 3, n = 24` (which will enumerate maximum possibilities as 24 is the max that can be created from 3 disctinct chosen from 1 - 9), you see there are 130 recursive calls.\\n\\nFrom this, and from the general structure of them (it seems it will check all possibilities of 0, 1, 2, and 3 length), we have the number of variations of a given length, `l`,  is `9 choose l`.\\n\\nSo we have the number of recursive calls is:\\n\\n`9 choose 0` + `9 choose 1` + `9 choose 2` + `9 choose 3` = 1 + 9 + 36 + 84. \\n\\nIn general if we assume that k can go up to 9, then we have sum(9 choose i) with i from 0 to 9, and m = 9. That is equal to 2^m. So the worst case is O(2^m). \\n\\nIn the specific case we created, the number of recursive calls exactly equals the sum of the (9 choose i) that we ranged over:  130. \\n\\n\\n\\n\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n  const s = [1,2,3,4,5,6,7,8,9];\\n  const results = [];\\n  \\n  recurse([], 0, 0);  \\n  \\n  return results;\\n  \\n  function recurse(cur, i, sum) {\\n    //console.log({cur, sum, k, n, i});\\n    if ( cur.length === k && sum === n ) {\\n      results.push([...cur]);\\n    } else {\\n      if ( sum > n || cur.length >= k ) {\\n        return;  \\n      } else {\\n        for( let j = i; j < s.length; j++ ) {\\n          cur.push(s[j]);\\n          recurse(cur, j+1, sum+s[j]);\\n          cur.pop();\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n  const s = [1,2,3,4,5,6,7,8,9];\\n  const results = [];\\n  \\n  recurse([], 0, 0);  \\n  \\n  return results;\\n  \\n  function recurse(cur, i, sum) {\\n    //console.log({cur, sum, k, n, i});\\n    if ( cur.length === k && sum === n ) {\\n      results.push([...cur]);\\n    } else {\\n      if ( sum > n || cur.length >= k ) {\\n        return;  \\n      } else {\\n        for( let j = i; j < s.length; j++ ) {\\n          cur.push(s[j]);\\n          recurse(cur, j+1, sum+s[j]);\\n          cur.pop();\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024994,
                "title": "java-simple-recursive-soln-0ms",
                "content": "Checking for all appropriate digits to be included in the ans, if it\\'s not the last digit of the ans list, then merging this digit with the list returned by the fututre calls for this particular digit and return the final list for this particular call.\\n\\nIf it\\'s the last digit (i.e. k == 1) and the digit is appropriate acc to the PS then just add this in a list of list of Integer and return else return empty list.\\n\\n\\'last fn var\\' is just keeping the value of last used digit for this particular fn call.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        return helper(n, k, 0);\\n    }\\n    \\n    public List<List<Integer>> helper(int n, int k, int last){\\n        List<List<Integer>> temp2 = new ArrayList<>();\\n        \\n        if(last >= n || (k == 1 && n >= 10)) return temp2;\\n        if(k == 1 && n > last){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(n);\\n            temp2.add(temp);\\n            return temp2;\\n        }\\n        \\n        for(int i = last + 1; i < n && i < 10; i++){\\n            List<List<Integer>> curr = helper(n - i, k - 1, i);\\n            if(!curr.isEmpty()){\\n                for(List<Integer> ins : curr){\\n                    List<Integer> temp3 = new ArrayList<>();\\n                    temp3.add(i);\\n                    temp3.addAll(ins);\\n                    temp2.add(temp3);\\n                }\\n            }\\n        }\\n        \\n        return temp2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        return helper(n, k, 0);\\n    }\\n    \\n    public List<List<Integer>> helper(int n, int k, int last){\\n        List<List<Integer>> temp2 = new ArrayList<>();\\n        \\n        if(last >= n || (k == 1 && n >= 10)) return temp2;\\n        if(k == 1 && n > last){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(n);\\n            temp2.add(temp);\\n            return temp2;\\n        }\\n        \\n        for(int i = last + 1; i < n && i < 10; i++){\\n            List<List<Integer>> curr = helper(n - i, k - 1, i);\\n            if(!curr.isEmpty()){\\n                for(List<Integer> ins : curr){\\n                    List<Integer> temp3 = new ArrayList<>();\\n                    temp3.add(i);\\n                    temp3.addAll(ins);\\n                    temp2.add(temp3);\\n                }\\n            }\\n        }\\n        \\n        return temp2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024991,
                "title": "easy-to-understand-backtracking-for-only-possible-cases-python",
                "content": "* Since the allowed numbers are 1 - 9 only and we can use a number atmost one time in a combination.\\n*  follwing the above condition, Max value of n can which can be obtained is 9*(9+1)/2 = 45, if n >45 we\\'ll return empty list.\\n * #####  For given value of k it possible to have combination if and only if  value of n is in between (k*(k+1))/2 ( i.e sum of first k elemets (1,2,...9) ) and (9 * (9+1))/2  -  ((9-k)* (9-k+1))/2 ( i.e sum of  last k elements in (1,2,3...9)  ), for such value of n and k we\\'ll use backtracking and all the possible combination.\\n * Other than above cases we\\'ll just return empty list.\\n \\n Python Code:\\n```\\nclass Solution:\\n    def solve(self,a,pos,k,n):\\n        if pos==k:\\n            if sum(a)==n:\\n                self.ans.append(a[:])\\n            return \\n        for i in range(a[-1]+1 if a else 1,10):\\n            a.append(i)\\n            self.solve(a,pos+1,k,n)\\n            a.pop()\\n            \\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if n>45:\\n            return []\\n        if (k*(k+1))//2>n and (9*10)//2-((9-k)*(9-k+1))//2<n :\\n            return []\\n        self.ans=[]\\n        a=[]\\n        self.solve(a,0,k,n)\\n        return self.ans\\n```\\n\\n**Please Upvote, if you find it helpful :)**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,a,pos,k,n):\\n        if pos==k:\\n            if sum(a)==n:\\n                self.ans.append(a[:])\\n            return \\n        for i in range(a[-1]+1 if a else 1,10):\\n            a.append(i)\\n            self.solve(a,pos+1,k,n)\\n            a.pop()\\n            \\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if n>45:\\n            return []\\n        if (k*(k+1))//2>n and (9*10)//2-((9-k)*(9-k+1))//2<n :\\n            return []\\n        self.ans=[]\\n        a=[]\\n        self.solve(a,0,k,n)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024775,
                "title": "java-classic-backtracking",
                "content": "```java\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        backtracking(combinations, new ArrayList<>(), k, n, 1);\\n        return combinations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> result, List<Integer> current, int k, int n, int start) {\\n        if (current.size() == k && n == 0) {\\n            result.add(new ArrayList<>(current));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            current.add(i);\\n            backtracking(result, current, k, n - i , i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        backtracking(combinations, new ArrayList<>(), k, n, 1);\\n        return combinations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> result, List<Integer> current, int k, int n, int start) {\\n        if (current.size() == k && n == 0) {\\n            result.add(new ArrayList<>(current));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            current.add(i);\\n            backtracking(result, current, k, n - i , i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024223,
                "title": "c-iterative-and-recursive-approach-fastest-solution",
                "content": "To get all combinations, we can either write a recursive solution or iterative solution.\\n**Recursive Idea:** In the solution, there are three states - n, k and num.\\n* n : represents number which we have to make using the remaining k numbers from range num - 9. \\n* k : represents how many numbers currently we have to make n.\\n* num :  represents which numbers are available from this state and the available numbers from each state are **num to 9**.\\n\\n**Time Complexity:** 2^9\\n\\n**Recursive Approach:** \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n        solve(n, k, 1);\\n        return ans;\\n    }\\n    \\n    void solve(int n, int k, int num){\\n        if(n==0){\\n            if(k==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        if(k==0){\\n            return;\\n        }\\n        \\n        if(num == 10){\\n            return;\\n        }\\n        \\n        if(n - num >= 0){\\n            temp.push_back(num);\\n            solve(n - num, k - 1, num + 1);\\n            temp.pop_back();\\n        }\\n        solve(n, k, num + 1);\\n    }\\n};\\n```\\n\\n**Iterative Approach Using Bfs:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n                \\n        queue<int> myq;\\n        myq.push(0);\\n        \\n        while(myq.size()){\\n            int u = myq.front();\\n            myq.pop();\\n            \\n            int val = 0, cur = 0, cnt  = 0;\\n            temp.clear();\\n            for(int i = 1; i <= 9; i++){\\n                if(u & (1<<(i-1))){\\n                    val = i;\\n                    temp.push_back(i);\\n                    cur += i;\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == k){\\n                if(cur == n){\\n                    ans.push_back(temp);\\n                }\\n                continue;\\n            }\\n            \\n            for(int i=val + 1;i<10;i++){\\n                if(cur + i <= n){\\n                    myq.push( (u | (1 << (i-1))) );\\n                } \\n                else{\\n                    break;\\n                }\\n            }           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n        solve(n, k, 1);\\n        return ans;\\n    }\\n    \\n    void solve(int n, int k, int num){\\n        if(n==0){\\n            if(k==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        if(k==0){\\n            return;\\n        }\\n        \\n        if(num == 10){\\n            return;\\n        }\\n        \\n        if(n - num >= 0){\\n            temp.push_back(num);\\n            solve(n - num, k - 1, num + 1);\\n            temp.pop_back();\\n        }\\n        solve(n, k, num + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n                \\n        queue<int> myq;\\n        myq.push(0);\\n        \\n        while(myq.size()){\\n            int u = myq.front();\\n            myq.pop();\\n            \\n            int val = 0, cur = 0, cnt  = 0;\\n            temp.clear();\\n            for(int i = 1; i <= 9; i++){\\n                if(u & (1<<(i-1))){\\n                    val = i;\\n                    temp.push_back(i);\\n                    cur += i;\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == k){\\n                if(cur == n){\\n                    ans.push_back(temp);\\n                }\\n                continue;\\n            }\\n            \\n            for(int i=val + 1;i<10;i++){\\n                if(cur + i <= n){\\n                    myq.push( (u | (1 << (i-1))) );\\n                } \\n                else{\\n                    break;\\n                }\\n            }           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024165,
                "title": "easy-runtime-0-ms-faster-than-100-00-eexplnation",
                "content": "this queston is similar to combination question\\nin this question we use backtracking to solve all the possible value\\n then we 1st check combination  for example\\n--> k=3,n=7\\n-->ist combination 1 less the value from k-1 and n-i\\n--> 2nd 2 then 1,2  k-1 and n-i;\\n-->3rd chosse 3 but not  sum 1+2+3==n so pop the last value \\n-->4 choose 1,2,4 then sum 1+2+4==n and value of k==0 \\nhence return the 1,2,4 \\n\\n```\\nclass Solution {\\npublic:\\n  void solve(int s,int k,int n,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=9;i++)    \\n        {\\n            v.push_back(i);\\n            solve(i+1,k-1,n-i,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        solve(1,k,n,v,ans);\\n        return ans;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n  void solve(int s,int k,int n,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2024116,
                "title": "python-backtracking",
                "content": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ans = []\\n\\t\\t\\n\\t\\t# s = start of iteration - to avoid repetitions\\n\\t\\t# tmp - temp list holding possible combination\\n\\t\\t# l - keep track of length of tmp\\n        def rec(k, n, s, tmp, l):\\n            if l == k:\\n                # return True to break out of loop\\n\\t\\t\\t\\t# we can\\'t get another answer from combination from here\\n\\t\\t\\t\\t# only combinations with sum greater than n\\n                if sum(tmp) == n:\\n                    ans.append(tmp)\\n                    return True\\n                return False\\n           \\n            for i in range(s, 10):\\n                if rec(k, n, i+1, tmp+[i], l+1):\\n                    break\\n\\t\\t\\t\\t\\t\\n        rec(k, n, 1, [], 0)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ans = []\\n\\t\\t\\n\\t\\t# s = start of iteration - to avoid repetitions\\n\\t\\t# tmp - temp list holding possible combination\\n\\t\\t# l - keep track of length of tmp\\n        def rec(k, n, s, tmp, l):\\n            if l == k:\\n                # return True to break out of loop\\n\\t\\t\\t\\t# we can\\'t get another answer from combination from here\\n\\t\\t\\t\\t# only combinations with sum greater than n\\n                if sum(tmp) == n:\\n                    ans.append(tmp)\\n                    return True\\n                return False\\n           \\n            for i in range(s, 10):\\n                if rec(k, n, i+1, tmp+[i], l+1):\\n                    break\\n\\t\\t\\t\\t\\t\\n        rec(k, n, 1, [], 0)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1557855,
                "title": "c-0ms-faster-than-100-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> res;\\n    \\n    void helper(vector<int> a ,int beg ,int t, int k)\\n    {\\n         if(t<=0)\\n        {\\n            if(t == 0 && k == 0)\\n        {\\n            res.push_back(a);\\n        }\\n            return;\\n    }\\n        \\n            \\n        for(int index = beg ; index <= 9 ; index++ )\\n        {\\n            if(index <= t)\\n            { \\n                a.push_back(index);\\n                helper(a , index + 1 , t - index , k - 1);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> a;\\n        helper(a,1,n,k);\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> res;\\n    \\n    void helper(vector<int> a ,int beg ,int t, int k)\\n    {\\n         if(t<=0)\\n        {\\n            if(t == 0 && k == 0)\\n        {\\n            res.push_back(a);\\n        }\\n            return;\\n    }\\n        \\n            \\n        for(int index = beg ; index <= 9 ; index++ )\\n        {\\n            if(index <= t)\\n            { \\n                a.push_back(index);\\n                helper(a , index + 1 , t - index , k - 1);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> a;\\n        helper(a,1,n,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843765,
                "title": "c-dfs-based-solution-100-time-75-space",
                "content": "I decided I wanted to build this as a DFS since I read the description and the first results I got from the template solution when I ran the first version of my code confirmed my mind in that direction.\\n\\nFirst of all I declared 4 class variables, in order not to have to pass them down to the recursive calls to my `dfs` helper:\\n* `res`, the accumulator storing the final result;\\n* `tmp`, the vector storing the possible solution as I go along to build them;\\n* `k` and `n` to keep track of what we have done so far with the recursive calls.\\n\\nIn my `dfs` helper I then set the need for only one variable (I know, I might have made a class variable out of it, but that is how I felt), `start`, that decides from which number we should start computing the remaining combinations.\\n\\nSay for example I need to find all the solutions summing up to `7` (`n`) using `3` (`k`) digits: I will start with `1` and progress on, with the problem now being getting up to `6` using `2` (more) digits, starting from `2` (in order to avoid duplicate solution, I will always consider numbers higher than the last one I pushed). And so on.\\n\\nIn order to achieve that, my `dfs` helper has first of all a base case: when `k` is down to `1`, it means we only have one digit left to push: if `n` (or rather: what is left of the original number we were provided, minus all the other numbers already added to `tmp`) is a single digit (`n < 10`) number, then we add it to `tmp`, add `tmp` to `res` and finally clean up, backtracking on `tmp` (ie: removing that last element we just added).\\n\\nOtherwise, and this is the core of the logic, we proceed to decrease `k`, create a `for` loop starting at `start + 1` (for the reason I mentioned above, so to have all the digits only once, in increasing order) and looping up to `lmt`, the minimum value we can still get, aptly set so that it will only equal the maximum amount you can still create with the digits left. I will not go too deep with the math, but it is basically just Gauss\\' formula with the previous value of `k`, considered from the starting point `start` we are at this loop.\\n\\nSay for example we begin the function with `k == 3` (initial value, that we decrease right before the loop, that is why the formula has increased values) and `start == 0`, then `lmt` is going to be `6` (`1 + 2 + 3` is the minimum value we can still get summing those numbers); if we entered the function with `k == 5` and `start == 2`, then we would have `20` (`2 + 3 + 4 + 5 + 6`).\\n\\nIf it still does not make sense, try with some pen and paper, but it works and we want to loop until `n >= lmt` (it would not make much sense otherwise: it would mean we cannot achieve `n` summing up all the digits left).\\n\\nNow, inside our loop we do a few things:\\n* update `n` and `tmp` before recursively calling `dfs` to it (remember we decrease `k` only once, before the loop);\\n* recursively calling `dfs` passing `i` (which will become our next `start`);\\n* backtracking `n` and `tmp`, restoring them to their previous values when the recursive calls are done;\\n* increasing `lmt`, since greater values of `i` also reduce how much we can still milk out of our remaining digits, by an amount `== k + 1`.\\n\\nFinally, before leaving `dfs`, we just backtrack on `k`.\\n\\nThe main function is going to be much more streamlined, since we just:\\n* update the class variables `n` and `k` with the provided initial values;\\n* call `dfs`, but only if it make sense - we are requested no more than `9` digits and it is a number that can actually be reached with all of them (the sum of all the first `9` positive digits is `45`;\\n* once we are done, we just have to return our lovely filled `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // support variables\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int k, n;\\n    // dfs generator\\n    void dfs(int start = 0) {\\n        // base case, only the last element potentially missing\\n        if (k == 1) {\\n            // allowing only for single digit insertions\\n            if (n < 10) {\\n                tmp.push_back(n);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        // updating k\\n        k--;\\n        for (int i = start + 1, lmt = (k + 2) * (k + 1) / 2 + start * (k + 1); n >= lmt; i++) {\\n            // updating n and tmp\\n            n -= i;\\n            tmp.push_back(i);\\n            dfs(i);\\n            // backtracking n and tmp\\n            n += i;\\n            tmp.pop_back();\\n            lmt += k + 1;\\n        }\\n        // backtracking k\\n        k++;\\n    }\\n    vector<vector<int>> combinationSum3(int _k, int _n) {\\n        k = _k;\\n        n = _n;\\n        // we proceed only if k < 10 and n is achievable with just 9 digits\\n        if (k < 10 && n < 46) dfs();\\n        return res;\\n    }\\n};\\n```\\n\\n[More informative discussion down below about optimisation opportunities by @cleydyr](https://leetcode.com/problems/combination-sum-iii/discuss/843765/c-dfs-based-solution-100-time-75-space/696363).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // support variables\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int k, n;\\n    // dfs generator\\n    void dfs(int start = 0) {\\n        // base case, only the last element potentially missing\\n        if (k == 1) {\\n            // allowing only for single digit insertions\\n            if (n < 10) {\\n                tmp.push_back(n);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        // updating k\\n        k--;\\n        for (int i = start + 1, lmt = (k + 2) * (k + 1) / 2 + start * (k + 1); n >= lmt; i++) {\\n            // updating n and tmp\\n            n -= i;\\n            tmp.push_back(i);\\n            dfs(i);\\n            // backtracking n and tmp\\n            n += i;\\n            tmp.pop_back();\\n            lmt += k + 1;\\n        }\\n        // backtracking k\\n        k++;\\n    }\\n    vector<vector<int>> combinationSum3(int _k, int _n) {\\n        k = _k;\\n        n = _n;\\n        // we proceed only if k < 10 and n is achievable with just 9 digits\\n        if (k < 10 && n < 46) dfs();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843373,
                "title": "python-super-simple-solution",
                "content": "the idea is to choose from all combinations of length k only the combinations which their sum is n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n         return [list for list in itertools.combinations(range(1, 10), k) if sum(list) == n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n         return [list for list in itertools.combinations(range(1, 10), k) if sum(list) == n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842908,
                "title": "512-iterations-bit-manipulation-non-backtracking",
                "content": "Let iterate all possible combinations from set {1, 2, 3, 4, 5, 6, 7, 8, 9} using bitmask.\\nFor example:\\n```\\nall digits: 1, 2, 3, 4, 5, 6, 7, 8, 9\\nmask:       0  0  1  0  0  1  0  0  0 -> this mask gives us subset {3, 6}\\n```\\nDuring each iteration we should count \"1\" bits in mask (should be **k**, skip mask if not) and should ckeck sum of subset values (should be **n**).\\nThis solution has exactly 2^9 iterations and generally speaking it has O(1) time complexity ;)\\n\\nJava\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        var result = new ArrayList<List<Integer>>();\\n\\n        int bits = 0x0200;\\n        var a = new Integer[k];\\n        while (--bits > 0) {\\n            if (countBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for (int i = 9; i >= 1 && sum <= n; i--) {\\n                if ((bits & (1 << i-1)) != 0) {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n\\n            if (sum == n) {\\n                result.add(Arrays.asList(a));\\n                a = new Integer[k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countBits(int x) {\\n        int count = 0;\\n        while (x > 0) {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nC#\\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        var result = new List<IList<int>>();\\n        \\n        int bits = 0x0200;\\n        var a = new int[k];\\n        while(--bits > 0)\\n        {\\n            if(CountBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for(int i=9; i>=1 && sum<=n; i--)\\n            {\\n                if((bits & (1<<(i-1))) != 0)\\n                {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n            \\n            if(sum == n)\\n            {\\n                result.Add(a);\\n                a = new int[k];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int CountBits(int x)\\n    {\\n        int count = 0;\\n        while(x > 0)\\n        {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nall digits: 1, 2, 3, 4, 5, 6, 7, 8, 9\\nmask:       0  0  1  0  0  1  0  0  0 -> this mask gives us subset {3, 6}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        var result = new ArrayList<List<Integer>>();\\n\\n        int bits = 0x0200;\\n        var a = new Integer[k];\\n        while (--bits > 0) {\\n            if (countBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for (int i = 9; i >= 1 && sum <= n; i--) {\\n                if ((bits & (1 << i-1)) != 0) {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n\\n            if (sum == n) {\\n                result.add(Arrays.asList(a));\\n                a = new Integer[k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countBits(int x) {\\n        int count = 0;\\n        while (x > 0) {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        var result = new List<IList<int>>();\\n        \\n        int bits = 0x0200;\\n        var a = new int[k];\\n        while(--bits > 0)\\n        {\\n            if(CountBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for(int i=9; i>=1 && sum<=n; i--)\\n            {\\n                if((bits & (1<<(i-1))) != 0)\\n                {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n            \\n            if(sum == n)\\n            {\\n                result.Add(a);\\n                a = new int[k];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int CountBits(int x)\\n    {\\n        int count = 0;\\n        while(x > 0)\\n        {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777779,
                "title": "c-easy-solution-using-backtracking-template-for-all-combination-sum-problems",
                "content": "**Combination Sum**\\nNotice in this question that repetition is allowed . That is the reason we pass j as it is in this call combination(ans,sub,target-candidates[j],j,candidates).\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\\n**Combination Sum II**\\nSimilar to the previous one we just we have to prevent the recursion calls from the duplicate ones.To prevent duplicates we use condition if(j>i && candidates[j]==candidates[j-1]) And also one element can be used only once that is why i have used j+1 in this call combination(ans,sub,target-candidates[j],j+1,candidates).\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(j>i && candidates[j]==candidates[j-1])continue;\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\\n**Combination Sum |||**\\nSame as combination II only difference being here there are no duplicates.So we don\\'t need to keep a check for it.\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates,int k){\\n        if(target==0 && sub.size()==k){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates,k);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> candidates;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,n,0,candidates,k);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(j>i && candidates[j]==candidates[j-1])continue;\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates,int k){\\n        if(target==0 && sub.size()==k){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates,k);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> candidates;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,n,0,candidates,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519489,
                "title": "0ms-java-code-using-backtracking",
                "content": "public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backTracking(res, new ArrayList<>(), k, n, 1);\\n        return res;\\n    }\\n    \\n    private void backTracking(List<List<Integer>> res, List<Integer> temp, int k, int target, int start) {\\n        if (target < 0 || temp.size() > k) return;\\n        if (target == 0 && temp.size() == k) {\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = start; i < 10; i++) {\\n            temp.add(i);\\n            backTracking(res, temp, k, target - i, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backTracking(res, new ArrayList<>(), k, n, 1);\\n        return res;\\n    }\\n    \\n    private void backTracking(List<List<Integer>> res, List<Integer> temp, int k, int target, int start) {\\n        if (target < 0 || temp.size() > k) return;\\n        if (target == 0 && temp.size() == k) {\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = start; i < 10; i++) {\\n            temp.add(i);\\n            backTracking(res, temp, k, target - i, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 381306,
                "title": "ruby-1-liner",
                "content": "```\\ndef combination_sum3(k, n)\\n  (1..9).to_a.combination(k).select { |nums| nums.sum == n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef combination_sum3(k, n)\\n  (1..9).to_a.combination(k).select { |nums| nums.sum == n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 60698,
                "title": "4-problems-1-solution-java-solutions-for-combinations-combination-sum1-combination-sum2-combination-sum3",
                "content": "**Combinations**\\n\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum1**\\n\\n\\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum2**\\n\\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n**CombinationSum3**\\n\\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60792,
                "title": "share-my-python-solution-with-iterative-backtracking",
                "content": "    class Solution:\\n    # @param {integer} k\\n    # @param {integer} n\\n    # @return {integer[][]}\\n    def combinationSum3(self, k, n):\\n        # Iterative backtracking: AC in 60 ms\\n        # -----------------------------------\\n        #\\n        ans = []\\n        stack = [(0, 1, [])]  # (total, start, combination)\\n        while stack:\\n            total, start, comb = stack.pop()\\n            if total == n and len(comb) == k:\\n                ans.append(comb)\\n                continue\\n\\n            for i in range(start, 10):\\n                tmp_total = total + i\\n                if tmp_total > n:\\n                    break\\n                stack.append((tmp_total, i + 1, comb + [i]))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 60825,
                "title": "accepted-c-solution-standard-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n        \\tvector<vector<int>> ret;\\n        \\tvector<int> partial;\\n        \\n        \\tbackTrackingFun(n,k,1,partial,ret);\\n        \\treturn ret;\\n        }\\n        \\n        void backTrackingFun(int n,int k,int idx,vector<int> partial,vector<vector<int>> &ret){\\n        \\tif(1==k){\\n        \\t\\tif(idx<=n && n<10){\\n        \\t\\t\\tpartial.push_back(n);\\n        \\t\\t\\tret.push_back(partial);\\n        \\t\\t}\\n        \\t\\treturn;\\n        \\t}\\n        \\n        \\tfor(auto i=idx;i<10;++i){\\n        \\t\\tif(i<n){\\n        \\t\\t\\tpartial.push_back(i);\\n        \\t\\t\\tbackTrackingFun(n-i,k-1,i+1,partial,ret);\\n        \\t\\t\\tpartial.pop_back();\\n        \\t\\t}else{\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n    };\\n\\nwell, there is not too much to say.it's not tricky at all.\\n\\n----------\\ncombinationSum2 and combinationSum below.\\ncontent of the caller function is the same only backTrackingFun is different.\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n    \\tvector<vector<int>> ret;\\n    \\tvector<int> partial;\\n    \\tsort(candidates.begin(),candidates.end());\\n    \\tbackTrackingFun(candidates,target,0,partial,ret);\\n    \\n    \\treturn ret;\\n    }\\n\\n\\n----------\\n\\ncombinationSum2\\n\\n    void backTrackingFun(const vector<int>& candidates, int target,int idx,vector<int> partial,vector<vector<int>> &ret){\\n    \\tif(0==target){\\n    \\t\\tret.push_back(partial);\\n    \\t\\treturn;\\n    \\t}\\n    \\n    \\tint size=candidates.size();\\n    \\tfor(auto i=idx;i<size;++i){\\n    \\t\\tint v=candidates[i];\\n    \\t\\t// remove dups\\n    \\t\\tif(i>idx && v==candidates[i-1]) continue;\\n    \\n    \\t\\tif(v<=target){\\n    \\t\\t\\tpartial.push_back(v);\\n    \\t\\t\\tbackTrackingFun(candidates,target-v,i+1,partial,ret);\\n    \\t\\t\\tpartial.pop_back();\\n    \\t\\t}else{\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    }\\n\\ncombinationSum\\n\\n    void backTrackingFun(const vector<int>& candidates, int target,int idx,vector<int> partial,vector<vector<int>> &ret){\\n    \\tif(0==target){\\n    \\t\\tret.push_back(partial);\\n    \\t\\treturn;\\n    \\t}\\n    \\n    \\tint size=candidates.size();\\n    \\tfor(auto i=idx;i<size;++i){\\n    \\t\\tint v=candidates.at(i);\\n    \\t\\tif(v<=target){\\n    \\t\\t\\tpartial.push_back(v);\\n    \\t\\t\\tbackTrackingFun(candidates,target-v,i,partial,ret);\\n    \\t\\t\\tpartial.pop_back();\\n    \\t\\t}else{\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n        \\tvector<vector<int>> ret;\\n        \\tvector<int> partial;\\n        \\n        \\tbackTrackingFun(n,k,1,partial,ret);\\n        \\treturn ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3876134,
                "title": "simple-code-backtracking-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTo solve this problem, we can use a recursive backtracking approach. Here\\'s a step-by-step explanation of the approach:\\n\\nInitialize necessary variables and arrays.\\nCall the main recursive function to find all valid combinations.\\nThe recursive function does the following:\\nBase Case: If the current index is equal to the array length, it means we have considered all numbers. At this point, we check if the size of the current combination is equal to k and if the target sum is 0 (indicating that we have found a valid combination that sums up to n). If both conditions are met, we add the current combination to the final answer.\\nPick: Add the current number to the current combination, decrease the target sum by the value of the current number, and recursively call the function with the updated values and move to the next index.\\nNot Pick: Remove the last element from the current combination (backtrack) to try the next number and call the function with the same index value but without including the current number. This helps explore other possible combinations.\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int [] arr=new int[]{1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> ds=new ArrayList<>();\\n        func(0,k,n,ds,arr,ans);\\n        return ans;\\n    }\\n\\n    public void func(int idx,int len,int target,List<Integer> ds,\\n                     int [] arr,List<List<Integer>> ans)\\n    {\\n        if(idx==arr.length){\\n            if(ds.size()==len && target==0) ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        ds.add(arr[idx]);\\n        func(idx+1,len,target-arr[idx],ds,arr,ans);\\n        ds.remove(ds.size()-1);\\n        func(idx+1,len,target,ds,arr,ans);\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int [] arr=new int[]{1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> ds=new ArrayList<>();\\n        func(0,k,n,ds,arr,ans);\\n        return ans;\\n    }\\n\\n    public void func(int idx,int len,int target,List<Integer> ds,\\n                     int [] arr,List<List<Integer>> ans)\\n    {\\n        if(idx==arr.length){\\n            if(ds.size()==len && target==0) ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        ds.add(arr[idx]);\\n        func(idx+1,len,target-arr[idx],ds,arr,ans);\\n        ds.remove(ds.size()-1);\\n        func(idx+1,len,target,ds,arr,ans);\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875751,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int nl, kl;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            if(arr.size() == kl) ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < nl; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        nl = 9, kl = k;\\n        for (int i = 1; i <= 9; i++) val.push_back(i);\\n        vector<int> arr;\\n        solve(arr, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int nl, kl;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            if(arr.size() == kl) ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < nl; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        nl = 9, kl = k;\\n        for (int i = 1; i <= 9; i++) val.push_back(i);\\n        vector<int> arr;\\n        solve(arr, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764696,
                "title": "beats-100-time-and-99-space-fast-solution-easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Backtracking\\n![image.png](https://assets.leetcode.com/users/images/13231a36-2935-4efc-88b6-0d7b5b1c2d8c_1689346156.2213929.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create 2 lists, one for the result and another for tracking current.\\n2. Create generate function for generating the list, accepting result list, current list, no of elements more required, required sum using current no of elements, and start element.\\n3. Generate checks if required element is 1 and required sum lies between start and n, if so add that to the current list and insert the list into result and remove the added element from the current list;\\n4. If the condition fails, generate starts a loop i = start till 9, and checks if the i is within n and n - i (new sum required) is greater than i (not taking the smaller elements under consideration).\\n5. If so, it add the element to the list and calls generate function again with k - 1 no of elements required to form n - i sum.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case, the code will generate all possible valid combinations of \\'k\\' numbers from 1 to 9. The number of valid combinations is given by the binomial coefficient formula: C(9, k), which is n! / (k! * (n-k)!).\\n\\nTherefore, the time complexity of the code is **O(C(9, k))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe maximum depth of recursion is \\'k\\'. Hence, the space complexity for recursion is **O(k)**.\\n\\n# Code\\n```\\nclass Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }\\n        for(int i = start; i <= 9; i++) {\\n            if(i <= n && n - i > i) {\\n                list.add(i);\\n                generate(result, list, k - 1, n - i, i + 1);\\n                list.remove(Integer.valueOf(i));\\n            }\\n            else break;\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        generate(result, list, k, n, 1);\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }\\n        for(int i = start; i <= 9; i++) {\\n            if(i <= n && n - i > i) {\\n                list.add(i);\\n                generate(result, list, k - 1, n - i, i + 1);\\n                list.remove(Integer.valueOf(i));\\n            }\\n            else break;\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        generate(result, list, k, n, 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342988,
                "title": "c-using-recursion-backtracking-beats-100-t-c-o-2-n-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n/*\\n\\tTime Complexity : O(2^N)\\n\\tSpace Complexity : O(N)\\n*/\\n\\nprivate:\\n    vector<vector<int>> res;\\n    \\n    void helper(int idx, int target, int k, vector<int> &temp, vector<int> &nums){\\n        if(target == 0 && temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        if(idx >= nums.size()) return;\\n        if(temp.size()>k) return;\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] <= target){\\n                temp.push_back(nums[i]);\\n                helper(i+1, target-nums[i], k, temp, nums);\\n                \\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> nums;\\n        for(int i=1; i<=9; i++) nums.push_back(i);\\n        vector<int> temp;\\n        \\n        // idx, currSum, target, k, temp \\n        helper(0, n, k, temp, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n/*\\n\\tTime Complexity : O(2^N)\\n\\tSpace Complexity : O(N)\\n*/\\n\\nprivate:\\n    vector<vector<int>> res;\\n    \\n    void helper(int idx, int target, int k, vector<int> &temp, vector<int> &nums){\\n        if(target == 0 && temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        if(idx >= nums.size()) return;\\n        if(temp.size()>k) return;\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] <= target){\\n                temp.push_back(nums[i]);\\n                helper(i+1, target-nums[i], k, temp, nums);\\n                \\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> nums;\\n        for(int i=1; i<=9; i++) nums.push_back(i);\\n        vector<int> temp;\\n        \\n        // idx, currSum, target, k, temp \\n        helper(0, n, k, temp, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120584,
                "title": "just-a-trick-100-faster-same-as-combination-sum-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit is same problem as combination sum II problem , here is just a modification is that our candidate array will be of 1 to 9.and this problem will be solved.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>ans;\\n    void f(int i, vector<int>&candidates , vector<int>&v , int t , int k){\\n        int n = candidates.size();\\n        if(t == 0 && k==0){\\n            ans.push_back(v);\\n        }\\n\\n        for(int j=i;j<n;j++){\\n\\n            if(j > i && candidates[j] == candidates[j-1]){\\n                continue;\\n            }\\n            if(candidates[j] <= t){\\n            v.push_back(candidates[j]);\\n            f(j+1 , candidates , v , t-candidates[j] , k-1);\\n            v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>candidates;\\n        int target = n;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n\\n        vector<int>v;\\n        f(0 , candidates , v , target , k);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>ans;\\n    void f(int i, vector<int>&candidates , vector<int>&v , int t , int k){\\n        int n = candidates.size();\\n        if(t == 0 && k==0){\\n            ans.push_back(v);\\n        }\\n\\n        for(int j=i;j<n;j++){\\n\\n            if(j > i && candidates[j] == candidates[j-1]){\\n                continue;\\n            }\\n            if(candidates[j] <= t){\\n            v.push_back(candidates[j]);\\n            f(j+1 , candidates , v , t-candidates[j] , k-1);\\n            v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>candidates;\\n        int target = n;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n\\n        vector<int>v;\\n        f(0 , candidates , v , target , k);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978482,
                "title": "very-easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n\\n vector<vector<int>> ans; //Globally declared ans vector so that we don\\'t have to pass this in each function call this will contain multiple temp vectors\\n   void solve(int k,int n,vector<int> num,int i,vector<int>& temp){\\n\\n    //Base Conditions\\n       if(n<0) return; //Base condition 1:As we are subtracting the value of n in our function call so if it becomes less than 0 or negative it means our temp array have sum more than n so we simply have to return because return typr of function is void.\\n        if(n==0){  //Base Condition 2:if temp elemets sum becomes exactly equal to n then n becomes 0 so now we have to check the sixe of array if size is equal to k then only we can push our temp vector into ans vector;\\n           if(temp.size()==k) ans.push_back(temp); //checking the condition of equallity i.e. temp size is euqal to k or not\\n           return; \\n        }\\n        if(i==num.size()) return; //Base Condition3: if index of num vector becomes equal to or greater its size then return in that case;\\n\\n\\n        //function Calling\\n        if(num[i]<=n){  //if element at index i in num vector is less or equal to n then either we can pick that element of i or not pick\\n            temp.push_back(num[i]); //pick that\\'s why pushing it into temp array\\n            solve(k,n-num[i],num,i+1,temp); //picking that\\'s why subtracting the value of that elememt from n i.e. n-nums[i] and increasing index by 1.\\n            temp.pop_back();//poping the picked element so that in further function call we doesnot want to pick that element\\n            solve(k,n,num,i+1,temp); //not pick that\\'s why not subtracting anything from n and then increasing the index by 1.\\n        }else{ //if element at index i in num vector is greater than  n then not pick\\n            solve(k,n,num,i+1,temp); //not pick\\n        }\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> num; //creating a temprory vector to store 1 to 9\\n        for(int i=1;i<10;i++){ // pushing 1 to 9 in vector num\\n            num.push_back(i);\\n        }\\n        vector<int> temp; // creating another vector temp which gets pushed inside ans vector if it satisfy the base condition\\n        solve(k,n,num,0,temp); //calling solve function which is declared above.\\n        return ans; // finally returning the answer;\\n    }\\n};\\n\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n\\n vector<vector<int>> ans; //Globally declared ans vector so that we don\\'t have to pass this in each function call this will contain multiple temp vectors\\n   void solve(int k,int n,vector<int> num,int i,vector<int>& temp){\\n\\n    //Base Conditions\\n       if(n<0) return; //Base condition 1:As we are subtracting the value of n in our function call so if it becomes less than 0 or negative it means our temp array have sum more than n so we simply have to return because return typr of function is void.\\n        if(n==0){  //Base Condition 2:if temp elemets sum becomes exactly equal to n then n becomes 0 so now we have to check the sixe of array if size is equal to k then only we can push our temp vector into ans vector;\\n           if(temp.size()==k) ans.push_back(temp); //checking the condition of equallity i.e. temp size is euqal to k or not\\n           return; \\n        }\\n        if(i==num.size()) return; //Base Condition3: if index of num vector becomes equal to or greater its size then return in that case;\\n\\n\\n        //function Calling\\n        if(num[i]<=n){  //if element at index i in num vector is less or equal to n then either we can pick that element of i or not pick\\n            temp.push_back(num[i]); //pick that\\'s why pushing it into temp array\\n            solve(k,n-num[i],num,i+1,temp); //picking that\\'s why subtracting the value of that elememt from n i.e. n-nums[i] and increasing index by 1.\\n            temp.pop_back();//poping the picked element so that in further function call we doesnot want to pick that element\\n            solve(k,n,num,i+1,temp); //not pick that\\'s why not subtracting anything from n and then increasing the index by 1.\\n        }else{ //if element at index i in num vector is greater than  n then not pick\\n            solve(k,n,num,i+1,temp); //not pick\\n        }\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> num; //creating a temprory vector to store 1 to 9\\n        for(int i=1;i<10;i++){ // pushing 1 to 9 in vector num\\n            num.push_back(i);\\n        }\\n        vector<int> temp; // creating another vector temp which gets pushed inside ans vector if it satisfy the base condition\\n        solve(k,n,num,0,temp); //calling solve function which is declared above.\\n        return ans; // finally returning the answer;\\n    }\\n};\\n\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868817,
                "title": "go-backtracking-map-solution",
                "content": "```\\nfunc backtrack(res *[][]int, k, n, sum int, curSequence []int, used map[int]struct{}) {\\n    if sum == n && len(curSequence) == k{\\n        cs := make([]int, len(curSequence))\\n        copy(cs, curSequence)\\n        *res = append(*res, cs)\\n        return\\n    }\\n\\n    for i := 1; i <= 9; i++ {\\n        if _, ok := used[i]; ok {\\n            continue\\n        }\\n\\n        switch {\\n        case len(curSequence) > k:\\n            continue\\n        case len(curSequence) > 0 && i <= curSequence[len(curSequence)-1]:\\n            continue\\n        case sum > n:\\n            continue\\n        }\\n\\n        used[i] = struct{}{}\\n        curSequence = append(curSequence, i)\\n        backtrack(res, k, n, sum+i, curSequence, used)\\n        delete(used, i)\\n        curSequence = curSequence[:len(curSequence)-1]\\n    }\\n}\\n\\nfunc combinationSum3(k int, n int) [][]int {\\n    var res [][]int\\n    used := make(map[int]struct{})\\n    backtrack(&res, k, n, 0/*sum*/, []int{} /*curSequence*/, used)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nfunc backtrack(res *[][]int, k, n, sum int, curSequence []int, used map[int]struct{}) {\\n    if sum == n && len(curSequence) == k{\\n        cs := make([]int, len(curSequence))\\n        copy(cs, curSequence)\\n        *res = append(*res, cs)\\n        return\\n    }\\n\\n    for i := 1; i <= 9; i++ {\\n        if _, ok := used[i]; ok {\\n            continue\\n        }\\n\\n        switch {\\n        case len(curSequence) > k:\\n            continue\\n        case len(curSequence) > 0 && i <= curSequence[len(curSequence)-1]:\\n            continue\\n        case sum > n:\\n            continue\\n        }\\n\\n        used[i] = struct{}{}\\n        curSequence = append(curSequence, i)\\n        backtrack(res, k, n, sum+i, curSequence, used)\\n        delete(used, i)\\n        curSequence = curSequence[:len(curSequence)-1]\\n    }\\n}\\n\\nfunc combinationSum3(k int, n int) [][]int {\\n    var res [][]int\\n    used := make(map[int]struct{})\\n    backtrack(&res, k, n, 0/*sum*/, []int{} /*curSequence*/, used)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774827,
                "title": "simple-clean-c-backtracking-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void combination(vector<int> &v,vector<vector<int>> &ans,vector<int> &ds,int k,int n,int i){\\n        if(ds.size()==k){\\n            if(n==0){\\n                ans.push_back(ds);\\n                return;\\n            }\\n        }\\n        if(i==v.size()){\\n            return;\\n        }  \\n        if(ds.size()<k){\\n        if(v[i]<=n){\\n        ds.push_back(v[i]);\\n        combination(v,ans,ds,k,n-v[i],i+1);\\n        ds.pop_back();\\n        combination(v,ans,ds,k,n,i+1);\\n            }\\n    }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v = {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>ans;\\n        vector<int> ds;\\n        combination(v,ans,ds,k,n,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combination(vector<int> &v,vector<vector<int>> &ans,vector<int> &ds,int k,int n,int i){\\n        if(ds.size()==k){\\n            if(n==0){\\n                ans.push_back(ds);\\n                return;\\n            }\\n        }\\n        if(i==v.size()){\\n            return;\\n        }  \\n        if(ds.size()<k){\\n        if(v[i]<=n){\\n        ds.push_back(v[i]);\\n        combination(v,ans,ds,k,n-v[i],i+1);\\n        ds.pop_back();\\n        combination(v,ans,ds,k,n,i+1);\\n            }\\n    }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v = {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>ans;\\n        vector<int> ds;\\n        combination(v,ans,ds,k,n,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715490,
                "title": "easy-to-understand",
                "content": "```\\ndef fun(k,n,p):\\n    if(n<=0 or k==1 and n>=p):\\n        return []\\n    elif(k==1):\\n        return([[n]])\\n    ans=[]\\n    for i in range(p-1,0,-1):\\n        a=fun(k-1,n-i,i)\\n        for x in a:\\n            ans.append(x+[i])\\n    return ans\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return(fun(k,n,10))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef fun(k,n,p):\\n    if(n<=0 or k==1 and n>=p):\\n        return []\\n    elif(k==1):\\n        return([[n]])\\n    ans=[]\\n    for i in range(p-1,0,-1):\\n        a=fun(k-1,n-i,i)\\n        for x in a:\\n            ans.append(x+[i])\\n    return ans\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return(fun(k,n,10))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677557,
                "title": "python-backtracking-with-comments",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if k > n:    # if number of elements greater than sum no point in checking\\n            return []\\n        if n > 45:   # we can have max sum 45 for [1,2....,9]\\n            return []\\n     \\n        lst = range(1,10)\\n\\n        ans=[]\\n\\n        def solve(ind, ds, target):\\n            if target == 0 and len(ds) == k: \\n                ans.append(ds[:])     # have to append a copy to our final answer (i.e. we cannot do ans.append(ds))\\n                return \\n\\n            for i in range(ind,len(lst)):\\n                if target < lst[i]:\\n                    break\\n                ds.append(lst[i])      # add the element to our data structure\\n                solve(i+1, ds, target-lst[i])   # remove that element from target\\n                ds.pop()        # now during backtracking we have to remove that element from our data structure\\n        solve(0,[],n)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if k > n:    # if number of elements greater than sum no point in checking\\n            return []\\n        if n > 45:   # we can have max sum 45 for [1,2....,9]\\n            return []\\n     \\n        lst = range(1,10)\\n\\n        ans=[]\\n\\n        def solve(ind, ds, target):\\n            if target == 0 and len(ds) == k: \\n                ans.append(ds[:])     # have to append a copy to our final answer (i.e. we cannot do ans.append(ds))\\n                return \\n\\n            for i in range(ind,len(lst)):\\n                if target < lst[i]:\\n                    break\\n                ds.append(lst[i])      # add the element to our data structure\\n                solve(i+1, ds, target-lst[i])   # remove that element from target\\n                ds.pop()        # now during backtracking we have to remove that element from our data structure\\n        solve(0,[],n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242425,
                "title": "100-faster-simple-backtracking-explaination-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(int i,int k, int n, vector<vector<int>> &ans, vector<int>&temp){\\n        /*If target i.e n is discovered and the size of temp is also k so added it to ans */\\n        if(n==0 and temp.size()==k){ans.push_back(temp); return;}\\n        \\n        /*checking for the numbers from i to 9*/\\n        for(int j=i; j<=9; j++){\\n            /*Calling for j<=n only */\\n            if(j<=n){\\n                temp.push_back(j);\\n                /*j+1 check from next number and should not repeat the number again*/\\n                /*reducing value of target*/\\n                \\n                rec(j+1,k,n-j,ans,temp);\\n                \\n                /*backtracking*/\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(n>55) return ans; /* if  required sum > 55 (sum 1 to 10) */\\n        vector<int> temp;\\n        /*Backtracking*/\\n        rec(1,k,n,ans,temp);\\n        \\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(int i,int k, int n, vector<vector<int>> &ans, vector<int>&temp){\\n        /*If target i.e n is discovered and the size of temp is also k so added it to ans */\\n        if(n==0 and temp.size()==k){ans.push_back(temp); return;}\\n        \\n        /*checking for the numbers from i to 9*/\\n        for(int j=i; j<=9; j++){\\n            /*Calling for j<=n only */\\n            if(j<=n){\\n                temp.push_back(j);\\n                /*j+1 check from next number and should not repeat the number again*/\\n                /*reducing value of target*/\\n                \\n                rec(j+1,k,n-j,ans,temp);\\n                \\n                /*backtracking*/\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(n>55) return ans; /* if  required sum > 55 (sum 1 to 10) */\\n        vector<int> temp;\\n        /*Backtracking*/\\n        rec(1,k,n,ans,temp);\\n        \\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2026238,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(n<k*(k+1)/2)\\n            return nm;\\n        task(1,k,n,new LinkedList<>(),nm);\\n            return nm;\\n    }\\n    static void task(int s, int k, int n, LinkedList<Integer> kk, List<List<Integer>> nm)\\n    {\\n        if(k<0||n<0)\\n            return;\\n        if(n==0&&k==0)\\n        {\\n            nm.add(new ArrayList<>(kk));\\n            return;\\n        }\\n        for(int i=s;i<=9;i++)\\n        {\\n            kk.add(i);\\n            task(i+1,k-1,n-i,kk,nm);\\n            kk.removeLast();\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(n<k*(k+1)/2)\\n            return nm;\\n        task(1,k,n,new LinkedList<>(),nm);\\n            return nm;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2026171,
                "title": "c-backtracking-solution",
                "content": "```\\n   void helper(vector<vector<int>>& output, int k, int n, int num,  vector<int> currentGroup)     {\\n        if(n ==0 && k ==0){\\n            output.push_back(currentGroup);\\n            return;\\n        }\\n        \\n        if(num <= 0) return;\\n        \\n        if(num <= n){\\n            currentGroup.push_back(num);\\n            helper(output, k-1, n-num, num-1, currentGroup);\\n            currentGroup.pop_back();      \\n        }\\n\\t\\t\\n        helper(output, k, n, num-1, currentGroup);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> currGroup;\\n        int num = 9;\\n        helper(output, k , n, num,  currGroup);\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n   void helper(vector<vector<int>>& output, int k, int n, int num,  vector<int> currentGroup)     {\\n        if(n ==0 && k ==0){\\n            output.push_back(currentGroup);\\n            return;\\n        }\\n        \\n        if(num <= 0) return;\\n        \\n        if(num <= n){\\n            currentGroup.push_back(num);\\n            helper(output, k-1, n-num, num-1, currentGroup);\\n            currentGroup.pop_back();      \\n        }\\n\\t\\t\\n        helper(output, k, n, num-1, currentGroup);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> currGroup;\\n        int num = 9;\\n        helper(output, k , n, num,  currGroup);\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2026134,
                "title": "c-next-permutation-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> bits;\\n        static vector<int> vals;\\n        if(vals.empty())for(int i=0;i<9;i++)vals.push_back(i+1);\\n        int i;\\n        bits.resize(9);\\n        for(i=0;i<k;i++)\\n            bits[8-i]=1;\\n        do{\\n            int now=inner_product(bits.begin(),bits.end(),vals.begin(),0);\\n            if(now==n){\\n                ans.push_back({});\\n                for(i=0;i<9;i++)\\n                    if(bits[i])ans.back().push_back(i+1);\\n            }\\n        }while(next_permutation(bits.begin(),bits.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> bits;\\n        static vector<int> vals;\\n        if(vals.empty())for(int i=0;i<9;i++)vals.push_back(i+1);\\n        int i;\\n        bits.resize(9);\\n        for(i=0;i<k;i++)\\n            bits[8-i]=1;\\n        do{\\n            int now=inner_product(bits.begin(),bits.end(),vals.begin(),0);\\n            if(now==n){\\n                ans.push_back({});\\n                for(i=0;i<9;i++)\\n                    if(bits[i])ans.back().push_back(i+1);\\n            }\\n        }while(next_permutation(bits.begin(),bits.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026081,
                "title": "java-backtracking-100-faster-recursive-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    private void backtrack(int k, int n, int i, List<Integer> val){\\n        \\n        if(k == 0 && n == 0){\\n            ans.add(val);\\n            return;\\n        }\\n        if(k < 0 || n < 0)\\n            return;\\n        \\n        for(; i <= 9; i++){\\n            val.add(i);\\n            backtrack(k-1, n-i, i+1, new ArrayList<>(val));\\n            val.remove(val.size()-1); //Backtrack\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<>();\\n        \\n        if(k >= n)\\n            return ans;\\n        \\n        backtrack(k, n, 1, new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    private void backtrack(int k, int n, int i, List<Integer> val){\\n        \\n        if(k == 0 && n == 0){\\n            ans.add(val);\\n            return;\\n        }\\n        if(k < 0 || n < 0)\\n            return;\\n        \\n        for(; i <= 9; i++){\\n            val.add(i);\\n            backtrack(k-1, n-i, i+1, new ArrayList<>(val));\\n            val.remove(val.size()-1); //Backtrack\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<>();\\n        \\n        if(k >= n)\\n            return ans;\\n        \\n        backtrack(k, n, 1, new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025936,
                "title": "python-39ms-solution",
                "content": "\\'\\'\\'\\n       \\n\\t   res=[]\\n        def backtrack(i=0,c=1,r=[],s=0):\\n            if i==k:\\n                if s==n:\\n                    res.append(r[:])\\n            if i>=k or c>9:\\n                return\\n            r.append(c)\\n            backtrack(i+1,c+1,r,s+c)\\n            r.pop()\\n            backtrack(i,c+1,r,s)\\n            \\n        backtrack()\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\'\\'\\'\\n       \\n\\t   res=[]\\n        def backtrack(i=0,c=1,r=[],s=0):\\n            if i==k:\\n                if s==n:\\n                    res.append(r[:])\\n            if i>=k or c>9:\\n                return\\n            r.append(c)\\n            backtrack(i+1,c+1,r,s+c)\\n            r.pop()\\n            backtrack(i,c+1,r,s)\\n            \\n        backtrack()\\n        return res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 2025397,
                "title": "one-liner-solution",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [list(x) for x in combinations(range(1,10), k) if sum(x) == n]\\n```\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [list(x) for x in combinations(range(1,10), k) if sum(x) == n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025273,
                "title": "c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    int sum=0;\\n    void f(int index,vector<int>&v,int k,int n){\\n      if(index>=v.size()){\\n        if(sum==n and temp.size()==k){\\n          ans.push_back(temp);\\n        }\\n        return;\\n      } \\n      if(sum>n) return;\\n      \\n      temp.push_back(v[index]);\\n      sum+=v[index];\\n      f(index+1,v,k,n);\\n      temp.pop_back();\\n      sum-=v[index];\\n      f(index+1,v,k,n);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n      vector<int>v;\\n      for(int i=1;i<=9;i++){\\n        v.push_back(i);\\n      }\\n      f(0,v,k,n);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    int sum=0;\\n    void f(int index,vector<int>&v,int k,int n){\\n      if(index>=v.size()){\\n        if(sum==n and temp.size()==k){\\n          ans.push_back(temp);\\n        }\\n        return;\\n      } \\n      if(sum>n) return;\\n      \\n      temp.push_back(v[index]);\\n      sum+=v[index];\\n      f(index+1,v,k,n);\\n      temp.pop_back();\\n      sum-=v[index];\\n      f(index+1,v,k,n);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n      vector<int>v;\\n      for(int i=1;i<=9;i++){\\n        v.push_back(i);\\n      }\\n      f(0,v,k,n);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024540,
                "title": "100-0-ms-simple-concise-code-meme",
                "content": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a0a687d6-aa68-4d8e-8edc-595ebaf2e719_1652158837.0654278.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024421,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int k,int n,vector<int> &c,vector<vector<int>> &ans,vector<int> &v)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(c);\\n            return;\\n        }\\n        if(k<0 || n<0)\\n            return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(v[i]==0 && n>=i && (c.size()>0?i>c[c.size()-1]:true))\\n            {\\n                v[i]=1;\\n                c.push_back(i);\\n                helper(k-1,n-i,c,ans,v);\\n                c.pop_back();\\n                v[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> visited(10,0);\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(k,n,curr,ans,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int k,int n,vector<int> &c,vector<vector<int>> &ans,vector<int> &v)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(c);\\n            return;\\n        }\\n        if(k<0 || n<0)\\n            return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(v[i]==0 && n>=i && (c.size()>0?i>c[c.size()-1]:true))\\n            {\\n                v[i]=1;\\n                c.push_back(i);\\n                helper(k-1,n-i,c,ans,v);\\n                c.pop_back();\\n                v[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> visited(10,0);\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(k,n,curr,ans,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024378,
                "title": "c-simple-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n       \\n        vector<int> ans;\\n        \\n        solve(k,n, 1 ,res,ans);\\n        return res;\\n    }\\n    void solve(int k , int n, int i,vector<vector<int>>&res, vector<int>&ans )\\n    {\\n        if(k==0)\\n        {\\n                int sum=0;\\n                for(int x=0;x<ans.size();x++)\\n                {\\n                    sum += ans[x];\\n                }\\n                if(sum == n)\\n                    res.push_back(ans);\\n            return;\\n        }\\n        if(i>9)\\n        {\\n            return;\\n        }\\n       \\n        ans.push_back(i);\\n        solve(k-1 , n,i+1,res,ans);\\n        ans.pop_back();\\n        solve(k , n ,i+1,res,ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n       \\n        vector<int> ans;\\n        \\n        solve(k,n, 1 ,res,ans);\\n        return res;\\n    }\\n    void solve(int k , int n, int i,vector<vector<int>>&res, vector<int>&ans )\\n    {\\n        if(k==0)\\n        {\\n                int sum=0;\\n                for(int x=0;x<ans.size();x++)\\n                {\\n                    sum += ans[x];\\n                }\\n                if(sum == n)\\n                    res.push_back(ans);\\n            return;\\n        }\\n        if(i>9)\\n        {\\n            return;\\n        }\\n       \\n        ans.push_back(i);\\n        solve(k-1 , n,i+1,res,ans);\\n        ans.pop_back();\\n        solve(k , n ,i+1,res,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024126,
                "title": "2-approaches-backtracking-and-bit-mask-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/).\\n\\nHere shows **2** Approaches to slove this problem: **Backtracking** and **Bit Mask**.\\n\\n# Backtracking\\n\\nA very easy backtracking solution. Just refer to [4 Approaches: BF 4 Loops, Backtracking, BFS, Queue with Image Explaination](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2021106/4-approaches-bf-4-loops-backtracking-bfs-queue-with-image-explanation/).\\n\\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        backtrack(ans, new ArrayList<>(), 1, k, n);\\n        return ans;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, List<Integer> path, int start, int k, int target) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            // trim \\n            if (i > target) {\\n                break;\\n            }\\n\\t\\t\\t\\n            // trim\\n            if (target - i == 0 && k > 1) {\\n                break;\\n            }\\n\\n            path.add(i);\\n            backtrack(res, path, i + 1, k - 1, target - i);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O({M \\\\choose k} \\\\times k)$, $M$ is the size of combinations, $M = 9$, the total combinations is $M \\\\choose k$.\\n- **Space Complexity**: $O(M + k)$, size of $path$ is $k$, the recursion stack is $O(M)$.\\n\\n\\n# Bit Mask\\n\\nSince the numbers are just from $1$ to $9$, the total sum of combinations is $2^9=512$.\\n\\nWe can map $1$ - $9$ with a number with a length of 9-bits number, bits $0$ means selecting $1$, bits $8$ means selecting $9$.\\n\\nEg:\\n\\n$000000001b$, means [1]\\n$000000011b$, means [1,2]\\n$100000011b$, means [1,2,9]\\n\\nWe can search from $1$ to $512$, take the number corresponding to the bit value of $1$ in $i$, and sum it up to see if it is satisfied.\\n\\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        for (int mask = 0; mask < (1 << 9); mask++) {\\n            List<Integer> path = new ArrayList<>();\\n            if (check(path, mask, k, n)) {\\n                ans.add(path);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean check(List<Integer> path, int mask, int k, int target) {\\n        path.clear();\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (((1 << i) & mask) != 0) {\\n                path.add(i + 1);\\n            }\\n        }\\n\\n        if (path.size() != k) {\\n            return false;\\n        }\\n\\n        int sum = 0;\\n        for (int x : path) {\\n            sum += x;\\n        }\\n\\n        return sum == target;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(M \\\\times 2^M)$, $M = 9$, every state needs $O(M + k) = O(M)$ to check.\\n- **Space Complexity**: $O(M)$, $M$ is size of $\\\\textit{path}$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        backtrack(ans, new ArrayList<>(), 1, k, n);\\n        return ans;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, List<Integer> path, int start, int k, int target) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            // trim \\n            if (i > target) {\\n                break;\\n            }\\n\\t\\t\\t\\n            // trim\\n            if (target - i == 0 && k > 1) {\\n                break;\\n            }\\n\\n            path.add(i);\\n            backtrack(res, path, i + 1, k - 1, target - i);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n```\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        for (int mask = 0; mask < (1 << 9); mask++) {\\n            List<Integer> path = new ArrayList<>();\\n            if (check(path, mask, k, n)) {\\n                ans.add(path);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean check(List<Integer> path, int mask, int k, int target) {\\n        path.clear();\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (((1 << i) & mask) != 0) {\\n                path.add(i + 1);\\n            }\\n        }\\n\\n        if (path.size() != k) {\\n            return false;\\n        }\\n\\n        int sum = 0;\\n        for (int x : path) {\\n            sum += x;\\n        }\\n\\n        return sum == target;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024122,
                "title": "golang",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    result := make([][]int, 0)\\n    \\n    backtrack(k, n, 1, []int{}, &result)\\n    \\n    return result\\n}\\n\\nfunc backtrack(k, target, start int, visited []int, result *[][]int) {\\n    if k == 0 && target == 0 {\\n        nums := make([]int, 0)\\n        nums = append(nums, visited...)\\n        *result = append(*result, nums)\\n        return\\n    }\\n    \\n    for i := start; i <= 9; i++ {\\n        visited = append(visited, i)\\n        backtrack(k-1, target-i, i+1, visited, result)\\n        visited = visited[:len(visited)-1]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    result := make([][]int, 0)\\n    \\n    backtrack(k, n, 1, []int{}, &result)\\n    \\n    return result\\n}\\n\\nfunc backtrack(k, target, start int, visited []int, result *[][]int) {\\n    if k == 0 && target == 0 {\\n        nums := make([]int, 0)\\n        nums = append(nums, visited...)\\n        *result = append(*result, nums)\\n        return\\n    }\\n    \\n    for i := start; i <= 9; i++ {\\n        visited = append(visited, i)\\n        backtrack(k-1, target-i, i+1, visited, result)\\n        visited = visited[:len(visited)-1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005679,
                "title": "simple-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<vector<int>>& ans,vector<int>& temp,int ind,int num,int k,int target){\\n        if(num==k){\\n            \\n            if(target==0){\\n                ans.push_back(temp);\\n                return ;\\n            }\\n        }\\n        \\n        \\n        for(int i=ind;i<=9;i++){\\n            if(i>target) return;\\n            temp.push_back(i);\\n            solve(ans,temp,i+1,num+1,k,target-i);\\n            temp.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(ans,temp,1,0,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<vector<int>>& ans,vector<int>& temp,int ind,int num,int k,int target){\\n        if(num==k){\\n            \\n            if(target==0){\\n                ans.push_back(temp);\\n                return ;\\n            }\\n        }\\n        \\n        \\n        for(int i=ind;i<=9;i++){\\n            if(i>target) return;\\n            temp.push_back(i);\\n            solve(ans,temp,i+1,num+1,k,target-i);\\n            temp.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(ans,temp,1,0,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983443,
                "title": "faster-than-96-89-solution-python",
                "content": "![image](https://assets.leetcode.com/users/images/37c371af-a0dd-4e4a-a5c9-6e2e7a924b63_1650963389.4401085.png)\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums=[i for i in range(1,10)]\\n        res=[]\\n        self.helper(res,nums,k,[],n)\\n        return res\\n    def helper(self,res,nums,k,path,t):\\n        if len(path)==k:\\n            if t==0:\\n                res.append(path)\\n        for i in range(len(nums)):\\n            if nums[i]>t:\\n                continue\\n            self.helper(res,nums[i+1:],k,path+[nums[i]],t-nums[i])\\n```\\nFeel free to ask about any line .\\nUpvote plz...\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums=[i for i in range(1,10)]\\n        res=[]\\n        self.helper(res,nums,k,[],n)\\n        return res\\n    def helper(self,res,nums,k,path,t):\\n        if len(path)==k:\\n            if t==0:\\n                res.append(path)\\n        for i in range(len(nums)):\\n            if nums[i]>t:\\n                continue\\n            self.helper(res,nums[i+1:],k,path+[nums[i]],t-nums[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808782,
                "title": "simplest-solution-easy-to-understand-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\nprivate:\\n    void f(int ind,int sum,int n,vector<vector<int>>& ans,vector<int>& ans2,int k){\\n        if(sum==n && k==0){\\n            ans.push_back(ans2);\\n            return;\\n        }\\n        if(sum>n){\\n            return;\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(i>n){\\n                break;\\n            }\\n            ans2.push_back(i);\\n            f(i+1,sum+i,n,ans,ans2,k-1);\\n            ans2.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> ans2;\\n        vector<vector<int>> ans;\\n        f(1,0,n,ans,ans2,k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void f(int ind,int sum,int n,vector<vector<int>>& ans,vector<int>& ans2,int k){\\n        if(sum==n && k==0){\\n            ans.push_back(ans2);\\n            return;\\n        }\\n        if(sum>n){\\n            return;\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(i>n){\\n                break;\\n            }\\n            ans2.push_back(i);\\n            f(i+1,sum+i,n,ans,ans2,k-1);\\n            ans2.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> ans2;\\n        vector<vector<int>> ans;\\n        f(1,0,n,ans,ans2,k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808291,
                "title": "c-recursion-simple-picking-and-non-picking-problem",
                "content": "Credits : Aditya Verma OP\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void findit(int i,int k,int n,vector<int>V){\\n        // we can also write base conditions in a more decent way\\n        if(n==0&&k==0){\\n            ans.push_back(V);              //true base condition\\n            return ;\\n        }\\n        if(i==10){\\n            return;                  // false base condition \\n        }\\n        vector<int>V1=V;                \\n        V1.push_back(i); \\n        // if we are picking in the answer k=k-1 & n=n-i \\n        findit(i+1,k-1,n-i,V1);       // picking in the answer\\n        findit(i+1,k,n,V);            // not picking\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>V;\\n        findit(1,k,n,V);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void findit(int i,int k,int n,vector<int>V){\\n        // we can also write base conditions in a more decent way\\n        if(n==0&&k==0){\\n            ans.push_back(V);              //true base condition\\n            return ;\\n        }\\n        if(i==10){\\n            return;                  // false base condition \\n        }\\n        vector<int>V1=V;                \\n        V1.push_back(i); \\n        // if we are picking in the answer k=k-1 & n=n-i \\n        findit(i+1,k-1,n-i,V1);       // picking in the answer\\n        findit(i+1,k,n,V);            // not picking\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>V;\\n        findit(1,k,n,V);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803227,
                "title": "c-100-faster-backtracking-solution",
                "content": "\\tclass Solution {\\n\\t\\tvector<vector<int>> ans; //to store our answer\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> &num,int idx,vector<int> &v,int sum,int k){\\n\\t\\t\\tif(sum==0 && k==0){  //base condition\\n\\t\\t\\t\\tans.push_back(v);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(idx==9) return; //what if we exceed our limit of taking number\\n\\t\\t\\tif(num[idx]<=sum)  //we can only take number less than or equal to sum\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(num[idx]),k-=1,sum-=num[idx];\\n\\t\\t\\t\\thelper(num,idx+1,v,sum,k);\\n\\t\\t\\t\\tv.pop_back(),k+=1,sum+=num[idx];\\n\\t\\t\\t\\thelper(num,idx+1,v,sum,k);\\n\\t\\t\\t}\\n\\t\\t\\telse   //if number is greater than sum then all further number will be too so return\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<vector<int>> combinationSum3(int k, int n) {\\n\\t\\t\\t  vector<int> v,num;\\n\\t\\t\\t  for(int i=1;i<=9;i++) num.push_back(i); //all number we need\\n\\t\\t\\t helper(num,0,v,n,k); \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tvector<vector<int>> ans; //to store our answer\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> &num,int idx,vector<int> &v,int sum,int k){\\n\\t\\t\\tif(sum==0 && k==0){  //base condition\\n\\t\\t\\t\\tans.push_back(v);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1798886,
                "title": "simple-and-clean-c-backtracking-solution-with-explanation",
                "content": "We need to pick numbers from 1 to 9, and not pick same number twice. It means if in the first place we fill 1, we can only fill 2 - 9 on 2nd place, 3 - 9 and onwards on 3rd place and so on.\\nFor filling each place, we are in a different recursion call, so in a different call stack space. \\n\\nWe will subtract the number taken for a particular place from `target`, and subtract 1 from `k` each time a number is added in our combination before calling the next recursive function, so that when both `target` and `k` are equal to 0, we know we\\'ve found the combination. We\\'ll add it to our answer and return.\\nIf any of `target` or `k` is equal to 0, it means we cannot fill that place, so we just return.\\n\\nIf the 1st place is filled with a number, the 2nd place needs to fill from the next number (so elements are not duplicated), so we passed `i + 1` to `index`, and in the next call stack, the `for` loop will start from the next number.\\n\\nIn the `for` loop, we push a number in our `combination`, and call the function recursively to fill the next place. Once it returns (either the `combination` was added to our answer, or it was not added), we remove the number from our `combination`, and try for the next number.\\n\\nAdditionally, if at any point for filling a particular place, `i >= target`, it means now any other number will also be greater than target for filling that particular place. We just break from the loop, so that we can recursively go to the previous place, increase the number on the previous place, then try again filling this particular place.\\n\\n**Lets take an example**\\nIf `target` = 4, `k` = 2 :\\n\\nFor the first place, we start by filling 1. We go to the next call stack and fill 2 for the next place. `combination: [1,2]`\\nThen we go to the next call stack. At this point, `k` = 0, `target` = 1, so we\\'ll just return. Now we\\'re back at filling the 2nd place, which was originally filled with 2. We remove 2, go one iteration further in the `for` loop, and now fill 3. `combination: [1, 3]`\\nIn the next call stack, `k` = 0, `target` = 0, therefore we add [1,3] to our answer. \\n\\nWe remove the element, but before going forward, we can see that `i >= target` (3 >= 3 in this call stack). There can be no greater element in this place than 3, given 1 is in the 1st place. So we `break` out of finding an element for this place, and go to the previous call stack. There too we remove 1 from 1st place, add 2 and search for an element on the next place. \\nThis goes on till all combinations are added to the answer.\\n\\n**Code:**\\n\\n```c++\\nclass Solution {\\npublic:\\n    void recursion(int k, int target, vector<vector<int>>& ans, vector<int>& combination, int index) {\\n        if(target == 0 && k == 0) {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        if(target == 0 || k == 0)\\n            return;\\n        \\n        for(int i = index; i < 10; i++) {\\n            \\n            combination.push_back(i);\\n            recursion(k - 1, target - i, ans, combination, i + 1);\\n            combination.pop_back();\\n            \\n            if(i >= target)\\n                break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        recursion(k, n, ans, combination, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void recursion(int k, int target, vector<vector<int>>& ans, vector<int>& combination, int index) {\\n        if(target == 0 && k == 0) {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        if(target == 0 || k == 0)\\n            return;\\n        \\n        for(int i = index; i < 10; i++) {\\n            \\n            combination.push_back(i);\\n            recursion(k - 1, target - i, ans, combination, i + 1);\\n            combination.pop_back();\\n            \\n            if(i >= target)\\n                break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        recursion(k, n, ans, combination, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721465,
                "title": "simple-c-recursion-code",
                "content": "class Solution {\\n    public:\\n    void rec(int ind,vector<int>&arr,int k,vector<int>&ds,vector<vector<int>>&ans,int n,int v)\\n    {\\n        if(ind==arr.size())\\n        {\\n            if(ds.size()==k and v==n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[ind]);\\n        rec(ind+1,arr,k,ds,ans,n,v+arr[ind]);\\n        ds.pop_back();\\n        rec(ind+1,arr,k,ds,ans,n,v);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        vector<int>arr;\\n        for(int i=1;i<=9;i++)\\n        {\\n            arr.push_back(i);\\n        }\\n        rec(0,arr,k,ds,ans,n,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    void rec(int ind,vector<int>&arr,int k,vector<int>&ds,vector<vector<int>>&ans,int n,int v)\\n    {\\n        if(ind==arr.size())\\n        {\\n            if(ds.size()==k and v==n)\\n            {\\n                ans.push_back(ds);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1535789,
                "title": "python-simple-efficient-code",
                "content": "```class Solution:\\n    def combinationSum3(self, k: int, n: int) -> list[list[int]]:\\n        res = []\\n        \\n        if k > n:\\n            return res\\n        \\n        def dfs(i, total, cur):\\n            if len(cur) == k and total == n:\\n                res.append(cur[:])\\n                return\\n            \\n            if len(cur) == k:\\n                return\\n            \\n            for j in range(i, 10):\\n                dfs(j + 1, total + j, cur + [j])\\n        \\n        dfs(1, 0, [])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```class Solution:\\n    def combinationSum3(self, k: int, n: int) -> list[list[int]]:\\n        res = []\\n        \\n        if k > n:\\n            return res\\n        \\n        def dfs(i, total, cur):\\n            if len(cur) == k and total == n:\\n                res.append(cur[:])\\n                return\\n            \\n            if len(cur) == k:\\n                return\\n            \\n            for j in range(i, 10):\\n                dfs(j + 1, total + j, cur + [j])\\n        \\n        dfs(1, 0, [])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1336846,
                "title": "recursion-backtracking-faster-than-100-cpp-solutions",
                "content": "This is same as combination sum-1. We just need to add some conditions to keep a check on given constraints(like the combination should contain k elements).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> arr{1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int start = 0;\\n         backtrack(arr,ans,v,start,k,n);\\n        return ans;\\n        \\n        \\n    }\\n    \\n    void backtrack(vector<int> &arr,vector<vector<int>> & ans, vector<int> &v,int start,int k,int sum){\\n        if(v.size()==k){\\n            if(sum==0){\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=start;i<arr.size();i++){\\n            if(arr[i]<=sum){\\n                v.push_back(arr[i]);\\n                backtrack(arr,ans,v,i+1,k,sum-arr[i]);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> arr{1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int start = 0;\\n         backtrack(arr,ans,v,start,k,n);\\n        return ans;\\n        \\n        \\n    }\\n    \\n    void backtrack(vector<int> &arr,vector<vector<int>> & ans, vector<int> &v,int start,int k,int sum){\\n        if(v.size()==k){\\n            if(sum==0){\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=start;i<arr.size();i++){\\n            if(arr[i]<=sum){\\n                v.push_back(arr[i]);\\n                backtrack(arr,ans,v,i+1,k,sum-arr[i]);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300888,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    int os;\\n    void solve(int n,int k,int index,vector<int>& cur,vector<int>& nums)\\n    {\\n        if(k == 0 || cur.size() == os || n == 0)\\n        {\\n            if(cur.size() == os && n == 0)\\n                result.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=index;i < nums.size();i++)\\n        {\\n            if(nums[i] <= n)\\n            {\\n                cur.push_back(nums[i]);\\n                solve(n-nums[i],k-1,i+1,cur,nums);   \\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        os = k;\\n        vector<int> array(9,0);\\n        for(int i=1;i<10;i++)\\n        {\\n            array[i-1] = i;\\n        }\\n        vector<int> temp;\\n        solve(n,k,0,temp,array);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    int os;\\n    void solve(int n,int k,int index,vector<int>& cur,vector<int>& nums)\\n    {\\n        if(k == 0 || cur.size() == os || n == 0)\\n        {\\n            if(cur.size() == os && n == 0)\\n                result.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=index;i < nums.size();i++)\\n        {\\n            if(nums[i] <= n)\\n            {\\n                cur.push_back(nums[i]);\\n                solve(n-nums[i],k-1,i+1,cur,nums);   \\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        os = k;\\n        vector<int> array(9,0);\\n        for(int i=1;i<10;i++)\\n        {\\n            array[i-1] = i;\\n        }\\n        vector<int> temp;\\n        solve(n,k,0,temp,array);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294029,
                "title": "c-backtracking-with-complete-explanation",
                "content": "**Explanation:**\\n* We use a vector for storing the possible numbers, a 2D vector for our result and a temp vector for storing each possible array.\\n* This problem is similar to Combination Sum II ,except there is a limit in length of the array \\'k\\', and there are no candidate vectors given.\\n* we use recursive function helper, for finding all the possibilities.\\n```\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v= {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>res;\\n        vector<int> path;\\n        if(k==0) return res;\\n        helper(v,res,path,k,0,n);\\n        return res;\\n    }\\n```\\n* \\tThe Helper function consists of the candidates vector(v) , result (res) ,temp vector(path) , length limit (k), iterative index(start) and target sum (target). Notice that we have passed parameters by reference which gives significant advantage in time and space complexities.\\n* \\twe start with 0 as the index in the first iteration. Let\\'s use the given example k=3, target(n) = 7;\\n* \\twe go throught 1 to 9 in an array. we pick the first element and push it in the vector. We decrement our target to target- the picked number and check if the remaining can be achieved by recursion. the start index is incremented because we can only have a max of 1 repetitions of a number. length limit(k) is decremented as we have picked an element;\\n* \\tif the target is less than zero, then no element in the candidate array can add up to make target as zero. hence we return if target <0;\\n* \\tif the length of path is k and target is achieved, we simply push the vector into the result. and return for other possibilites.\\n* \\tfor checking other possibilities, we need to remove our last element and iterate from the next number. since the length of the path vector is reduced, we increment k.\\n```\\n    void helper(vector<int> &v,vector<vector<int>>&res,vector<int>& path,int &k,int start,int target)\\n    {\\n        if(target <0)\\n        {\\n            return;\\n        }\\n        if(k==0 && target==0)\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<9;i++)\\n        {\\n            path.push_back(v[i]);\\n            helper(v,res,path,--k,i+1,target-v[i]);\\n            path.pop_back();\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v= {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>res;\\n        vector<int> path;\\n        if(k==0) return res;\\n        helper(v,res,path,k,0,n);\\n        return res;\\n    }\\n```\n```\\n    void helper(vector<int> &v,vector<vector<int>>&res,vector<int>& path,int &k,int start,int target)\\n    {\\n        if(target <0)\\n        {\\n            return;\\n        }\\n        if(k==0 && target==0)\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<9;i++)\\n        {\\n            path.push_back(v[i]);\\n            helper(v,res,path,--k,i+1,target-v[i]);\\n            path.pop_back();\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283367,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(1,k,n,new ArrayList(),result);\\n        return result;\\n    }\\n    public void recur(int start,int k,int n,List<Integer> list,List<List<Integer>> result)\\n    {\\n        if(k<0 || n<0)\\n            return;\\n        if(k==0 && n==0)\\n        {\\n            result.add(new ArrayList(list));\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            list.add(i);\\n            recur(i+1,k-1,n-i,list,result);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(1,k,n,new ArrayList(),result);\\n        return result;\\n    }\\n    public void recur(int start,int k,int n,List<Integer> list,List<List<Integer>> result)\\n    {\\n        if(k<0 || n<0)\\n            return;\\n        if(k==0 && n==0)\\n        {\\n            result.add(new ArrayList(list));\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            list.add(i);\\n            recur(i+1,k-1,n-i,list,result);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229801,
                "title": "c-super-short-dp",
                "content": "Solve Coin Change II first. The approach is the same.\\n\\n```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<vector<int>>> dp(n + 1);\\n\\tdp[0].push_back(vector<int>());\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto arr : dp[j - i])\\n\\t\\t\\t\\tif (arr.size() < k && (j < n || arr.size() == k - 1) && (arr.empty() || arr.back() != i))\\n\\t\\t\\t\\t\\tdp[j].push_back(arr),\\n\\t\\t\\t\\t\\tdp[j].back().push_back(i);\\n\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<vector<int>>> dp(n + 1);\\n\\tdp[0].push_back(vector<int>());\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto arr : dp[j - i])\\n\\t\\t\\t\\tif (arr.size() < k && (j < n || arr.size() == k - 1) && (arr.empty() || arr.back() != i))\\n\\t\\t\\t\\t\\tdp[j].push_back(arr),\\n\\t\\t\\t\\t\\tdp[j].back().push_back(i);\\n\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197346,
                "title": "java-backtracking-beats-100-0ms-t-c-o-1-s-c-o-1",
                "content": "\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic List<List<Integer>> combinationSum3(int k, int n) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tcombinationSum3Helper(k, n, map, 0, ans, temp, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic void combinationSum3Helper(int k, int n, boolean[] map, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int last) {\\n\\n\\t\\tif (k == 0 && curr == n) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t} else if (k == 0 && curr != n)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (int i = last + 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i]) {\\n\\t\\t\\t\\tmap[i] = true;\\n\\t\\t\\t\\ttemp.add(i);\\n\\t\\t\\t\\tcombinationSum3Helper(k - 1, n, map, curr + i, ans, temp, i);\\n\\t\\t\\t\\tmap[i] = false;\\n\\t\\t\\t\\ttemp.remove(temp.size() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic List<List<Integer>> combinationSum3(int k, int n) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tcombinationSum3Helper(k, n, map, 0, ans, temp, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic void combinationSum3Helper(int k, int n, boolean[] map, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int last) {\\n\\n\\t\\tif (k == 0 && curr == n) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t} else if (k == 0 && curr != n)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (int i = last + 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i]) {\\n\\t\\t\\t\\tmap[i] = true;\\n\\t\\t\\t\\ttemp.add(i);\\n\\t\\t\\t\\tcombinationSum3Helper(k - 1, n, map, curr + i, ans, temp, i);\\n\\t\\t\\t\\tmap[i] = false;\\n\\t\\t\\t\\ttemp.remove(temp.size() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1197081,
                "title": "c-simple-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void help(vector<int>&number, int strt, int &k, int &target, vector<int>&V, int sum)\\n    {\\n        if(sum == target and k == V.size())\\n        {\\n            ans.push_back(V);\\n            return;\\n        }\\n        \\n        if(strt == number.size())\\n            return;\\n        \\n        if(V.size() >= k)\\n            return;\\n        \\n        for(int i=strt; i<number.size(); i++)\\n        {\\n            if(sum + number[i] <= target)\\n            {\\n                V.push_back(number[i]);\\n                help(number, i+1, k, target, V, sum + number[i]);\\n                V.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> number={1,2,3,4,5,6,7,8,9};\\n        \\n        vector<int>V;\\n        \\n        help(number, 0, k, n, V, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void help(vector<int>&number, int strt, int &k, int &target, vector<int>&V, int sum)\\n    {\\n        if(sum == target and k == V.size())\\n        {\\n            ans.push_back(V);\\n            return;\\n        }\\n        \\n        if(strt == number.size())\\n            return;\\n        \\n        if(V.size() >= k)\\n            return;\\n        \\n        for(int i=strt; i<number.size(); i++)\\n        {\\n            if(sum + number[i] <= target)\\n            {\\n                V.push_back(number[i]);\\n                help(number, i+1, k, target, V, sum + number[i]);\\n                V.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> number={1,2,3,4,5,6,7,8,9};\\n        \\n        vector<int>V;\\n        \\n        help(number, 0, k, n, V, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012810,
                "title": "easy-to-understand-100-faster-backtracking",
                "content": "class Solution {\\npublic:\\n    \\n    void check(vector<vector<int>>& ans,vector<int>& vec,int target,int k,int st){\\n        \\n        if(target<0 || vec.size()>k)           //base condition\\n\\t\\t\\treturn;                                    \\n        \\n        if(target==0 && vec.size()==k)    //base condition for successful combination\\n            ans.push_back(vec);\\n        \\n        for(int i=st;i<10;i++){\\n            vec.push_back(i);\\n            check(ans,vec,target-i,k,i+1);     \\n            vec.pop_back();                       //Backtrack\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int>vec;\\n        \\n        check(ans,vec,n,k,1);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void check(vector<vector<int>>& ans,vector<int>& vec,int target,int k,int st){\\n        \\n        if(target<0 || vec.size()>k)           //base condition\\n\\t\\t\\treturn;                                    \\n        \\n        if(target==0 && vec.size()==k)    //base condition for successful combination\\n            ans.push_back(vec);\\n        \\n        for(int i=st;i<10;i++){\\n            vec.push_back(i);\\n            check(ans,vec,target-i,k,i+1);     \\n            vec.pop_back();                       //Backtrack\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 993838,
                "title": "clean-code-using-backtracking",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n     int[] arr=new int[9];\\n        arr[0]=1;\\n        arr[1]=2;\\n        arr[2]=3;\\n        arr[3]=4;\\n        arr[4]=5;\\n        arr[5]=6;\\n        arr[6]=7;\\n        arr[7]=8;\\n        arr[8]=9;\\n     List<List<Integer>> ans=new ArrayList<>();\\n        rec(arr,k,0,n,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    \\n    public void rec(int[] cd, int k,int idx, int tgt,int depth,List<Integer> temp,List<List<Integer>> ans){\\n        \\n        if(tgt<0 || depth>k)\\n            return;\\n        \\n        if(tgt==0){\\n            if(depth==k)\\n            ans.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n        \\n        for(int i=idx;i<cd.length;i++){\\n                  \\n             temp.add(cd[i]);\\n             rec(cd,k,i+1,tgt-cd[i],depth+1,temp,ans);\\n             temp.remove(temp.size()-1);\\n               \\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n     int[] arr=new int[9];\\n        arr[0]=1;\\n        arr[1]=2;\\n        arr[2]=3;\\n        arr[3]=4;\\n        arr[4]=5;\\n        arr[5]=6;\\n        arr[6]=7;\\n        arr[7]=8;\\n        arr[8]=9;\\n     List<List<Integer>> ans=new ArrayList<>();\\n        rec(arr,k,0,n,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 843873,
                "title": "java-combination-sum-iii-recursion-include-exclude",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        findCombinations(1, k, n, new ArrayList<Integer>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void findCombinations(int currNum, int listSize, int target, List<Integer> currList,  List<List<Integer>> result){\\n        \\n        if(target==0 && currList.size() == listSize){\\n            \\n            List<Integer> list= new ArrayList<>();\\n            list.addAll(currList);\\n            \\n            result.add(list);\\n            return;\\n        }\\n        \\n        if(currList.size() == listSize || target<0 || currNum==10) return;\\n        \\n        currList.add(currNum);\\n        findCombinations(currNum+1, listSize, target-currNum, currList, result);\\n        currList.remove(currList.size()-1);\\n        \\n        findCombinations(currNum+1, listSize, target, currList, result);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        findCombinations(1, k, n, new ArrayList<Integer>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void findCombinations(int currNum, int listSize, int target, List<Integer> currList,  List<List<Integer>> result){\\n        \\n        if(target==0 && currList.size() == listSize){\\n            \\n            List<Integer> list= new ArrayList<>();\\n            list.addAll(currList);\\n            \\n            result.add(list);\\n            return;\\n        }\\n        \\n        if(currList.size() == listSize || target<0 || currNum==10) return;\\n        \\n        currList.add(currNum);\\n        findCombinations(currNum+1, listSize, target-currNum, currList, result);\\n        currList.remove(currList.size()-1);\\n        \\n        findCombinations(currNum+1, listSize, target, currList, result);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843460,
                "title": "simplest-backtracking-solution-with-comments-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void solve(int k , int n , vector<int> current , int index , int sum){\\n        \\n        if(k==0 and n==0){  //base case 1 : if k==0 and sum is exhausted than we have our required solution\\n            result.push_back(current); \\n            return ;                \\n        }\\n        \\n        if(k==0){        //base case 2: if k is exhausted but the sum is less or more , return from here\\n            return ;\\n        }\\n        \\n        for(int i=index ;i<=9 ; i++){  //choose numbers from 1 to 9\\n            \\n            if(n<=sum){  //if the current sum is less than the required sum than only include the element\\n                current.push_back(i);\\n                solve(k-1,n-i,current,i+1,sum); //subtract k by 1 , subtract current sum by included element , check for next element\\n            }\\n                \\n            current.pop_back(); //backtrack from here as either our current sum has exceeded the sum required or we have reached our solution and we want to explore more possibilites so remove last element  from the current vector\\n        }\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        if(k==0 || n==0) return {};  //if k==0 or n==0 return 0\\n        int sum = n;\\n        solve(k,n,{},1,sum);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void solve(int k , int n , vector<int> current , int index , int sum){\\n        \\n        if(k==0 and n==0){  //base case 1 : if k==0 and sum is exhausted than we have our required solution\\n            result.push_back(current); \\n            return ;                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 843371,
                "title": "combination-sum-iii-java-solution-beats-100-in-runtime-backtracking",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public void findAns(int curNo, int curSum, int targetSum, int targetSize,\\n                       ArrayList<Integer> curSet){\\n        if((curNo >= 10) || \\n           (targetSum <= curSum) || (curSet.size() >= targetSize)){\\n            if((curSet.size() == targetSize) && (targetSum == curSum)){\\n                ans.add(new ArrayList<Integer>(curSet));\\n            }\\n        }else{\\n            //do not include current element in set\\n            findAns(curNo+1, curSum, targetSum, targetSize, curSet);\\n            //include current element in set\\n            curSet.add(curNo);\\n            findAns(curNo+1, curSum + curNo , targetSum, targetSize, curSet);\\n            //backtrack\\n            curSet.remove(curSet.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<List<Integer>>();\\n        findAns(1, 0, n, k, new ArrayList<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public void findAns(int curNo, int curSum, int targetSum, int targetSize,\\n                       ArrayList<Integer> curSet){\\n        if((curNo >= 10) || \\n           (targetSum <= curSum) || (curSet.size() >= targetSize)){\\n            if((curSet.size() == targetSize) && (targetSum == curSum)){\\n                ans.add(new ArrayList<Integer>(curSet));\\n            }\\n        }else{\\n            //do not include current element in set\\n            findAns(curNo+1, curSum, targetSum, targetSize, curSet);\\n            //include current element in set\\n            curSet.add(curNo);\\n            findAns(curNo+1, curSum + curNo , targetSum, targetSize, curSet);\\n            //backtrack\\n            curSet.remove(curSet.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<List<Integer>>();\\n        findAns(1, 0, n, k, new ArrayList<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843290,
                "title": "c-combination-sum-iii-share-my-backtracking-solution",
                "content": "Generally, my solution is not fastest but easy to understand.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> sub(0);\\n        \\n        solve(sub, 0, k, n);\\n        return res;\\n    }\\n    void solve(vector<int> &sub, int be, int k, int n){\\n        if( n == 0 && k == 0 ){\\n            res.push_back(sub);\\n            return;\\n        }\\n        if( n < 0 || k < 0){\\n            return; \\n        }\\n        for(int i = be + 1; i <= 9; ++i){\\n            vector<int> ne = sub;\\n            ne.push_back(i);\\n            solve(ne, i, k-1, n-i);\\n        }\\n    }\\n    \\nprivate:\\n    vector< vector<int> > res;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> sub(0);\\n        \\n        solve(sub, 0, k, n);\\n        return res;\\n    }\\n    void solve(vector<int> &sub, int be, int k, int n){\\n        if( n == 0 && k == 0 ){\\n            res.push_back(sub);\\n            return;\\n        }\\n        if( n < 0 || k < 0){\\n            return; \\n        }\\n        for(int i = be + 1; i <= 9; ++i){\\n            vector<int> ne = sub;\\n            ne.push_back(i);\\n            solve(ne, i, k-1, n-i);\\n        }\\n    }\\n    \\nprivate:\\n    vector< vector<int> > res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843173,
                "title": "a-few-solutions",
                "content": "DFS + BT to find all and return candidate `paths` of cardinality `K` and total `T`.\\n\\n---\\n\\n**Similiar Problems:**\\n\\n* [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/506331/a-few-solutions)\\n* [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/506360/a-few-solutions)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun combinationSum3(K: Int, T: Int): List<List<Int>> {\\n        var paths = mutableListOf<List<Int>>()\\n        fun go(start: Int = 1, t: Int = 0, path: MutableList<Int> = mutableListOf<Int>()) {\\n            if (path.size == K) {\\n                if (t == T)\\n                    paths.add(path.toList())\\n                return\\n            }\\n            for (x in start..9) {\\n                path.add(x)\\n                go(x + 1, t + x, path)\\n                path.removeAt(path.lastIndex)\\n            }\\n        }\\n        go()\\n        return paths\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet combinationSum3 = (K, T, paths = []) => {\\n    let go = (start = 1, t = 0, path = []) => {\\n        if (path.length == K) {\\n            if (t == T)\\n                paths.push([...path]);\\n            return;\\n        }\\n        for (let x = start; x <= 9; ++x)\\n            go(x + 1, t + x, path.concat(x));\\n    };\\n    go();\\n    return paths;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def combinationSum3(self, K: int, T: int) -> List[List[int]]:\\n        paths = []\\n        def go(start = 1, t = 0, path = []):\\n            if len(path) == K:\\n                if t == T:\\n                    paths.append(path[:])\\n            for x in range(start, 9 + 1):\\n                go(x + 1, t + x, path + [x])\\n        go()\\n        return paths\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn combination_sum3(K: i32, T: i32) -> VVI {\\n        let mut paths = vec![];\\n        fn go(start: i32, k: i32, t: i32, path: &mut VI, paths: &mut VVI) {\\n            if k == 0 {\\n                if t == 0 {\\n                    paths.push(path.clone());\\n                }\\n                return;\\n            }\\n            for x in start..=9 {\\n                path.push(x);\\n                go(x + 1, k - 1, t - x, path, paths);\\n                path.pop();\\n            }\\n        }\\n        go(1, K, T, &mut vec![], &mut paths);\\n        return paths;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<void(int, int, VI&&)>;\\n    VVI combinationSum3(int K, int T, VVI paths = {}) {\\n        fun go = [&](auto start, auto t, auto&& path) {\\n            if (path.size() == K) {\\n                if (t == T)\\n                    paths.emplace_back(path);\\n                return;\\n            }\\n            for (auto x{ start }; x <= 9; ++x) {\\n                path.push_back(x);\\n                go(x + 1, t + x, move(path));\\n                path.pop_back();\\n            }\\n        };\\n        go(1, 0, {});\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun combinationSum3(K: Int, T: Int): List<List<Int>> {\\n        var paths = mutableListOf<List<Int>>()\\n        fun go(start: Int = 1, t: Int = 0, path: MutableList<Int> = mutableListOf<Int>()) {\\n            if (path.size == K) {\\n                if (t == T)\\n                    paths.add(path.toList())\\n                return\\n            }\\n            for (x in start..9) {\\n                path.add(x)\\n                go(x + 1, t + x, path)\\n                path.removeAt(path.lastIndex)\\n            }\\n        }\\n        go()\\n        return paths\\n    }\\n}\\n```\n```\\nlet combinationSum3 = (K, T, paths = []) => {\\n    let go = (start = 1, t = 0, path = []) => {\\n        if (path.length == K) {\\n            if (t == T)\\n                paths.push([...path]);\\n            return;\\n        }\\n        for (let x = start; x <= 9; ++x)\\n            go(x + 1, t + x, path.concat(x));\\n    };\\n    go();\\n    return paths;\\n};\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, K: int, T: int) -> List[List[int]]:\\n        paths = []\\n        def go(start = 1, t = 0, path = []):\\n            if len(path) == K:\\n                if t == T:\\n                    paths.append(path[:])\\n            for x in range(start, 9 + 1):\\n                go(x + 1, t + x, path + [x])\\n        go()\\n        return paths\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn combination_sum3(K: i32, T: i32) -> VVI {\\n        let mut paths = vec![];\\n        fn go(start: i32, k: i32, t: i32, path: &mut VI, paths: &mut VVI) {\\n            if k == 0 {\\n                if t == 0 {\\n                    paths.push(path.clone());\\n                }\\n                return;\\n            }\\n            for x in start..=9 {\\n                path.push(x);\\n                go(x + 1, k - 1, t - x, path, paths);\\n                path.pop();\\n            }\\n        }\\n        go(1, K, T, &mut vec![], &mut paths);\\n        return paths;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<void(int, int, VI&&)>;\\n    VVI combinationSum3(int K, int T, VVI paths = {}) {\\n        fun go = [&](auto start, auto t, auto&& path) {\\n            if (path.size() == K) {\\n                if (t == T)\\n                    paths.emplace_back(path);\\n                return;\\n            }\\n            for (auto x{ start }; x <= 9; ++x) {\\n                path.push_back(x);\\n                go(x + 1, t + x, move(path));\\n                path.pop_back();\\n            }\\n        };\\n        go(1, 0, {});\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843007,
                "title": "python-1-line-itertools-easy-to-understand",
                "content": "Function *combinations(iterable, k)*  from *itertools* returns all k-lenth combinations from s.\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [num for num in itertools.combinations(range(1,10), k) if sum(num)==n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [num for num in itertools.combinations(range(1,10), k) if sum(num)==n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842624,
                "title": "python-3-backtracking-dfs-explanations",
                "content": "### Explanation\\n- Intuitively, backtracking should work with this question, since the final result depends on previous step, and there is a recursive relation between current value and next possible value\\n- Numbers in each possible combination are unique, so we can use a variable to indicate the start number to avoid repeat (`start_num`)\\n- We need to count how many numbers (`digit`) we used, combo with numbers over `k` will be disqualified \\n- `cur`: is current combo\\n- `cur_sum`: is current sum of current combo, if `cum_sum > n`, this combo will be disqualified\\n### Implementation\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(digit, start_num, cur, cur_sum):\\n            if cur_sum == n and digit == k: ans.append(cur[:])\\n            elif digit >= k or cur_sum > n: return    \\n            else:\\n                for i in range(start_num+1, 10):\\n                    cur.append(i)\\n                    dfs(digit+1, i, cur, cur_sum+i)\\n                    cur.pop()\\n        ans = list()\\n        dfs(0, 0, [], 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(digit, start_num, cur, cur_sum):\\n            if cur_sum == n and digit == k: ans.append(cur[:])\\n            elif digit >= k or cur_sum > n: return    \\n            else:\\n                for i in range(start_num+1, 10):\\n                    cur.append(i)\\n                    dfs(digit+1, i, cur, cur_sum+i)\\n                    cur.pop()\\n        ans = list()\\n        dfs(0, 0, [], 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842615,
                "title": "combination-sum-iii-python-1-line-solution",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return filter(lambda x: sum(x) == n, combinations(range(1, 10), r=k))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return filter(lambda x: sum(x) == n, combinations(range(1, 10), r=k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842613,
                "title": "very-simple-python-solution-using-itertools",
                "content": "```\\nimport itertools\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        allNumbers=[i for i in range(1,10)]\\n        res=[]\\n        for item in itertools.combinations(allNumbers,k):\\n            if sum(item)==n:\\n                res.append(item)\\n                \\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        allNumbers=[i for i in range(1,10)]\\n        res=[]\\n        for item in itertools.combinations(allNumbers,k):\\n            if sum(item)==n:\\n                res.append(item)\\n                \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 802224,
                "title": "c-dp-coin-change-ii-analog",
                "content": "First of all, try to solve **coin change ii** problem. Here, technique is the same.\\n\\n```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<unordered_set<int>>> dp(n + 1, \\n\\t\\tvector<unordered_set<int>>());\\n\\n\\tdp[0] = { unordered_set<int>() };\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto set : dp[j - i])\\n\\t\\t\\t\\tif (set.size() < k && !set.count(i))\\n\\t\\t\\t\\t\\tset.insert(i), dp[j].push_back(set);\\n\\n\\tvector<vector<int>> result;\\n\\n\\tfor (auto set : dp[n])\\n\\t\\tif (set.size() == k)\\n\\t\\t\\tresult.push_back(vector<int>(set.begin(), set.end()));\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<unordered_set<int>>> dp(n + 1, \\n\\t\\tvector<unordered_set<int>>());\\n\\n\\tdp[0] = { unordered_set<int>() };\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto set : dp[j - i])\\n\\t\\t\\t\\tif (set.size() < k && !set.count(i))\\n\\t\\t\\t\\t\\tset.insert(i), dp[j].push_back(set);\\n\\n\\tvector<vector<int>> result;\\n\\n\\tfor (auto set : dp[n])\\n\\t\\tif (set.size() == k)\\n\\t\\t\\tresult.push_back(vector<int>(set.begin(), set.end()));\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702351,
                "title": "details-in-pruning-an-optimization-for-lower-time-complexity",
                "content": "Wisely select the starting number and ending number can significantly reduece the time cost of this problem. The algorithm can be considered as growing a **tree** and find all nodes on the k-th level with a sum of n, then what we gonna do to optimize is **pruning** so that the tree would not grow too large.\\n\\nRegardless of the algorithm, dfs or bfs, it is necessary to find the next number si that it can be appended to the current unfinished combination, Let\\'s say the range is from *starting number* to *ending numbe*r.\\n\\n>**Starting number**\\nMost solutions start from the next available number, which is the currently largest number + 1. It is good enough to avoid duplicates in a combination, but not strong enough condition.  One  thing worth thinking here is: is it possible to reach the target sum pick this number?\\nIf not, it would be better to prune the combinations, whose largest possible sum does not covers current target sum.\\ne.g.\\na candidate combination is currently [1,2,x,x,x]. x\\'s are vacacies to fill, which should sum up to, say, 22\\nThe first x is the number to fill in this iteration, which is ok to start with 3 (= 2 + 1), but consider the following:\\nThe largest sum of the last two vacancies are 17 (= 9 + 8)\\nso the min start would be 5 (= 22 - 17), instead of 3 (= 2 + 1).\\nHow to calculate the start.\\nIt is quite straightforward to figure out the starting number. Simply fill the rest vacancies with the largest possible number and get the sum (arithmetic sequence). The starting number can be calculated by substracting the sum from current target.\\n\\n>**Ending number**\\n>Again it is ok to pick 9 as an end, but there are still somthing to prune.\\n>Firstly, is there enough number to finish the combination?\\n>e.g.\\n>A candidate combination is currently [3,4,x,x,x], three numbers to go. If  9 is picked here, then we have [3,4,9,x,x], there are no numbers to fill in the rest two vacancies. Instead, the max number to pick in this iteration is 7, so that the rest two can be 8 and 9.\\n>Secondly, is the current picked number too large for the current target sum?\\n>e.g.\\n>A candidate combination is currently [1,2,x,x,x], current target sum to go is 16, which means the rest three vacanies sum up to 16. If we pick 5 as the next nmber, then the sequence with the least sum with be [1,2,5,6,7], the sum of vacancies is 18 (= 5 + 6 + 7) > 16, so the ending number here is 4, so that the lesat-sum sequenc would be [1,2,4,5,6], with 4 + 5 + 6 = 15 < 16.\\n>Whichever of the two upper limits is smaller, we take it.\\n\\nAn snippet in python implementing BFS is below.\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        # bfs optimzied by pruning, \\n\\t\\t\\n        MIN_NUM = 1\\n        MAX_NUM = 9\\n        q = [([], n)]\\n        level = 0\\n        \\n        while level < k:\\n            next_level = []\\n            for path, target in q:\\n                # avoid duplicate numbers in a combination\\n                lower_limit_1 = path[-1] + 1 if path else MIN_NUM\\n                # guarantee the largest sum covers target (larger than target)\\n                lower_limit_2 = target - (2 * MAX_NUM - k + level + 2) * (k - level - 1) // 2\\n                # guarantee enough numbers to finish the sequence\\n                upper_limit_1 = MAX_NUM + 1 - k + level\\n                # guarantee the least sum does not overflow (no larger than target)\\n                upper_limit_2 = int(target / (k - level) - (k - level - 1) / 2)\\n                \\n                lower_limit = max(lower_limit_1, lower_limit_2)\\n                upper_limit = min(upper_limit_1, upper_limit_2)\\n                \\n                for num in range(lower_limit, upper_limit + 1): # upper_limit + 1 for right exlusive\\n                    next_level.append((path + [num], target - num))\\n            \\n            level += 1\\n            q = next_level\\n            \\n        return [path for path, target in q if target == 0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        # bfs optimzied by pruning, \\n\\t\\t\\n        MIN_NUM = 1\\n        MAX_NUM = 9\\n        q = [([], n)]\\n        level = 0\\n        \\n        while level < k:\\n            next_level = []\\n            for path, target in q:\\n                # avoid duplicate numbers in a combination\\n                lower_limit_1 = path[-1] + 1 if path else MIN_NUM\\n                # guarantee the largest sum covers target (larger than target)\\n                lower_limit_2 = target - (2 * MAX_NUM - k + level + 2) * (k - level - 1) // 2\\n                # guarantee enough numbers to finish the sequence\\n                upper_limit_1 = MAX_NUM + 1 - k + level\\n                # guarantee the least sum does not overflow (no larger than target)\\n                upper_limit_2 = int(target / (k - level) - (k - level - 1) / 2)\\n                \\n                lower_limit = max(lower_limit_1, lower_limit_2)\\n                upper_limit = min(upper_limit_1, upper_limit_2)\\n                \\n                for num in range(lower_limit, upper_limit + 1): # upper_limit + 1 for right exlusive\\n                    next_level.append((path + [num], target - num))\\n            \\n            level += 1\\n            q = next_level\\n            \\n        return [path for path, target in q if target == 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 689915,
                "title": "python-backtracking-easy-solution",
                "content": "Runtime: 32 ms, faster than 65.87% of Python3 online submissions for Combination Sum III.\\nMemory Usage: 13.6 MB, less than 94.07% of Python3 online submissions for Combination Sum III.\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.k, self.n, self.res = k, n, []\\n        self.backtrack([i+1 for i in range(9)], [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        if len(current) == self.k and sum(current) == self.n:\\n            self.res.append(current)\\n            return\\n        if len(current) == self.k or sum(current) == self.n:\\n            return\\n        for i in range(start, len(nums)):\\n            self.backtrack(nums, current + [nums[i]], i + 1)",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "Runtime: 32 ms, faster than 65.87% of Python3 online submissions for Combination Sum III.\\nMemory Usage: 13.6 MB, less than 94.07% of Python3 online submissions for Combination Sum III.\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.k, self.n, self.res = k, n, []\\n        self.backtrack([i+1 for i in range(9)], [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        if len(current) == self.k and sum(current) == self.n:\\n            self.res.append(current)\\n            return\\n        if len(current) == self.k or sum(current) == self.n:\\n            return\\n        for i in range(start, len(nums)):\\n            self.backtrack(nums, current + [nums[i]], i + 1)",
                "codeTag": "Java"
            },
            {
                "id": 645100,
                "title": "java-simple-solution-beats-100-of-java-submissions-with-explanation",
                "content": "Time complexity is O (9^k) since that\\'s the number of solutions one can have but actual runtime should be less as there is actually only (n-k) possible numbers to place.\\n\\nThe main idea is to build these combinations through the recursive calls. We start with an empty list as combination. We will try adding the next possible unique number (by keeping track of `currNum`) and `remain` will keep track of how much more we need to add to reach the sum n. Once `remain` is 0 and we have reached the required number of `k` integers to form the sum, we will add it to the `results` list.\\nWe will only continue building the combination if the `remain` can be satisfied by the next possible number `currNum`. If not, we will stop building this specific combination since if it won\\'t be satisified by the `currNum`, it sure won\\'t be satisfied for the next possible numbers that are greater than `currNum`.\\n\\nNote: We can save further space by not making new list `copy` of the combination to pass into the recursive calls and instead, add it to a single list and backtrack by removing it after the recursive call returns. However, to make this solution simpler and easier to to understand, I used copied lists.\\n\\nThanks for reading and would appreciate any feedback!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        makeComb(1, n, new ArrayList<Integer>(), k, results);\\n        return results;\\n    }\\n    \\n    private void makeComb(int currNum, int remain, List<Integer> comb, int k, List<List<Integer>> results) {\\n        if (remain == 0 && comb.size() == k) {\\n            results.add(comb);\\n        } else if (remain >= currNum) {\\n            for (int i = currNum; i <= 9;i++) {\\n                List<Integer> copy = new ArrayList<>(comb);\\n                copy.add(i);\\n                makeComb(i + 1, remain - i, copy, k, results);\\n            }\\n        }\\n    }\\n}\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        makeComb(1, n, new ArrayList<Integer>(), k, results);\\n        return results;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 619055,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\n    void combinationSum3Util(vector<int>nums, int l, int k, int n, vector<int>& v,\\n                            vector<vector<int>>& ans) {\\n        \\n        if (v.size() == k && n == 0) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for (int i = l; i < nums.size(); i++) {\\n            v.push_back(nums[i]);\\n            combinationSum3Util(nums, i+1, k, n-nums[i], v, ans);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>nums;\\n        for (int i = 1; i <= 9; i++)\\n            nums.push_back(i);\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        combinationSum3Util(nums, 0, k, n, v, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void combinationSum3Util(vector<int>nums, int l, int k, int n, vector<int>& v,\\n                            vector<vector<int>>& ans) {\\n        \\n        if (v.size() == k && n == 0) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for (int i = l; i < nums.size(); i++) {\\n            v.push_back(nums[i]);\\n            combinationSum3Util(nums, i+1, k, n-nums[i], v, ans);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>nums;\\n        for (int i = 1; i <= 9; i++)\\n            nums.push_back(i);\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        combinationSum3Util(nums, 0, k, n, v, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547111,
                "title": "go-golang-0ms-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Combination Sum III.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Combination Sum III.\\n\\n```go\\nfunc combinationSum3(k int, n int) [][]int {\\n    ans := [][]int{}\\n    helper(k, n, 1, []int{}, &ans)\\n    return ans\\n}\\n\\nfunc helper(k, n, i int, cur []int, ans *[][]int) {\\n    if k < 0 || n < 0 { return }\\n    if k == 0 && n == 0 { *ans = append(*ans, append([]int{}, cur...)); return }\\n    for j := i; j <= 9; j++ { helper(k - 1, n - j, j + 1, append(cur, j), ans) }\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc combinationSum3(k int, n int) [][]int {\\n    ans := [][]int{}\\n    helper(k, n, 1, []int{}, &ans)\\n    return ans\\n}\\n\\nfunc helper(k, n, i int, cur []int, ans *[][]int) {\\n    if k < 0 || n < 0 { return }\\n    if k == 0 && n == 0 { *ans = append(*ans, append([]int{}, cur...)); return }\\n    for j := i; j <= 9; j++ { helper(k - 1, n - j, j + 1, append(cur, j), ans) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391725,
                "title": "java-backtracking-solution-beats-100-with-explains",
                "content": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(n>45) return ans;  //we can use only onece for element 1->9 so maximun n must be 45\\n        helper(ans,new ArrayList<>(),n,1,k,n);\\n        return ans;\\n    }\\n    public void helper(List<List<Integer>> ans,List<Integer> one,int target,int start,int k,int n){\\n        if(target==0 && one.size()==k){\\n            ans.add(new ArrayList<>(one));\\n            return;\\n        }\\n        for(int i=start;i<=9;i++){\\n            if(target<i) return; // if target less than i , we do not need to go on anymore \\n            one.add(i);\\n            helper(ans,one,target-i,i+1,k,n);\\n            one.remove(one.size()-1);\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(n>45) return ans;  //we can use only onece for element 1->9 so maximun n must be 45\\n        helper(ans,new ArrayList<>(),n,1,k,n);\\n        return ans;\\n    }\\n    public void helper(List<List<Integer>> ans,List<Integer> one,int target,int start,int k,int n){\\n        if(target==0 && one.size()==k){\\n            ans.add(new ArrayList<>(one));\\n            return;\\n        }\\n        for(int i=start;i<=9;i++){\\n            if(target<i) return; // if target less than i , we do not need to go on anymore \\n            one.add(i);\\n            helper(ans,one,target-i,i+1,k,n);\\n            one.remove(one.size()-1);\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565816,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565528,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1566487,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1929270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1570873,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1745508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1576291,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1567920,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 2029637,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1742692,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565816,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565528,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1566487,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1929270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1570873,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1745508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1576291,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1567920,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 2029637,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1742692,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1572630,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572584,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572349,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571444,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2054065,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1995843,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1988755,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1839590,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1823663,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757524,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    }
]