[
    {
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "question_content": "Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.\nIf there exist multiple answers, you can return any of them.\n&nbsp;\nExample 1:\n\nInput: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\nOutput: [1,2,3,4,5,6,7]\n\nExample 2:\n\nInput: preorder = [1], postorder = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\t1 <= preorder.length <= 30\n\t1 <= preorder[i] <= preorder.length\n\tAll the values of preorder are unique.\n\tpostorder.length == preorder.length\n\t1 <= postorder[i] <= postorder.length\n\tAll the values of postorder are unique.\n\tIt is guaranteed that preorder and postorder are the preorder traversal and postorder traversal of the same binary tree.",
        "solutions": [
            {
                "id": 161268,
                "title": "c-java-python-one-pass-real-o-n",
                "content": "## **Foreword**\\nI saw some solutions saying `O(N)` time, but actually they are not.\\nIf it takes already `O(N)` time to find left part and right part, it could not be `O(N)`.\\n<br>\\n\\n## **Complexity**:\\nTime `O(N)`, as we iterate both pre index and post index only once.\\nSpace `O(height)`, depending on the height of constructed tree.\\n<br>\\n\\n## **Recursive Solution**\\nCreate a node `TreeNode(pre[preIndex])` as the root.\\n\\nBecasue root node will be lastly iterated in post order,\\n`if root.val == post[posIndex]`,\\nit means we have constructed the whole tree,\\n\\nIf we haven\\'t completed constructed the whole tree,\\nSo we recursively `constructFromPrePost` for left sub tree and right sub tree.\\n\\nAnd finally, we\\'ll reach the `posIndex` that `root.val == post[posIndex]`.\\nWe increment `posIndex` and return our `root` node.\\n\\n**C++:**\\n```cpp\\n    int preIndex = 0, posIndex = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if (root->val != post[posIndex])\\n            root->left = constructFromPrePost(pre, post);\\n        if (root->val != post[posIndex])\\n            root->right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\\n\\n**Java:**\\ninspired by @duhber\\n```java\\n    int preIndex = 0, posIndex = 0;\\n    public TreeNode constructFromPrePost(int[]pre, int[]post) {\\n        TreeNode root = new TreeNode(pre[preIndex++]);\\n        if (root.val != post[posIndex])\\n            root.left = constructFromPrePost(pre, post);\\n        if (root.val != post[posIndex])\\n            root.right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\\n**Python:**\\n```py\\n    preIndex, posIndex = 0, 0\\n    def constructFromPrePost(self, pre, post):\\n        root = TreeNode(pre[self.preIndex])\\n        self.preIndex += 1\\n        if (root.val != post[self.posIndex]):\\n            root.left = self.constructFromPrePost(pre, post)\\n        if (root.val != post[self.posIndex]):\\n            root.right = self.constructFromPrePost(pre, post)\\n        self.posIndex += 1\\n        return root\\n```\\n<br>\\n\\n## **Iterative Solution**\\nWe will **preorder** generate TreeNodes, push them to `stack` and **postorder** pop them out.\\n1. Iterate on `pre` array and construct node one by one.\\n2. `stack` save the current path of tree.\\n3. `node = new TreeNode(pre[i])`, if not left child, add node to the left. otherwise add it to the right.\\n4. If we meet a same value in the pre and post, it means we complete the construction for current subtree. We pop it from `stack`.\\n\\n**C++:**\\n```cpp\\n    TreeNode* constructFromPrePost(vector<int> pre, vector<int> post) {\\n        vector<TreeNode*> s;\\n        s.push_back(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.size(); ++i) {\\n            TreeNode* node = new TreeNode(pre[i]);\\n            while (s.back()->val == post[j])\\n                s.pop_back(), j++;\\n            if (s.back()->left == NULL) s.back()->left = node;\\n            else s.back()->right = node;\\n            s.push_back(node);\\n        }\\n        return s[0];\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; ++i) {\\n            TreeNode node = new TreeNode(pre[i]);\\n            while (s.getLast().val == post[j]) {\\n                s.pollLast(); j++;\\n            }\\n            if (s.getLast().left == null) s.getLast().left = node;\\n            else s.getLast().right = node;\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\\n**Python:**\\n```py\\n    def constructFromPrePost(self, pre, post):\\n        stack = [TreeNode(pre[0])]\\n        j = 0\\n        for v in pre[1:]:\\n            node = TreeNode(v)\\n            while stack[-1].val == post[j]:\\n                stack.pop()\\n                j += 1\\n            if not stack[-1].left:\\n                stack[-1].left = node\\n            else:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```\\n<br>\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int preIndex = 0, posIndex = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if (root->val != post[posIndex])\\n            root->left = constructFromPrePost(pre, post);\\n        if (root->val != post[posIndex])\\n            root->right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\n```java\\n    int preIndex = 0, posIndex = 0;\\n    public TreeNode constructFromPrePost(int[]pre, int[]post) {\\n        TreeNode root = new TreeNode(pre[preIndex++]);\\n        if (root.val != post[posIndex])\\n            root.left = constructFromPrePost(pre, post);\\n        if (root.val != post[posIndex])\\n            root.right = constructFromPrePost(pre, post);\\n        posIndex++;\\n        return root;\\n    }\\n```\n```py\\n    preIndex, posIndex = 0, 0\\n    def constructFromPrePost(self, pre, post):\\n        root = TreeNode(pre[self.preIndex])\\n        self.preIndex += 1\\n        if (root.val != post[self.posIndex]):\\n            root.left = self.constructFromPrePost(pre, post)\\n        if (root.val != post[self.posIndex]):\\n            root.right = self.constructFromPrePost(pre, post)\\n        self.posIndex += 1\\n        return root\\n```\n```cpp\\n    TreeNode* constructFromPrePost(vector<int> pre, vector<int> post) {\\n        vector<TreeNode*> s;\\n        s.push_back(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.size(); ++i) {\\n            TreeNode* node = new TreeNode(pre[i]);\\n            while (s.back()->val == post[j])\\n                s.pop_back(), j++;\\n            if (s.back()->left == NULL) s.back()->left = node;\\n            else s.back()->right = node;\\n            s.push_back(node);\\n        }\\n        return s[0];\\n    }\\n```\n```java\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; ++i) {\\n            TreeNode node = new TreeNode(pre[i]);\\n            while (s.getLast().val == post[j]) {\\n                s.pollLast(); j++;\\n            }\\n            if (s.getLast().left == null) s.getLast().left = node;\\n            else s.getLast().right = node;\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\n```py\\n    def constructFromPrePost(self, pre, post):\\n        stack = [TreeNode(pre[0])]\\n        j = 0\\n        for v in pre[1:]:\\n            node = TreeNode(v)\\n            while stack[-1].val == post[j]:\\n                stack.pop()\\n                j += 1\\n            if not stack[-1].left:\\n                stack[-1].left = node\\n            else:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161372,
                "title": "java-python-divide-and-conquer-with-explanation",
                "content": "The problem is easier to solve if we decrease it into subproblems using **Divide and Conquer**.\\n```\\ne.g.   Given preorder : 1 2 4 5 3 6;     postorder: 4 5 2 6 3 1.\\nWe see it as preorder : 1 (2 4 5) (3 6); postorder: (4 5 2) (6 3) 1 [to be explained afterwards]\\nThat can be decreased to subproblems A, B, C: \\nA. preorder : 1; postorder: 1 =>\\n 1\\nB. preorder : (2 4 5); postorder: (4 5 2) => \\n   2\\n  / \\\\\\n 4   5\\nC. preorder : (3 6); postorder: (6 3) => \\n   3\\n  / \\n 6     or\\n   3\\n    \\\\\\n     6\\n* Then we conquer the subproblems => A.left = B; A.right = C;\\n   1\\n  / \\\\\\n 2   3\\n/ \\\\  /\\n4  5 6\\n```\\nIf we observe parameters in each recursion above:\\n```\\npreStart: 0, preEnd: 5, postStart: 0, postEnd: 5\\npreStart: 1, preEnd: 3, postStart: 0, postEnd: 2\\npreStart: 4, preEnd: 5, postStart: 3, postEnd: 4\\n```\\nFor the commented, `[to be explained afterwards]`, how do we decrease a problem?\\nThat is, 1 is root and 2 is its left child. Since 2 is the root of the left subtree, all elements in front of 2 in `post[]` must be in the left subtree also. \\nWe recursively follow the above approach.\\nPlease note that `pre[preStart + 1] may also be the root of the right subtree` if there is no left subtree at all in the orginal tree. Since we are asked to generate one possible original tree, I assume `pre[preStart + 1]` to be the left subtree root always.\\n\\n****\\n**Java**\\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length - 1, post, 0, pre.length - 1);\\n    }\\n    \\n    private TreeNode constructFromPrePost(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {\\n        // Base cases.\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        if (preStart == preEnd) {\\n            return new TreeNode(pre[preStart]);\\n        }\\n        \\n        // Build root.\\n        TreeNode root = new TreeNode(pre[preStart]);\\n        \\n        // Locate left subtree.\\n        int leftSubRootInPre = preStart + 1; \\n        int leftSubRootInPost = findLeftSubRootInPost(pre[leftSubRootInPre], post, postStart, postEnd);\\n        int leftSubEndInPre = leftSubRootInPre + (leftSubRootInPost - postStart);\\n        \\n        // Divide.\\n        TreeNode leftSubRoot = constructFromPrePost(pre, leftSubRootInPre, leftSubEndInPre, \\n                                                    post, postStart, leftSubRootInPost);  \\n        TreeNode rightSubRoot = constructFromPrePost(pre, leftSubEndInPre + 1, preEnd, \\n                                                     post, leftSubRootInPost + 1, postEnd - 1);\\n        \\n        // Conquer.      \\n        root.left = leftSubRoot;\\n        root.right = rightSubRoot;\\n        \\n        return root;\\n    }\\n    \\n    private int findLeftSubRootInPost(int leftSubRootVal, int[] post, int postStart, int postEnd) {\\n        for (int i = postStart; i <= postEnd; i++) {\\n            if (post[i] == leftSubRootVal) {\\n                return i;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n\\n```\\n**Python**\\n```\\n    def constructFromPrePost(self, pre, post):\\n        return self.constructFromPrePostRecurUtil(\\n            pre, 0, len(pre) - 1, post, 0, len(post) - 1)\\n        \\n    def constructFromPrePostRecurUtil(\\n            self, \\n            pre, \\n            preStart, \\n            preEnd, \\n            post, \\n            postStart, \\n            postEnd):\\n        # Base case.\\n        if (preStart > preEnd):\\n            return None\\n        if (preStart == preEnd):\\n            return TreeNode(pre[preStart])\\n        # Recursive case.\\n        root = TreeNode(pre[preStart])\\n        leftRootIndexInPre = preStart + 1\\n        leftRootIndexInPost = self.getIndexInPost(\\n            post, pre[leftRootIndexInPre])\\n        leftEndIndexInPre = leftRootIndexInPre + \\\\\\n            (leftRootIndexInPost - postStart)\\n        root.left = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftRootIndexInPre, \\n            leftEndIndexInPre, \\n            post, \\n            postStart, \\n            leftRootIndexInPost)\\n        root.right = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftEndIndexInPre + 1, \\n            preEnd, \\n            post, \\n            leftRootIndexInPost + 1, \\n            postEnd - 1)\\n        return root\\n        \\n    def getIndexInPost(self, post, target):\\n        for i, v in enumerate(post):\\n            if v == target:\\n                return i\\n        return -1   # to optimize\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\ne.g.   Given preorder : 1 2 4 5 3 6;     postorder: 4 5 2 6 3 1.\\nWe see it as preorder : 1 (2 4 5) (3 6); postorder: (4 5 2) (6 3) 1 [to be explained afterwards]\\nThat can be decreased to subproblems A, B, C: \\nA. preorder : 1; postorder: 1 =>\\n 1\\nB. preorder : (2 4 5); postorder: (4 5 2) => \\n   2\\n  / \\\\\\n 4   5\\nC. preorder : (3 6); postorder: (6 3) => \\n   3\\n  / \\n 6     or\\n   3\\n    \\\\\\n     6\\n* Then we conquer the subproblems => A.left = B; A.right = C;\\n   1\\n  / \\\\\\n 2   3\\n/ \\\\  /\\n4  5 6\\n```\n```\\npreStart: 0, preEnd: 5, postStart: 0, postEnd: 5\\npreStart: 1, preEnd: 3, postStart: 0, postEnd: 2\\npreStart: 4, preEnd: 5, postStart: 3, postEnd: 4\\n```\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length - 1, post, 0, pre.length - 1);\\n    }\\n    \\n    private TreeNode constructFromPrePost(int[] pre, int preStart, int preEnd, int[] post, int postStart, int postEnd) {\\n        // Base cases.\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        if (preStart == preEnd) {\\n            return new TreeNode(pre[preStart]);\\n        }\\n        \\n        // Build root.\\n        TreeNode root = new TreeNode(pre[preStart]);\\n        \\n        // Locate left subtree.\\n        int leftSubRootInPre = preStart + 1; \\n        int leftSubRootInPost = findLeftSubRootInPost(pre[leftSubRootInPre], post, postStart, postEnd);\\n        int leftSubEndInPre = leftSubRootInPre + (leftSubRootInPost - postStart);\\n        \\n        // Divide.\\n        TreeNode leftSubRoot = constructFromPrePost(pre, leftSubRootInPre, leftSubEndInPre, \\n                                                    post, postStart, leftSubRootInPost);  \\n        TreeNode rightSubRoot = constructFromPrePost(pre, leftSubEndInPre + 1, preEnd, \\n                                                     post, leftSubRootInPost + 1, postEnd - 1);\\n        \\n        // Conquer.      \\n        root.left = leftSubRoot;\\n        root.right = rightSubRoot;\\n        \\n        return root;\\n    }\\n    \\n    private int findLeftSubRootInPost(int leftSubRootVal, int[] post, int postStart, int postEnd) {\\n        for (int i = postStart; i <= postEnd; i++) {\\n            if (post[i] == leftSubRootVal) {\\n                return i;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException();\\n    }\\n\\n```\n```\\n    def constructFromPrePost(self, pre, post):\\n        return self.constructFromPrePostRecurUtil(\\n            pre, 0, len(pre) - 1, post, 0, len(post) - 1)\\n        \\n    def constructFromPrePostRecurUtil(\\n            self, \\n            pre, \\n            preStart, \\n            preEnd, \\n            post, \\n            postStart, \\n            postEnd):\\n        # Base case.\\n        if (preStart > preEnd):\\n            return None\\n        if (preStart == preEnd):\\n            return TreeNode(pre[preStart])\\n        # Recursive case.\\n        root = TreeNode(pre[preStart])\\n        leftRootIndexInPre = preStart + 1\\n        leftRootIndexInPost = self.getIndexInPost(\\n            post, pre[leftRootIndexInPre])\\n        leftEndIndexInPre = leftRootIndexInPre + \\\\\\n            (leftRootIndexInPost - postStart)\\n        root.left = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftRootIndexInPre, \\n            leftEndIndexInPre, \\n            post, \\n            postStart, \\n            leftRootIndexInPost)\\n        root.right = self.constructFromPrePostRecurUtil(\\n            pre, \\n            leftEndIndexInPre + 1, \\n            preEnd, \\n            post, \\n            leftRootIndexInPost + 1, \\n            postEnd - 1)\\n        return root\\n        \\n    def getIndexInPost(self, post, target):\\n        for i, v in enumerate(post):\\n            if v == target:\\n                return i\\n        return -1   # to optimize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161286,
                "title": "c-o-n-recursive-solution",
                "content": "For two subarrays `pre[a,b]` and `post[c,d]`, if we want to reconstruct a tree from them, we know that pre[a]==post[d] is the root node.\\n\\n```\\n[root][......left......][...right..]  ---pre\\n[......left......][...right..][root]  ---post\\n```\\n\\n`pre[a+1]` is the root node of the left subtree.\\nFind the index of `pre[a+1]` in `post`, then we know the left subtree should be constructed from `pre[a+1, a+idx-c+1]` and `post[c, idx]`.\\n\\nHere is my code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; // value->index\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int len = post.size();\\n        for (int i = 0; i < len; i++) m[post[i]] = i;\\n        return construct(pre, post, 0, len - 1, 0, len - 1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int a, int b, int c, int d) {\\n        TreeNode* n = new TreeNode(pre[a]);\\n        if (a == b) return n;\\n        int t = pre[a + 1];\\n        int idx = m[t];\\n        int len = idx - c + 1;\\n        n->left = construct(pre, post, a + 1, a + len, c, c + len - 1);\\n        if (idx + 1 == d) return n;\\n        n->right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[root][......left......][...right..]  ---pre\\n[......left......][...right..][root]  ---post\\n```\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; // value->index\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int len = post.size();\\n        for (int i = 0; i < len; i++) m[post[i]] = i;\\n        return construct(pre, post, 0, len - 1, 0, len - 1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int a, int b, int c, int d) {\\n        TreeNode* n = new TreeNode(pre[a]);\\n        if (a == b) return n;\\n        int t = pre[a + 1];\\n        int idx = m[t];\\n        int len = idx - c + 1;\\n        n->left = construct(pre, post, a + 1, a + len, c, c + len - 1);\\n        if (idx + 1 == d) return n;\\n        n->right = construct(pre, post, a + len + 1, b, idx + 1, d - 1);\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748216,
                "title": "python3-solution-with-a-detailed-explanation-construct-binary-tree-from",
                "content": "Make sure you understand the preorder and postorder traversal and how the nodes are arranged in each, with respect to the other one. [This](https://www.***.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/) might help. I also find [this](https://www.***.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/) explanation helpful. The solution that I\\'ll show below comes from reading different posts on leetcode and elsewhere. \\n\\nSome relations between the two orders include: 1) the first node of `pre` is root, same as the last node of `post`. 2) The second node of `pre` is left subtree root, while the second to the last node of `post` is the right subtree root. Now think for a moment about `post`. The last number is `root` value, if we do `post.pop()`, what is the last element now? The root of right subtree, right? What if we do that again? The last node now is the root of a deeper subtree on the right side again (`7`). \\n\\nCheck out this example! `pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]`. This can correspond to a tree like this (note that we can construct many trees given `pre` and `post`): \\n\\n\\t\\t\\t\\t\\t   1\\n\\t\\t\\t\\t2             3\\n\\t\\t\\t  4\\t 5           6  7\\n\\nThe node of right subtrees are `3`, and then `7`. If you check the `post`, you\\'ll see that they appear from right after `root`. We\\'ll use this in the solution. We do some prechecking to see whether tree is empty of not. If there has zero nodes, we return `None`. If there is one node, it\\'s root, we `return TreeNode(post.pop())`. Line `#3` adds the last element of `post` to the tree as the `root` of that level. Then, in line `#4`, it finds the  index in `pre` corresponding to the last element of `post` after popping (the `root` of right subtree in that level) because that element is the start of right subtree in `pre` (check the example). After we `pop` the root (`1`) from `post`, the root of right subtree is `3`. Now, in `pre`, anything before `3` corresponds to the left subtree with `2` being the root of it. \\n\\nNow comes the recursive part of solution. We split the `pre` into two parts, one for right subtree (line `#1`) and one for left subtree (line `#2`). We add them to `node.right` and `node.left`, respectively. Imaging you\\'re at the `root` level, in line `#3`, you add the root to `node`. Then, line `#1` after recursion produces the whole right subtree, and line `#2` produces the whole left subtree. Finally, `node` is returned which includes all the elements. Keep reading! \\n\\n\\t\\t\\t\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # read this: https://www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\\n        def helper(pre,post):\\n            print(\\'pre is: \\', pre, \\'post is: \\', post)\\n            if not pre:\\n                return None\\n        \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n        \\n        \\n            node=TreeNode(post.pop()) #3\\n            ind=pre.index(post[-1]) #4\\n        \\n            node.right=helper(pre[ind:],post) #1\\n            node.left=helper(pre[1:ind],post) #2\\n            return node\\n    \\n        return helper(pre,post)\\n```\\n\\nIf you print `pre` and `post` everytime the `helper` function is called, you get something like this: \\n\\t\\t\\t\\n```\\npre is:  [1, 2, 4, 5, 3, 6, 7] post is:  [4, 5, 2, 6, 7, 3, 1] # initial\\npre is:  [3, 6, 7] post is:  [4, 5, 2, 6, 7, 3] # right subtree depth 1 (right side of root) \\npre is:  [7] post is:  [4, 5, 2, 6, 7] #  right subtree depth 2 (right side of root)\\npre is:  [6] post is:  [4, 5, 2, 6] # line 2 is called for left subtree of level 2 (right side of root)\\npre is:  [2, 4, 5] post is:  [4, 5, 2] # line 2 is called for level one left subtree (left side of root)\\npre is:  [5] post is:  [4, 5] # line 1 is called for right subtree of level 2 (left side of root)\\npre is:  [4] post is:  [4] # line 2 is called for left subtree of level 2 (left side of root)\\n```\\n\\nThe `pre` and `post` here show each of the traversals once `helper` is called. For example, at first row, initial `pre` and `post` are shown. Next row, is when `helper` is called in line `#1`. Now, we have a new `pre` and `post`. The `pre` is the one that gets splited in each calling of `helper` while `post` pops its last element every time `helper` is called. As you can see, `post` looses one element at a time. \\n\\nI hope it\\'s clear. Let me know if there is any ambiquity anywhere. \\n\\n========================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix them. \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # read this: https://www.techiedelight.com/construct-full-binary-tree-from-preorder-postorder-sequence/\\n        def helper(pre,post):\\n            print(\\'pre is: \\', pre, \\'post is: \\', post)\\n            if not pre:\\n                return None\\n        \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n        \\n        \\n            node=TreeNode(post.pop()) #3\\n            ind=pre.index(post[-1]) #4\\n        \\n            node.right=helper(pre[ind:],post) #1\\n            node.left=helper(pre[1:ind],post) #2\\n            return node\\n    \\n        return helper(pre,post)\\n```\n```\\npre is:  [1, 2, 4, 5, 3, 6, 7] post is:  [4, 5, 2, 6, 7, 3, 1] # initial\\npre is:  [3, 6, 7] post is:  [4, 5, 2, 6, 7, 3] # right subtree depth 1 (right side of root) \\npre is:  [7] post is:  [4, 5, 2, 6, 7] #  right subtree depth 2 (right side of root)\\npre is:  [6] post is:  [4, 5, 2, 6] # line 2 is called for left subtree of level 2 (right side of root)\\npre is:  [2, 4, 5] post is:  [4, 5, 2] # line 2 is called for level one left subtree (left side of root)\\npre is:  [5] post is:  [4, 5] # line 1 is called for right subtree of level 2 (left side of root)\\npre is:  [4] post is:  [4] # line 2 is called for left subtree of level 2 (left side of root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161651,
                "title": "easy-python-recursive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if not pre or not post: return None\\n        root = TreeNode(pre[0])\\n        if len(post) == 1: return root\\n        idx = pre.index(post[-2])\\n        root.left = self.constructFromPrePost(pre[1: idx], post[:(idx - 1)])\\n        root.right = self.constructFromPrePost(pre[idx: ], post[(idx - 1):-1])\\n        return root\\n```\\n\\nThe first element in \"pre\" and the last element in \"post\" should both be the value of the root. The second to last of \"post\" should be the value of right child of the root. So we can find the index to split \"left\" and \"right\" children in \"pre\". Don\\'t forget to evaluate if the length of \"post\" is larger than 1, since we used post[-2]. ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if not pre or not post: return None\\n        root = TreeNode(pre[0])\\n        if len(post) == 1: return root\\n        idx = pre.index(post[-2])\\n        root.left = self.constructFromPrePost(pre[1: idx], post[:(idx - 1)])\\n        root.right = self.constructFromPrePost(pre[idx: ], post[(idx - 1):-1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161281,
                "title": "clean-java-o-n",
                "content": "The key point is 1: preprocessing. 2: Find the correct index\\n\\n\\tclass Solution {\\n    Map<Integer, Integer> postMap = new HashMap<>();\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int length = pre.length;\\n        for(int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return build(0, length - 1, 0, length - 1, pre, post);\\n    }\\n    \\n    private TreeNode build(int preLeft, int preRight, int postLeft, int postRight, int[] pre, int[] post) {\\n        if(preLeft > preRight || postLeft > postRight) {\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(pre[preLeft]);\\n        \\n        if(preLeft + 1 <= preRight) {\\n            int index = postMap.get(pre[preLeft + 1]);\\n            int sum = index - postLeft;\\n            root.left = build(preLeft + 1, preLeft + sum + 1, postLeft, postLeft + sum, pre, post);\\n            root.right = build(preLeft + sum + 2, preRight, postLeft + sum + 1, postRight - 1, pre, post);\\n        }\\n\\n        return root;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, Integer> postMap = new HashMap<>();\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int length = pre.length;\\n        for(int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 821268,
                "title": "c-construct-tree-using-preorder-traversal-first",
                "content": "August 30, 2020\\n889. Construct Binary Tree from Preorder and Postorder Traversal\\n**Introduction**\\nI like to learn all ideas to solve this tree algorithm. I came cross this idea from the discussion post [here](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161268/C%2B%2BJavaPython-One-Pass-Real-O(N)).\\n\\nThe idea is to construct binary tree using preorder traversal list, so it is easy to figure out the order of nodes in preorder list is from root node to left child until last one without left child. And then it is time to set up a node as a right child. \\n\\n**Case study**\\nI like to draw the diagram to explain how to solve this question using given example in the problem statement. \\nInput: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\\nOutput: [1,2,3,4,5,6,7]\\n\\nI debugged the code and then figured out the idea. It is to construct binary tree using preorder list first, starting from root node, and then go left continuously until it is the node without left child. Actually it is the first node in postorder traveral. \\n\\nUsing the example, root node 1 -> left child - node 2 -> left child - node 4, argue that it is the node without left child, since value is the first node in postorder traversal, marking using a in the following diagram. Preorder traversal list is iterated from a to b to c, the third node is with value 4. Now need to increment postorder traversal list\\'s index. \\n\\n![image](https://assets.leetcode.com/users/images/31024d89-5b18-4b4b-9f96-a21c4c0e22c6_1598857372.1623378.png)\\n\\nOne important task is to argue that when pre[preIndex] == post[postIndex], for example, preIndex = 2, node with value 4 is leaf node, in other words, skip steps to add left and right child. \\n\\nI think that the idea is hard to figure out and I will come back later to see if I can learn better next time. \\nFollow up on August 31, 2020\\nThe first time the condition is true: pre[preIndex] == post[postIndex], \\nNo. 1, preIndex = 2, postIndex = 0, value is 4, so depth first search break out:\\n root.left  = runPreorder(pre, post);   \\n No. 2, preIndex = 3, postIndex = 1, value is 5, so depth first search break out:\\n root.right = runPreorder(pre, post).\\n \\n**Design concern**\\nI do think that it is easy to figure out that each time a node is visited in preorder list, the node is added to the binary tree, preIndex variable is incremented by one. And if pre[preIndex] == post[postIndex], then skip to add left or right child, increment postIndex by one. \\nAs long as preIndex and postIndex both have places to increment one, the design is completed. Do not overthink. \\n\\n**Follow up**\\n**Another case study**\\nBased on the previous test case binary tree, if node with value 5 and node with value 6 are removed, then there are two solutions.\\nInput: pre = [1,2,4,3,7], post = [4,2,7,3,1]\\nOutput: [1,2,3,4,7]\\nThere are two solutions I can come out so far. \\nFour solutions:\\noutput 1: [1, 2, 3, 4, null, null, 7]\\noutput 2: [1, 2, 3, 4, null, 7, null]\\n\\n![image](https://assets.leetcode.com/users/images/4fd7cbb8-b0cf-490a-b878-ab1d783f14ec_1599026142.568195.png)\\n\\nIn my approach, the solution given in my code is solution 2. Node with value 7 is the left child of node 3. \\n\\nSolution 2 is to assume that node with value 7 is the first node in left subtree; actually  there is another case, missing left subtree, value 7 is the first node in right subtree instead. \\n\\n\\n\\n**Time complexity**\\nIt should be O(N). \\n\\n**Advice**\\nTake some time to read this paper about the algorithm. [Here](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.8845&rep=rep1&type=pdf) is the link. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace preorder_post_order\\n{\\n    public class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n        public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n          this.val = val;\\n          this.left = left;\\n          this.right = right;\\n      }\\n    }\\n\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var node1 = new TreeNode(1);\\n            var node2 = new TreeNode(2);\\n            var node3 = new TreeNode(3);\\n            var node4 = new TreeNode(4);\\n            var node5 = new TreeNode(5);\\n            var node6 = new TreeNode(6);\\n            var node7 = new TreeNode(7);\\n\\n            node1.left = node2;\\n            node1.right = node3;\\n            node2.left = node4;\\n            node2.right = node5;\\n            node3.left = node6;\\n            node3.right = node7;\\n\\n            var root = ConstructFromPrePost(\\n                new int[]{1,2,4,5,3,6,7}, \\n                new int[]{4,5,2,6,7,3,1});\\n        }\\n\\n        public static int preIndex = 0;\\n        public static int postIndex = 0;\\n        public static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {            \\n\\t\\t    preIndex = 0;\\n\\t\\t\\tpostIndex = 0;\\n            return runPreorder(pre, post);\\n        }\\n\\n        /// <summary>\\n        /// August 30, 2020\\n        /// Recursive function desgin: \\n        /// </summary>\\n        /// <param name=\"pre\"></param>\\n        /// <param name=\"post\"></param>\\n        /// <returns></returns>\\n        private static TreeNode runPreorder(int[] pre, int[] post)\\n        {\\n            var preLength = pre.Length;\\n            var postLength = post.Length;\\n\\n            if (pre == null || post == null || preIndex >= preLength || postIndex >= postLength)\\n                return null;\\n\\n            var rootVal = pre[preIndex];\\n\\n            var root = new TreeNode(pre[preIndex]);\\n            preIndex++;\\n\\n            if (rootVal != post[postIndex])\\n            {\\n                root.left    = runPreorder(pre, post);           \\n                root.right = runPreorder(pre, post);\\n            }\\n\\n            postIndex++;\\n\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace preorder_post_order\\n{\\n    public class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n        public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n          this.val = val;\\n          this.left = left;\\n          this.right = right;\\n      }\\n    }\\n\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var node1 = new TreeNode(1);\\n            var node2 = new TreeNode(2);\\n            var node3 = new TreeNode(3);\\n            var node4 = new TreeNode(4);\\n            var node5 = new TreeNode(5);\\n            var node6 = new TreeNode(6);\\n            var node7 = new TreeNode(7);\\n\\n            node1.left = node2;\\n            node1.right = node3;\\n            node2.left = node4;\\n            node2.right = node5;\\n            node3.left = node6;\\n            node3.right = node7;\\n\\n            var root = ConstructFromPrePost(\\n                new int[]{1,2,4,5,3,6,7}, \\n                new int[]{4,5,2,6,7,3,1});\\n        }\\n\\n        public static int preIndex = 0;\\n        public static int postIndex = 0;\\n        public static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {            \\n\\t\\t    preIndex = 0;\\n\\t\\t\\tpostIndex = 0;\\n            return runPreorder(pre, post);\\n        }\\n\\n        /// <summary>\\n        /// August 30, 2020\\n        /// Recursive function desgin: \\n        /// </summary>\\n        /// <param name=\"pre\"></param>\\n        /// <param name=\"post\"></param>\\n        /// <returns></returns>\\n        private static TreeNode runPreorder(int[] pre, int[] post)\\n        {\\n            var preLength = pre.Length;\\n            var postLength = post.Length;\\n\\n            if (pre == null || post == null || preIndex >= preLength || postIndex >= postLength)\\n                return null;\\n\\n            var rootVal = pre[preIndex];\\n\\n            var root = new TreeNode(pre[preIndex]);\\n            preIndex++;\\n\\n            if (rootVal != post[postIndex])\\n            {\\n                root.left    = runPreorder(pre, post);           \\n                root.right = runPreorder(pre, post);\\n            }\\n\\n            postIndex++;\\n\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249734,
                "title": "simple-java-recursion-with-explanation-o-n",
                "content": "Simple Algo steps we have to follow:-\\n1.preorder first element is the root, add that in TreeNode.\\n2.now find the next element from preorder, then its index from postorder map.\\n3.for left tree , elements will be from start upto the index of next element from postorder array\\n4.for right tree, elements will be from next index of the above element found upto end-1, because we already added root element into the tree, which is last in postorder array.\\n\\n```\\n int postpreindex=0;\\n public  TreeNode constructFromPrePost(int[] pre, int[] post) {\\n\\t\\t\\t \\n\\t\\t\\t HashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t        for(int i=0;i<post.length;i++) {\\n\\t\\t        \\tmap.put(post[i], i);\\n\\t\\t        }\\n\\t\\t       return helper(pre,post,map,0,post.length-1);\\n\\t\\t    }\\n\\n\\n\\tprivate  TreeNode helper(int[] preorder, int[] postorder,HashMap<Integer, Integer> map, int start, int end) {\\n\\t\\t\\tif(start>end) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode root=new TreeNode(preorder[postpreindex++]);\\n\\t\\t\\t\\n\\t\\t\\tif(start==end) {\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint index=map.get(preorder[postpreindex]);\\n\\t\\t\\t\\n\\t\\t\\troot.left=helper(preorder,postorder,map,start,index);\\n\\t\\t\\troot.right=helper(preorder,postorder,map,index+1,end-1);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n int postpreindex=0;\\n public  TreeNode constructFromPrePost(int[] pre, int[] post) {\\n\\t\\t\\t \\n\\t\\t\\t HashMap<Integer,Integer> map=new HashMap<>();\\n\\t\\t        for(int i=0;i<post.length;i++) {\\n\\t\\t        \\tmap.put(post[i], i);\\n\\t\\t        }\\n\\t\\t       return helper(pre,post,map,0,post.length-1);\\n\\t\\t    }\\n\\n\\n\\tprivate  TreeNode helper(int[] preorder, int[] postorder,HashMap<Integer, Integer> map, int start, int end) {\\n\\t\\t\\tif(start>end) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode root=new TreeNode(preorder[postpreindex++]);\\n\\t\\t\\t\\n\\t\\t\\tif(start==end) {\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint index=map.get(preorder[postpreindex]);\\n\\t\\t\\t\\n\\t\\t\\troot.left=helper(preorder,postorder,map,start,index);\\n\\t\\t\\troot.right=helper(preorder,postorder,map,index+1,end-1);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177793,
                "title": "python-easy-to-understand-recursion",
                "content": "The first value of \\'pre\\' and last value of \\'post\\' is \\'root\\'. Find the second value of \\'pre\\' in \\'post\\' as it is the left child of \\'root\\'. From here, we divide pre and post into left branch and right branch.\\n\\n```\\ndef constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre: return\\n        root = TreeNode(pre[0])\\n        pre, post = pre[1:], post[:-1]\\n        if not pre: return root\\n        i = post.index(pre[0])\\n        root.left = self.constructFromPrePost(pre[:i+1], post[:i+1])\\n        root.right = self.constructFromPrePost(pre[i+1:], post[i+1:])\\n        return root\\n",
                "solutionTags": [],
                "code": "The first value of \\'pre\\' and last value of \\'post\\' is \\'root\\'. Find the second value of \\'pre\\' in \\'post\\' as it is the left child of \\'root\\'. From here, we divide pre and post into left branch and right branch.\\n\\n```\\ndef constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre: return\\n        root = TreeNode(pre[0])\\n        pre, post = pre[1:], post[:-1]\\n        if not pre: return root\\n        i = post.index(pre[0])\\n        root.left = self.constructFromPrePost(pre[:i+1], post[:i+1])\\n        root.right = self.constructFromPrePost(pre[i+1:], post[i+1:])\\n        return root\\n",
                "codeTag": "Python3"
            },
            {
                "id": 163540,
                "title": "java-recursive-solution-beat-99-9",
                "content": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length-1, post, 0, post.length-1);\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int preL, int preR, int[] post, int postL, int postR) {\\n        if (preL > preR || postL > postR) return null;\\n        TreeNode root = new TreeNode(pre[preL]);\\n        if (preL == preR) return root;\\n        \\n        int index = -1;\\n        for (int i = postL ; i < postR ; i++) {\\n            if (pre[preL+1] == post[i]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if (index == -1) return root;\\n        \\n        root.left = constructFromPrePost(pre, preL+1, preL+1+(index-postL), post, postL, index);\\n        root.right = constructFromPrePost(pre, preL+1+(index-postL)+1, preR, post, index+1, postR);\\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return constructFromPrePost(pre, 0, pre.length-1, post, 0, post.length-1);\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int preL, int preR, int[] post, int postL, int postR) {\\n        if (preL > preR || postL > postR) return null;\\n        TreeNode root = new TreeNode(pre[preL]);\\n        if (preL == preR) return root;\\n        \\n        int index = -1;\\n        for (int i = postL ; i < postR ; i++) {\\n            if (pre[preL+1] == post[i]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n        if (index == -1) return root;\\n        \\n        root.left = constructFromPrePost(pre, preL+1, preL+1+(index-postL), post, postL, index);\\n        root.right = constructFromPrePost(pre, preL+1+(index-postL)+1, preR, post, index+1, postR);\\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688342,
                "title": "c-o-n-2-recursive",
                "content": "**\\nI saw many solutions here but none of them was as easily understandable as this one. \\nSee, we know its impossible to create a unique binary tree with just preorder and postorder. We can only construct full binary tree. Below are the simple steps to solve this problem: \\n1. First node in preorder is always the root node. We will create a node root with data = pre[preindex].\\n2. Now, how to find the left subtree nodes? See, the second element in preorder is the immediate left node of root.  And in postorder, this (second element of preorder) node is lying after all the elements of left subtree (as its POSTorder.). \\n3. So we will find the index of that node( say its index) in postorder and recursively build the tree. All the nodes  ( postorder[0] to postorder[index]{ including } ) will form the left subtree and the nodes { postorder[index+1] to postorder[end-1]) will contribute to the right subtree. We are not taking the last node of POSTorder as it is the root node and has already used.\\n4. Take care of the base conditions and you are good to go.\\n\\n**\\nclass Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>&pre,vector<int>&post,int &preindex,int start,int end)\\n    {\\n        if(start>end or preindex>=pre.size())\\n            return NULL;\\n        TreeNode* new_head = new TreeNode(pre[preindex++]);\\n        if(preindex==pre.size() or start==end)\\n            return new_head;\\n        int i;\\n        for(i=start;i<=end;i++)\\n        {\\n            if(pre[preindex]==post[i])\\n                break;\\n        }\\n        if(i<=end)\\n        {\\n            new_head->left = buildTree(pre,post,preindex,start,i);\\n            new_head->right = buildTree(pre,post,preindex,i+1,end-1);\\n        }\\n        return new_head;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int preindex = 0 ;\\n        return buildTree(pre,post,preindex,0,pre.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* buildTree(vector<int>&pre,vector<int>&post,int &preindex,int start,int end)\\n    {\\n        if(start>end or preindex>=pre.size())\\n            return NULL;\\n        TreeNode* new_head = new TreeNode(pre[preindex++]);\\n        if(preindex==pre.size() or start==end)\\n            return new_head;\\n        int i;\\n        for(i=start;i<=end;i++)\\n        {\\n            if(pre[preindex]==post[i])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1308753,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n     \\n        //map all the elements of postorder with their index\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<post.size();i++)\\n            mp[post[i]]=i;\\n        \\n        int preorderIndex=0;\\n        return buildTree(pre,mp,preorderIndex);\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& pre,unordered_map<int,int>& mp,int& preorderIndex)\\n    {\\n        int curr=pre[preorderIndex];\\n        TreeNode* n=new TreeNode(curr);\\n        preorderIndex++;\\n        if(preorderIndex<pre.size()  && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            //the next elemenet is present to the left of tree\\n            n->left=buildTree(pre,mp,preorderIndex);\\n        }\\n        else \\n            return n;\\n        if(preorderIndex < pre.size() && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            n->right=buildTree(pre,mp,preorderIndex);\\n        }\\n        return n;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you ;)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n     \\n        //map all the elements of postorder with their index\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<post.size();i++)\\n            mp[post[i]]=i;\\n        \\n        int preorderIndex=0;\\n        return buildTree(pre,mp,preorderIndex);\\n        \\n    }\\n    TreeNode* buildTree(vector<int>& pre,unordered_map<int,int>& mp,int& preorderIndex)\\n    {\\n        int curr=pre[preorderIndex];\\n        TreeNode* n=new TreeNode(curr);\\n        preorderIndex++;\\n        if(preorderIndex<pre.size()  && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            //the next elemenet is present to the left of tree\\n            n->left=buildTree(pre,mp,preorderIndex);\\n        }\\n        else \\n            return n;\\n        if(preorderIndex < pre.size() && mp[pre[preorderIndex]] < mp[curr])\\n        {\\n            n->right=buildTree(pre,mp,preorderIndex);\\n        }\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259055,
                "title": "python-combo-pack-3-questions",
                "content": "I think it\\'s instructive to consider three travelsal questions together.\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n**889. Construct Binary Tree from Preorder and Postorder Traversal**\\n\\nWe need 2 out of 3 travesal arrays (preorder, inorder, postorder) in order to uniquely reconstruct the binary tree. For all 3 cases consider a function `recur(preorder, inorder)` that reconstructs one node at a time. The structure is the same for all three problems: (i) Find the current node to split, (ii) Find left and right traversals, (iii) Create the node and find left and right subtrees via recursion.\\n\\n* **Preorder and Inorder Traversal:** The node we consider is `x = preorder[0]`. How do we split `preorder` and `inorder` when we go left and right? For both arrays, they can be splitted into two based on a single index as in both arrays all left elements appear before right elements. For `inorder` find `i` such that `inorder[i] = x` and split as `inorder[:i]` and `inorder[i+1:]`. On the other hand, for `preorder` the lengths should match `inorder` which means the only choice we have is the pair `preorder[1:i+1]` and `preorder[i+1:]`. This is so, because we have already used `preorder[0]`.\\n\\n* **Inorder and Postorder Traversal:** The node we consider is `x = postorder[-1]`. How do we split `postorder` and `inorder` when we go left and right? Once again, for both arrays, they can be splitted into two based on a single index as in both arrays all left elements appear before right elements. For `inorder` find `i` such that `inorder[i] = x` and split as `inorder[:i]` and `inorder[i+1:]`. On the other hand, for `postorder` the lengths should match `inorder` which means the only choice we have is the pair `postorder[:i]` and `preorder[i:]`.\\n\\n* **Preorder and Postorder Traversal:** This is the trickiest one! (The length should be at least two in both arrays to proceed.) Reverse `postorder` before you begin. The node we consider is `x = preorder[0]`. To find how many elements are to the left, find `i` such that `preorder[i] == postorder[1]`. Then the preorder is splitted as `preorder[1:i]` and `preorder[i:]`. Since postorder is flipped the left and right elements appear in reverse order, but they are given by `postorder[n-i+1:]` and `postorder[1:n-i+1]`.\\n\\n\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def recur(preorder, inorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            preorder_left, preorder_right = preorder[1:i+1], preorder[i+1:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, inorder_left)\\n            this.right = recur(preorder_right, inorder_right)\\n            return this\\n        \\n        return recur(preorder, inorder)\\n```\\n\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def recur(inorder, postorder):\\n            if not postorder: return None\\n            #current value\\n            x = postorder.pop()\\n\\t\\t\\t#split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            postorder_left, postorder_right = postorder[:i], postorder[i:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(inorder_left, postorder_left)\\n            this.right = recur(inorder_right, postorder_right)\\n            return this\\n        \\n        return recur(inorder, postorder)\\n```\\n\\n**889. Construct Binary Tree from Preorder and Postorder Traversal**\\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        def recur(preorder, postorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            preorder_left, preorder_right = [], []\\n            postorder_left, postorder_right = [], []\\n            if len(preorder) > 1:\\n                i, n = preorder.index(postorder[1]), len(preorder)\\n                preorder_left, preorder_right = preorder[1:i], preorder[i:]\\n                postorder_left, postorder_right = postorder[n-i+1:], postorder[1:n-i+1] \\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, postorder_left)\\n            this.right = recur(preorder_right, postorder_right)\\n            return this\\n        \\n        return recur(preorder, postorder[::-1])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def buildTree(self, preorder, inorder):\\n        def recur(preorder, inorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            preorder_left, preorder_right = preorder[1:i+1], preorder[i+1:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, inorder_left)\\n            this.right = recur(preorder_right, inorder_right)\\n            return this\\n        \\n        return recur(preorder, inorder)\\n```\n```python\\nclass Solution:\\n    def buildTree(self, inorder, postorder):\\n        def recur(inorder, postorder):\\n            if not postorder: return None\\n            #current value\\n            x = postorder.pop()\\n\\t\\t\\t#split\\n            i = inorder.index(x)\\n            inorder_left, inorder_right = inorder[:i], inorder[i+1:]\\n            postorder_left, postorder_right = postorder[:i], postorder[i:]\\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(inorder_left, postorder_left)\\n            this.right = recur(inorder_right, postorder_right)\\n            return this\\n        \\n        return recur(inorder, postorder)\\n```\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        def recur(preorder, postorder):\\n            if not preorder: return None\\n            #current value\\n            x = preorder[0]\\n            #split\\n            preorder_left, preorder_right = [], []\\n            postorder_left, postorder_right = [], []\\n            if len(preorder) > 1:\\n                i, n = preorder.index(postorder[1]), len(preorder)\\n                preorder_left, preorder_right = preorder[1:i], preorder[i:]\\n                postorder_left, postorder_right = postorder[n-i+1:], postorder[1:n-i+1] \\n            #create node\\n            this = TreeNode(x)\\n            this.left = recur(preorder_left, postorder_left)\\n            this.right = recur(preorder_right, postorder_right)\\n            return this\\n        \\n        return recur(preorder, postorder[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763804,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not pre:\\n            return None\\n        root = TreeNode(post.pop())\\n        if len(pre) == 1:\\n            return root\\n        rightIndex = pre.index(post[-1])\\n        root.right = self.constructFromPrePost(pre[rightIndex:], post)\\n        root.left = self.constructFromPrePost(pre[1:rightIndex], post)\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not pre:\\n            return None\\n        root = TreeNode(post.pop())\\n        if len(pre) == 1:\\n            return root\\n        rightIndex = pre.index(post[-1])\\n        root.right = self.constructFromPrePost(pre[rightIndex:], post)\\n        root.left = self.constructFromPrePost(pre[1:rightIndex], post)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161312,
                "title": "simple-java-using-stack-with-explanation",
                "content": "Lets see what we know;\\n1- We know that root always comes first in PreOrder but Last in Post Order. So, if we read PreOrder list from start, and check the position of the node in Post Order list, whatever nodes come before its index in PostOrder list is sub Node of this node (this node is the parent node for sure).\\n2- PreOrder always start from ROOT, then LEFT, and then RIGHT. So if the current node in PreOrder list has no left node, the next node in the list is its left node for sure (please refer to the *NOTE*), unless the next node index in PostOrder list is higher than the current node, since we know that in PostOrder we have LEFT,RIGHT, ROOT. So what ever node comes after the current node in our PreOrder list is a sub node of the current node as long as it\\'s index is smaller than the current node index in our PostOrder list. \\n*Note: We assume it is the left node, as it may have a right node which comes later. Since PreOrder is Root,Left,Right, and we start reading the list from 0 index, so we do not know whether the right node exists or not. What if it has a right node and we set the first sub node as its right node.* \\n```\\n public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n    \\tif(post==null || post.length==0 || pre==null || pre.length==0) return null;\\n    \\tint len = post.length;\\t\\n    \\tHashMap<Integer,Integer> index = new HashMap<>();\\n    \\tfor(int i=0; i<len; i++) index.put(post[i], i); //record the indexs\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tint i=0;\\n    \\tTreeNode root = new TreeNode(pre[i++]); //the first node in our PreOrder list is always the ROOT Node\\n    \\tstack.push(root);\\n    \\twhile(i<len){  //start reading the PreOrder list and check the indexs with PostOrder list\\n    \\t\\tTreeNode next = new TreeNode(pre[i]);    \\t\\t\\n    \\t\\twhile(index.get(stack.peek().val)<index.get(next.val)) stack.pop(); //we remove nodes with smaller index from stack as they cannot be the next nodes\\' parent\\n    \\t\\tTreeNode existing = stack.pop();    \\t\\t\\t\\n    \\t\\tif(existing.left==null) { //left always come first\\n    \\t\\t\\texisting.left=next;\\n    \\t\\t\\tstack.push(existing); stack.push(next); // we push the existing node again into the stack as it may have a right node\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\texisting.right=next;\\n    \\t\\t\\tstack.push(next); // we do not push the existing node anymore, as it\\'s left and right nodes already found\\n    \\t\\t}    \\t\\t    \\t\\t\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n    \\tif(post==null || post.length==0 || pre==null || pre.length==0) return null;\\n    \\tint len = post.length;\\t\\n    \\tHashMap<Integer,Integer> index = new HashMap<>();\\n    \\tfor(int i=0; i<len; i++) index.put(post[i], i); //record the indexs\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tint i=0;\\n    \\tTreeNode root = new TreeNode(pre[i++]); //the first node in our PreOrder list is always the ROOT Node\\n    \\tstack.push(root);\\n    \\twhile(i<len){  //start reading the PreOrder list and check the indexs with PostOrder list\\n    \\t\\tTreeNode next = new TreeNode(pre[i]);    \\t\\t\\n    \\t\\twhile(index.get(stack.peek().val)<index.get(next.val)) stack.pop(); //we remove nodes with smaller index from stack as they cannot be the next nodes\\' parent\\n    \\t\\tTreeNode existing = stack.pop();    \\t\\t\\t\\n    \\t\\tif(existing.left==null) { //left always come first\\n    \\t\\t\\texisting.left=next;\\n    \\t\\t\\tstack.push(existing); stack.push(next); // we push the existing node again into the stack as it may have a right node\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\texisting.right=next;\\n    \\t\\t\\tstack.push(next); // we do not push the existing node anymore, as it\\'s left and right nodes already found\\n    \\t\\t}    \\t\\t    \\t\\t\\n    \\t\\ti++;\\n    \\t}\\n    \\treturn root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369848,
                "title": "java-easy-approach-with-explanation-hashmap-postorder",
                "content": "```\\nclass Solution\\n{\\n    private HashMap<Integer, Integer> postorderMap= new HashMap<>();//data -- index\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) \\n    {\\n        for(int i= 0; i< postorder.length; i++)//putting the postorder value and index into the hash map to reduce the  access time of O(1)\\n            postorderMap.put(postorder[i], i);\\n        \\n        return constructBT(preorder, 0, preorder.length - 1, 0, postorder.length - 1);//creates the BST, and returns the new root\\n    }\\n    public TreeNode constructBT(int[] preorder, int preorderStart, int preorderEnd, int postorderStart, int postorderEnd) \\n    {//postorder travrersal is used because we want to first know about children first and then the parent  \\n        if(preorderStart > preorderEnd)//base case when we rech to wrong index, retuning null to tell the parent there is no node \\n            return null;\\n        \\n        int rootData= preorder[preorderStart];//new root, root is always present at the starting index of the preorder (Root Left Right)\\n \\n        if(preorderStart == preorderEnd)//when we reach to array size of 1, we return that node since no child is present after that node \\n            return new TreeNode(rootData, null, null);\\n        \\n        int  LeftrootIndex= postorderMap.get(preorder[preorderStart + 1]);//as we know that the postorder traverse first Left then Right and then root, so we are taking advantage of that we are getting the index of root next element in postorder(as it will be the upperbound for left subtree )\\n        \\n        int leftSubtreeSize= LeftrootIndex - postorderStart + 1;//w.r.t to root //including both the index //calculating the left subtree length to partion the array and contruct the tree recursively \\n            \\n        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the left subtree and knowing about the child \\n        TreeNode right= constructBT(preorder, preorderStart + leftSubtreeSize + 1, preorderEnd, LeftrootIndex + 1, preorderEnd - 1);        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the right subtree and knowing about the child \\n\\n        \\n        TreeNode node= new TreeNode(rootData, left, right);//after the full fledged information of left and right child constructing the node \\n        \\n        return node;//returning the node to maintain the backward limnk between newly created nodes \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    private HashMap<Integer, Integer> postorderMap= new HashMap<>();//data -- index\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) \\n    {\\n        for(int i= 0; i< postorder.length; i++)//putting the postorder value and index into the hash map to reduce the  access time of O(1)\\n            postorderMap.put(postorder[i], i);\\n        \\n        return constructBT(preorder, 0, preorder.length - 1, 0, postorder.length - 1);//creates the BST, and returns the new root\\n    }\\n    public TreeNode constructBT(int[] preorder, int preorderStart, int preorderEnd, int postorderStart, int postorderEnd) \\n    {//postorder travrersal is used because we want to first know about children first and then the parent  \\n        if(preorderStart > preorderEnd)//base case when we rech to wrong index, retuning null to tell the parent there is no node \\n            return null;\\n        \\n        int rootData= preorder[preorderStart];//new root, root is always present at the starting index of the preorder (Root Left Right)\\n \\n        if(preorderStart == preorderEnd)//when we reach to array size of 1, we return that node since no child is present after that node \\n            return new TreeNode(rootData, null, null);\\n        \\n        int  LeftrootIndex= postorderMap.get(preorder[preorderStart + 1]);//as we know that the postorder traverse first Left then Right and then root, so we are taking advantage of that we are getting the index of root next element in postorder(as it will be the upperbound for left subtree )\\n        \\n        int leftSubtreeSize= LeftrootIndex - postorderStart + 1;//w.r.t to root //including both the index //calculating the left subtree length to partion the array and contruct the tree recursively \\n            \\n        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the left subtree and knowing about the child \\n        TreeNode right= constructBT(preorder, preorderStart + leftSubtreeSize + 1, preorderEnd, LeftrootIndex + 1, preorderEnd - 1);        TreeNode left= constructBT(preorder, preorderStart+ 1, preorderStart + leftSubtreeSize, postorderStart, LeftrootIndex);//recursing down the right subtree and knowing about the child \\n\\n        \\n        TreeNode node= new TreeNode(rootData, left, right);//after the full fledged information of left and right child constructing the node \\n        \\n        return node;//returning the node to maintain the backward limnk between newly created nodes \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161287,
                "title": "recursive-c-o-n-log-n",
                "content": "The basic idea is to find the left subtree and the right subtree. \\n* The root node must be the first element of the pre sequence.\\n* The root node must be the last element of the post sequence.\\n* The left subtree and the right subtree must be consecutive in both of the sequences.\\n```\\npre: 1 | 2 4 5 | 3 6 7\\npost:  | 4 5 2 | 6 7 3 | 1\\n```\\n\\nStart scanning from pre[1] and post[0]. Once they contains the same set of numbers, we can truncate it to be two parts. One is the left subtree, another is the right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constuctFromRange(vector<int>& pre, vector<int>& post, int s1, int e1, int s2, int e2) {\\n        if (s1 > e1 || s2 > e2) return NULL;\\n        TreeNode *root = new TreeNode(pre[s1]);\\n        if (s1 == e1) return root;\\n        int m1 = s1 + 1, m2 = s2;\\n        int set1 = 0, set2 = 0;\\n        while (set1 == 0 || set1 != set2) {\\n            set1 = set1 | (1 << pre[m1++]);\\n            set2 = set2 | (1 << post[m2++]);\\n        }\\n        root->left = constuctFromRange(pre, post, s1 + 1, m1 - 1, s2, m2 - 1);\\n        root->right = constuctFromRange(pre, post, m1, e1, m2, e2);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return constuctFromRange(pre, post, 0, pre.size() - 1, 0, post.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npre: 1 | 2 4 5 | 3 6 7\\npost:  | 4 5 2 | 6 7 3 | 1\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constuctFromRange(vector<int>& pre, vector<int>& post, int s1, int e1, int s2, int e2) {\\n        if (s1 > e1 || s2 > e2) return NULL;\\n        TreeNode *root = new TreeNode(pre[s1]);\\n        if (s1 == e1) return root;\\n        int m1 = s1 + 1, m2 = s2;\\n        int set1 = 0, set2 = 0;\\n        while (set1 == 0 || set1 != set2) {\\n            set1 = set1 | (1 << pre[m1++]);\\n            set2 = set2 | (1 << post[m2++]);\\n        }\\n        root->left = constuctFromRange(pre, post, s1 + 1, m1 - 1, s2, m2 - 1);\\n        root->right = constuctFromRange(pre, post, m1, e1, m2, e2);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return constuctFromRange(pre, post, 0, pre.size() - 1, 0, post.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491853,
                "title": "c-clean-solution-for-beginners-recurse-on-left-and-right-subtree",
                "content": "The idea is:\\n- keep a `pre_start` index for the preorder array\\n- use the preorder array as root nodes\\n- everytime, find the left child, which is at `pre_start + 1` in preorder\\n- find the left child\\'s index in postorder\\n- split the nodes in the postorder into left and right subtree\\n- time is O( n )\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> val_to_idx;\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder, int pre_start, int post_start, int post_end){\\n        if(post_start > post_end) return NULL;\\n        if(post_start == post_end) return new TreeNode(preorder[pre_start]);\\n        \\n        int val = preorder[pre_start];\\n        int left_child = preorder[pre_start + 1];\\n        int left_child_idx = val_to_idx[left_child];\\n        int left_size = left_child_idx - post_start + 1;\\n        \\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(preorder, postorder, pre_start+1, post_start, left_child_idx);\\n        root->right = build(preorder, postorder, pre_start+left_size+1, left_child_idx+1, post_end-1);\\n        \\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i = 0; i < postorder.size(); i++){\\n            val_to_idx[postorder[i]] = i;\\n        }\\n        return build(preorder, postorder, 0, 0, preorder.size()-1);\\n    }\\n};\\n```\\n\\nHope it can help!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> val_to_idx;\\n    \\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder, int pre_start, int post_start, int post_end){\\n        if(post_start > post_end) return NULL;\\n        if(post_start == post_end) return new TreeNode(preorder[pre_start]);\\n        \\n        int val = preorder[pre_start];\\n        int left_child = preorder[pre_start + 1];\\n        int left_child_idx = val_to_idx[left_child];\\n        int left_size = left_child_idx - post_start + 1;\\n        \\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(preorder, postorder, pre_start+1, post_start, left_child_idx);\\n        root->right = build(preorder, postorder, pre_start+left_size+1, left_child_idx+1, post_end-1);\\n        \\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i = 0; i < postorder.size(); i++){\\n            val_to_idx[postorder[i]] = i;\\n        }\\n        return build(preorder, postorder, 0, 0, preorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431380,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int preidx=0,postidx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post)\\n    {\\n        TreeNode* root=new TreeNode(pre[preidx++]);\\n        if(root->val!=post[postidx])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postidx])\\n            root->right=constructFromPrePost(pre,post);\\n        postidx++;\\n        return root;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int preidx=0,postidx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post)\\n    {\\n        TreeNode* root=new TreeNode(pre[preidx++]);\\n        if(root->val!=post[postidx])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postidx])\\n            root->right=constructFromPrePost(pre,post);\\n        postidx++;\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2268607,
                "title": "c-easy-recursive-solution",
                "content": "\\uD83D\\uDD25 **Kindly Upvote, It is FREE From your side**\\n\\n\\uD83D\\uDE07 Observation:-\\nPreorder Traversal is:- Root Left and Right\\nPostOrder Traversal is:- Left Right Root.\\n\\nNow, we know the exact location of the Root that is the First element of the Preorder. But we donot know about the Left and Right Subtree after the root selection. For that We can select the first element of the left in preorder and can search in Postorder. So we\\'ll find the left and right subtree after that in the Postorder.\\n\\nMake sure you keep four pointers to tract start and end of pre and post order.\\n\\nRest, follow the code and dry run a case to know more about it.\\n\\n\\n\\n```\\n#define Tn TreeNode*\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int findElement(vc post, int element){\\n        return find(post.begin(), post.end(), element) - post.begin();\\n    }\\n    \\n    TreeNode* helper(vc &pre, vc &post, int preStart, int preEnd, int postStart, int postEnd){\\n        if(preStart > preEnd){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(pre[preStart]);\\n        \\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int index = findElement(post, pre[preStart+1]);\\n        int length = index-postStart+1;\\n        \\n        root->left = helper(pre, post, preStart+1, preStart+length, postStart, index);\\n        root->right = helper(pre, post, preStart+length+1, preEnd, index+1, postEnd-1);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define Tn TreeNode*\\n#define um unordered_map<int, int>\\n#define vc vector<int>\\n#define dvc vector<vector<int>>\\n#define ll long long int\\nclass Solution {\\nprivate:\\n    int findElement(vc post, int element){\\n        return find(post.begin(), post.end(), element) - post.begin();\\n    }\\n    \\n    TreeNode* helper(vc &pre, vc &post, int preStart, int preEnd, int postStart, int postEnd){\\n        if(preStart > preEnd){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(pre[preStart]);\\n        \\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int index = findElement(post, pre[preStart+1]);\\n        int length = index-postStart+1;\\n        \\n        root->left = helper(pre, post, preStart+1, preStart+length, postStart, index);\\n        root->right = helper(pre, post, preStart+length+1, preEnd, index+1, postEnd-1);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635468,
                "title": "c-beats-92-5-29-line-code-unordered-map-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int idx = 0;\\n\\n    TreeNode * dfs(vector<int>& preorder, int s, int e, vector<int>& postorder){\\n        if(s > e)\\n            return NULL;\\n        if(s == e)\\n            return new TreeNode(preorder[idx++]);\\n\\n        int pos = um[preorder[idx+1]];\\n\\n        TreeNode * root = new TreeNode(preorder[idx++]);\\n        root->left      = dfs(preorder, s, pos, postorder);\\n        root->right     = dfs(preorder, pos+1, e-1, postorder);\\n\\n        return root;\\n    }\\n\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\n        int pos = postorder.size();\\n        for(int i = 0; i<pos; i++)\\n            um[postorder[i]] = i;\\n\\n        return dfs(preorder, 0, pos-1, postorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> um;\\n    int idx = 0;\\n\\n    TreeNode * dfs(vector<int>& preorder, int s, int e, vector<int>& postorder){\\n        if(s > e)\\n            return NULL;\\n        if(s == e)\\n            return new TreeNode(preorder[idx++]);\\n\\n        int pos = um[preorder[idx+1]];\\n\\n        TreeNode * root = new TreeNode(preorder[idx++]);\\n        root->left      = dfs(preorder, s, pos, postorder);\\n        root->right     = dfs(preorder, pos+1, e-1, postorder);\\n\\n        return root;\\n    }\\n\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\n        int pos = postorder.size();\\n        for(int i = 0; i<pos; i++)\\n            um[postorder[i]] = i;\\n\\n        return dfs(preorder, 0, pos-1, postorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446650,
                "title": "python-easy-to-understand-solution",
                "content": "Solution has an extra step to make it easier to understand and implement - this can be optimized away.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        # Slice preorder and postorder to make math easier\\n        preorder = preorder[1:]\\n        posted = postorder[:-1]\\n        if preorder and postorder:\\n            left_start = preorder[0]\\n            left_end = postorder.index(preorder[0])\\n\\t\\t\\t# Left is everything up to and including left end\\n            root.left = self.constructFromPrePost(preorder[:left_end + 1], postorder[:left_end + 1])\\n\\t\\t\\t# Right is everything after left ends\\n            root.right = self.constructFromPrePost(preorder[left_end + 1:], postorder[left_end + 1:])\\n        return root\\n```\\n\\nOptimized:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        if len(preorder) > 1:\\n            left_start = preorder[1]\\n            left_end = postorder.index(preorder[1])\\n\\t\\t\\t# Note that the (extra) array slicing is gone in favor of more logical slicing\\n\\t\\t\\t# This could be optimized further to not slice at all if you\\'re particularly brave in an interview\\n            root.left = self.constructFromPrePost(preorder[1:left_end + 2], postorder[:left_end + 1])\\n            root.right = self.constructFromPrePost(preorder[left_end + 2:], postorder[left_end + 1:-1])\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        # Slice preorder and postorder to make math easier\\n        preorder = preorder[1:]\\n        posted = postorder[:-1]\\n        if preorder and postorder:\\n            left_start = preorder[0]\\n            left_end = postorder.index(preorder[0])\\n\\t\\t\\t# Left is everything up to and including left end\\n            root.left = self.constructFromPrePost(preorder[:left_end + 1], postorder[:left_end + 1])\\n\\t\\t\\t# Right is everything after left ends\\n            root.right = self.constructFromPrePost(preorder[left_end + 1:], postorder[left_end + 1:])\\n        return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        \\n        if len(preorder) > 1:\\n            left_start = preorder[1]\\n            left_end = postorder.index(preorder[1])\\n\\t\\t\\t# Note that the (extra) array slicing is gone in favor of more logical slicing\\n\\t\\t\\t# This could be optimized further to not slice at all if you\\'re particularly brave in an interview\\n            root.left = self.constructFromPrePost(preorder[1:left_end + 2], postorder[:left_end + 1])\\n            root.right = self.constructFromPrePost(preorder[left_end + 2:], postorder[left_end + 1:-1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733971,
                "title": "c-solution-4-lines-code-only",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(root->val != post[posIndex]) root->left = constructFromPrePost(pre,post);\\n        if(root->val != post[posIndex]) root->right = constructFromPrePost(pre,post);\\n        posIndex++;\\n        return root;\\n    }\\nprivate:\\n    int preIndex = 0, posIndex = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(root->val != post[posIndex]) root->left = constructFromPrePost(pre,post);\\n        if(root->val != post[posIndex]) root->right = constructFromPrePost(pre,post);\\n        posIndex++;\\n        return root;\\n    }\\nprivate:\\n    int preIndex = 0, posIndex = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161300,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            post.pop()\\n            if pre:\\n                if pre[0] == post[-1]:\\n                    root.left = self.constructFromPrePost(pre, post)\\n                else:\\n                    l, r = post.index(pre[0]), pre.index(post[-1])\\n                    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])\\n                    root.right = self.constructFromPrePost(pre[r:], post[l + 1:]) \\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre, post):\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            post.pop()\\n            if pre:\\n                if pre[0] == post[-1]:\\n                    root.left = self.constructFromPrePost(pre, post)\\n                else:\\n                    l, r = post.index(pre[0]), pre.index(post[-1])\\n                    root.left = self.constructFromPrePost(pre[:r], post[:l + 1])\\n                    root.right = self.constructFromPrePost(pre[r:], post[l + 1:]) \\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760443,
                "title": "javascript-clean-dfs",
                "content": "## Solution-1\\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    let i = 0;\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const node = pre[i++]\\n        const idx = arr.indexOf(pre[i]);\\n        const tree = new TreeNode(node);\\n        tree.left = callDFS(arr.slice(0, idx+1));\\n        tree.right = callDFS(arr.slice(idx+1, arr.indexOf(node)))\\n        return tree;\\n    }\\n    return callDFS(post)\\n};\\n```\\n\\n## Solution-2: Optimized Using Hash Map\\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    const map = {}; let i = 0;\\n    \\n    for(let i = 0; i < post.length; i++) {\\n        map[post[i]] = i;\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end || i >= pre.length) return null;\\n        const node = pre[i++], idx = map[pre[i]];\\n        const tree = new TreeNode(node);\\n        if(idx < start || idx > end) return tree;\\n        tree.left = callDFS(start, idx);\\n        tree.right = callDFS(idx+1, map[node]-1)\\n        return tree;\\n    }\\n    return callDFS(0, post.length-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    let i = 0;\\n    \\n    function callDFS(arr) {\\n        if(!arr.length) return null;\\n        const node = pre[i++]\\n        const idx = arr.indexOf(pre[i]);\\n        const tree = new TreeNode(node);\\n        tree.left = callDFS(arr.slice(0, idx+1));\\n        tree.right = callDFS(arr.slice(idx+1, arr.indexOf(node)))\\n        return tree;\\n    }\\n    return callDFS(post)\\n};\\n```\n```javascript\\nvar constructFromPrePost = function(pre, post) {\\n    const map = {}; let i = 0;\\n    \\n    for(let i = 0; i < post.length; i++) {\\n        map[post[i]] = i;\\n    }\\n    \\n    function callDFS(start, end) {\\n        if(start > end || i >= pre.length) return null;\\n        const node = pre[i++], idx = map[pre[i]];\\n        const tree = new TreeNode(node);\\n        if(idx < start || idx > end) return tree;\\n        tree.left = callDFS(start, idx);\\n        tree.right = callDFS(idx+1, map[node]-1)\\n        return tree;\\n    }\\n    return callDFS(0, post.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 416491,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nAs we can return any tree matching the given traversals, we can safely assume `pre[i+1]`, if exists, is always a left child of `pre[i]`.\\n\\nThe basic idea is to divide the `pre[i..j]` into three parts `[root] [left-subtree] [right-subtree]`. To defined these boundaries, we make use of the fact that in post-order traversal, everything before the root is under that root. So we need to find `pre[i+1]` in the `post` Why? `pre[i]` is root by defintion and by our assumtion `pre[i+1]` should be the last node in the post-order traversal for that subtree.\\n\\n**PS** Searching time can be reduced by reverse mapping using hashmap on `post`.\\n\\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return helper(pre, 0, pre.length-1, post, 0, pre.length-1);\\n    }\\n    private TreeNode helper(int[] pre, int i, int j, int[] post, int s, int e){\\n        if(i > j) return null;\\n        TreeNode curr = new TreeNode(pre[i]);\\n        if(i == j) return curr;\\n        int k=s;\\n        for(; k < e; k++)\\n            if(post[k] == pre[i+1])\\n                break;\\n        int len = k-s+1;\\n        curr.left = helper(pre, i+1, i+len, post, s, k);\\n        curr.right = helper(pre, i+len+1, j, post, k+1, e-1);\\n        return curr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return helper(pre, 0, pre.length-1, post, 0, pre.length-1);\\n    }\\n    private TreeNode helper(int[] pre, int i, int j, int[] post, int s, int e){\\n        if(i > j) return null;\\n        TreeNode curr = new TreeNode(pre[i]);\\n        if(i == j) return curr;\\n        int k=s;\\n        for(; k < e; k++)\\n            if(post[k] == pre[i+1])\\n                break;\\n        int len = k-s+1;\\n        curr.left = helper(pre, i+1, i+len, post, s, k);\\n        curr.right = helper(pre, i+len+1, j, post, k+1, e-1);\\n        return curr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256466,
                "title": "python-recursion-d-c",
                "content": "We can build to tree on recursively building the subtree. We just need to figure out what\\'s the slice of pre and post for subtree.\\n\\nFor example, we have tree as:\\n```\\n\\t 1\\n\\t/ \\\\\\n   2   3\\n  /\\\\   /\\\\\\n 4  5 6  7\\n```\\nSo, pre: [1,2,4,5,3,6,7] and post: [4,5,2,6,7,3,1]\\nRoot node always at the front in preorder while at the back in the post order. That\\'s quite obvious for root node 1.\\n\\nNow let\\'s check the left subtree, with a root node 2. We can use preorder to find left subtree\\'s root node\\'s location while use postorder to count left subtree\\'s nodes\\' number.\\nWe know left subtree roots at 2 as pre[1] (pre[0] is root node). So we can count left subtree\\'s node number as post.index(pre[0]) + 1 = 3 **since all nodes ahead of 2 in post order is within the subtree roots at 2.** (post[4,5,2]). And we mark leftcnt = post.index(pre[0]) + 1 and pass pre[1:lcnt+1], post[:lcnt] down to the left subtree construction. (pre->[2,4,5], post->[4,5,2], preorder and postorder preserve). And rest slice of pre and post[:-1] (post[-1] is root node) belongs to right subtree.\\n\\nWhen preorder list has only one element, it points to a leaf node. And there is no need to build subtree for it. We just return TreeNode(pre[0].val).\\n```\\ndef constructFromPrePost(pre, post):\\n\\tif not pre: return None\\n\\troot = TreeNode(pre[0])\\n\\tif len(pre) > 1:\\n\\t\\tlcnt = post.index(pre[1]) + 1\\n\\t\\troot.left = constructFromPrePost(pre[1:lcnt+1], post[:lcnt])\\n\\t\\troot.right = constructFromPrePost(pre[lcnt+1:], post[lcnt:-1])\\n\\treturn root\\n```",
                "solutionTags": [],
                "code": "```\\n\\t 1\\n\\t/ \\\\\\n   2   3\\n  /\\\\   /\\\\\\n 4  5 6  7\\n```\n```\\ndef constructFromPrePost(pre, post):\\n\\tif not pre: return None\\n\\troot = TreeNode(pre[0])\\n\\tif len(pre) > 1:\\n\\t\\tlcnt = post.index(pre[1]) + 1\\n\\t\\troot.left = constructFromPrePost(pre[1:lcnt+1], post[:lcnt])\\n\\t\\troot.right = constructFromPrePost(pre[lcnt+1:], post[lcnt:-1])\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 225230,
                "title": "clean-java-recursive-solution",
                "content": "\\n```\\nclass Solution {\\n    int preStart;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        preStart = 0;\\n        return helper(pre, post, 0, post.length - 1);\\n    }\\n    \\n    public TreeNode helper(int[] pre, int[] post, int postStart, int postEnd){\\n        if (postStart > postEnd) return null;\\n        \\n        int rootVal = post[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        preStart++;\\n        \\n        if (preStart == pre.length || postStart == postEnd){\\n            return root;\\n        }\\n        \\n        int leftVal = pre[preStart];\\n        int tmp = postStart;\\n        for(; tmp <= postEnd; tmp++){\\n            if (post[tmp] == leftVal){\\n                break;\\n            }\\n        }\\n        root.left = helper(pre, post, postStart, tmp);\\n        root.right = helper(pre, post, tmp + 1, postEnd - 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int preStart;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        preStart = 0;\\n        return helper(pre, post, 0, post.length - 1);\\n    }\\n    \\n    public TreeNode helper(int[] pre, int[] post, int postStart, int postEnd){\\n        if (postStart > postEnd) return null;\\n        \\n        int rootVal = post[postEnd];\\n        TreeNode root = new TreeNode(rootVal);\\n        preStart++;\\n        \\n        if (preStart == pre.length || postStart == postEnd){\\n            return root;\\n        }\\n        \\n        int leftVal = pre[preStart];\\n        int tmp = postStart;\\n        for(; tmp <= postEnd; tmp++){\\n            if (post[tmp] == leftVal){\\n                break;\\n            }\\n        }\\n        root.left = helper(pre, post, postStart, tmp);\\n        root.right = helper(pre, post, tmp + 1, postEnd - 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446533,
                "title": "c-easy-understanding-code-o-n-time-o-n-space",
                "content": "**(1)** First one thing we know that the first element of preorder is root of the tree :)\\n **(2)** Now we have to find the left subtree for this node \\n      Hint : the second element in preorder of that root node always be left node of root. This (second element of preorder) node is lying after all the elements of left subtree in postorder vector ( because of it\\'s arrangement in postorder)\\n**(3)** Now we have to find the right subtree for this node\\n     Hint : all the element of right side of the left element (which we use to make left subtree) in postorder make the right subtree.\\n\\t \\n-->> by recursion for each left and right subtree with boundry condition we can get our tree.\\n-->>The important thing is that we have to make boundry condition for the left subtree and right subtree which we simple make by finding the index of current element in postorder that\\'s why we use hashmap to store index of post order.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    TreeNode* build (vector<int>&pre,vector<int>&post,int &preidx ,int left,int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        TreeNode* temp=new TreeNode(pre[preidx]);\\n        if(left==right)\\n            return temp;\\n        \\n        preidx++;\\n        int i=mp[pre[preidx]];                                                      \\n        \\n        temp->left=build(pre,post,preidx,left,i);\\n        temp->right=build(pre,post,preidx,i+1,right-1);\\n        \\n        return temp;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(int i=0;i<post.size();i++)\\n        {\\n            mp[post[i]]=i;\\n        }\\n        int preidx=0;\\n        return build(pre,post,preidx,0,pre.size()-1);\\n    }\\n};\\n\\n//Feel free to ask any doubt in comment section;",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    TreeNode* build (vector<int>&pre,vector<int>&post,int &preidx ,int left,int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        TreeNode* temp=new TreeNode(pre[preidx]);\\n        if(left==right)\\n            return temp;\\n        \\n        preidx++;\\n        int i=mp[pre[preidx]];                                                      \\n        \\n        temp->left=build(pre,post,preidx,left,i);\\n        temp->right=build(pre,post,preidx,i+1,right-1);\\n        \\n        return temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1416245,
                "title": "easy-c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  TreeNode* construct(vector<int>& pre, vector<int>& post, int s1,int e1,int s2,int e2)\\n  {\\n    if(s1>e1 || s2>e2) return NULL;\\n    TreeNode* root=new TreeNode(pre[s1]);\\n    if(s1==e1) return root;\\n    \\n    int idx=s2;\\n    while(pre[s1+1]!=post[idx])\\n      idx++;\\n    \\n    int b=idx-s2+1;\\n\\n    root->left=construct(pre,post,s1+1,s1+b,s2,idx);\\n    root->right=construct(pre,post,s1+b+1,e1,idx+1,e2-1);\\n    \\n    return root;\\n    \\n  }\\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root= construct(preorder,postorder,0,preorder.size()-1,0,postorder.size()-1);\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  TreeNode* construct(vector<int>& pre, vector<int>& post, int s1,int e1,int s2,int e2)\\n  {\\n    if(s1>e1 || s2>e2) return NULL;\\n    TreeNode* root=new TreeNode(pre[s1]);\\n    if(s1==e1) return root;\\n    \\n    int idx=s2;\\n    while(pre[s1+1]!=post[idx])\\n      idx++;\\n    \\n    int b=idx-s2+1;\\n\\n    root->left=construct(pre,post,s1+1,s1+b,s2,idx);\\n    root->right=construct(pre,post,s1+b+1,e1,idx+1,e2-1);\\n    \\n    return root;\\n    \\n  }\\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root= construct(preorder,postorder,0,preorder.size()-1,0,postorder.size()-1);\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939552,
                "title": "full-explanation-best-o-n-solution-no-auxiliary-hash-no-index-search-recursive-python-3",
                "content": "Suggested solutions for this problem are non-optimal. They both use `index` (in the second case, a much worse version by the way). There is no need for that.\\n\\nMy solution iterates both lists forward only, using recursion to reconstruct the tree.\\n\\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        i, j = 0, 0\\n        def reconstruct():\\n            nonlocal i, j\\n            n = TreeNode(pre[i])\\n            i += 1\\n            if n.val != post[j]:\\n                n.left = reconstruct()\\n                if n.val != post[j]:\\n                    n.right = reconstruct()\\n            j += 1\\n            return n\\n\\n        return reconstruct()\\n```\\n\\nThe essential idea is that `pre` hold values in _descending_ order, and `post` holds _checkpoints_ that indicate when you need to _ascend_ in the reconstructed sub-tree.\\n\\nLet\\'s take for example this tree:\\n```\\n                    1\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t     2      3\\n\\t\\t\\t    /      /\\n\\t\\t       4      6\\n\\t\\t\\t  / \\\\     \\n\\t\\t     7   5     \\n\\npre=[1,2,4,7,5,3,6]\\npost=[7,5,4,2,6,3,1]\\n```\\t\\t\\t\\t   \\n\\nWe iterate `pre` and create descendant nodes (to the left in this case) until our current node value matches the current value of `post[j]` (`j==0` `post[j] == 7`). That\\'s our first _checkpoint_:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   /\\n\\t\\t     [7]\\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n      ^\\n```\\n\\nWe are now at node `7`, and `n.val == post[j]`, which means we reached the end of that path and we need to _ascend_ to the parent node, incrementing `j` (now `j=1`, `post[j]==5`) before moving up\\n\\nWe just went back to the parent node `4`, and we need to compare again `post` with `n.val`. They don\\'t match, which means this node still have descendants. Since we have already have a `left` child for node `4`, we need to assign this new node to the right subtree.\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   /\\n\\t\\t      7 \\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\\n\\nNow we are assigning `5` to the right subtree of node `4`.\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7  [5]\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\\n\\nThe algorithm is recursive, and logic is the same: `n.val == post[j]`, which means we have no more descendants. Then we advance `j` and return to the parent.\\n\\nWe are back to node 4. Notice how `post[j]` matches with the current node in our stack. It is important to realize we are walking back the stack, so the _\"current node in the stack\"_ is not the same thing as our _\"current position in the `pre` list\"_:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n          ^\\n```\\n\\nThat is not a coincidence. This is because our node has both left and right children, and the post-order traversal matches needs to match the current node. We don\\'t even need to check for that in this case. We can just advance `j` again and go up one level in the stack:\\n\\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t [2]\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n            ^\\n```\\n\\nIntersting. Our current node matches `post[j]` in this case. That means it has no right child. If it had a right subtree, these numbers wouldn\\'t match (that what has happened to node `4` after processing `7`, right before processing `5`... take a look above).\\nNow that we know node `2` has no right subtree, we just increment `j` and move back to its parent.\\n\\nThe rest of the algorithm is the same (it is recursive :-) ). We will go back to node `1`, realize `post[j]` doesn\\'t match current node value, reconstruct the right subtree for nodes `3` and `6`. Then we start ascending from `6` -> `3` -> `1`\\n\\nIn the final step, we are back to root node `1` and `post[j] == 1` (which is the last index). So we just return the root node. Task is done.\\n\\n---\\n\\nAlso made a version using iterators. Unfortunatelly iterators don\\'t have a `peek` method, (`more_itertools.peekable` would be perfect) so we need to keep a variable with this state.\\n\\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        pre = map(TreeNode, pre)\\n\\t\\tpost = iter(post)\\n        peek = next(post)\\n\\n        def reconstruct():\\n            nonlocal peek\\n            n = next(pre)\\n            if n.val != peek:\\n                n.left = reconstruct()\\n                if n.val != peek:\\n                    n.right = reconstruct()\\n            peek = next(post, None)\\n            return n\\n\\n        return reconstruct()\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        i, j = 0, 0\\n        def reconstruct():\\n            nonlocal i, j\\n            n = TreeNode(pre[i])\\n            i += 1\\n            if n.val != post[j]:\\n                n.left = reconstruct()\\n                if n.val != post[j]:\\n                    n.right = reconstruct()\\n            j += 1\\n            return n\\n\\n        return reconstruct()\\n```\n```\\n                    1\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t     2      3\\n\\t\\t\\t    /      /\\n\\t\\t       4      6\\n\\t\\t\\t  / \\\\     \\n\\t\\t     7   5     \\n\\npre=[1,2,4,7,5,3,6]\\npost=[7,5,4,2,6,3,1]\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   /\\n\\t\\t     [7]\\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n      ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   /\\n\\t\\t      7 \\n\\npre=[1,2,4,7,5,3,6]\\n           ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7  [5]\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n        ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t  2\\n\\t\\t\\t     /\\n\\t\\t       [4]\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n          ^\\n```\n```\\n                    1\\n\\t\\t\\t\\t   /\\n\\t\\t\\t\\t [2]\\n\\t\\t\\t     /\\n\\t\\t        4\\n\\t\\t\\t   / \\\\\\n\\t\\t      7   5\\n\\npre=[1,2,4,7,5,3,6]\\n             ^\\npost=[7,5,4,2,6,3,1]\\n            ^\\n```\n```python\\nclass Solution:\\n\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        pre = map(TreeNode, pre)\\n\\t\\tpost = iter(post)\\n        peek = next(post)\\n\\n        def reconstruct():\\n            nonlocal peek\\n            n = next(pre)\\n            if n.val != peek:\\n                n.left = reconstruct()\\n                if n.val != peek:\\n                    n.right = reconstruct()\\n            peek = next(post, None)\\n            return n\\n\\n        return reconstruct()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535343,
                "title": "java-recursion-and-iterative",
                "content": "```\\n    int i = 0, j = 0;\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        TreeNode node = new TreeNode(pre[i++]);\\n        if (node.val != post[j]) {\\n            node.left = constructFromPrePost(pre, post);\\n        }\\n        if (node.val != post[j]) {\\n            node.right = constructFromPrePost(pre, post);\\n        }\\n        j++;\\n        return node;\\n    }\\n```\\n\\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; i++){\\n            TreeNode node = new TreeNode(pre[i]);\\n            while(s.getLast().val == post[j]) {\\n                s.pollLast();\\n                j++;  // \\n            }\\n            if (s.getLast().left == null) {\\n                s.getLast().left = node;\\n            } else {\\n                s.getLast().right = node;\\n            }\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```\\nRef: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161268/C%2B%2BJavaPython-One-Pass-Real-O(N)",
                "solutionTags": [],
                "code": "```\\n    int i = 0, j = 0;\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        TreeNode node = new TreeNode(pre[i++]);\\n        if (node.val != post[j]) {\\n            node.left = constructFromPrePost(pre, post);\\n        }\\n        if (node.val != post[j]) {\\n            node.right = constructFromPrePost(pre, post);\\n        }\\n        j++;\\n        return node;\\n    }\\n```\n```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Deque<TreeNode> s = new ArrayDeque<>();\\n        s.offer(new TreeNode(pre[0]));\\n        for (int i = 1, j = 0; i < pre.length; i++){\\n            TreeNode node = new TreeNode(pre[i]);\\n            while(s.getLast().val == post[j]) {\\n                s.pollLast();\\n                j++;  // \\n            }\\n            if (s.getLast().left == null) {\\n                s.getLast().left = node;\\n            } else {\\n                s.getLast().right = node;\\n            }\\n            s.offer(node);\\n        }\\n        return s.getFirst();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 357699,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    int pre[];\\n    int post[];\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        this.pre = pre;\\n        this.post = post;\\n        return helper(0, pre.length-1, 0, post.length-1);\\n    }\\n    \\n    public TreeNode helper(int pre_start, int pre_end, int post_start, int post_end){\\n        if (post_start > post_end){\\n            return null;\\n        }\\n        \\n        int cur = pre[pre_start];\\n        TreeNode root = new TreeNode(cur);\\n        if (pre_start == pre_end){\\n            return root;\\n        }\\n        int left = pre[pre_start+1];\\n        int index = 0;\\n        for(int i = post_start; i<=post_end; i++){\\n            if (post[i]==left){\\n                index = i;\\n            }\\n        }\\n        root.left = helper(pre_start+1, pre_start+index-post_start+1, post_start, index);\\n        root.right = helper(pre_start+index-post_start+2, pre_end, index+1, post_end-1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int pre[];\\n    int post[];\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        this.pre = pre;\\n        this.post = post;\\n        return helper(0, pre.length-1, 0, post.length-1);\\n    }\\n    \\n    public TreeNode helper(int pre_start, int pre_end, int post_start, int post_end){\\n        if (post_start > post_end){\\n            return null;\\n        }\\n        \\n        int cur = pre[pre_start];\\n        TreeNode root = new TreeNode(cur);\\n        if (pre_start == pre_end){\\n            return root;\\n        }\\n        int left = pre[pre_start+1];\\n        int index = 0;\\n        for(int i = post_start; i<=post_end; i++){\\n            if (post[i]==left){\\n                index = i;\\n            }\\n        }\\n        root.left = helper(pre_start+1, pre_start+index-post_start+1, post_start, index);\\n        root.right = helper(pre_start+index-post_start+2, pre_end, index+1, post_end-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161379,
                "title": "recursive-easy-to-understand-with-explanation-c",
                "content": "The idea here is that you find preLeft, preRight and postLeft, postRight in every iteration and use preLeft as your root. \\nUse post to get the length of the left subtree, and then use that to recurse. \\n\\nNote that using preorder and postorder we can only find a tree w/o ambiguity if the tree is a full binary tree. The question says that its guaranteed to have an answer.\\n\\n```\\npublic class Solution {\\n\\n    public TreeNode ConstructFromPrePost(int[] pre, int[] post) {\\n        \\n\\t\\treturn ConstructTreeUtil(pre, post, 0, pre.Length-1,  0, post.Length-1);\\n    }\\n\\t\\n\\tprivate TreeNode ConstructTreeUtil(int[] pre, int[] post, int preLeft, int preRight, int postLeft, int postRight)\\n\\t{\\n\\t\\tif(preLeft > preRight || postLeft > postRight)\\t\\treturn null;\\n\\t\\t\\n\\t\\tvar root = new TreeNode(pre[preLeft]);\\n\\n\\t\\tif(preLeft < preRight)\\n\\t\\t{\\n\\t\\t\\tvar leftRootIndexinPost = Array.IndexOf(post, pre[preLeft+1]);\\t\\t\\t// Use this to split;\\n\\t\\t\\tvar len \\t    = leftRootIndexinPost - postLeft;\\n\\t\\n\\t\\t\\troot.left  = ConstructTreeUtil(pre, post, preLeft+1, preLeft+1+len, postLeft, postLeft+len);\\n\\t\\t\\troot.right = ConstructTreeUtil(pre, post, preLeft+len+2, preRight, postLeft+len+1, postRight-1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn root;\\n\\t}\\n}\\n```\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public TreeNode ConstructFromPrePost(int[] pre, int[] post) {\\n        \\n\\t\\treturn ConstructTreeUtil(pre, post, 0, pre.Length-1,  0, post.Length-1);\\n    }\\n\\t\\n\\tprivate TreeNode ConstructTreeUtil(int[] pre, int[] post, int preLeft, int preRight, int postLeft, int postRight)\\n\\t{\\n\\t\\tif(preLeft > preRight || postLeft > postRight)\\t\\treturn null;\\n\\t\\t\\n\\t\\tvar root = new TreeNode(pre[preLeft]);\\n\\n\\t\\tif(preLeft < preRight)\\n\\t\\t{\\n\\t\\t\\tvar leftRootIndexinPost = Array.IndexOf(post, pre[preLeft+1]);\\t\\t\\t// Use this to split;\\n\\t\\t\\tvar len \\t    = leftRootIndexinPost - postLeft;\\n\\t\\n\\t\\t\\troot.left  = ConstructTreeUtil(pre, post, preLeft+1, preLeft+1+len, postLeft, postLeft+len);\\n\\t\\t\\troot.right = ConstructTreeUtil(pre, post, preLeft+len+2, preRight, postLeft+len+1, postRight-1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn root;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963421,
                "title": "best-c-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& post, int start, int end, int element){\\n        for(int i = start; i <= end; i++){\\n            if(post[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int preIndex = 0;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post, int start, int end){\\n        // base case\\n        if(start > end || preIndex >= pre.size())\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(preIndex >= pre.size() || start == end)\\n            return root;\\n        int pos = search(post, start, end, pre[preIndex]);\\n        \\n        root->left = solve(pre, post, start, pos);\\n        root->right = solve(pre, post, pos + 1, end - 1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        return solve(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& post, int start, int end, int element){\\n        for(int i = start; i <= end; i++){\\n            if(post[i] == element)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    \\n    int preIndex = 0;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post, int start, int end){\\n        // base case\\n        if(start > end || preIndex >= pre.size())\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[preIndex++]);\\n        if(preIndex >= pre.size() || start == end)\\n            return root;\\n        int pos = search(post, start, end, pre[preIndex]);\\n        \\n        root->left = solve(pre, post, start, pos);\\n        root->right = solve(pre, post, pos + 1, end - 1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        return solve(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066956,
                "title": "simple-approach-o-n-time-preorder-traversal",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pre_idx=0,post_idx=0;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[pre_idx++]);\\n        if(root->val!=postorder[post_idx]){\\n            root->left=constructFromPrePost(preorder,postorder);\\n        }\\n        if(root->val!=postorder[post_idx]){\\n            root->right=constructFromPrePost(preorder,postorder);\\n        }\\n\\n        post_idx++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pre_idx=0,post_idx=0;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[pre_idx++]);\\n        if(root->val!=postorder[post_idx]){\\n            root->left=constructFromPrePost(preorder,postorder);\\n        }\\n        if(root->val!=postorder[post_idx]){\\n            root->right=constructFromPrePost(preorder,postorder);\\n        }\\n\\n        post_idx++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351831,
                "title": "java-explanation-no-hashmap-easy-to-implement",
                "content": "**Intuition**\\n\\nThere are two keys in this problem:\\n\\n(1) First element of preorder is **root**.\\n(2) The **first element of left-subtree** of **preorder[ ]** is the **last element of left-subtree**. It\\'s because the order difference between preorder traversal and postorder traversal. \\nFor example, we have `preorder = [1,2,4,5,3,6,7]` and `postorder = [4,5,2,6,7,3,1]`.\\nNow, we know `1` is **root** and `2` is **first element of left-subtree**.\\n\\nQ. How do we figure out the **left-subtree** and **right-subtree** at this point?\\n\\nA. **Preorder** means we process the **root** -> **left** -> **right**, and because of preorder traversal we can identify the **root** node. **Postorder** process **left** -> **right** -> **root**. Therefore, `[2]` is the first node in left-subtree from **preorder**, and `[2]` is also the last node of left-subtree in **postorder**. \\nTherefore, `[4, 5, 2]` are all left-subtree elements.\\n\\n![image](https://assets.leetcode.com/users/images/585f2b5b-0541-4e92-b123-c95b89b02b13_1660051589.8914473.png)\\n\\n\\nLeave the questions below. I\\'ll try my best to answer the questions within **100 days**. \\n\\n```\\nclass Solution \\n{\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        // O(n) time | O(h) space\\n        if(preorder == null || postorder == null || preorder.length == 0 || postorder.length == 0)  return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        int mid = 0;\\n        \\n        if(preorder.length == 1)    return root;\\n        \\n        // update mid\\n        for(int i = 0; i < postorder.length; i++)\\n        {\\n            if(preorder[1] == postorder[i])\\n            {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        \\n        root.left = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1, 1 + mid + 1),\\n                                            Arrays.copyOfRange(postorder, 0, mid + 1));\\n        \\n        root.right = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1 + mid + 1, preorder.length),\\n                                            Arrays.copyOfRange(postorder, mid + 1, postorder.length - 1));\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        // O(n) time | O(h) space\\n        if(preorder == null || postorder == null || preorder.length == 0 || postorder.length == 0)  return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        int mid = 0;\\n        \\n        if(preorder.length == 1)    return root;\\n        \\n        // update mid\\n        for(int i = 0; i < postorder.length; i++)\\n        {\\n            if(preorder[1] == postorder[i])\\n            {\\n                mid = i;\\n                break;\\n            }\\n        }\\n        \\n        root.left = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1, 1 + mid + 1),\\n                                            Arrays.copyOfRange(postorder, 0, mid + 1));\\n        \\n        root.right = constructFromPrePost(\\n                                            Arrays.copyOfRange(preorder, 1 + mid + 1, preorder.length),\\n                                            Arrays.copyOfRange(postorder, mid + 1, postorder.length - 1));\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741226,
                "title": "c-easy-recursive-one-pass",
                "content": "```\\n#define null nullptr\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* help(vector<int>& pre, vector<int>& post,int start,int end){\\n        //BAse Case\\n        if(start>end) return null;\\n        if(i>=pre.size()) return null;\\n        int j =-1;\\n        for(int k = start;k<=end;k++)\\n            if(pre[i]==post[k]){\\n                j=k;\\n                break;\\n            }\\n        if(j==-1) return null;\\n        i++;\\n        TreeNode* root = new TreeNode(post[j]);\\n        TreeNode* l = help(pre,post,start,j-1);\\n        root->left=l;\\n        TreeNode* r = help(pre,post,start,j-1);\\n        root->right=r;\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return help(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n#define null nullptr\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* help(vector<int>& pre, vector<int>& post,int start,int end){\\n        //BAse Case\\n        if(start>end) return null;\\n        if(i>=pre.size()) return null;\\n        int j =-1;\\n        for(int k = start;k<=end;k++)\\n            if(pre[i]==post[k]){\\n                j=k;\\n                break;\\n            }\\n        if(j==-1) return null;\\n        i++;\\n        TreeNode* root = new TreeNode(post[j]);\\n        TreeNode* l = help(pre,post,start,j-1);\\n        root->left=l;\\n        TreeNode* r = help(pre,post,start,j-1);\\n        root->right=r;\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return help(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647023,
                "title": "concise-java-solution-with-explanation",
                "content": "**Explanation** - We know that first element in pre array is the root. We also know that second element in the pre array is the root of the left subtree. Now if we can find this second element in the post array then all elements before it and including it would belong to the left sub tree and all elements after it (excluding the last element which is the root) will be the elements in the right subtree. We can apply this logic recursively while processing each element in the pre array and build the tree. We use a hashmap for fast lookups in the post array.\\n```\\nclass Solution {\\n\\n    private Map<Integer,Integer> postMap = new HashMap<>();\\n    private int preIdx;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        IntStream.range(0, post.length).forEach(i -> postMap.put(post[i], i));\\n        return buildTree(0, post.length - 1, pre, post);\\n    }\\n    \\n    private TreeNode buildTree(int lo, int hi, int[] pre, int[] post) {\\n        if (preIdx == pre.length || lo > hi) return null;\\n        \\n        TreeNode root = new TreeNode(pre[preIdx++]);\\n        if (lo == hi) return root;\\n        \\n        int leftSubRootPostIdx = postMap.get(pre[preIdx]);\\n        \\n        root.left = buildTree(lo, leftSubRootPostIdx, pre, post);\\n        root.right = buildTree(leftSubRootPostIdx + 1, hi - 1, pre, post);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private Map<Integer,Integer> postMap = new HashMap<>();\\n    private int preIdx;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        IntStream.range(0, post.length).forEach(i -> postMap.put(post[i], i));\\n        return buildTree(0, post.length - 1, pre, post);\\n    }\\n    \\n    private TreeNode buildTree(int lo, int hi, int[] pre, int[] post) {\\n        if (preIdx == pre.length || lo > hi) return null;\\n        \\n        TreeNode root = new TreeNode(pre[preIdx++]);\\n        if (lo == hi) return root;\\n        \\n        int leftSubRootPostIdx = postMap.get(pre[preIdx]);\\n        \\n        root.left = buildTree(lo, leftSubRootPostIdx, pre, post);\\n        root.right = buildTree(leftSubRootPostIdx + 1, hi - 1, pre, post);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486725,
                "title": "c-o-n-solution-faster-than-92-c-submission-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n     int  preindx=0,postindx=0;\\n      TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n         \\n          TreeNode *root = new TreeNode(preorder[preindx++]);\\n          if(root->val!=postorder[postindx]){\\n              root->left=constructFromPrePost(preorder,postorder);\\n          }\\n          if(root->val!=postorder[postindx]){\\n              root->right=constructFromPrePost(preorder,postorder);\\n          }\\n            postindx++;\\n          return root;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int  preindx=0,postindx=0;\\n      TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n         \\n          TreeNode *root = new TreeNode(preorder[preindx++]);\\n          if(root->val!=postorder[postindx]){\\n              root->left=constructFromPrePost(preorder,postorder);\\n          }\\n          if(root->val!=postorder[postindx]){\\n              root->right=constructFromPrePost(preorder,postorder);\\n          }\\n            postindx++;\\n          return root;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467524,
                "title": "simple-c-solution-with-comments-recursive-map",
                "content": "\\tTreeNode* func(vector<int> &preorder, int prestart,int preend,vector<int> &postorder,int poststart,int postend, map<int,int> &postmap) {\\n        if(prestart>preend || poststart>postend) {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]); // Considering first element of preorder to be root of tree\\n        if(prestart+1<=preend) { \\n\\t\\t\\tint newroot=preorder[prestart+1];   // considering second element of preorder to be root of left subtree\\n\\t\\t\\tint postroot=postmap[newroot];\\n\\t\\t\\tint numsleft=postroot-poststart;\\n\\t\\t\\troot->left=func(preorder,prestart+1,prestart+numsleft+1,postorder,poststart,postroot,postmap); \\n\\t\\t\\troot->right=func(preorder,prestart+numsleft+2,preend,postorder,postroot+1,postend-1,postmap);\\n\\t\\t}\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        map<int,int> postmap;\\n        for(int i=0;i<postorder.size();i++) {\\n            postmap[postorder[i]]=i;\\n        }\\n        return func(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1,postmap);\\n    }",
                "solutionTags": [],
                "code": "\\tTreeNode* func(vector<int> &preorder, int prestart,int preend,vector<int> &postorder,int poststart,int postend, map<int,int> &postmap) {\\n        if(prestart>preend || poststart>postend) {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]); // Considering first element of preorder to be root of tree\\n        if(prestart+1<=preend) { \\n\\t\\t\\tint newroot=preorder[prestart+1];   // considering second element of preorder to be root of left subtree\\n\\t\\t\\tint postroot=postmap[newroot];\\n\\t\\t\\tint numsleft=postroot-poststart;\\n\\t\\t\\troot->left=func(preorder,prestart+1,prestart+numsleft+1,postorder,poststart,postroot,postmap); \\n\\t\\t\\troot->right=func(preorder,prestart+numsleft+2,preend,postorder,postroot+1,postend-1,postmap);\\n\\t\\t}\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        map<int,int> postmap;\\n        for(int i=0;i<postorder.size();i++) {\\n            postmap[postorder[i]]=i;\\n        }\\n        return func(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1,postmap);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1287488,
                "title": "java-recursive-solution",
                "content": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return preOrPost(pre,0,pre.length-1,post,0,pre.length-1);\\n    }\\n    \\n    public TreeNode preOrPost(int[] pre,int preStart,int preEnd,int[] post,int postStart,int postEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[preStart]);\\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int idx=postStart;\\n        while(post[idx]!=pre[preStart+1]){\\n            idx++;\\n        }\\n        \\n        int len=idx-postStart+1;\\n        root.left=preOrPost(pre,preStart+1,preStart+len,post,postStart,idx);\\n        root.right=preOrPost(pre,preStart+len+1,preEnd,post,idx+1,postEnd-1);\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return preOrPost(pre,0,pre.length-1,post,0,pre.length-1);\\n    }\\n    \\n    public TreeNode preOrPost(int[] pre,int preStart,int preEnd,int[] post,int postStart,int postEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[preStart]);\\n        if(preStart==preEnd){\\n            return root;\\n        }\\n        \\n        int idx=postStart;\\n        while(post[idx]!=pre[preStart+1]){\\n            idx++;\\n        }\\n        \\n        int len=idx-postStart+1;\\n        root.left=preOrPost(pre,preStart+1,preStart+len,post,postStart,idx);\\n        root.right=preOrPost(pre,preStart+len+1,preEnd,post,idx+1,postEnd-1);\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946726,
                "title": "python3-consistent-soln-for-105-106-and-889",
                "content": "**Background**\\nGiven a binary tree, there are 3 orders to traverse it: preorder, inorder and postorder, all of which are widely used in practice. Conversely, if a traversal result is provided, one cannot recreate the binary tree as differently structued binary trees could result in the same traversal. But if two traversals are given, then it is possible to build the tree, which is what 105, 106 and 889 on LC are about. \\n\\n[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)\\n[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\n[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\\n\\n**Iterative approach**\\nHere, we scan through one vector while using the other one to decide to go deeper on the tree or retrace to higher level. In this iterative approach we use a stack to store the nodes that we\\'ve visited and can potentially go back to. \\n\\n105 \\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n\\t\\troot = None\\n\\t    stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace \\n                node.right = node = TreeNode(x)\\n            stack.append(node)\\n        return root\\n```\\n\\n106 \\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n        root = None\\n        stack = []\\n        for x in reversed(postorder): \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] > mp[stack[-1].val]: stack[-1].right = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] > mp[x]: node = stack.pop() # retrace \\n                node.left = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\n889 \\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop() # retrace \\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n\\t\\troot = None\\n\\t    stack = []\\n        for x in preorder: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] < mp[x]: node = stack.pop() # retrace \\n                node.right = node = TreeNode(x)\\n            stack.append(node)\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(inorder)} # relative position \\n        root = None\\n        stack = []\\n        for x in reversed(postorder): \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] > mp[stack[-1].val]: stack[-1].right = node = TreeNode(x)\\n            else: \\n                while stack and mp[stack[-1].val] > mp[x]: node = stack.pop() # retrace \\n                node.left = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop() # retrace \\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 643903,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return construct(pre, 0, pre.size()-1, post, 0, post.size()-1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return construct(pre, 0, pre.size()-1, post, 0, post.size()-1);\\n    }\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617458,
                "title": "javascript-solution",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n  return prePostTreeBuilder(0, pre.length - 1, 0, post.length - 1);\\n  \\n  function prePostTreeBuilder(preStart, preEnd, postStart, postEnd) {\\n    if (preStart > preEnd) return null;\\n    \\n    const root = new TreeNode(pre[preStart]);\\n    if (preStart == preEnd) return root;\\n    \\n    const leftVal = pre[preStart + 1];\\n    let leftPostIndex;\\n    \\n    for (leftPostIndex = postStart; leftPostIndex <= postEnd; leftPostIndex++) {\\n      if (post[leftPostIndex] === leftVal) break;\\n    }\\n    \\n    const leftTreeSize = leftPostIndex - postStart;\\n    \\n    const preLeftStart = preStart + 1;\\n    const preLeftEnd = preLeftStart + leftTreeSize;\\n    const leftPostStart = postStart;\\n    const leftPostEnd = leftPostIndex;\\n    \\n    const preRightStart = preLeftEnd + 1;\\n    const preRightEnd = preEnd;\\n    const postRightStart = leftPostIndex + 1;\\n    const postRightEnd = postEnd - 1;\\n    \\n    root.left = prePostTreeBuilder(preLeftStart, preLeftEnd, leftPostStart, leftPostEnd);\\n    root.right = prePostTreeBuilder(preRightStart, preRightEnd, postRightStart, postRightEnd);\\n    \\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n  return prePostTreeBuilder(0, pre.length - 1, 0, post.length - 1);\\n  \\n  function prePostTreeBuilder(preStart, preEnd, postStart, postEnd) {\\n    if (preStart > preEnd) return null;\\n    \\n    const root = new TreeNode(pre[preStart]);\\n    if (preStart == preEnd) return root;\\n    \\n    const leftVal = pre[preStart + 1];\\n    let leftPostIndex;\\n    \\n    for (leftPostIndex = postStart; leftPostIndex <= postEnd; leftPostIndex++) {\\n      if (post[leftPostIndex] === leftVal) break;\\n    }\\n    \\n    const leftTreeSize = leftPostIndex - postStart;\\n    \\n    const preLeftStart = preStart + 1;\\n    const preLeftEnd = preLeftStart + leftTreeSize;\\n    const leftPostStart = postStart;\\n    const leftPostEnd = leftPostIndex;\\n    \\n    const preRightStart = preLeftEnd + 1;\\n    const preRightEnd = preEnd;\\n    const postRightStart = leftPostIndex + 1;\\n    const postRightEnd = postEnd - 1;\\n    \\n    root.left = prePostTreeBuilder(preLeftStart, preLeftEnd, leftPostStart, leftPostEnd);\\n    root.right = prePostTreeBuilder(preRightStart, preRightEnd, postRightStart, postRightEnd);\\n    \\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168714,
                "title": "java-recursive-time-o-n-space-o-n-solution",
                "content": "```java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (pre == null || pre.length == 0 || post == null || post.length == 0 || pre.length != post.length) {\\n            return null;\\n        }\\n        \\n        HashMap<Integer, Integer> postMap = new HashMap<>();\\n        \\n        for (int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return buildTreeHelper(pre, 0, pre.length - 1, post, 0, postMap);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] post, int postStart, HashMap<Integer, Integer> postMap) {\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[preStart]);\\n        \\n        if (preStart == preEnd) {\\n            return node;\\n        }\\n        \\n        int leftChildPostIndex = postMap.get(pre[preStart + 1]);\\n        int numLeft = leftChildPostIndex - postStart + 1;\\n        \\n        node.left = buildTreeHelper(pre, preStart + 1, preStart + numLeft, post, postStart, postMap);\\n        node.right = buildTreeHelper(pre, preStart + numLeft + 1, preEnd, post, leftChildPostIndex + 1, postMap);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (pre == null || pre.length == 0 || post == null || post.length == 0 || pre.length != post.length) {\\n            return null;\\n        }\\n        \\n        HashMap<Integer, Integer> postMap = new HashMap<>();\\n        \\n        for (int i = 0; i < post.length; i++) {\\n            postMap.put(post[i], i);\\n        }\\n        \\n        return buildTreeHelper(pre, 0, pre.length - 1, post, 0, postMap);\\n    }\\n    \\n    public TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] post, int postStart, HashMap<Integer, Integer> postMap) {\\n        if (preStart > preEnd) {\\n            return null;\\n        }\\n        \\n        TreeNode node = new TreeNode(pre[preStart]);\\n        \\n        if (preStart == preEnd) {\\n            return node;\\n        }\\n        \\n        int leftChildPostIndex = postMap.get(pre[preStart + 1]);\\n        int numLeft = leftChildPostIndex - postStart + 1;\\n        \\n        node.left = buildTreeHelper(pre, preStart + 1, preStart + numLeft, post, postStart, postMap);\\n        node.right = buildTreeHelper(pre, preStart + numLeft + 1, preEnd, post, leftChildPostIndex + 1, postMap);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165409,
                "title": "one-pass-o-n-recursive-solution-beats-100-c-submissions",
                "content": "I simply traverse both arrays and recursively create a new node for each new item in preorder array. I use postorder array to identify when to return from my recursive function, as if current node\\'s value equals to post[j] it means we\\'ve seen all its children already.\\n\\n**Complexity:**\\nO(N) Time O(N) Space\\n\\n**C#**\\n```\\n        public TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            return ConstructTree(pre, ref i, post, ref j);\\n        }\\n\\n        private TreeNode ConstructTree(int[] pre, ref int i, int[] post, ref int j)\\n        {\\n            TreeNode node = new TreeNode(pre[i++]);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.left = ConstructTree(pre, ref i, post, ref j);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.right = ConstructTree(pre, ref i, post, ref j);\\n            j++;\\n            return node;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            int i = 0;\\n            int j = 0;\\n            return ConstructTree(pre, ref i, post, ref j);\\n        }\\n\\n        private TreeNode ConstructTree(int[] pre, ref int i, int[] post, ref int j)\\n        {\\n            TreeNode node = new TreeNode(pre[i++]);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.left = ConstructTree(pre, ref i, post, ref j);\\n            if(node.val == post[j])\\n            {\\n                j++;\\n                return node;\\n            }\\n            node.right = ConstructTree(pre, ref i, post, ref j);\\n            j++;\\n            return node;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161282,
                "title": "javascript-solution-use-recursion",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length===0) return null;\\n    if(pre.length===1) return new TreeNode(pre[0]);\\n    let res = new TreeNode(pre[0]);\\n    let leftVal = pre[1], indexOfLeft = post.indexOf(leftVal);\\n    res.left = constructFromPrePost(pre.slice(1, indexOfLeft+2), post.slice(0,indexOfLeft+1));\\n    res.right = constructFromPrePost(pre.slice(indexOfLeft+2), post.slice(indexOfLeft+1));\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length===0) return null;\\n    if(pre.length===1) return new TreeNode(pre[0]);\\n    let res = new TreeNode(pre[0]);\\n    let leftVal = pre[1], indexOfLeft = post.indexOf(leftVal);\\n    res.left = constructFromPrePost(pre.slice(1, indexOfLeft+2), post.slice(0,indexOfLeft+1));\\n    res.right = constructFromPrePost(pre.slice(indexOfLeft+2), post.slice(indexOfLeft+1));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3305293,
                "title": "beats-100-java-solution-using-recursion-simple-and-clean-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) - recursion stack space\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode f(int[] pre, int[] post, int preS, int preE, int postS, int postE){\\n      if(postS>postE) return null;\\n      int rootVal=pre[preS];\\n      TreeNode root=new TreeNode(rootVal);\\n      if(preS==preE) return root;\\n      int p=postS;\\n      for(int i=postS; i<=postE-1; i++){\\n        if(pre[preS+1]==post[i]) {\\n          p=i;\\n          break;\\n        }\\n      }\\n\\n      int lPostS=postS;\\n      int lPostE=p;\\n      int rPostS=p+1;\\n      int rPostE=postE-1;\\n      int lPreS=preS+1;\\n      int lPreE=lPostE-lPostS+preS+1;\\n      int rPreS=lPreE+1;\\n      int rPreE=preE;\\n      root.left=f(pre, post, lPreS, lPreE, lPostS, lPostE);\\n      root.right=f(pre, post, rPreS, rPreE, rPostS, rPostE);\\n      return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n      return f(preorder, postorder, 0, preorder.length-1, 0, preorder.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode f(int[] pre, int[] post, int preS, int preE, int postS, int postE){\\n      if(postS>postE) return null;\\n      int rootVal=pre[preS];\\n      TreeNode root=new TreeNode(rootVal);\\n      if(preS==preE) return root;\\n      int p=postS;\\n      for(int i=postS; i<=postE-1; i++){\\n        if(pre[preS+1]==post[i]) {\\n          p=i;\\n          break;\\n        }\\n      }\\n\\n      int lPostS=postS;\\n      int lPostE=p;\\n      int rPostS=p+1;\\n      int rPostE=postE-1;\\n      int lPreS=preS+1;\\n      int lPreE=lPostE-lPostS+preS+1;\\n      int rPreS=lPreE+1;\\n      int rPreE=preE;\\n      root.left=f(pre, post, lPreS, lPreE, lPostS, lPostE);\\n      root.right=f(pre, post, rPreS, rPreE, rPostS, rPostE);\\n      return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n      return f(preorder, postorder, 0, preorder.length-1, 0, preorder.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814735,
                "title": "c-simple-solution-using-divide-and-conquer",
                "content": "Idea: - \\n1. Create the node from preorder array starting from index 0\\n2. Then search next elment of preorder array in the postorder\\n3. Now the elment present in postorder left to that element(including) is part of left subtree of node and element present on the right side of that element in postorder before the node val is part of right subtree of node\\n\\nFor ex: - Pre [ ] = [1 2 3 4 5 6 7 8] post[ ] = [3 5 4 2 7 8 6 1]  \\n                                             \\n\\tNow, create the root node 1\\n\\tand search 2 in postorder ( 2 is at index 3), the element 3 4 5 2 are in left subtree of 1 and 6 7 8 are in right subtree of 1;\\n\\tthis same will be repeated for 2 and all the elements\\n\\t```\\n\\t\\n\\t                                           1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/      \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 2\\t        6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /    \\\\\\t  /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3      4    7      8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\n\\t int preIdx = 0;\\n      \\n    int search(vector<int> &postorder, int key, int start, int end)\\n    {\\n        for(int i=start; i<= end; i++)\\n        {\\n            if(postorder[i] == key)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    TreeNode* constructing(vector<int> pre, vector<int> post, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        if(start == end)\\n        {\\n            return new TreeNode(pre[preIdx++]);\\n        }\\n        \\n        TreeNode* root = new TreeNode(pre[preIdx++]);\\n        int idx2 = search(post, pre[preIdx],start, end);\\n        \\n        root->left = constructing(pre, post, start, idx2);\\n        root->right = constructing(pre, post, idx2+1, end-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root = constructing(preorder, postorder, 0, postorder.size()-1);\\n        return root;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\t\\n\\t                                           1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/      \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 2\\t        6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  /    \\\\\\t  /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3      4    7      8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\n\\t int preIdx = 0;\\n      \\n    int search(vector<int> &postorder, int key, int start, int end)\\n    {\\n        for(int i=start; i<= end; i++)\\n        {\\n            if(postorder[i] == key)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    TreeNode* constructing(vector<int> pre, vector<int> post, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return NULL;\\n        }\\n        if(start == end)\\n        {\\n            return new TreeNode(pre[preIdx++]);\\n        }\\n        \\n        TreeNode* root = new TreeNode(pre[preIdx++]);\\n        int idx2 = search(post, pre[preIdx],start, end);\\n        \\n        root->left = constructing(pre, post, start, idx2);\\n        root->right = constructing(pre, post, idx2+1, end-1);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root = constructing(preorder, postorder, 0, postorder.size()-1);\\n        return root;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2538437,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n  map<int,int> mp;\\n  TreeNode* solve(vector<int>&preorder,vector<int>&postorder,int prestart,int preend,int poststart,int postend){\\n    if(prestart>preend)return NULL;\\n    TreeNode*root=new TreeNode(preorder[prestart]);\\n    if(prestart==preend)return root;\\n    int idx=mp[preorder[prestart+1]];\\n    int offset=idx-poststart;\\n    root->left=solve(preorder,postorder,prestart+1,prestart+1+offset,poststart,idx);\\n    root->right=solve(preorder,postorder,prestart+1+offset+1,preend,idx+1,postend-1);\\n    return root;\\n  }\\n  \\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<postorder.size();i++)mp[postorder[i]]=i;\\n      \\n      int prestart=0,poststart=0;\\n      int preend=preorder.size()-1;\\n      int postend=postorder.size()-1;\\n      \\n        return solve(preorder,postorder,prestart,preend,poststart,postend);\\n    }\\n};\\n```\\n\\n**DO UPVOTE IF HELPFULL**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  map<int,int> mp;\\n  TreeNode* solve(vector<int>&preorder,vector<int>&postorder,int prestart,int preend,int poststart,int postend){\\n    if(prestart>preend)return NULL;\\n    TreeNode*root=new TreeNode(preorder[prestart]);\\n    if(prestart==preend)return root;\\n    int idx=mp[preorder[prestart+1]];\\n    int offset=idx-poststart;\\n    root->left=solve(preorder,postorder,prestart+1,prestart+1+offset,poststart,idx);\\n    root->right=solve(preorder,postorder,prestart+1+offset+1,preend,idx+1,postend-1);\\n    return root;\\n  }\\n  \\n  \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<postorder.size();i++)mp[postorder[i]]=i;\\n      \\n      int prestart=0,poststart=0;\\n      int preend=preorder.size()-1;\\n      int postend=postorder.size()-1;\\n      \\n        return solve(preorder,postorder,prestart,preend,poststart,postend);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413877,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(height of tree i.e. O(logN))***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // search element in postorder array\\n    \\n    int search(vector<int>& post, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(post[i] == val)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // search the index of pre[pre_idx] in post array\\n       \\n        int idx = search(post, start, end, pre[pre_idx]);\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```\\n\\n* ***Approach 2 :- Optimized***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // mp store the index of corresponding element of postorder\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // get the index of pre[pre_idx] from map\\n       \\n        int idx = mp[pre[pre_idx]];\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        // insert the index of element of postorder into map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[postorder[i]] = i;\\n        }\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // search element in postorder array\\n    \\n    int search(vector<int>& post, int start, int end, int val)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n            if(post[i] == val)\\n                return i;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // search the index of pre[pre_idx] in post array\\n       \\n        int idx = search(post, start, end, pre[pre_idx]);\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // mp store the index of corresponding element of postorder\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // pre_idx keeps track of element of preorder array\\n    \\n    int pre_idx = 0;\\n    \\n    // construct tree\\n    \\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end || pre_idx >= pre.size())\\n            return NULL;\\n        \\n        // create a node put value as pre[pre_idx]\\n        \\n        TreeNode* root = new TreeNode(pre[pre_idx]);\\n        \\n        pre_idx++;\\n        \\n        // if there is only one element in range of [start, end] or pre_idx is the last index of pre array\\n        \\n        if(pre_idx >= pre.size() || start == end)\\n            return root;\\n        \\n        // get the index of pre[pre_idx] from map\\n       \\n        int idx = mp[pre[pre_idx]];\\n        \\n        // construct left subtree\\n        \\n        root -> left = construct(pre, post, start, idx);\\n        \\n        // construct right subtree, as we can see that we are not including the last element of range, because we have already included as root\\n        \\n        root -> right = construct(pre, post, idx + 1, end - 1);\\n        \\n        // return root\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int n = preorder.size();\\n        \\n        // insert the index of element of postorder into map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[postorder[i]] = i;\\n        }\\n        \\n        return construct(preorder, postorder, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064148,
                "title": "c-iterative-solution",
                "content": "**Some Observations**\\n<ul>\\n<li>If i<sup>th</sup> element is present in preorder any index after j<sup>th</sup> element, then i<sup>th</sup> element can never be a descendant of j<sup>th</sup> element.\\n<li>If i<sup>th</sup> element is present in postorder any index before j<sup>th</sup> element, then jth element can never be a descendant to i<sup>th</sup> element.\\n<li>First element of preorder is always equal to the last element of postorder and it is the value which will be forming the root of the tree.</li>\\n</ul>\\n\\n**Algorithm**\\n\\nA stack is maintained where every stack element is a tuple (i, node), where i represents the index of the element in the preorder and node represents the newly created node with its value as preorder[i]. First, root node with value = preorder[0] is pushed into the stack as (0, root). Next we traverse postorder in reverse direction excluding the last element (since it is already included as root element) and find out the index of this postorder\\'s element in the preorder. If stack\\'s top has index > the index of preorder corresponding to that value, this implies that the current element cannot be a descendant to the element at top of the stack. Since we are reverse traversing the postorder, this also implies that the elements in stack can never be descendant of this element. Hence, we keep pop such elements out till we arrive at a situation when stack\\'s top element has index < current preorder\\'s index. If right of the stack\\'s top element points to NULL, we make it point to newly created node (which we encountered while doing postorder). Else, we make the left pointer of stack\\'s top node to point to the new node and then pop it from the stack. We push the newly created node along with its corresponding index in the preorder for next elements yet to be explored.\\n\\n**Code in C++**\\n\\n```\\nTreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<pair<int, TreeNode *> > st;\\n        int j;\\n        TreeNode *root = new TreeNode(preorder[0]);\\n        st.push(make_pair(0, root));\\n        for(int i = postorder.size()-2; i >= 0; i--) {\\n            for(j = 1; j < preorder.size(); j++) {\\n                if(preorder[j] == postorder[i]) {\\n                    break;\\n                }\\n            }\\n            TreeNode *temp = new TreeNode(preorder[j]);;\\n            while(st.top().first > j) {\\n                st.pop();\\n            }\\n            if(!st.top().second->right) {\\n                st.top().second->right = new TreeNode(preorder[j]);\\n                st.push(make_pair(j, st.top().second->right));\\n            } else {\\n                st.top().second->left = temp;\\n                st.push(make_pair(j, temp));\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<pair<int, TreeNode *> > st;\\n        int j;\\n        TreeNode *root = new TreeNode(preorder[0]);\\n        st.push(make_pair(0, root));\\n        for(int i = postorder.size()-2; i >= 0; i--) {\\n            for(j = 1; j < preorder.size(); j++) {\\n                if(preorder[j] == postorder[i]) {\\n                    break;\\n                }\\n            }\\n            TreeNode *temp = new TreeNode(preorder[j]);;\\n            while(st.top().first > j) {\\n                st.pop();\\n            }\\n            if(!st.top().second->right) {\\n                st.top().second->right = new TreeNode(preorder[j]);\\n                st.push(make_pair(j, st.top().second->right));\\n            } else {\\n                st.top().second->left = temp;\\n                st.push(make_pair(j, temp));\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981974,
                "title": "python-iterative-o-n-solution",
                "content": "We know a few properties of preorder and postorder traversal:\\n- leftmost element in preorder = root\\n- rightmost element in postorder = root\\n- leftmost element in postorder = leftmost node\\n- rightmost element in preorder = rightmost node\\n\\n\\nWe iterate through preorder until we reaches leftmost node, then we backtrack.\\n\\n```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0: return None\\n        root = TreeNode(preorder[0])\\n        stack, i = [root], 0\\n        for n in preorder[1:]:\\n            if stack[-1].val != postorder[i]:\\n                stack[-1].left = left = TreeNode(n)\\n                stack.append(left)\\n            else:\\n                while stack and stack[-1].val == postorder[i]:\\n                    cur = stack.pop()\\n                    i += 1\\n                stack[-1].right = right = TreeNode(n)\\n                stack.append(right)\\n        return root\\n```\\n\\nThis is similar to this [solution](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1979921/python-iterative-on-solution).",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0: return None\\n        root = TreeNode(preorder[0])\\n        stack, i = [root], 0\\n        for n in preorder[1:]:\\n            if stack[-1].val != postorder[i]:\\n                stack[-1].left = left = TreeNode(n)\\n                stack.append(left)\\n            else:\\n                while stack and stack[-1].val == postorder[i]:\\n                    cur = stack.pop()\\n                    i += 1\\n                stack[-1].right = right = TreeNode(n)\\n                stack.append(right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917697,
                "title": "c-solution-recursive",
                "content": "class Solution {\\n    TreeNode *helper(vector<int>p,vector<int>post,int &preindex,int l,int h,int size)\\n    {\\n\\t\\n        if(preindex>=size || l>h)return NULL;\\n        TreeNode *root=new TreeNode(p[preindex]);\\n        preindex++;\\n        if(l==h)return root;\\n        int i;\\n        for(i=l;i<=h;i++)\\n        {\\n            if(p[preindex]==post[i])\\n                break;\\n        }\\n        if(i<=h)\\n        {\\n            root->left=helper(p,post,preindex,l,i,size);\\n            root->right=helper(p,post,preindex,i+1,h-1,size);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n\\t\\n        int preindex=0;\\n        return helper(preorder,postorder,preindex,0,preorder.size()-1,preorder.size());\\n        \\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    TreeNode *helper(vector<int>p,vector<int>post,int &preindex,int l,int h,int size)\\n    {\\n\\t\\n        if(preindex>=size || l>h)return NULL;\\n        TreeNode *root=new TreeNode(p[preindex]);\\n        preindex++;\\n        if(l==h)return root;\\n        int i;\\n        for(i=l;i<=h;i++)\\n        {\\n            if(p[preindex]==post[i])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879578,
                "title": "easy-c-dfs",
                "content": "```\\nclass Solution {\\n    int preIndex = 0;\\n    TreeNode* construct(vector<int>& preorder, vector<int>& postorder, int post_s, int post_e){\\n        if(post_s>post_e) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[preIndex]);\\n        ++preIndex;\\n        if(post_s==post_e) return root;\\n        int post = post_s;\\n        while(postorder[post]!=preorder[preIndex]) ++post;\\n        root->left = construct(preorder,postorder,post_s,post);\\n        root->right = construct(preorder,postorder,post+1,post_e-1);\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return construct(preorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int preIndex = 0;\\n    TreeNode* construct(vector<int>& preorder, vector<int>& postorder, int post_s, int post_e){\\n        if(post_s>post_e) return nullptr;\\n        TreeNode* root = new TreeNode(preorder[preIndex]);\\n        ++preIndex;\\n        if(post_s==post_e) return root;\\n        int post = post_s;\\n        while(postorder[post]!=preorder[preIndex]) ++post;\\n        root->left = construct(preorder,postorder,post_s,post);\\n        root->right = construct(preorder,postorder,post+1,post_e-1);\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return construct(preorder,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860564,
                "title": "c-iterative-approach-easy-to-understand",
                "content": "**Solution:**\\n```\\npublic class Solution {\\n    public TreeNode ConstructFromPrePost(int[] preorder, int[] postorder) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        int n = preorder.Length;\\n        bool[] isRoot = new bool[n];\\n        int[] pos = new int[n + 1];\\n        for(int i = 0; i < n; ++i) {\\n            pos[postorder[i]] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            int nextRoot = 0;\\n            for(int j = pos[preorder[i]] + 1; j < n; ++j) {\\n                if(isRoot[j]) {\\n                    nextRoot = postorder[j];\\n                    break;\\n                }\\n            }\\n            TreeNode node = new TreeNode(preorder[i], null, null);\\n            dict[preorder[i]] = node;\\n            if(nextRoot != 0) {\\n                TreeNode root = dict[nextRoot];\\n                if(root.left == null) root.left = node;\\n                else root.right = node;\\n            }\\n            isRoot[pos[preorder[i]]] = true;\\n        }\\n        return dict[preorder[0]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode ConstructFromPrePost(int[] preorder, int[] postorder) {\\n        Dictionary<int, TreeNode> dict = new Dictionary<int, TreeNode>();\\n        int n = preorder.Length;\\n        bool[] isRoot = new bool[n];\\n        int[] pos = new int[n + 1];\\n        for(int i = 0; i < n; ++i) {\\n            pos[postorder[i]] = i;\\n        }\\n        for(int i = 0; i < n; ++i) {\\n            int nextRoot = 0;\\n            for(int j = pos[preorder[i]] + 1; j < n; ++j) {\\n                if(isRoot[j]) {\\n                    nextRoot = postorder[j];\\n                    break;\\n                }\\n            }\\n            TreeNode node = new TreeNode(preorder[i], null, null);\\n            dict[preorder[i]] = node;\\n            if(nextRoot != 0) {\\n                TreeNode root = dict[nextRoot];\\n                if(root.left == null) root.left = node;\\n                else root.right = node;\\n            }\\n            isRoot[pos[preorder[i]]] = true;\\n        }\\n        return dict[preorder[0]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843058,
                "title": "python-well-explained-solution-easy",
                "content": "**\\nPreorder is  -> root -> left -> right\\nPostorder is -> left -> right -> root\\nIf you see the difference between them is the how the root node is accessed\\n\\nIn preorder traversal if a node and its children exists it is guaranteed that children will come after the node . [ node 1 , node 2 , node 3 , node 4, ]\\nif node 2 have a child it will definitely coming after node 2 in preorder traversal\\n\\nThe opposite is true for postorder . \\n\\nOne more think to observe is that if node1 has a child node2 and node2 has a child node3\\nThen node3 will always come after node2 and node2 will always come after node1 in preorder and node3 will always come first then node2 then node3 in postorder\\n\\nSo my intution is based on following two observations\\n1. If for node 1 , node 2 in preorder ( index of node 1 < node 2 ):\\n         node 1 is parent of node2 if and only if node 1 comes after node 2 in postorder\\n\\n2. If the above is not true that means node 2 can never lie in the subtree rooted as node 1 \\n    so we check for nodes before node 1\\n\\t\\n\\tBut which node to check first > Ofcourse the most recent \\n\\tso we make a stack of nodes that can be possible parents\\n\\twhenever we make a new node we add it to stack and when the last item fails to be a \\n\\tparent we know that its era ended and he can\\'t be a parent again so we pop() from stack\\n**\\n\\n\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        n = len(preorder)\\n        d = {postorder[i]:i for i in range(n)}\\n        for i in range(1,n):\\n            b = d[preorder[i]]\\n            while stack:\\n                a = d[stack[-1].val]\\n                if a - b > 0:\\n                    node = stack[-1]\\n                    new =  TreeNode(preorder[i])\\n                    if node.left == None:node.left = new\\n                    else:node.right = new\\n                    stack.append(new)\\n                    break\\n                else: stack.pop()\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        n = len(preorder)\\n        d = {postorder[i]:i for i in range(n)}\\n        for i in range(1,n):\\n            b = d[preorder[i]]\\n            while stack:\\n                a = d[stack[-1].val]\\n                if a - b > 0:\\n                    node = stack[-1]\\n                    new =  TreeNode(preorder[i])\\n                    if node.left == None:node.left = new\\n                    else:node.right = new\\n                    stack.append(new)\\n                    break\\n                else: stack.pop()\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798311,
                "title": "easy-c-intuitive-explanation-with-comments",
                "content": "**Idea :** The idea of this solution is that we first create a root node with the first element of the preorder traversal.\\nAfter this we recursively construct the left and right subtrees by passing the appropriate preorder and postorder traversals for the left and right subtree.\\n\\nWe know that the root of the left subtree will be the next element to the current root in preorder traversal, we use this fact to find the new beginning and ending indexes of preorder and postorder traversals for the left and right subtrees of the current node.\\n\\n```\\nTreeNode<int> *constructTree(vector<int> preorder, vector<int> postorder, int preBeg, int preEnd, int postBeg, int postEnd)\\n    {\\n        if (preBeg > preEnd || postBeg > postEnd || preEnd > preorder.size())\\n            return NULL;\\n\\n        TreeNode<int> *root = new TreeNode<int>(preorder[preBeg]);\\n\\t    \\n\\t\\t// If there is a single element in the preorder traversal, we do not need to further construct its subtrees.\\n        if (preBeg == preEnd)\\n            return root;\\n\\t\\t\\n\\t\\t// Finding the new beginning and ending indexes of the preorder and postorder traversals for the left and right subtrees\\n        int newPreBeg = preBeg + 1, newPreEnd;\\n        int newPostBeg = postBeg, newPostEnd;\\n\\n        for (int i = newPostBeg; i < postEnd; i++)\\n            if (postorder[i] == preorder[newPreBeg])\\n            {\\n                newPostEnd = i;\\n                break;\\n            }\\n\\n        newPreEnd = newPreBeg + newPostEnd - newPostBeg;\\n\\n\\t\\t// Recursively constructing left subtree\\n        root->left = constructTree(preorder, postorder, newPreBeg, newPreEnd, newPostBeg, newPostEnd);\\n        \\n\\t\\t// Recursively constructing the right subtree\\n\\t\\troot->right = constructTree(preorder, postorder, newPreEnd + 1, preEnd, newPostEnd + 1, postEnd - 1);\\n\\n        return root;\\n    }\\n\\n    TreeNode<int> *constructFromPrePost(vector<int> &preorder, vector<int> &postorder)\\n    {\\n        return constructTree(preorder, postorder, 0, preorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n```\\n\\n***Please upvote if you found this useful.***",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nTreeNode<int> *constructTree(vector<int> preorder, vector<int> postorder, int preBeg, int preEnd, int postBeg, int postEnd)\\n    {\\n        if (preBeg > preEnd || postBeg > postEnd || preEnd > preorder.size())\\n            return NULL;\\n\\n        TreeNode<int> *root = new TreeNode<int>(preorder[preBeg]);\\n\\t    \\n\\t\\t// If there is a single element in the preorder traversal, we do not need to further construct its subtrees.\\n        if (preBeg == preEnd)\\n            return root;\\n\\t\\t\\n\\t\\t// Finding the new beginning and ending indexes of the preorder and postorder traversals for the left and right subtrees\\n        int newPreBeg = preBeg + 1, newPreEnd;\\n        int newPostBeg = postBeg, newPostEnd;\\n\\n        for (int i = newPostBeg; i < postEnd; i++)\\n            if (postorder[i] == preorder[newPreBeg])\\n            {\\n                newPostEnd = i;\\n                break;\\n            }\\n\\n        newPreEnd = newPreBeg + newPostEnd - newPostBeg;\\n\\n\\t\\t// Recursively constructing left subtree\\n        root->left = constructTree(preorder, postorder, newPreBeg, newPreEnd, newPostBeg, newPostEnd);\\n        \\n\\t\\t// Recursively constructing the right subtree\\n\\t\\troot->right = constructTree(preorder, postorder, newPreEnd + 1, preEnd, newPostEnd + 1, postEnd - 1);\\n\\n        return root;\\n    }\\n\\n    TreeNode<int> *constructFromPrePost(vector<int> &preorder, vector<int> &postorder)\\n    {\\n        return constructTree(preorder, postorder, 0, preorder.size() - 1, 0, postorder.size() - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514579,
                "title": "cpp-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    int preIndx=0;\\npublic:\\n    TreeNode* getTree(vector<int>& preorder,vector<int>&postorder,int lo,int hi,int sz){\\n        if(lo>hi or preIndx>=sz){\\n            return nullptr;\\n        }\\n        TreeNode* root=new TreeNode(preorder[preIndx++]);\\n        \\n        if(lo==hi){\\n            return root;\\n        }\\n        \\n        int i;\\n        for(i=lo;i<=hi;i++){\\n            if(preorder[preIndx]==postorder[i]){\\n                break;\\n            }\\n        }\\n        \\n        if(i<=hi){\\n            root->left=getTree(preorder,postorder,lo,i,sz);\\n            root->right=getTree(preorder,postorder,i+1,hi-1,sz);\\n        }\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int sz=preorder.size();\\n        TreeNode* ans= getTree(preorder,postorder,0,sz-1,sz);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int preIndx=0;\\npublic:\\n    TreeNode* getTree(vector<int>& preorder,vector<int>&postorder,int lo,int hi,int sz){\\n        if(lo>hi or preIndx>=sz){\\n            return nullptr;\\n        }\\n        TreeNode* root=new TreeNode(preorder[preIndx++]);\\n        \\n        if(lo==hi){\\n            return root;\\n        }\\n        \\n        int i;\\n        for(i=lo;i<=hi;i++){\\n            if(preorder[preIndx]==postorder[i]){\\n                break;\\n            }\\n        }\\n        \\n        if(i<=hi){\\n            root->left=getTree(preorder,postorder,lo,i,sz);\\n            root->right=getTree(preorder,postorder,i+1,hi-1,sz);\\n        }\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int sz=preorder.size();\\n        TreeNode* ans= getTree(preorder,postorder,0,sz-1,sz);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200971,
                "title": "easy-to-understand-java-code-with-explanation",
                "content": "```\\nclass Solution {\\n   // prei used to traverse preorder array , posti used to traverse post order array , both are global so that it becomes easier for us \\n    \\n    //dry run on a piece of paper to understand everything more clearly \\n    \\n    int prei = 0; \\n    int posti = 0;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int val = pre[prei];// preorder values will be hit first - construct tree from peorder \\n        TreeNode node = new TreeNode(val);\\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // prei incremented to construct left subtree \\n        node.left = constructFromPrePost(pre,post); // construct left subtree \\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // increment to construct right subtree \\n        node.right = constructFromPrePost(pre,post); // construct right subtree \\n        if(val==post[posti]){\\n            posti++; // this node is processed in post order so increment posti\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   // prei used to traverse preorder array , posti used to traverse post order array , both are global so that it becomes easier for us \\n    \\n    //dry run on a piece of paper to understand everything more clearly \\n    \\n    int prei = 0; \\n    int posti = 0;\\n    \\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int val = pre[prei];// preorder values will be hit first - construct tree from peorder \\n        TreeNode node = new TreeNode(val);\\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // prei incremented to construct left subtree \\n        node.left = constructFromPrePost(pre,post); // construct left subtree \\n        if(val==post[posti]){ \\n            posti++; // this node is processed in post order so increment posti\\n            return node;\\n        }\\n        prei++; // increment to construct right subtree \\n        node.right = constructFromPrePost(pre,post); // construct right subtree \\n        if(val==post[posti]){\\n            posti++; // this node is processed in post order so increment posti\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143729,
                "title": "python-easy-one-pass-iterative-o-n-with-full-proof",
                "content": "In a preorder traversal trace, if P is a parent node and L and R are its children, we must have \\nindex(P) < index(L) < index(R).\\n\\nFor postorder traversal trace, the condition we have to satisfy is \\nindex(L) < index(R) < index(P).\\n\\nBut **these necessary conditions are also sufficient.** Suppose we generate a tree T with no preorder (P<L<R) index violations, and no postorder (L < R < P) index violations.\\n\\nIf the correct tree, T\\', is distinct from T beyond left/right mirroring, while having the same vertex set, it must be that we can find two nodes (x, y) such that x is an ancestor of y in T and y is an ancestor of x in T\\'. But **our preorder and postorder conditions are inherited by descendants**:\\n\\nIf PP is the parent of x, then in a **preorder**, we have\\nindex(PP) < index(P)\\nso we also get index(PP) < index(P) < index(P\\'s children)\\n\\nwith the same inheritance pattern holding for **postorders**:\\nindex(P\\'s children) < index(P) < index (PP).\\n\\nSo this is a contradiction, as our tree has x and y in an order compatible with these conditions, and the \\'correct\\' tree has x and y in the opposite order.\\n\\nWe do one pass over post to get a mapping of values to indices. We keep a stack with our current path down from root, such that each path vertex (except root) has a free child spot, and iterate over the preorder. The lowest node in our current path that satisfies the postorder condition gets x as a child, the first free of left or right, and we move on to x as our current bottom of the path.\\n\\nTime: O(n) \\nSpace: O(n) unless we can steal space from the post-array, in which case we only need O(height) for stack\\n\\n\\n```python\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tindex_in_post = {post[i]: i for i in range(len(post))}\\n\\tcurr_node = TreeNode(pre[0])\\n\\tpath_from_root = [TreeNode(pre[0])]\\n\\tfor x in pre[1:]:\\n\\t\\tnew_node = TreeNode(x)\\n\\t\\twhile index_in_post[x] >= index_in_post[curr_node.val]:\\n\\t\\t\\tcurr_node = path_from_root.pop()\\n\\t\\tif curr_node.left is None:\\n\\t\\t\\tcurr_node.left = new_node\\n\\t\\t\\tpath_from_root.append(curr_node)\\n\\t\\telse:\\n\\t\\t\\tcurr_node.right = new_node\\n\\t\\tcurr_node = new_node\\n\\treturn path_from_root[0]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tindex_in_post = {post[i]: i for i in range(len(post))}\\n\\tcurr_node = TreeNode(pre[0])\\n\\tpath_from_root = [TreeNode(pre[0])]\\n\\tfor x in pre[1:]:\\n\\t\\tnew_node = TreeNode(x)\\n\\t\\twhile index_in_post[x] >= index_in_post[curr_node.val]:\\n\\t\\t\\tcurr_node = path_from_root.pop()\\n\\t\\tif curr_node.left is None:\\n\\t\\t\\tcurr_node.left = new_node\\n\\t\\t\\tpath_from_root.append(curr_node)\\n\\t\\telse:\\n\\t\\t\\tcurr_node.right = new_node\\n\\t\\tcurr_node = new_node\\n\\treturn path_from_root[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1084806,
                "title": "python-recursive-question-about-the-subtree",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if len(pre) == 0 or len(post) == 0:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        currentRootValue = pre[0]\\n        subTreeRootValue = pre[1]\\n        subTreeRootIdx = post.index(subTreeRootValue)\\n        leftSubTree = None\\n        rightSubTree = None\\n        if subTreeRootIdx == len(post) - 2:\\n            rightSubTree = self.constructFromPrePost(pre[1:], post[:-1])\\n        else:\\n            leftSubTree = self.constructFromPrePost(pre[1:subTreeRootIdx + 2], post[:subTreeRootIdx + 1])\\n            rightSubTree = self.constructFromPrePost(pre[subTreeRootIdx + 2:], post[subTreeRootIdx + 1:-1])\\n        return TreeNode(currentRootValue, leftSubTree, rightSubTree)\\n```\\n\\n\\nThis method has the same flavour as Construct Binary Tree from **Inorder and Postorder** Traversal and Construct Binary Tree from **Preorder and Inorder** Traversal.\\nHowever, without the reference of Inorder traversal value, it is in doubt whether the tree has left subtree or not.\\n\\nFor example:\\npre = [1, 2, 4, 5, 3, 6, 7]\\npost = [4, 5, 2, 6, 7, 3, 1]\\npre[1] = 2 is the root of subtree, \\nthe reason why it is the left one is that in post, after post[2] = 2, there are still numbers from the right subtree.\\n\\nHowever, though it passed the test case, I am confused about this pre and post:\\npre = [1, 3, 6, 7]\\npost = [6, 7, 3, 1]\\nbecause 3, 6, 7 can be from the left or right subtree, so there are two binary trees for this pre and post.\\nThough I do the if else in my code, it did not make it clear...\\nWhat do you reckon?",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if len(pre) == 0 or len(post) == 0:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        currentRootValue = pre[0]\\n        subTreeRootValue = pre[1]\\n        subTreeRootIdx = post.index(subTreeRootValue)\\n        leftSubTree = None\\n        rightSubTree = None\\n        if subTreeRootIdx == len(post) - 2:\\n            rightSubTree = self.constructFromPrePost(pre[1:], post[:-1])\\n        else:\\n            leftSubTree = self.constructFromPrePost(pre[1:subTreeRootIdx + 2], post[:subTreeRootIdx + 1])\\n            rightSubTree = self.constructFromPrePost(pre[subTreeRootIdx + 2:], post[subTreeRootIdx + 1:-1])\\n        return TreeNode(currentRootValue, leftSubTree, rightSubTree)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921467,
                "title": "c-recursive-solution",
                "content": "```\\nprivate:\\n    TreeNode* createNode(vector<int>& pre, vector<int>& post, int s, int sp, int N)\\n    {\\n        if (N == 0) return NULL;\\n        TreeNode* root = new TreeNode(pre[s]);\\n        if(N == 1) return root;\\n        \\n        int L = 0;\\n        for(int i = sp; i < sp + N; ++i)\\n        {\\n            if(post[i] == pre[s+1])\\n            {\\n                L = i - sp + 1;\\n                break;\\n            }\\n        }\\n        \\n        root -> left = createNode(pre, post, s+1, sp, L);\\n        root -> right = createNode(pre, post, s+L+1, sp+L, N-L-1);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return  createNode(pre, post, 0, 0, pre.size());\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n    TreeNode* createNode(vector<int>& pre, vector<int>& post, int s, int sp, int N)\\n    {\\n        if (N == 0) return NULL;\\n        TreeNode* root = new TreeNode(pre[s]);\\n        if(N == 1) return root;\\n        \\n        int L = 0;\\n        for(int i = sp; i < sp + N; ++i)\\n        {\\n            if(post[i] == pre[s+1])\\n            {\\n                L = i - sp + 1;\\n                break;\\n            }\\n        }\\n        \\n        root -> left = createNode(pre, post, s+1, sp, L);\\n        root -> right = createNode(pre, post, s+L+1, sp+L, N-L-1);\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return  createNode(pre, post, 0, 0, pre.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591122,
                "title": "java-o-n-2-recursive-solution-0-ms-time-100",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    private TreeNode helper(int[] preorder, int[] postorder, int preStart, int postStart, int length) {\\n        \\n        if(length == 0) return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        if(length == 1) return root;\\n        \\n        int index = 1;\\n        for(; index < length; index++) if(postorder[postStart + index - 1] == preorder[preStart + 1]) break;\\n        \\n        root.left = helper(preorder, postorder, preStart + 1, postStart, index);\\n        root.right = helper(preorder, postorder, preStart + index + 1, postStart + index, length - index - 1);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        return helper(preorder, postorder, 0, 0, preorder.length);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private TreeNode helper(int[] preorder, int[] postorder, int preStart, int postStart, int length) {\\n        \\n        if(length == 0) return null;\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        if(length == 1) return root;\\n        \\n        int index = 1;\\n        for(; index < length; index++) if(postorder[postStart + index - 1] == preorder[preStart + 1]) break;\\n        \\n        root.left = helper(preorder, postorder, preStart + 1, postStart, index);\\n        root.right = helper(preorder, postorder, preStart + index + 1, postStart + index, length - index - 1);\\n        \\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 469702,
                "title": "c-4ms-98-o-n-solution-o-n-space",
                "content": "The first solution here is the standard `O(N^2)` time `O(N)` space solution.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return makeTree(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, vector<int>& post, const int i1, const int j1, const int i2, const int j2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2; // Relative index of matching head in post[]\\n        for(int k = i2; k <= j2; ++k)\\n            if(post[k] == pre[i1+1]) {next = k+1-i2; break;}\\n        \\n        n->left = makeTree(pre, post, i1+1, i1+next, i2, i2+next-1); // Convert relative index of post into that of pre[] and post[]\\n        n->right = makeTree(pre, post, i1+next+1, j1, i2+next, j2-1);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\nIf we hash the look up for `next` , the run-time becomes `O(N)`. Space complexity is still `O(N)`. The solution below uses this and achieves `O(N)` time.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> m;\\n        int size = post.size();\\n        for(int i = 0; i < size; ++i) m[post[i]] = i;\\n        return makeTree(pre, m, 0, pre.size()-1, 0);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, unordered_map<int, int>& m, const int i1, const int j1, const int i2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2;\\n        if(m.count(pre[i1+1])) next = m[pre[i1+1]]+1-i2;\\n        n->left = makeTree(pre, m, i1+1, i1+next, i2);\\n        n->right = makeTree(pre, m, i1+next+1, j1, i2+next);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return makeTree(pre, post, 0, pre.size()-1, 0, post.size()-1);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, vector<int>& post, const int i1, const int j1, const int i2, const int j2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2; // Relative index of matching head in post[]\\n        for(int k = i2; k <= j2; ++k)\\n            if(post[k] == pre[i1+1]) {next = k+1-i2; break;}\\n        \\n        n->left = makeTree(pre, post, i1+1, i1+next, i2, i2+next-1); // Convert relative index of post into that of pre[] and post[]\\n        n->right = makeTree(pre, post, i1+next+1, j1, i2+next, j2-1);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> m;\\n        int size = post.size();\\n        for(int i = 0; i < size; ++i) m[post[i]] = i;\\n        return makeTree(pre, m, 0, pre.size()-1, 0);\\n    }\\n    static TreeNode* makeTree(vector<int>& pre, unordered_map<int, int>& m, const int i1, const int j1, const int i2) {\\n        if(i1 > j1) return nullptr;\\n        if(i1 == j1) return new TreeNode(pre[i1]);\\n        TreeNode *n = new TreeNode(pre[i1]);\\n        int next = i2;\\n        if(m.count(pre[i1+1])) next = m[pre[i1+1]]+1-i2;\\n        n->left = makeTree(pre, m, i1+1, i1+next, i2);\\n        n->right = makeTree(pre, m, i1+next+1, j1, i2+next);\\n        return n;\\n        \\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 403417,
                "title": "all-three-questions-105-106-889",
                "content": "Construct Binary Tree from Inorder and Postorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int index;\\n    int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n     TreeNode* build(vector<int>&inorder,vector<int>&postorder,int l,int r)\\n     {\\n         if(r<l)\\n             return NULL;\\n        TreeNode* root=new TreeNode(postorder[index--]);\\n        int pos=find(inorder,root->val,l,r);\\n         root->right=build(inorder,postorder,pos+1,r);\\n         root->left=build(inorder,postorder,l,pos-1);\\n         return root;\\n         \\n     }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n=inorder.size();\\n        index=n-1;\\n       return build(inorder,postorder,0,n-1);  \\n    }\\n};\\n```\\nConstruct Binary Tree from Preorder and Inorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int index=0;\\n     int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* build(vector<int>& pre, vector<int>& in,int l,int r)\\n    {\\n        if(r<l)\\n            return NULL;\\n        TreeNode* root=new TreeNode(pre[index++]);\\n        int pos=find(in,root->val,l,r);\\n        root->left=build(pre,in,l,pos-1);\\n        root->right=build(pre,in,pos+1,r);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        int n=in.size();\\n        index=0;\\n        return build(pre,in,0,n-1);\\n    }\\n};\\n```\\nConstruct Binary Tree from Preorder and Postorder Traversal\\n```\\nclass Solution {\\npublic:\\n    int preind=0,postind=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[preind++]);\\n        if(root->val!=post[postind])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postind])\\n            root->right=constructFromPrePost(pre,post);\\n        postind++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int index;\\n    int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n     TreeNode* build(vector<int>&inorder,vector<int>&postorder,int l,int r)\\n     {\\n         if(r<l)\\n             return NULL;\\n        TreeNode* root=new TreeNode(postorder[index--]);\\n        int pos=find(inorder,root->val,l,r);\\n         root->right=build(inorder,postorder,pos+1,r);\\n         root->left=build(inorder,postorder,l,pos-1);\\n         return root;\\n         \\n     }\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int n=inorder.size();\\n        index=n-1;\\n       return build(inorder,postorder,0,n-1);  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int index=0;\\n     int find(vector<int>&inorder,int val,int l,int r)\\n    {\\n        for(int i=l;i<=r;i++)\\n        {\\n            if(inorder[i]==val)\\n                return i;\\n        }\\n        return -1;\\n    }\\n    TreeNode* build(vector<int>& pre, vector<int>& in,int l,int r)\\n    {\\n        if(r<l)\\n            return NULL;\\n        TreeNode* root=new TreeNode(pre[index++]);\\n        int pos=find(in,root->val,l,r);\\n        root->left=build(pre,in,l,pos-1);\\n        root->right=build(pre,in,pos+1,r);\\n        return root;\\n    }\\n    TreeNode* buildTree(vector<int>& pre, vector<int>& in) {\\n        int n=in.size();\\n        index=0;\\n        return build(pre,in,0,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int preind=0,postind=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[preind++]);\\n        if(root->val!=post[postind])\\n            root->left=constructFromPrePost(pre,post);\\n        if(root->val!=post[postind])\\n            root->right=constructFromPrePost(pre,post);\\n        postind++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371224,
                "title": "c-implementation",
                "content": "```\\npublic static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            var head = new TreeNode(pre[0]);\\n            var stack = new Stack<TreeNode>();\\n            stack.Push(head);\\n            for (int i = 1, j = 0; i < pre.Length; i++)\\n            {\\n                var node = new TreeNode(pre[i]);\\n                while (stack.Peek().val == post[j])\\n                {\\n                    stack.Pop();\\n                    j++;\\n                }\\n\\n                if (stack.Peek().left == null)\\n                    stack.Peek().left = node;\\n                else stack.Peek().right = node;\\n                stack.Push(node);\\n            }\\n\\n            return head;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static TreeNode ConstructFromPrePost(int[] pre, int[] post)\\n        {\\n            var head = new TreeNode(pre[0]);\\n            var stack = new Stack<TreeNode>();\\n            stack.Push(head);\\n            for (int i = 1, j = 0; i < pre.Length; i++)\\n            {\\n                var node = new TreeNode(pre[i]);\\n                while (stack.Peek().val == post[j])\\n                {\\n                    stack.Pop();\\n                    j++;\\n                }\\n\\n                if (stack.Peek().left == null)\\n                    stack.Peek().left = node;\\n                else stack.Peek().right = node;\\n                stack.Push(node);\\n            }\\n\\n            return head;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349721,
                "title": "javascript-o-n-time-and-o-n-space-solution-with-explanation",
                "content": "TLDR:\\n    - the left node is always to the right of the value in preorder\\n    - the right node is always to the left of the value in postorder\\n    - these two conditions are always true IF we have not already assigned these values as another node\\'s left/right\\n\\nSTEPS\\nOne loop to save reference of value indexes from postorder array into an object so we can later achieve constant time lookup versus using .indexOf() for every item - O(N^2)\\n\\nstarting at pre[0]\\n    - left = preorder[i + 1]\\n    - right = (index of preorder[i] in postorder) - 1\\n\\nSince all numbers are unique, we can have a history object with keys as val and values as the node we created to keep track of which nodes should not be duplicated as left/right.  This also allows us to have constant time access to the node we want to add a left/right\\n     \\n hist = {\\n\\t1: new TreeNode(1),\\n\\t2: new TreeNode(2),\\n\\tetc...\\n }\\n \\n```\\nconst constructFromPrePost = function(pre, post) {\\n    let hist = {};\\n    let postIndexes = {};\\n    let head = new TreeNode(pre[0]);\\n    hist[pre[0]] = head;\\n    \\n    for (let k = 0; k < post.length; k++) {\\n        postIndexes[post[k]] = k;\\n    }\\n\\n    for (let i = 0; i < pre.length; i++) {\\n        let currentNode = hist[pre[i]];\\n        \\n        let leftVal = pre[i+1];\\n        if (leftVal && !hist[leftVal]) {\\n            let leftNode = new TreeNode(leftVal);\\n            currentNode.left = leftNode;\\n            hist[leftVal] = leftNode;\\n        }\\n        \\n        let rightVal = post[postIndexes[pre[i]] - 1];\\n        if (rightVal && !hist[rightVal]) {\\n            let rightNode = new TreeNode(rightVal);\\n            currentNode.right = rightNode;\\n            hist[rightVal] = rightNode;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst constructFromPrePost = function(pre, post) {\\n    let hist = {};\\n    let postIndexes = {};\\n    let head = new TreeNode(pre[0]);\\n    hist[pre[0]] = head;\\n    \\n    for (let k = 0; k < post.length; k++) {\\n        postIndexes[post[k]] = k;\\n    }\\n\\n    for (let i = 0; i < pre.length; i++) {\\n        let currentNode = hist[pre[i]];\\n        \\n        let leftVal = pre[i+1];\\n        if (leftVal && !hist[leftVal]) {\\n            let leftNode = new TreeNode(leftVal);\\n            currentNode.left = leftNode;\\n            hist[leftVal] = leftNode;\\n        }\\n        \\n        let rightVal = post[postIndexes[pre[i]] - 1];\\n        if (rightVal && !hist[rightVal]) {\\n            let rightNode = new TreeNode(rightVal);\\n            currentNode.right = rightNode;\\n            hist[rightVal] = rightNode;\\n        }\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270865,
                "title": "c-true-o-n-time-recursion-beat-100",
                "content": "```\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        // pre: [1 3 6 7], post: [6 7 3 1], you will never know if [3 6 7] is left subtree of root 1 or the right subtree.\\n        int i = 0, j = 0;\\n        return helper(pre, i, post, j);\\n    }\\n\\n    TreeNode* helper(const vector<int>& pre, int& i, const vector<int>& post, int& j) {\\n        if (i == pre.size()) return nullptr;\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        // Simplify the above logic to be as follows:\\n        while (post[j] != root->val) {\\n            if (!root->left)\\n                root->left = helper(pre, i, post, j);\\n            else\\n                root->right = helper(pre, i, post, j);\\n        }\\n        j++;\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        // pre: [1 3 6 7], post: [6 7 3 1], you will never know if [3 6 7] is left subtree of root 1 or the right subtree.\\n        int i = 0, j = 0;\\n        return helper(pre, i, post, j);\\n    }\\n\\n    TreeNode* helper(const vector<int>& pre, int& i, const vector<int>& post, int& j) {\\n        if (i == pre.size()) return nullptr;\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        // Simplify the above logic to be as follows:\\n        while (post[j] != root->val) {\\n            if (!root->left)\\n                root->left = helper(pre, i, post, j);\\n            else\\n                root->right = helper(pre, i, post, j);\\n        }\\n        j++;\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210913,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\n**Time Complexity:** `O(N)` - building a hash-table takes `O(N)` time and recursive reconstruction spends O(1) time per node\\n**Space Complexity:** `O(N + H) = O(N)` - the hash-table size and the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    Map<Integer, Integer> postOrderMap = new HashMap<>();\\n    int preOrderIndex = 0;\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postOrderMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderIndex++]);\\n\\n        if (postOrderStartIndex < postOrderEndIndex) {\\n            int postOrderIndex = postOrderMap.get(preorder[preOrderIndex]);\\n            root.left = constructFromPrePostHelper(preorder, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n**Time Complexity:** `O(N)` - building a hash-table takes `O(N)` time and recursive reconstruction spends O(1) time per node\\n**Space Complexity:** `O(N + H) = O(N)` - the hash-table size and the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> postMap = new HashMap<>();\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, preorder.length - 1, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int preOrderStartIndex, int preOrderEndIndex, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderStartIndex++]);\\n\\n        if (preOrderStartIndex <= preOrderEndIndex) {\\n            int postOrderIndex = postMap.get(preorder[preOrderStartIndex]);\\n            int preOrderIndex = preOrderStartIndex + postOrderIndex - postOrderStartIndex;\\n\\n            root.left = constructFromPrePostHelper(preorder, preOrderStartIndex, preOrderIndex, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, preOrderIndex + 1, preOrderEndIndex, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> postOrderMap = new HashMap<>();\\n    int preOrderIndex = 0;\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postOrderMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderIndex++]);\\n\\n        if (postOrderStartIndex < postOrderEndIndex) {\\n            int postOrderIndex = postOrderMap.get(preorder[preOrderIndex]);\\n            root.left = constructFromPrePostHelper(preorder, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashMap<Integer, Integer> postMap = new HashMap<>();\\n\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        for (int i = 0; i < postorder.length; i++) {\\n            postMap.put(postorder[i], i);\\n        }\\n        return constructFromPrePostHelper(preorder, 0, preorder.length - 1, 0, postorder.length - 1);\\n    }\\n\\n    private TreeNode constructFromPrePostHelper(int[] preorder, int preOrderStartIndex, int preOrderEndIndex, int postOrderStartIndex, int postOrderEndIndex) {\\n        if (postOrderStartIndex > postOrderEndIndex) {\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[preOrderStartIndex++]);\\n\\n        if (preOrderStartIndex <= preOrderEndIndex) {\\n            int postOrderIndex = postMap.get(preorder[preOrderStartIndex]);\\n            int preOrderIndex = preOrderStartIndex + postOrderIndex - postOrderStartIndex;\\n\\n            root.left = constructFromPrePostHelper(preorder, preOrderStartIndex, preOrderIndex, postOrderStartIndex, postOrderIndex);\\n            root.right = constructFromPrePostHelper(preorder, preOrderIndex + 1, preOrderEndIndex, postOrderIndex + 1, postOrderEndIndex - 1);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164015,
                "title": "straight-forward-recursion-in-java",
                "content": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int n = pre.length;\\n        if (n==0) return null; \\n        TreeNode root = new TreeNode(pre[0]);\\n        if (n>1) {\\n            int x = pre[1];\\n            int j=0; \\n            while (post[j]!=x)\\n                j++; \\n            root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, j+2), Arrays.copyOfRange(post, 0, j+1)); \\n            root.right = constructFromPrePost(Arrays.copyOfRange(pre, j+2, n), Arrays.copyOfRange(post, j+1, n-1)); \\n        }\\n        return root; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        int n = pre.length;\\n        if (n==0) return null; \\n        TreeNode root = new TreeNode(pre[0]);\\n        if (n>1) {\\n            int x = pre[1];\\n            int j=0; \\n            while (post[j]!=x)\\n                j++; \\n            root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, j+2), Arrays.copyOfRange(post, 0, j+1)); \\n            root.right = constructFromPrePost(Arrays.copyOfRange(pre, j+2, n), Arrays.copyOfRange(post, j+1, n-1)); \\n        }\\n        return root; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161344,
                "title": "java-recursive-solution",
                "content": "Basically, you need to find the boundary of the left tree in post order array, then use the length to calculate the index\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if(pre.length == 0 || post.length == 0 || pre.length != post.length)\\n            return null;\\n        return dfs(pre, 0, pre.length - 1, post, 0, post.length - 1);\\n    }\\n    private TreeNode dfs(int[] pre, int ps, int pe, int[] post, int pps, int ppe) {\\n        if(ps > pe || pps > ppe) return null;\\n        TreeNode root = new TreeNode(pre[ps]);\\n        if(ps + 1 > pe) return root;\\n\\t\\t\\t\\t// this is the start of the left tree\\n        int val = pre[ps + 1], idx = pps;\\n        for(; idx < ppe; idx++) {\\n            if(post[idx] == val) break;\\n        }\\n        root.left = dfs(pre, ps + 1, ps + idx - pps + 1, post, pps, idx);\\n        root.right = dfs(pre, ps + idx - pps + 2, pe, post, idx + 1, ppe - 1);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if(pre.length == 0 || post.length == 0 || pre.length != post.length)\\n            return null;\\n        return dfs(pre, 0, pre.length - 1, post, 0, post.length - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3772052,
                "title": "perhaps-shortest-python-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nModified from [lee215\\'s solution](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/161268/c-java-python-one-pass-real-o-n/), with two index vars replaced by pop operations.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$ extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(postorder.pop())\\n        if root.val != preorder[-1]:\\n            root.right = self.constructFromPrePost(preorder, postorder)\\n        if root.val != preorder[-1]:\\n            root.left = self.constructFromPrePost(preorder, postorder)\\n        preorder.pop()\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(postorder.pop())\\n        if root.val != preorder[-1]:\\n            root.right = self.constructFromPrePost(preorder, postorder)\\n        if root.val != preorder[-1]:\\n            root.left = self.constructFromPrePost(preorder, postorder)\\n        preorder.pop()\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692211,
                "title": "easy-c-solution-beat-97-2",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int preindex=0,posindex=0;\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        if(root->val!=postorder[posindex])\\n            root->left=constructFromPrePost(preorder,postorder);\\n        if(root->val!=postorder[posindex])\\n            root->right=constructFromPrePost(preorder,postorder);\\n        posindex++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int preindex=0,posindex=0;\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        TreeNode* root=new TreeNode(preorder[preindex++]);\\n        if(root->val!=postorder[posindex])\\n            root->left=constructFromPrePost(preorder,postorder);\\n        if(root->val!=postorder[posindex])\\n            root->right=constructFromPrePost(preorder,postorder);\\n        posindex++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617169,
                "title": "easy-to-understand-97-beats-c",
                "content": "\\n# Approach\\nrecursive \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* helper(int preFirst, int preEnd, vector<int> &preorder, int postFirst, \\n    int postEnd, vector<int> &postorder) {\\n        \\n        if(preFirst > preEnd) return NULL;\\n        int preRoot = preorder[preFirst];\\n\\n        TreeNode* root = new TreeNode(preRoot);\\n        if(preFirst == preEnd) return root;\\n\\n        int postRoot = postFirst;\\n        for(int i=postFirst; i<=postEnd-1; i++) {\\n            if(postorder[i] == preorder[preFirst+1]) {\\n                postRoot = i;\\n                break;\\n            }\\n        }\\n\\n        int postLeftSt = postFirst, postLeftEnd = postRoot;\\n        int postRightSt = postRoot+1, postRightEnd = postEnd - 1;\\n\\n        int preLeftSt = preFirst + 1, preLeftEnd = postLeftEnd - postLeftSt + preFirst + 1;\\n        int preRightSt = preLeftEnd + 1, preRightEnd = preEnd;\\n\\n\\n        root->left = helper(preLeftSt, preLeftEnd, preorder, postLeftSt, postLeftEnd, postorder);\\n\\n        root->right = helper(preRightSt, preRightEnd, preorder, postRightSt, postRightEnd, postorder);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size();\\n        return helper(0, n-1, preorder, 0, n-1, postorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    TreeNode* helper(int preFirst, int preEnd, vector<int> &preorder, int postFirst, \\n    int postEnd, vector<int> &postorder) {\\n        \\n        if(preFirst > preEnd) return NULL;\\n        int preRoot = preorder[preFirst];\\n\\n        TreeNode* root = new TreeNode(preRoot);\\n        if(preFirst == preEnd) return root;\\n\\n        int postRoot = postFirst;\\n        for(int i=postFirst; i<=postEnd-1; i++) {\\n            if(postorder[i] == preorder[preFirst+1]) {\\n                postRoot = i;\\n                break;\\n            }\\n        }\\n\\n        int postLeftSt = postFirst, postLeftEnd = postRoot;\\n        int postRightSt = postRoot+1, postRightEnd = postEnd - 1;\\n\\n        int preLeftSt = preFirst + 1, preLeftEnd = postLeftEnd - postLeftSt + preFirst + 1;\\n        int preRightSt = preLeftEnd + 1, preRightEnd = preEnd;\\n\\n\\n        root->left = helper(preLeftSt, preLeftEnd, preorder, postLeftSt, postLeftEnd, postorder);\\n\\n        root->right = helper(preRightSt, preRightEnd, preorder, postRightSt, postRightEnd, postorder);\\n\\n        return root;\\n    }\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size();\\n        return helper(0, n-1, preorder, 0, n-1, postorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511719,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size() - 1;\\n        return build(preorder, postorder, 0, n, 0, n);\\n    }\\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder,\\n                    int preLeft, int preRight, int postLeft, int postRight)\\n    {\\n        if (preLeft > preRight || postLeft > postRight) return NULL;\\n        TreeNode* ans = new TreeNode(preorder[preLeft]);\\n        if (preLeft == preRight) return ans; \\n        int len = 1;\\n        for (;len < preRight - preLeft; len++)\\n        {\\n            if (preorder[preLeft + 1] == postorder[postLeft + len - 1])\\n                break;\\n        }\\n        ans->left = build(preorder, postorder, preLeft + 1, preLeft + len, postLeft, postLeft + len - 1);\\n        ans->right = build(preorder, postorder, preLeft + len + 1, preRight, postLeft + len, postRight - 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        self.post_indices = {v: idx for idx, v in enumerate(postorder)}\\n        self.pre_index = 0\\n\\n        print(preorder, postorder)\\n        def buildTree(left, right):\\n            if left > right:\\n                return None            \\n            node = TreeNode(val=preorder[self.pre_index])\\n            self.pre_index +=1 \\n            if self.pre_index > len(preorder) - 1 or left == right: # critical\\n                return node                       \\n            post_index = self.post_indices[preorder[self.pre_index]]\\n            node.left = buildTree(left, post_index)\\n            node.right = buildTree(post_index + 1, right-1)\\n            return node\\n        \\n        return buildTree(0, len(preorder)-1)\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }\\n    int pre = 0, post = 0;\\n    TreeNode build(int[] PRE, int[] POST) {\\n        TreeNode n = new TreeNode(PRE[pre]);\\n        pre++;\\n        if (n.val != POST[post]) {\\n            n.left = build(PRE, POST);\\n        }\\n        if (n.val != POST[post]) {\\n            n.right = build(PRE, POST);\\n        }\\n        post++;\\n        return n;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int n = preorder.size() - 1;\\n        return build(preorder, postorder, 0, n, 0, n);\\n    }\\n    TreeNode* build(vector<int>& preorder, vector<int>& postorder,\\n                    int preLeft, int preRight, int postLeft, int postRight)\\n    {\\n        if (preLeft > preRight || postLeft > postRight) return NULL;\\n        TreeNode* ans = new TreeNode(preorder[preLeft]);\\n        if (preLeft == preRight) return ans; \\n        int len = 1;\\n        for (;len < preRight - preLeft; len++)\\n        {\\n            if (preorder[preLeft + 1] == postorder[postLeft + len - 1])\\n                break;\\n        }\\n        ans->left = build(preorder, postorder, preLeft + 1, preLeft + len, postLeft, postLeft + len - 1);\\n        ans->right = build(preorder, postorder, preLeft + len + 1, preRight, postLeft + len, postRight - 1);\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        self.post_indices = {v: idx for idx, v in enumerate(postorder)}\\n        self.pre_index = 0\\n\\n        print(preorder, postorder)\\n        def buildTree(left, right):\\n            if left > right:\\n                return None            \\n            node = TreeNode(val=preorder[self.pre_index])\\n            self.pre_index +=1 \\n            if self.pre_index > len(preorder) - 1 or left == right: # critical\\n                return node                       \\n            post_index = self.post_indices[preorder[self.pre_index]]\\n            node.left = buildTree(left, post_index)\\n            node.right = buildTree(post_index + 1, right-1)\\n            return node\\n        \\n        return buildTree(0, len(preorder)-1)\\n```\n```Java []\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] PRE, int[] POST) {\\n        return build(PRE, POST);\\n    }\\n    int pre = 0, post = 0;\\n    TreeNode build(int[] PRE, int[] POST) {\\n        TreeNode n = new TreeNode(PRE[pre]);\\n        pre++;\\n        if (n.val != POST[post]) {\\n            n.left = build(PRE, POST);\\n        }\\n        if (n.val != POST[post]) {\\n            n.right = build(PRE, POST);\\n        }\\n        post++;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502061,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* dfs(vector<int>& preorder,int prestart,int preend, vector<int>& postorder,int poststart,int postend)\\n    {\\n        if(prestart>preend)\\n        {\\n            return NULL;\\n        }\\n        if(poststart>postend)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        if(prestart==preend)\\n        {\\n            return root;\\n        }\\n        int postindex=poststart;\\n        while(postorder[postindex]!=preorder[prestart+1])\\n        {\\n            postindex++;\\n        }\\n        int len= postindex-poststart+1;\\n        root->left=dfs(preorder,prestart+1,prestart+len,postorder,poststart,postindex);\\n        root->right=dfs(preorder,prestart+len+1,preend,postorder,postindex+1,postend-1);\\n        return root;\\n\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return dfs(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* dfs(vector<int>& preorder,int prestart,int preend, vector<int>& postorder,int poststart,int postend)\\n    {\\n        if(prestart>preend)\\n        {\\n            return NULL;\\n        }\\n        if(poststart>postend)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[prestart]);\\n        if(prestart==preend)\\n        {\\n            return root;\\n        }\\n        int postindex=poststart;\\n        while(postorder[postindex]!=preorder[prestart+1])\\n        {\\n            postindex++;\\n        }\\n        int len= postindex-poststart+1;\\n        root->left=dfs(preorder,prestart+1,prestart+len,postorder,poststart,postindex);\\n        root->right=dfs(preorder,prestart+len+1,preend,postorder,postindex+1,postend-1);\\n        return root;\\n\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return dfs(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417213,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nvector<int>pre,post;\\nvoid f(TreeNode* root,vector<int>& preorder, vector<int>& postorder){\\n    int d = root->val;\\n    int pr = pre[d];\\n    int pst = post[d];\\n\\n    for(int j = pr + 1;j < preorder.size();j++){\\n        if(!visited[preorder[j]] and post[d] > post[preorder[j]]){\\n            visited[preorder[j]] = 1;\\n            root->left = new TreeNode(preorder[j]);\\n            f(root->left,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n    for(int j = pst - 1;j >= 0;j--){\\n        if(!visited[postorder[j]] and pre[d] < pre[postorder[j]]){\\n            visited[postorder[j]] = 1;\\n            root->right = new TreeNode(postorder[j]);\\n            f(root->right,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n\\n}\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        visited.resize(31,false);\\n        pre.resize(31,0);\\n        post.resize(31,0);\\n        for(int i = 0;i < preorder.size();i++)pre[preorder[i]] = i;\\n        for(int i = 0;i < postorder.size();i++)post[postorder[i]] = i;\\n\\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        f(root,preorder,postorder);\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<bool>visited;\\nvector<int>pre,post;\\nvoid f(TreeNode* root,vector<int>& preorder, vector<int>& postorder){\\n    int d = root->val;\\n    int pr = pre[d];\\n    int pst = post[d];\\n\\n    for(int j = pr + 1;j < preorder.size();j++){\\n        if(!visited[preorder[j]] and post[d] > post[preorder[j]]){\\n            visited[preorder[j]] = 1;\\n            root->left = new TreeNode(preorder[j]);\\n            f(root->left,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n    for(int j = pst - 1;j >= 0;j--){\\n        if(!visited[postorder[j]] and pre[d] < pre[postorder[j]]){\\n            visited[postorder[j]] = 1;\\n            root->right = new TreeNode(postorder[j]);\\n            f(root->right,preorder,postorder);\\n            break;\\n        }\\n    }\\n\\n\\n}\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        visited.resize(31,false);\\n        pre.resize(31,0);\\n        post.resize(31,0);\\n        for(int i = 0;i < preorder.size();i++)pre[preorder[i]] = i;\\n        for(int i = 0;i < postorder.size();i++)post[postorder[i]] = i;\\n\\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        f(root,preorder,postorder);\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777642,
                "title": "c-simple-solution",
                "content": "\\tTreeNode *maketree(vector<int>& preorder, vector<int>& postorder,int &preidx,int left,int right,int size)\\n    {\\n        if(left>right || preidx>=size)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[preidx]);\\n        preidx++;\\n        if(left==right)\\n            return root;\\n        int i=0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(preorder[preidx]==postorder[i])\\n                break;\\n        }\\n        if(i<=right)\\n        {\\n            root->left=maketree(preorder,postorder,preidx,left,i,size);\\n            root->right=maketree(preorder,postorder,preidx,i+1,right-1,size);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) \\n    {\\n        int preidx=0;\\n        return maketree(preorder,postorder,preidx,0,preorder.size()-1,preorder.size());    \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tTreeNode *maketree(vector<int>& preorder, vector<int>& postorder,int &preidx,int left,int right,int size)\\n    {\\n        if(left>right || preidx>=size)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[preidx]);\\n        preidx++;\\n        if(left==right)\\n            return root;\\n        int i=0;\\n        for(i=left;i<=right;i++)\\n        {\\n            if(preorder[preidx]==postorder[i])\\n                break;\\n        }\\n        if(i<=right)\\n        {\\n            root->left=maketree(preorder,postorder,preidx,left,i,size);\\n            root->right=maketree(preorder,postorder,preidx,i+1,right-1,size);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) \\n    {\\n        int preidx=0;\\n        return maketree(preorder,postorder,preidx,0,preorder.size()-1,preorder.size());    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2510576,
                "title": "java-2ms-easy-explained-solution",
                "content": "Let us consider the two given arrays as pre[] = {1, 2, 4, 8, 9, 5, 3, 6, 7} and post[] = {8, 9, 4, 5, 2, 6, 7, 3, 1}; \\n\\nIn pre[], the leftmost element is root of tree. Since the tree is full and array size is more than 1. The value next to 1 in pre[], must be left child of root. So we know 1 is root and 2 is left child. How to find the all nodes in left subtree? We know 2 is root of all nodes in left subtree. All nodes before 2 in post[] must be in left subtree. Now we know 1 is root, elements {8, 9, 4, 5, 2} are in left subtree, and the elements {6, 7, 3} are in right subtree. \\n\\t\"\\t\\t\\t       1\\n                /           \\\\\\\\\\n               /               \\\\\\\\\\n     {8, 9, 4, 5, 2}        {6, 7, 3}  \"\\nWe recursively follow the approach.\\n\\t\\t    1\\n        /       \\\\\\\\\\n      2           3\\n    /  \\\\\\\\        /  \\\\\\\\\\n   4     5      6    7\\n  / \\\\\\\\  \\n8     9 \\n\\nTime Complexity: O(h), Space Auxiliary Space :O(h)\\n// h is the height of the tree.\\n\\n\\n-----------------------------------------CODE--------------------------------------------------------------------------\\n\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = preorder.length;\\n        return construct(preorder, postorder, 0, n-1, n);        \\n    }\\n    \\n    private TreeNode construct(int[] pre, int[] post, int l, int h, int n){\\n        if(p>=n || l>h)\\n            return null;\\n        TreeNode node = new TreeNode(pre[p]);\\n        p++;\\n        if(l==h || p>=n)\\n            return node;\\n        int i;\\n        for(i=l;i<=h;i++)\\n            if(pre[p]==post[i])\\n                break;\\n        if(i<=h){\\n            node.left = construct(pre, post, l, i, n);\\n            node.right = construct(pre, post, i+1, h-1, n);\\n        }\\n        return node;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = preorder.length;\\n        return construct(preorder, postorder, 0, n-1, n);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475027,
                "title": "c-neat-and-clean-recursive-code-easy-understanding",
                "content": "```\\n/*\\n* prsi = preorder starting index\\n* prei = preorder ending index\\n* posi = postorder starting index\\n* poei = postorder ending index\\n*/\\nclass Solution {\\nprivate:\\n  TreeNode *constructTree(vector<int> &pre, int prsi, int prei, vector<int> &post, int posi, int poei){\\n    if(prsi>prei) return NULL;\\n    TreeNode *root = new TreeNode(pre[prsi]);\\n\\t//if one element is present no order to check for it\\'s left part and right part or u may say base case\\n    if(prsi==prei) return root;\\n    int idx = posi;\\n    while(post[idx]!=pre[prsi+1]) idx++;\\n    int totalElem = idx-posi+1;\\n\\t//recursive call to construct left subtree and right subtree\\n    root->left = constructTree(pre, prsi+1, prsi+totalElem, post, posi, idx);\\n    root->right = constructTree(pre, prsi+totalElem+1, prei, post, idx+1, poei-1);\\n    return root;\\n  }\\npublic:\\n  TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder){\\n    return constructTree(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n* prsi = preorder starting index\\n* prei = preorder ending index\\n* posi = postorder starting index\\n* poei = postorder ending index\\n*/\\nclass Solution {\\nprivate:\\n  TreeNode *constructTree(vector<int> &pre, int prsi, int prei, vector<int> &post, int posi, int poei){\\n    if(prsi>prei) return NULL;\\n    TreeNode *root = new TreeNode(pre[prsi]);\\n\\t//if one element is present no order to check for it\\'s left part and right part or u may say base case\\n    if(prsi==prei) return root;\\n    int idx = posi;\\n    while(post[idx]!=pre[prsi+1]) idx++;\\n    int totalElem = idx-posi+1;\\n\\t//recursive call to construct left subtree and right subtree\\n    root->left = constructTree(pre, prsi+1, prsi+totalElem, post, posi, idx);\\n    root->right = constructTree(pre, prsi+totalElem+1, prei, post, idx+1, poei-1);\\n    return root;\\n  }\\npublic:\\n  TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder){\\n    return constructTree(preorder, 0, preorder.size()-1, postorder, 0, postorder.size()-1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452364,
                "title": "do-you-wanna-build-a-binary-tree-a-problem-set-explained-with-figures",
                "content": "## 0. Preliminary\\n### Inorder\\nAn inorder traversal technique follows the\\xA0**Left Root Right** policy. Here, Left Root Right means that the left subtree of the root node is traversed first, then the root node, and then the right subtree of the root node is traversed.\\n### Preorder\\nIn preorder traversal, first, root node is visited, then left sub-tree and after that right sub-tree is visited. The process of preorder traversal can be represented as: **root\\xA0\\u2192\\xA0left\\xA0\\u2192\\xA0right**\\n### Postorder\\nThe postorder traversal technique follows the\\xA0**Left Right Root**\\xA0policy. Here, Left Right Root means the left subtree of the root node is traversed first, then the right subtree, and finally, the root node is traversed.\\n## 1. [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/f3291d64-bcc9-429b-b360-b1739023eadd_1661753418.4619062.png)\\n\\n\\nHow to improve efficiency?\\n- Create a map for `inorder`\\n- Turn `preorder` into a queue, since `popleft` is O(1) operation\\n```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        preorder = deque(preorder)\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root_index = inorder_map[preorder.popleft()]\\n            root = TreeNode(inorder[root_index], dfs(start, root_index-1), dfs(root_index+1, end))\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\\n\\n## 2. [Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/352aad74-b9e8-49a5-bc4b-4d00d46fdfd6_1660981274.7573395.png)\\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\\n## 3. [Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\\n![image](https://assets.leetcode.com/users/images/9e0a3581-d415-4359-a603-a02663830f54_1660981157.1101289.png)\\n```\\nclass Solution(object):\\n    def constructFromPrePost(self, preorder, postorder):\\n        preorder_map = {v:i for i, v in enumerate(preorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            if start == end: return TreeNode(postorder.pop())\\n            root = TreeNode(postorder.pop())\\n            print(postorder, start, end)\\n            right_start = preorder_map[postorder[-1]]\\n            root.right = dfs(right_start, end)\\n            root.left = dfs(start+1, right_start-1)\\n            return root\\n        \\n        return dfs(0, len(preorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        preorder = deque(preorder)\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root_index = inorder_map[preorder.popleft()]\\n            root = TreeNode(inorder[root_index], dfs(start, root_index-1), dfs(root_index+1, end))\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\n```\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        inorder_map = {val:i for i, val in enumerate(inorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            root = TreeNode(postorder.pop())\\n            root_index = inorder_map[root.val]\\n            root.right = dfs(root_index+1, end)  # have to put right before left because postorder.pop will return the right node first\\n            root.left = dfs(start, root_index-1)\\n            return root\\n        \\n        return dfs(0, len(inorder)-1)\\n```\n```\\nclass Solution(object):\\n    def constructFromPrePost(self, preorder, postorder):\\n        preorder_map = {v:i for i, v in enumerate(preorder)}\\n        \\n        def dfs(start, end):\\n            if start > end: return None\\n            if start == end: return TreeNode(postorder.pop())\\n            root = TreeNode(postorder.pop())\\n            print(postorder, start, end)\\n            right_start = preorder_map[postorder[-1]]\\n            root.right = dfs(right_start, end)\\n            root.left = dfs(start+1, right_start-1)\\n            return root\\n        \\n        return dfs(0, len(preorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419272,
                "title": "intuition-explained-o-n-c-solution",
                "content": "```\\nint i=0;\\n    unordered_map<int,int> m;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post,int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n            TreeNode* root= new TreeNode(pre[i++]);  //preordeer wala element root bnado\\n        \\n        //start==end hai to exit kro vrna endless loop me fas skta (start,idx) and for last element i++ will be out of bounds in preorder so in that case also return root\\n        \\n            if(i>=pre.size() or start==end)\\n                return root;\\n        \\n        //preorder ka agla element root->left ka head hai prr left subtree me kitne elements ayege ye decide krega postorder traversal start se idx tak left part hai idx+1 se end-1 tka right part hai . end of postorder = root;\\n        \\n        int idx=m[pre[i]];  \\n        \\n        root->left=solve(pre,post,start,idx);\\n        root->right=solve(pre,post,idx+1,end-1);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        for(int i=0;i<post.size();i++)  //for O(1) searchibg store in map\\n            m[post[i]]=i;\\n        \\n        return solve(pre,post,0,post.size()-1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint i=0;\\n    unordered_map<int,int> m;\\n    \\n    TreeNode* solve(vector<int>& pre, vector<int>& post,int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n            TreeNode* root= new TreeNode(pre[i++]);  //preordeer wala element root bnado\\n        \\n        //start==end hai to exit kro vrna endless loop me fas skta (start,idx) and for last element i++ will be out of bounds in preorder so in that case also return root\\n        \\n            if(i>=pre.size() or start==end)\\n                return root;\\n        \\n        //preorder ka agla element root->left ka head hai prr left subtree me kitne elements ayege ye decide krega postorder traversal start se idx tak left part hai idx+1 se end-1 tka right part hai . end of postorder = root;\\n        \\n        int idx=m[pre[i]];  \\n        \\n        root->left=solve(pre,post,start,idx);\\n        root->right=solve(pre,post,idx+1,end-1);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        for(int i=0;i<post.size();i++)  //for O(1) searchibg store in map\\n            m[post[i]]=i;\\n        \\n        return solve(pre,post,0,post.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2406697,
                "title": "c-recursive-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int> &preorder,unordered_map<int,int> &mp,\\n                   int pre_start,int pre_end,int post_start,int post_end)\\n    {\\n        if(pre_start>pre_end || post_start>post_end)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[pre_start]);\\n        if(pre_start==pre_end)\\n            return root;\\n        \\n        int temp=mp[preorder[pre_start+1]];\\n        int len=temp-post_start+1;\\n        \\n        root->left=solve(preorder, mp, pre_start+1, pre_start+len,\\n                        post_start,temp);\\n        root->right=solve(preorder, mp, pre_start+len+1, pre_end,\\n                         temp+1,post_end-1);\\n            \\n        return root;    \\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        int n=postorder.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[postorder[i]]=i;\\n        }\\n        return solve(preorder,mp,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int> &preorder,unordered_map<int,int> &mp,\\n                   int pre_start,int pre_end,int post_start,int post_end)\\n    {\\n        if(pre_start>pre_end || post_start>post_end)\\n            return NULL;\\n        \\n        TreeNode *root=new TreeNode(preorder[pre_start]);\\n        if(pre_start==pre_end)\\n            return root;\\n        \\n        int temp=mp[preorder[pre_start+1]];\\n        int len=temp-post_start+1;\\n        \\n        root->left=solve(preorder, mp, pre_start+1, pre_start+len,\\n                        post_start,temp);\\n        root->right=solve(preorder, mp, pre_start+len+1, pre_end,\\n                         temp+1,post_end-1);\\n            \\n        return root;    \\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,int> mp;\\n        int n=postorder.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[postorder[i]]=i;\\n        }\\n        return solve(preorder,mp,0,n-1,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378712,
                "title": "python-simple-recursion",
                "content": "\\n    def constructFromPrePost(self, preorder, postorder):\\n        if not preorder and not postorder:\\n            return None\\n        \\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        idx = postorder.index(preorder[1])\\n        \\n        root = TreeNode(preorder[0])\\n        root.left = self.constructFromPrePost(preorder[1:idx+2], postorder[:idx+1])\\n        root.right = self.constructFromPrePost(preorder[idx+2:], postorder[idx+1:-1])\\n        \\n        return root",
                "solutionTags": [],
                "code": "\\n    def constructFromPrePost(self, preorder, postorder):\\n        if not preorder and not postorder:\\n            return None\\n        \\n        if len(preorder) == 1:\\n            return TreeNode(preorder[0])\\n        \\n        idx = postorder.index(preorder[1])\\n        \\n        root = TreeNode(preorder[0])\\n        root.left = self.constructFromPrePost(preorder[1:idx+2], postorder[:idx+1])\\n        root.right = self.constructFromPrePost(preorder[idx+2:], postorder[idx+1:-1])\\n        \\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 2343606,
                "title": "python-recursive-solution",
                "content": "Below is the code\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder, preStart, preEnd, postorder, postStart, postEnd):\\n            if preStart > preEnd:\\n                return\\n            elif preStart == preEnd:\\n                return TreeNode(preorder[preStart])\\n            \\n            rootVal = preorder[preStart]\\n            leftRootVal = preorder[preStart + 1]\\n            index = valToIndex[leftRootVal]\\n            root = TreeNode(rootVal)\\n            leftSize = index - postStart + 1\\n            \\n            root.left = build(preorder, preStart + 1, preStart + leftSize,\\npostorder, postStart, index)\\n            root.right = build(preorder, preStart + leftSize + 1, preEnd,\\npostorder, index + 1, postEnd - 1)\\n            \\n            return root\\n        \\n        valToIndex = {}\\n        for i in range(len(postorder)):\\n            valToIndex[postorder[i]] = i\\n        \\n        return build(preorder, 0, len(preorder) - 1, postorder, 0, len(postorder) - 1)\\n```\\n\\nLeave a comment if you have questions !",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\n        def build(preorder, preStart, preEnd, postorder, postStart, postEnd):\\n            if preStart > preEnd:\\n                return\\n            elif preStart == preEnd:\\n                return TreeNode(preorder[preStart])\\n            \\n            rootVal = preorder[preStart]\\n            leftRootVal = preorder[preStart + 1]\\n            index = valToIndex[leftRootVal]\\n            root = TreeNode(rootVal)\\n            leftSize = index - postStart + 1\\n            \\n            root.left = build(preorder, preStart + 1, preStart + leftSize,\\npostorder, postStart, index)\\n            root.right = build(preorder, preStart + leftSize + 1, preEnd,\\npostorder, index + 1, postEnd - 1)\\n            \\n            return root\\n        \\n        valToIndex = {}\\n        for i in range(len(postorder)):\\n            valToIndex[postorder[i]] = i\\n        \\n        return build(preorder, 0, len(preorder) - 1, postorder, 0, len(postorder) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285366,
                "title": "iterative-stack-based-post-order-traversal",
                "content": "```\\n# include \"stdio.h\"\\n# include \"stdlib.h\"\\n# include \"stdbool.h\"\\n\\nstruct TreeNode {\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode* createTreeNode(int val) {\\n    struct TreeNode* new_tree_node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    new_tree_node->val = val;\\n    new_tree_node->left = NULL;\\n    new_tree_node->right = NULL;\\n    return new_tree_node;\\n}\\n\\nstruct StackElement{\\n    struct TreeNode* node;\\n    struct StackElement* next;\\n};\\n\\nstruct Stack{\\n    struct StackElement* top;\\n};\\n\\nstruct StackElement* createStackElement(struct TreeNode* node){\\n    struct StackElement* new_stack_element = (struct StackElement*)malloc(sizeof(struct StackElement));\\n    new_stack_element->node = node;\\n    new_stack_element->next = NULL;\\n    return new_stack_element;\\n}\\n\\nstruct Stack* createStack(){\\n    struct Stack* new_stack = (struct Stack*)malloc(sizeof(struct Stack));\\n    new_stack->top = NULL;\\n    return new_stack;\\n}\\n\\nvoid deleteStackElement(struct StackElement* stack_element){\\n    free(stack_element);\\n}\\n\\nstruct TreeNode* peekStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element) return top_element->node;\\n    return NULL;\\n}\\n\\nvoid addToStack(struct Stack* stack, struct TreeNode* node){\\n    struct StackElement* new_stack_element = createStackElement(node);\\n    new_stack_element->next = stack->top;\\n    stack->top = new_stack_element;\\n}\\n\\nstruct TreeNode* popFromStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element){\\n        stack->top = top_element->next;\\n        struct TreeNode* node_to_return = top_element->node;\\n        deleteStackElement(top_element);\\n        return node_to_return;\\n    }\\n    return NULL;\\n}\\n\\nvoid deleteStack(struct Stack* stack){\\n    while(popFromStack(stack));\\n    free(stack);\\n}\\n\\nstruct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }\\n        }\\n        // otherwise add the current node to the stack\\n        else addToStack(stack, new_node);\\n\\n        pre_order_pointer++;\\n    }\\n    deleteStack(stack);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# include \"stdio.h\"\\n# include \"stdlib.h\"\\n# include \"stdbool.h\"\\n\\nstruct TreeNode {\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode* createTreeNode(int val) {\\n    struct TreeNode* new_tree_node = (struct TreeNode*)malloc(sizeof(struct TreeNode));\\n    new_tree_node->val = val;\\n    new_tree_node->left = NULL;\\n    new_tree_node->right = NULL;\\n    return new_tree_node;\\n}\\n\\nstruct StackElement{\\n    struct TreeNode* node;\\n    struct StackElement* next;\\n};\\n\\nstruct Stack{\\n    struct StackElement* top;\\n};\\n\\nstruct StackElement* createStackElement(struct TreeNode* node){\\n    struct StackElement* new_stack_element = (struct StackElement*)malloc(sizeof(struct StackElement));\\n    new_stack_element->node = node;\\n    new_stack_element->next = NULL;\\n    return new_stack_element;\\n}\\n\\nstruct Stack* createStack(){\\n    struct Stack* new_stack = (struct Stack*)malloc(sizeof(struct Stack));\\n    new_stack->top = NULL;\\n    return new_stack;\\n}\\n\\nvoid deleteStackElement(struct StackElement* stack_element){\\n    free(stack_element);\\n}\\n\\nstruct TreeNode* peekStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element) return top_element->node;\\n    return NULL;\\n}\\n\\nvoid addToStack(struct Stack* stack, struct TreeNode* node){\\n    struct StackElement* new_stack_element = createStackElement(node);\\n    new_stack_element->next = stack->top;\\n    stack->top = new_stack_element;\\n}\\n\\nstruct TreeNode* popFromStack(struct Stack* stack){\\n    struct StackElement* top_element = stack->top;\\n    if(top_element){\\n        stack->top = top_element->next;\\n        struct TreeNode* node_to_return = top_element->node;\\n        deleteStackElement(top_element);\\n        return node_to_return;\\n    }\\n    return NULL;\\n}\\n\\nvoid deleteStack(struct Stack* stack){\\n    while(popFromStack(stack));\\n    free(stack);\\n}\\n\\nstruct TreeNode* constructFromPrePost(int* preorder, int preorderSize, int* postorder, int postorderSize){\\n    // create the stack\\n    struct Stack* stack = createStack();\\n\\n    // create a variable to store the root node\\n    struct TreeNode* root = NULL;\\n\\n    // create pointers for traversing preorder and postorder\\n    int pre_order_pointer = 0; \\n    int post_order_pointer = 0;\\n\\n    while(pre_order_pointer < preorderSize){\\n        // create a node from the current value of preorder array\\n        struct TreeNode* new_node = createTreeNode(preorder[pre_order_pointer]);\\n\\n        // get the node\\'s parent from the stack\\n        struct TreeNode* parent = peekStack(stack);\\n\\n        // create the tree\\n        if(!parent) root = new_node;\\n        else if(parent->left) parent->right = new_node;\\n        else parent->left = new_node;\\n\\n        // check if current preorder value is equal to current post order value\\n        if(preorder[pre_order_pointer] == postorder[post_order_pointer]){\\n            post_order_pointer++;\\n            // keep popping from the stack and incrementing post order until postorder[post_order_pointer] is different from the stack top value\\n            while(peekStack(stack) && postorder[post_order_pointer] == peekStack(stack)->val){\\n                popFromStack(stack);\\n                post_order_pointer++;\\n            }\\n        }\\n        // otherwise add the current node to the stack\\n        else addToStack(stack, new_node);\\n\\n        pre_order_pointer++;\\n    }\\n    deleteStack(stack);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282905,
                "title": "c-faster-soln",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        } \\n        int mid = 1;\\n        for (int i=1; i<=prej-prei; i++){\\n            if (pre[prei+i]==post[postj-1] && (i<2 || post[posti+i-2]==pre[prei+1])){\\n                mid = i; break;\\n            }\\n        }\\n        root->left = construct(pre, prei+1, prei+mid-1, post, posti, posti+mid-2);\\n        root->right = construct(pre, prei+mid, prej, post, posti+mid-1, postj-1);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        \\n        int prestart = 0;\\n        int preend = preorder.size()-1;\\n        \\n        int poststart = 0;\\n        int postend = postorder.size()-1;\\n        return construct(preorder,prestart,preend,postorder,poststart,postend);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* construct(vector<int>& pre, int prei, int prej, \\n                        vector<int>& post, int posti, int postj){\\n        if (prei>prej) return NULL;\\n        TreeNode* root = new TreeNode(pre[prei]);\\n        if (prei==prej){\\n            root->left = NULL; root->right = NULL;\\n            return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2249594,
                "title": "easy-java-implementation-with-explanation",
                "content": "As we know that the first node during preorder traversal is root and the last node during post order traversal is node. We are using this concept to build a binary tree with preorder and postorder traversal.\\n\\nApproach:\\n* Take a helper function which will return a TreeNode and pass 6 arguments- Preorder, preorder start index, preorder end index, Postorder, postorder start index, postorder end index.\\n* Since we are solving this recursively the base case would be if the preorder start index == preorder end index or it can be postorder start index == postorder end index i.e there is only one element in preorder and postorder and we surely know that this is the root node. So construct a node and return it.\\n* If the above condition is not true then we will update the four pointers pre start, pre end , post start, post end.\\n* The first element in preorder traversal is the root and the second element is going to come under the left subtree(here we are considering only full binary trees) so this becomes the preorder start index.\\n* To calculate the pre order end index we need to know the count of elements in the left sub tree . This can be done using the post order traversal.\\n* Iterate throught the post order and look for the index of the element preorder[preorder start +1] in post order.This index will become postorder end index for the leftSub tree.\\n* The count of elements in leftSub Tree will be postorder start index - index + 1.\\n* Now pre order end index = preorder start + count and post order start remain the same.\\n* Pass these arguments to get the left sub tree for root. and for root we will again calculate the 4 pointers\\n* Preorder start = preorder start + 1, preorder end = preorder end, \\n* Postorder start = index+1, postorder end = postorder end -1.\\n* Pass these arguments to get the right sub Tree of the root.\\n* And finally return the root.\\n\\n\\n\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        int ps = 0, pe=preorder.length-1;\\n        int pos = 0, poe= postorder.length-1;\\n        \\n        return constructTree(preorder,ps,pe,postorder,pos,poe);\\n    }\\n    \\n    public TreeNode constructTree(int[] preorder, int ps, int pe, int[] postorder, int pos,int poe){\\n        \\n        if(ps > pe) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[ps]);\\n        \\n        if(ps - pe == 0) return root;\\n        \\n        int index = -1;\\n        for(int i=poe-1; i >= pos; i--){\\n            if(postorder[i] == preorder[ps+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int count = index - pos + 1;\\n        \\n        root.left = constructTree(preorder, ps+1,ps+count, postorder, pos, index );\\n        root.right = constructTree(preorder, ps+count + 1, pe, postorder,index+1, poe-1);\\n        \\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        \\n        int ps = 0, pe=preorder.length-1;\\n        int pos = 0, poe= postorder.length-1;\\n        \\n        return constructTree(preorder,ps,pe,postorder,pos,poe);\\n    }\\n    \\n    public TreeNode constructTree(int[] preorder, int ps, int pe, int[] postorder, int pos,int poe){\\n        \\n        if(ps > pe) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[ps]);\\n        \\n        if(ps - pe == 0) return root;\\n        \\n        int index = -1;\\n        for(int i=poe-1; i >= pos; i--){\\n            if(postorder[i] == preorder[ps+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        \\n        int count = index - pos + 1;\\n        \\n        root.left = constructTree(preorder, ps+1,ps+count, postorder, pos, index );\\n        root.right = constructTree(preorder, ps+count + 1, pe, postorder,index+1, poe-1);\\n        \\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242692,
                "title": "java-faster-than-99-31-memory-less-than-77-45",
                "content": "```\\n\\'\\'\\'\\nclass Solution {\\n    public int findRoot(int[] postorder,int start, int end, int root)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n           if(postorder[i] == root) return i;\\n        }\\n    \\n        return -1;\\n    }\\n    \\n    public TreeNode buildFullBT(int[] postorder, int[] preorder, int preStart, int preEnd, int poStart, int poEnd)\\n    {\\n        \\n        if(preStart > preEnd) return null;\\n         if(preStart==preEnd) return new TreeNode(preorder[preStart]);\\n             \\n            \\n        TreeNode node  = new TreeNode(preorder[preStart]); \\n        int rootIndex = findRoot(postorder,poStart, poEnd, preorder[preStart + 1]);\\n        node.left = buildFullBT(postorder, preorder, preStart + 1, preStart + rootIndex - poStart + 1, poStart, rootIndex);\\n        \\n        node.right = buildFullBT(postorder, preorder, preEnd - poEnd + rootIndex + 2, preEnd, rootIndex + 1,\\n                                poEnd - 1);\\n        \\n        return node;\\n    }\\n        \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        \\n        return buildFullBT(postorder, preorder,0, preorder.length - 1, 0, postorder.length - 1);\\n        \\n        \\n        \\n    }\\n}\\n\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n\\'\\'\\'\\nclass Solution {\\n    public int findRoot(int[] postorder,int start, int end, int root)\\n    {\\n        for(int i = start; i <= end; i++)\\n        {\\n           if(postorder[i] == root) return i;\\n        }\\n    \\n        return -1;\\n    }\\n    \\n    public TreeNode buildFullBT(int[] postorder, int[] preorder, int preStart, int preEnd, int poStart, int poEnd)\\n    {\\n        \\n        if(preStart > preEnd) return null;\\n         if(preStart==preEnd) return new TreeNode(preorder[preStart]);\\n             \\n            \\n        TreeNode node  = new TreeNode(preorder[preStart]); \\n        int rootIndex = findRoot(postorder,poStart, poEnd, preorder[preStart + 1]);\\n        node.left = buildFullBT(postorder, preorder, preStart + 1, preStart + rootIndex - poStart + 1, poStart, rootIndex);\\n        \\n        node.right = buildFullBT(postorder, preorder, preEnd - poEnd + rootIndex + 2, preEnd, rootIndex + 1,\\n                                poEnd - 1);\\n        \\n        return node;\\n    }\\n        \\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder)\\n    {\\n        \\n        return buildFullBT(postorder, preorder,0, preorder.length - 1, 0, postorder.length - 1);\\n        \\n        \\n        \\n    }\\n}\\n\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242505,
                "title": "python3-same-template-to-solve-3-binary-tree-construction-problems",
                "content": "**Construct using Preorder and Postorder**\\n\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n        index = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])\\n        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])\\n        return root\\n```\\n\\n**Construct using Preorder and Inorder**\\n\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        mid = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1: mid+1], inorder[:mid])\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n        return root\\n```\\n\\n**Construct using Postorder and Inorder**\\n\\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not postorder or not inorder:\\n            return\\n        \\n        root = TreeNode(postorder[-1])\\n        mid = inorder.index(postorder[-1])\\n        root.left = self.buildTree(inorder[:mid], postorder[:mid])\\n        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])\\n        return root\\n        \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n        index = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:index+2], postorder[:index+1])\\n        root.right = self.constructFromPrePost(preorder[index+2:], postorder[index+1:-1])\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not inorder:\\n            return\\n        \\n        root = TreeNode(preorder[0])\\n        mid = inorder.index(preorder[0])\\n        root.left = self.buildTree(preorder[1: mid+1], inorder[:mid])\\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\\n        return root\\n```\n```\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not postorder or not inorder:\\n            return\\n        \\n        root = TreeNode(postorder[-1])\\n        mid = inorder.index(postorder[-1])\\n        root.left = self.buildTree(inorder[:mid], postorder[:mid])\\n        root.right = self.buildTree(inorder[mid+1:], postorder[mid:-1])\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222353,
                "title": "java-solution-very-easy-approach-easy-and-simple-to-understand",
                "content": "```\\nclass Solution {\\n    TreeNode tree_builder(int[] preorder,int preStart,int preEnd, int[] postorder,int poStart,int posEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        if(preStart==preEnd)return root;\\n        int idx=poStart;\\n        while(postorder[idx]!=preorder[preStart+1]){\\n            idx++;\\n        }\\n        int total_elements=(idx-poStart)+1;\\n        root.left=tree_builder(preorder,preStart+1,preStart+total_elements,postorder,poStart,idx);\\n        root.right=tree_builder(preorder,preStart+total_elements+1,preEnd,postorder,idx+1,posEnd-1);\\n        \\n        return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return tree_builder(preorder,0,preorder.length-1,postorder,0,postorder.length-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree_builder(int[] preorder,int preStart,int preEnd, int[] postorder,int poStart,int posEnd){\\n        if(preStart>preEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(preorder[preStart]);\\n        if(preStart==preEnd)return root;\\n        int idx=poStart;\\n        while(postorder[idx]!=preorder[preStart+1]){\\n            idx++;\\n        }\\n        int total_elements=(idx-poStart)+1;\\n        root.left=tree_builder(preorder,preStart+1,preStart+total_elements,postorder,poStart,idx);\\n        root.right=tree_builder(preorder,preStart+total_elements+1,preEnd,postorder,idx+1,posEnd-1);\\n        \\n        return root;\\n    }\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return tree_builder(preorder,0,preorder.length-1,postorder,0,postorder.length-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219852,
                "title": "c-easy-recursion",
                "content": "Please Upvote :)\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int vis[32];\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        memset(vis,0,sizeof(vis));\\n        return fun(preorder,0,postorder,postorder.size()-1);\\n    }\\n    TreeNode* fun(vector<int>& pre,int p,vector<int>& post,int q)\\n    {\\n        //cout<<\"Initial : \\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        TreeNode* root=new TreeNode(pre[p]);\\n        vis[root->val]=1;\\n        p++;\\n        q--;\\n        //cout<<root->val<<\"\\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        \\n        if(q<0 || p>=pre.size())\\n            return root;\\n        \\n        if(vis[pre[p]]==0)\\n        {\\n            int j=q;\\n            while(j>0 && post[j]!=pre[p])\\n                j--;\\n            if(post[j]==pre[p])\\n                root->left=fun(pre,p,post,j);\\n        }\\n        if(vis[post[q]]==0)\\n        {\\n            int j=p;\\n            while(j<pre.size()-1 && pre[j]!=post[q])\\n                j++;\\n            if(pre[j]==post[q])\\n            root->right=fun(pre,j,post,q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int vis[32];\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        memset(vis,0,sizeof(vis));\\n        return fun(preorder,0,postorder,postorder.size()-1);\\n    }\\n    TreeNode* fun(vector<int>& pre,int p,vector<int>& post,int q)\\n    {\\n        //cout<<\"Initial : \\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        TreeNode* root=new TreeNode(pre[p]);\\n        vis[root->val]=1;\\n        p++;\\n        q--;\\n        //cout<<root->val<<\"\\\\t\"<<p<<\"\\\\t\"<<q<<endl;\\n        \\n        if(q<0 || p>=pre.size())\\n            return root;\\n        \\n        if(vis[pre[p]]==0)\\n        {\\n            int j=q;\\n            while(j>0 && post[j]!=pre[p])\\n                j--;\\n            if(post[j]==pre[p])\\n                root->left=fun(pre,p,post,j);\\n        }\\n        if(vis[post[q]]==0)\\n        {\\n            int j=p;\\n            while(j<pre.size()-1 && pre[j]!=post[q])\\n                j++;\\n            if(pre[j]==post[q])\\n            root->right=fun(pre,j,post,q);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2182173,
                "title": "java-solution-recursive-both-approach-using-hashmap-and-normal",
                "content": "**No Extra Space : 2MS**\\n```\\nclass Solution {\\n    static int index;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        int mid;\\n        for(mid=start; mid<=end; mid++){\\n            if(postorder[mid] == preorder[index]){\\n                break;\\n            }\\n        }\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\n\\n**Using Extra Space , HashMap : 1MS**\\n```\\nclass Solution {\\n    static int index;\\n    static HashMap<Integer,Integer> map = new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        for(int i=0;i<postorder.length;i++){\\n            map.put(postorder[i],i);\\n        }\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        \\n        \\n        int mid = map.get(preorder[index]);\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int index;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        int mid;\\n        for(mid=start; mid<=end; mid++){\\n            if(postorder[mid] == preorder[index]){\\n                break;\\n            }\\n        }\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static int index;\\n    static HashMap<Integer,Integer> map = new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        if(preorder.length != postorder.length) return null;\\n        index = 0;\\n        for(int i=0;i<postorder.length;i++){\\n            map.put(postorder[i],i);\\n        }\\n        TreeNode root = Solve(preorder,postorder,0,postorder.length-1);\\n        return root;\\n    }\\n    \\n    public TreeNode Solve(int[] preorder, int[] postorder, int start, int end){\\n        if(index >= postorder.length || start > end ){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        if(start == end || index >= postorder.length){\\n            return root;\\n        }\\n        \\n        \\n        \\n        int mid = map.get(preorder[index]);\\n        \\n        if(mid<=end){\\n            root.left = Solve(preorder,postorder,start,mid);\\n            root.right = Solve(preorder,postorder,mid+1,end-1);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147478,
                "title": "cpp-tree",
                "content": "```\\nNode* HelperFunction(vector<int> preorder, int preorderStartIdx, int preorderEndIdx,\\n                     vector<int> postorder, int postorderStartIdx, int postorderEndIdx) {\\n\\tif (preorderStartIdx > preorderEndIdx) return NULL;\\n\\n\\tNode* node = new Node(postorder[postorderEndIdx]);\\n\\t//edge case\\n\\tif (preorderStartIdx == preorderEndIdx) return node;\\n\\n\\tint idx = postorderStartIdx;\\n\\twhile (postorder[idx] != preorder[preorderStartIdx + 1]) idx++;\\n\\tint countOfElements = idx - postorderStartIdx + 1;\\n\\n\\t//recursive calls\\n\\tnode->left = HelperFunction(preorder, preorderStartIdx + 1, preorderStartIdx + countOfElements, postorder, postorderStartIdx, idx);\\n\\tnode->right = HelperFunction(preorder, preorderStartIdx + countOfElements + 1, preorderEndIdx, postorder, idx + 1, postorderEndIdx - 1);\\n\\n\\treturn node;\\n}\\n\\nNode* constructBTFromPostorderAndpreorder(vector<int> postorder, vector<int> preorder) {\\n\\tint n = preorder.size();\\n\\treturn HelperFunction(preorder, 0, n - 1, postorder, 0 , n - 1);\\n}",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nNode* HelperFunction(vector<int> preorder, int preorderStartIdx, int preorderEndIdx,\\n                     vector<int> postorder, int postorderStartIdx, int postorderEndIdx) {\\n\\tif (preorderStartIdx > preorderEndIdx) return NULL;\\n\\n\\tNode* node = new Node(postorder[postorderEndIdx]);\\n\\t//edge case\\n\\tif (preorderStartIdx == preorderEndIdx) return node;\\n\\n\\tint idx = postorderStartIdx;\\n\\twhile (postorder[idx] != preorder[preorderStartIdx + 1]) idx++;\\n\\tint countOfElements = idx - postorderStartIdx + 1;\\n\\n\\t//recursive calls\\n\\tnode->left = HelperFunction(preorder, preorderStartIdx + 1, preorderStartIdx + countOfElements, postorder, postorderStartIdx, idx);\\n\\tnode->right = HelperFunction(preorder, preorderStartIdx + countOfElements + 1, preorderEndIdx, postorder, idx + 1, postorderEndIdx - 1);\\n\\n\\treturn node;\\n}\\n\\nNode* constructBTFromPostorderAndpreorder(vector<int> postorder, vector<int> preorder) {\\n\\tint n = preorder.size();\\n\\treturn HelperFunction(preorder, 0, n - 1, postorder, 0 , n - 1);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2136783,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def build(preLeft, preRight):\\n            if preLeft > preRight:\\n                return None\\n            \\n            # food for thought: why do we need this base case?\\n            if preLeft == preRight:\\n                root = TreeNode(postorder[self.postIdx])\\n                self.postIdx -= 1\\n                return root\\n            \\n            rootVal = postorder[self.postIdx]\\n            root = TreeNode(rootVal)\\n            self.postIdx -= 1\\n            \\n            cutIdx = mp[postorder[self.postIdx]]\\n            root.right = build(cutIdx, preRight)\\n            root.left = build(preLeft + 1, cutIdx - 1)\\n            return root\\n            \\n        \\n        self.postIdx = len(postorder) - 1\\n        mp = {val : idx for idx, val in enumerate(preorder)}\\n        return build(0, len(preorder) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def build(preLeft, preRight):\\n            if preLeft > preRight:\\n                return None\\n            \\n            # food for thought: why do we need this base case?\\n            if preLeft == preRight:\\n                root = TreeNode(postorder[self.postIdx])\\n                self.postIdx -= 1\\n                return root\\n            \\n            rootVal = postorder[self.postIdx]\\n            root = TreeNode(rootVal)\\n            self.postIdx -= 1\\n            \\n            cutIdx = mp[postorder[self.postIdx]]\\n            root.right = build(cutIdx, preRight)\\n            root.left = build(preLeft + 1, cutIdx - 1)\\n            return root\\n            \\n        \\n        self.postIdx = len(postorder) - 1\\n        mp = {val : idx for idx, val in enumerate(preorder)}\\n        return build(0, len(preorder) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078080,
                "title": "simple-js-solution-w-comments-dfs",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 113 ms, faster than 72.50% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n// Memory Usage: 45.3 MB, less than 18.33% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nconst constructFromPrePost = (preorder, postorder) => {\\n\\tlet preIdx = 0;\\n\\tlet postIdx = 0;\\n\\n\\tconst traverse = () => {\\n\\t\\tconst root = new TreeNode(preorder[preIdx++]);\\n\\n\\t\\t// when preorder[preIdx] !== postorder[postIdx], create current Left/Right subtree\\n\\t\\t// when preorder[preIdx] === postorder[postIdx], completed building current Left/Right subtree\\n\\t\\tif (root.val !== postorder[postIdx]) root.left = traverse();\\n\\t\\tif (root.val !== postorder[postIdx]) root.right = traverse();\\n\\n\\t\\t// increment postIdx to switch on to other side of the subtree\\n\\t\\tpostIdx++;\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\treturn traverse();\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 113 ms, faster than 72.50% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n// Memory Usage: 45.3 MB, less than 18.33% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nconst constructFromPrePost = (preorder, postorder) => {\\n\\tlet preIdx = 0;\\n\\tlet postIdx = 0;\\n\\n\\tconst traverse = () => {\\n\\t\\tconst root = new TreeNode(preorder[preIdx++]);\\n\\n\\t\\t// when preorder[preIdx] !== postorder[postIdx], create current Left/Right subtree\\n\\t\\t// when preorder[preIdx] === postorder[postIdx], completed building current Left/Right subtree\\n\\t\\tif (root.val !== postorder[postIdx]) root.left = traverse();\\n\\t\\tif (root.val !== postorder[postIdx]) root.right = traverse();\\n\\n\\t\\t// increment postIdx to switch on to other side of the subtree\\n\\t\\tpostIdx++;\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\treturn traverse();\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052580,
                "title": "python-recursive-solutoin",
                "content": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        postorder.pop(-1)\\n        \\n        if preorder:\\n            char = preorder[0]\\n            i = postorder.index(char)\\n            root.left = self.constructFromPrePost(preorder[0: i + 1], postorder[0:i+1])\\n            root.right = self.constructFromPrePost(preorder[i+1:], postorder[i+1:])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder or not postorder:\\n            return None\\n        \\n        root = TreeNode(preorder.pop(0))\\n        postorder.pop(-1)\\n        \\n        if preorder:\\n            char = preorder[0]\\n            i = postorder.index(char)\\n            root.left = self.constructFromPrePost(preorder[0: i + 1], postorder[0:i+1])\\n            root.right = self.constructFromPrePost(preorder[i+1:], postorder[i+1:])\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2044852,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int preInd = 0, postInd = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode *root = new TreeNode(pre[preInd++]);\\n        if(root->val != post[postInd]) {\\n            root->left = constructFromPrePost(pre, post);\\n        }\\n        if(root->val != post[postInd]) {\\n            root->right = constructFromPrePost(pre, post);\\n        }\\n        postInd++;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int preInd = 0, postInd = 0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode *root = new TreeNode(pre[preInd++]);\\n        if(root->val != post[postInd]) {\\n            root->left = constructFromPrePost(pre, post);\\n        }\\n        if(root->val != post[postInd]) {\\n            root->right = constructFromPrePost(pre, post);\\n        }\\n        postInd++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940467,
                "title": "python-3-reursive-9-line",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder: return None\\n        n = len(preorder)\\n        if n == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        idx = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:idx + 2], postorder[:idx + 1])\\n        root.right = self.constructFromPrePost(preorder[idx + 2:], postorder[idx + 1:- 1])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        if not preorder: return None\\n        n = len(preorder)\\n        if n == 1:\\n            return TreeNode(preorder[0])\\n        \\n        root = TreeNode(preorder[0])\\n        idx = postorder.index(preorder[1])\\n        root.left = self.constructFromPrePost(preorder[1:idx + 2], postorder[:idx + 1])\\n        root.right = self.constructFromPrePost(preorder[idx + 2:], postorder[idx + 1:- 1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812417,
                "title": "java-o-n-clean-solutions",
                "content": "Here I provide 1 solutions with 2 different implementations. \\nThe longer and slower one comes first (but may be easier to follow).\\n\\nWe can build the tree by doing a preorder traversal with the only added constraint that **parent post index > child post index**.\\n\\nIn general, when it comes to following two different traversals, we can just simulate the process straight up with 1 traversal + the constraint from the other traversal mixed in.\\n\\n**Solution 1 (Queue):** [<ins>Average Speed</ins>]\\n```Java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i; // quick lookup array\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int p : preorder){\\n            queue.offer(p);\\n        }\\n        return build(queue, queue.peek(), preorder, post);\\n    }\\n\\n    private TreeNode build(Queue<Integer> queue, int parent, int[] pre, int[] post){\\n        if (queue.isEmpty()) return null;\\n        if (post[queue.peek()] > post[parent]) return null;  \\n        int val = queue.poll();\\n        return new TreeNode(val, build(queue, val, pre, post), \\n                                 build(queue, val, pre, post));\\n    }\\n}\\n```\\n\\nHere is the array version for those who dislike queue. \\nIt runs faster because of less overhead and one less O(n) processing loop in the beginning.\\n\\n**Solution 2 (Array)** [<ins>Beat 90% Speed</ins>]:\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i;\\n        }\\n        return build(new int[]{0}, 0, preorder, post);\\n    }\\n\\n    private TreeNode build(int[] cur, int parent, int[] pre, int[] post){\\n        if (cur[0] >= pre.length) return null;\\n        if (post[pre[cur[0]]] > post[pre[parent]]) return null;\\n        int idx = cur[0]++;\\n        return new TreeNode(pre[idx], \\n                            build(cur, idx, pre, post), \\n                            build(cur, idx, pre, post));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i; // quick lookup array\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int p : preorder){\\n            queue.offer(p);\\n        }\\n        return build(queue, queue.peek(), preorder, post);\\n    }\\n\\n    private TreeNode build(Queue<Integer> queue, int parent, int[] pre, int[] post){\\n        if (queue.isEmpty()) return null;\\n        if (post[queue.peek()] > post[parent]) return null;  \\n        int val = queue.poll();\\n        return new TreeNode(val, build(queue, val, pre, post), \\n                                 build(queue, val, pre, post));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        int n = postorder.length;\\n        int[] post = new int[n + 1];\\n        for (int i = 0; i < n; i++){\\n            post[postorder[i]] = i;\\n        }\\n        return build(new int[]{0}, 0, preorder, post);\\n    }\\n\\n    private TreeNode build(int[] cur, int parent, int[] pre, int[] post){\\n        if (cur[0] >= pre.length) return null;\\n        if (post[pre[cur[0]]] > post[pre[parent]]) return null;\\n        int idx = cur[0]++;\\n        return new TreeNode(pre[idx], \\n                            build(cur, idx, pre, post), \\n                            build(cur, idx, pre, post));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770133,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def construct(self, pre, post):\\n        if post:\\n            if len(post) == 1:\\n                return TreeNode(pre.pop(0))\\n            root_val = pre.pop(0)\\n            ind = post.index(pre[0])\\n            root = TreeNode(root_val)\\n            root.left = self.construct(pre, post[:ind+1])\\n            root.right = self.construct(pre, post[ind+1:-1])\\n            return root\\n        \\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        return self.construct(preorder, postorder)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def construct(self, pre, post):\\n        if post:\\n            if len(post) == 1:\\n                return TreeNode(pre.pop(0))\\n            root_val = pre.pop(0)\\n            ind = post.index(pre[0])\\n            root = TreeNode(root_val)\\n            root.left = self.construct(pre, post[:ind+1])\\n            root.right = self.construct(pre, post[ind+1:-1])\\n            return root\\n        \\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        return self.construct(preorder, postorder)",
                "codeTag": "Java"
            },
            {
                "id": 1689086,
                "title": "java-dfs-o-n-beats-100",
                "content": "Please upvote if you find it helpful! Or leave comments or suggestions below!\\nI will try my best to answer them! Thank you so much!!\\n\\n```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return dfs(preorder, 0, preorder.length-1, postorder, 0, postorder.length-1);\\n    }\\n    \\n    private TreeNode dfs(int[] preorder, int preLeft, int preRight, int[] postorder, int postLeft, int postRight) {\\n        if (preLeft == preRight) return new TreeNode(preorder[preLeft]);\\n        \\n        TreeNode curRoot = new TreeNode(preorder[preLeft]);\\n        int leftChildIdx = findIdx(postorder, postLeft, postRight, preorder[preLeft + 1]); \\n        int numOfLeftChild = leftChildIdx - postLeft + 1;   \\n        \\n        if (leftChildIdx == (postRight - 1)) {\\n            // if this node has only one child, then it could be right or left child.\\n            curRoot.left = dfs(preorder, preLeft + 1, preRight, postorder, postLeft, postRight - 1);\\n        } else {\\n            curRoot.left = dfs(preorder, preLeft + 1, preLeft + numOfLeftChild, postorder, postLeft, postLeft + numOfLeftChild - 1);\\n            curRoot.right = dfs(preorder, preLeft + numOfLeftChild + 1, preRight, postorder, postLeft + numOfLeftChild, postRight - 1);\\n        }\\n        \\n        return curRoot;\\n    }\\n    \\n    private int findIdx(int[] postorder, int postLeft, int postRight, int target) {\\n        \\n        for (int i = postLeft; i <= postRight; i++) {\\n            if (postorder[i] == target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        return dfs(preorder, 0, preorder.length-1, postorder, 0, postorder.length-1);\\n    }\\n    \\n    private TreeNode dfs(int[] preorder, int preLeft, int preRight, int[] postorder, int postLeft, int postRight) {\\n        if (preLeft == preRight) return new TreeNode(preorder[preLeft]);\\n        \\n        TreeNode curRoot = new TreeNode(preorder[preLeft]);\\n        int leftChildIdx = findIdx(postorder, postLeft, postRight, preorder[preLeft + 1]); \\n        int numOfLeftChild = leftChildIdx - postLeft + 1;   \\n        \\n        if (leftChildIdx == (postRight - 1)) {\\n            // if this node has only one child, then it could be right or left child.\\n            curRoot.left = dfs(preorder, preLeft + 1, preRight, postorder, postLeft, postRight - 1);\\n        } else {\\n            curRoot.left = dfs(preorder, preLeft + 1, preLeft + numOfLeftChild, postorder, postLeft, postLeft + numOfLeftChild - 1);\\n            curRoot.right = dfs(preorder, preLeft + numOfLeftChild + 1, preRight, postorder, postLeft + numOfLeftChild, postRight - 1);\\n        }\\n        \\n        return curRoot;\\n    }\\n    \\n    private int findIdx(int[] postorder, int postLeft, int postRight, int target) {\\n        \\n        for (int i = postLeft; i <= postRight; i++) {\\n            if (postorder[i] == target) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678044,
                "title": "o-n-time-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        p=preorder.length-1;\\n        return generateTree(preorder,postorder,0,preorder.length-1);\\n    }\\n    public TreeNode generateTree(int[] preorder,int [] postorder,int s,int e){\\n        if(s>e) return null;\\n        TreeNode node = new TreeNode(postorder[p],null,null);\\n        int k=e+1;\\n        p--;\\n        for(int i=s+1;i<=e;i++){\\n            if(preorder[i] == postorder[p]){\\n                k=i;break;\\n            }\\n        }\\n        TreeNode right = generateTree(preorder,postorder,k,e);\\n        TreeNode left = generateTree(preorder,postorder,s+1,k-1);\\n        node.left = left;\\n        node.right = right;\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int p=0;\\n    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {\\n        p=preorder.length-1;\\n        return generateTree(preorder,postorder,0,preorder.length-1);\\n    }\\n    public TreeNode generateTree(int[] preorder,int [] postorder,int s,int e){\\n        if(s>e) return null;\\n        TreeNode node = new TreeNode(postorder[p],null,null);\\n        int k=e+1;\\n        p--;\\n        for(int i=s+1;i<=e;i++){\\n            if(preorder[i] == postorder[p]){\\n                k=i;break;\\n            }\\n        }\\n        TreeNode right = generateTree(preorder,postorder,k,e);\\n        TreeNode left = generateTree(preorder,postorder,s+1,k-1);\\n        node.left = left;\\n        node.right = right;\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651685,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void printvec (vector<int> p) {\\n        cout << \"print vec \" << endl;\\n        \\n        for(auto i : p) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int> postorder, int &index) {\\n        if (postorder.size() == 0) return NULL;\\n        if (index >= preorder.size()) return NULL;\\n        //cout << \"index is \" << index << endl;\\n        //printvec(postorder);\\n        \\n        TreeNode* temp = new TreeNode(preorder[index]);\\n        postorder.pop_back();\\n        index++;\\n        if (index >= preorder.size() || postorder.size() == 0) {\\n            return temp;\\n        }\\n        vector<int> post1;\\n        vector<int> post2;\\n        int i = 0;\\n        while (postorder[i] != preorder[index]) {\\n            post1.push_back(postorder[i]);\\n            i++;\\n        }\\n        post1.push_back(postorder[i]);\\n        i++;\\n        temp->left = helper(preorder, post1, index);\\n        while(i < postorder.size()) {\\n            post2.push_back(postorder[i]);\\n            i++;\\n        }\\n        \\n        temp->right =  helper(preorder, post2, index);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int index = 0;\\n        return helper(preorder, postorder, index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void printvec (vector<int> p) {\\n        cout << \"print vec \" << endl;\\n        \\n        for(auto i : p) {\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n    }\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int> postorder, int &index) {\\n        if (postorder.size() == 0) return NULL;\\n        if (index >= preorder.size()) return NULL;\\n        //cout << \"index is \" << index << endl;\\n        //printvec(postorder);\\n        \\n        TreeNode* temp = new TreeNode(preorder[index]);\\n        postorder.pop_back();\\n        index++;\\n        if (index >= preorder.size() || postorder.size() == 0) {\\n            return temp;\\n        }\\n        vector<int> post1;\\n        vector<int> post2;\\n        int i = 0;\\n        while (postorder[i] != preorder[index]) {\\n            post1.push_back(postorder[i]);\\n            i++;\\n        }\\n        post1.push_back(postorder[i]);\\n        i++;\\n        temp->left = helper(preorder, post1, index);\\n        while(i < postorder.size()) {\\n            post2.push_back(postorder[i]);\\n            i++;\\n        }\\n        \\n        temp->right =  helper(preorder, post2, index);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        int index = 0;\\n        return helper(preorder, postorder, index);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1615841,
                "title": "python3-both-o-n-2-and-o-n-solution",
                "content": "**O(N^2)** solution\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def findRootOfLeftSubTreeInPostorderArray(num):\\n            for i in range(len(postorder)):\\n                if postorder[i] == num:\\n                    return i\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = findRootOfLeftSubTreeInPostorderArray(preorder[preStart+1])\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n               \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n````\\nOptimize above code using dictionary(in python)/ hashmap(in java) to **O(N)**\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = postorderMap[preorder[preStart+1]]\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n        \\n        postorderMap = {}\\n        for i, value in enumerate(postorder):\\n            postorderMap[value] = i\\n            \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```\\nFor optimized soln extra space increases the space complexity to O(len(postorder)) ~ O(N)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def findRootOfLeftSubTreeInPostorderArray(num):\\n            for i in range(len(postorder)):\\n                if postorder[i] == num:\\n                    return i\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = findRootOfLeftSubTreeInPostorderArray(preorder[preStart+1])\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n               \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        \\n        def dfs(preStart, preEnd, postStart, postEnd):\\n            if preStart>preEnd: return None\\n            root = TreeNode(preorder[preStart])            \\n            if preStart == preEnd: return root\\n            \\n            idx = postorderMap[preorder[preStart+1]]\\n            l = idx - postStart + 1\\n            root.left = dfs(preStart+1, preStart+l, postStart, idx)\\n            root.right = dfs(preStart+l+1, preEnd, idx+1, postEnd)\\n            \\n            return root\\n        \\n        postorderMap = {}\\n        for i, value in enumerate(postorder):\\n            postorderMap[value] = i\\n            \\n        return dfs(0, len(preorder)-1, 0, len(postorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594376,
                "title": "python-devide-and-conquer-with-explaination",
                "content": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\t\"\"\"\\n\\t\\tpre:1,2,4,5,3,6,7\\n\\t\\tpost:4,5,2,6,7,3,1\\n\\t\\t=> \\n\\t\\troot=1\\n\\t\\tleft node-----       ----------post_idx\\n\\t\\t\\t\\t\\t |       |\\n\\t\\t\\t\\tpre:(2,4,5),(3,6,7)\\n\\t\\t\\t\\tpost:(4,5,2),(6,7,3)\\n\\t\\t------pre_idx-----^        ^----right node\\n\\n\\t\\tpre_idx = post.index(2) = 2\\n\\t\\tpost_idx = pre.index(3) = 3\\n\\t\\t1.left = pre:[2,4,5]=pre[:3]=pre[:pre_idx+1], post:[4,5,2]=post[:3]=post[:pre_idx+1]\\n\\t\\t1.right = pre:[3,6,7]=pre[3:]=pre[post_idx:], post:[6,7,3]=post[3:]=post[pre_idx+1:]\\n\\n\\t\"\"\"\\n\\tdef build(pre, post):\\n\\t\\tif len(pre) != len(post):\\n\\t\\t\\treturn None\\n\\t\\troot = TreeNode(pre.pop(0)) # root node is the first in pre order\\n\\t\\tpost.remove(root.val) # remove it from post order\\n\\n\\t\\tif not pre:\\n\\t\\t\\treturn root\\n\\t\\tpre_idx = post.index(pre[0]) # assume pre[0] is the left node, find its index in post order\\n\\t\\tpost_idx = pre.index(post[-1]) # assume post[-1] is the right node, find its index in pre order\\n\\t\\troot.left = build(pre[:pre_idx+1], post[:pre_idx+1]) # devide and conquer\\n\\t\\troot.right = build(pre[post_idx:], post[pre_idx+1:])\\n\\t\\treturn root\\n\\treturn build(preorder, postorder)\\n```",
                "solutionTags": [],
                "code": "```\\ndef constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n\\t\"\"\"\\n\\t\\tpre:1,2,4,5,3,6,7\\n\\t\\tpost:4,5,2,6,7,3,1\\n\\t\\t=> \\n\\t\\troot=1\\n\\t\\tleft node-----       ----------post_idx\\n\\t\\t\\t\\t\\t |       |\\n\\t\\t\\t\\tpre:(2,4,5),(3,6,7)\\n\\t\\t\\t\\tpost:(4,5,2),(6,7,3)\\n\\t\\t------pre_idx-----^        ^----right node\\n\\n\\t\\tpre_idx = post.index(2) = 2\\n\\t\\tpost_idx = pre.index(3) = 3\\n\\t\\t1.left = pre:[2,4,5]=pre[:3]=pre[:pre_idx+1], post:[4,5,2]=post[:3]=post[:pre_idx+1]\\n\\t\\t1.right = pre:[3,6,7]=pre[3:]=pre[post_idx:], post:[6,7,3]=post[3:]=post[pre_idx+1:]\\n\\n\\t\"\"\"\\n\\tdef build(pre, post):\\n\\t\\tif len(pre) != len(post):\\n\\t\\t\\treturn None\\n\\t\\troot = TreeNode(pre.pop(0)) # root node is the first in pre order\\n\\t\\tpost.remove(root.val) # remove it from post order\\n\\n\\t\\tif not pre:\\n\\t\\t\\treturn root\\n\\t\\tpre_idx = post.index(pre[0]) # assume pre[0] is the left node, find its index in post order\\n\\t\\tpost_idx = pre.index(post[-1]) # assume post[-1] is the right node, find its index in pre order\\n\\t\\troot.left = build(pre[:pre_idx+1], post[:pre_idx+1]) # devide and conquer\\n\\t\\troot.right = build(pre[post_idx:], post[pre_idx+1:])\\n\\t\\treturn root\\n\\treturn build(preorder, postorder)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1570887,
                "title": "c-o-n-easy-to-understand",
                "content": "Logic very similar to my [this](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/492724/very-easy-to-understand-recursive-solution-with-explanation-and-diagram) explanation of Leetcode 106\\n```\\nmap<int, int> mapp;\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& postorder, int preS, int preE, int posS, int posE){\\n        if((preS>preE) || (posS>posE)) return NULL;\\n        int rootData = preorder[preS];\\n        TreeNode* root = new TreeNode(rootData);\\n        if(preS==preE || posS==posE) return root;\\n        int rpreE = preE;\\n        int lposS = posS;\\n        int lpreS = preS+1;\\n        int rposE = posE-1;\\n        \\n        //following line is the main logic \\n        int lposE= mapp[preorder[preS+1]];\\n\\n        int rposS = lposE+1;\\n        int lpreE = lpreS+lposE-lposS;\\n        int rpreS = lpreE+1;\\n        root->left = helper(preorder, postorder, lpreS, lpreE, lposS, lposE);\\n        root->right = helper(preorder, postorder, rpreS, rpreE, rposS, rposE);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        mapp.clear();\\n        for(int i=0; i<postorder.size(); i++){\\n            mapp[postorder[i]]=i;\\n        }\\n        return helper(preorder, postorder, 0, preorder.size()-1, 0, postorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nmap<int, int> mapp;\\nclass Solution {\\npublic:\\n    \\n    TreeNode* helper(vector<int>& preorder, vector<int>& postorder, int preS, int preE, int posS, int posE){\\n        if((preS>preE) || (posS>posE)) return NULL;\\n        int rootData = preorder[preS];\\n        TreeNode* root = new TreeNode(rootData);\\n        if(preS==preE || posS==posE) return root;\\n        int rpreE = preE;\\n        int lposS = posS;\\n        int lpreS = preS+1;\\n        int rposE = posE-1;\\n        \\n        //following line is the main logic \\n        int lposE= mapp[preorder[preS+1]];\\n\\n        int rposS = lposE+1;\\n        int lpreE = lpreS+lposE-lposS;\\n        int rpreS = lpreE+1;\\n        root->left = helper(preorder, postorder, lpreS, lpreE, lposS, lposE);\\n        root->right = helper(preorder, postorder, rpreS, rpreE, rposS, rposE);\\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        mapp.clear();\\n        for(int i=0; i<postorder.size(); i++){\\n            mapp[postorder[i]]=i;\\n        }\\n        return helper(preorder, postorder, 0, preorder.size()-1, 0, postorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569258,
                "title": "c-stack-based-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<TreeNode*> stk;\\n        int j = 0;\\n        TreeNode* head = nullptr;\\n        for (int i = 0; i < preorder.size(); i++) {\\n            TreeNode* node = new TreeNode(preorder[i]);\\n            if (i == 0) head = node;\\n            if (!stk.empty()) {\\n                if (!stk.top()->left)\\n                    stk.top()->left = node;\\n                else\\n                    stk.top()->right = node;\\n            }\\n            stk.push(node);\\n            while (!stk.empty() && postorder[j] == stk.top()->val) {\\n                stk.pop();\\n                j++;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        stack<TreeNode*> stk;\\n        int j = 0;\\n        TreeNode* head = nullptr;\\n        for (int i = 0; i < preorder.size(); i++) {\\n            TreeNode* node = new TreeNode(preorder[i]);\\n            if (i == 0) head = node;\\n            if (!stk.empty()) {\\n                if (!stk.top()->left)\\n                    stk.top()->left = node;\\n                else\\n                    stk.top()->right = node;\\n            }\\n            stk.push(node);\\n            while (!stk.empty() && postorder[j] == stk.top()->val) {\\n                stk.pop();\\n                j++;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564989,
                "title": "c-easy-solution-using-map",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,TreeNode*> m;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        m[preorder[0]]=root;\\n        for(int i=1;i<preorder.size();++i){\\n            int j=0;\\n            for(;j<postorder.size();++j)\\n                if(preorder[i]==postorder[j]) break;\\n            TreeNode* temp=new TreeNode(postorder[j]);\\n            for(int n=j;n<postorder.size();++n){\\n                if(m.find(postorder[n])!=m.end()){\\n                    if(m[postorder[n]]->left==NULL){\\n                        m[postorder[n]]->left=temp;\\n                        break;\\n                    }else{\\n                        m[postorder[n]]->right=temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            m[postorder[j]]=temp;\\n        }\\n        return root;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        unordered_map<int,TreeNode*> m;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        m[preorder[0]]=root;\\n        for(int i=1;i<preorder.size();++i){\\n            int j=0;\\n            for(;j<postorder.size();++j)\\n                if(preorder[i]==postorder[j]) break;\\n            TreeNode* temp=new TreeNode(postorder[j]);\\n            for(int n=j;n<postorder.size();++n){\\n                if(m.find(postorder[n])!=m.end()){\\n                    if(m[postorder[n]]->left==NULL){\\n                        m[postorder[n]]->left=temp;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1547796,
                "title": "python-recursion-solution-with-my-personal-thought-process",
                "content": "Before I saw this question, I been solving around 300 Google  questions with mixture of Easy, and mostly medium. AND STILL, this question was definitely difficult for me. Took me an hour to solve or little more.\\n\\n*Key here is that everytime you are stuck solving this question, think of the characteristics of preoder and postorder again\\n\\n**Preorder** will define you what the root is. (if you understand preorder, you know it prints the value of the first encounter node first. For example, [1,2,4] in this case  shows that root is 1 and left node is 2 and right node  is 4\\n\\n**Postorder** will print the last element or leaf first of the left side. Thus, [2,4,1] in this case, 2 is bottom left side. \\n\\nTo come up with the solution, the key is to figure out this\\n\\n**If the current value of preorder  == first element of the postorder, that\\'s when you stop the recursion and return the node itself.**\\n\\nFor example, [2,4,1] -> we will hit bottom of the leaf node at 2. Then since preorder[index] == postorder[0], return TreeNode(2). Now at TreeNode(1), 1 is not the value on the front of postorder[0] now since 2 is gone. (postorder = [4,1]) at this point. Then  we iterate preorder and go through another recursion again. Then we generate TreeNode(4) and 4 is now at the front of postorder[0], we pop that value and return TreeNode(4). We repeat this process unil index < len(preorder) and postorder[0] != curr_value\\n\\n```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def dfs(index):\\n            node = TreeNode(preorder[index])\\n            while postorder[0] != node.val and index+1 < len(preorder):\\n                if not node.left:\\n                    node.left, index = dfs(index+1)\\n                else:\\n                    node.right, index = dfs(index+1)\\n\\n            postorder.pop(0)\\n            return node, index\\n        \\n        root, index = dfs(0)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        def dfs(index):\\n            node = TreeNode(preorder[index])\\n            while postorder[0] != node.val and index+1 < len(preorder):\\n                if not node.left:\\n                    node.left, index = dfs(index+1)\\n                else:\\n                    node.right, index = dfs(index+1)\\n\\n            postorder.pop(0)\\n            return node, index\\n        \\n        root, index = dfs(0)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498906,
                "title": "python-simple-solution-recursive-intuitive",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        q = deque(preorder)\\n        def dfs(post):\\n            if not post or not q:\\n                return \\n            if q[0] not in post:\\n                return \\n            cur = q.popleft()\\n            curNode = TreeNode(cur)\\n            split = post.index(cur)\\n            curNode.left = dfs(post[:split])\\n            curNode.right = dfs(post[:split])\\n            return curNode\\n        return dfs(postorder)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, preorder, postorder):\\n        q = deque(preorder)\\n        def dfs(post):\\n            if not post or not q:\\n                return \\n            if q[0] not in post:\\n                return \\n            cur = q.popleft()\\n            curNode = TreeNode(cur)\\n            split = post.index(cur)\\n            curNode.left = dfs(post[:split])\\n            curNode.right = dfs(post[:split])\\n            return curNode\\n        return dfs(postorder)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352150,
                "title": "c-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void fillMaps(vector<int> vec, unordered_map<int, int>& map) {\\n        for(int i=0;i<vec.size();i++) \\n            map[vec[i]] = i;\\n        return ;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> preMap;\\n        unordered_map<int, int> postMap;\\n        fillMaps(pre, preMap);\\n        fillMaps(post, postMap);\\n        set<int> visited;\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(pre[0]);\\n        q.push(root);\\n        visited.insert(pre[0]);\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            int l = preMap[curr->val]+1;\\n            int r = postMap[curr->val]-1;\\n            if(l < pre.size() && visited.find(pre[l]) == visited.end()) {\\n                TreeNode* lft = new TreeNode(pre[l]);\\n                curr->left = lft;\\n                q.push(lft);\\n                visited.insert(pre[l]);\\n            }\\n            if(r >= 0 && visited.find(post[r]) == visited.end()) {\\n                TreeNode* rht = new TreeNode(post[r]);\\n                curr->right = rht;\\n                q.push(rht);\\n                visited.insert(post[r]);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void fillMaps(vector<int> vec, unordered_map<int, int>& map) {\\n        for(int i=0;i<vec.size();i++) \\n            map[vec[i]] = i;\\n        return ;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> preMap;\\n        unordered_map<int, int> postMap;\\n        fillMaps(pre, preMap);\\n        fillMaps(post, postMap);\\n        set<int> visited;\\n        queue<TreeNode*> q;\\n        TreeNode* root = new TreeNode(pre[0]);\\n        q.push(root);\\n        visited.insert(pre[0]);\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            int l = preMap[curr->val]+1;\\n            int r = postMap[curr->val]-1;\\n            if(l < pre.size() && visited.find(pre[l]) == visited.end()) {\\n                TreeNode* lft = new TreeNode(pre[l]);\\n                curr->left = lft;\\n                q.push(lft);\\n                visited.insert(pre[l]);\\n            }\\n            if(r >= 0 && visited.find(post[r]) == visited.end()) {\\n                TreeNode* rht = new TreeNode(post[r]);\\n                curr->right = rht;\\n                q.push(rht);\\n                visited.insert(post[r]);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347037,
                "title": "100-faster-java-solution-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return construct(pre,0,pre.length-1,post,0,post.length-1);\\n    }\\n    public TreeNode construct(int[] pre,int preSI,int preEI,int[] post,int postSI,int postEI){\\n        if(preSI>preEI){\\n            return null;\\n        }\\n        TreeNode root=new TreeNode(pre[preSI]);\\n        int postIdx=postSI;\\n        if(preSI==preEI){\\n            return root;\\n        }\\n        while(post[postIdx]!=pre[preSI+1]){\\n            postIdx++;\\n        }\\n        int tnel=postIdx-postSI+1;\\n        root.left=construct(pre,preSI+1,preSI+tnel,post,postSI,postIdx-1);\\n        root.right=construct(pre,preSI+tnel+1,preEI,post,postIdx+1,postEI);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return construct(pre,0,pre.length-1,post,0,post.length-1);\\n    }\\n    public TreeNode construct(int[] pre,int preSI,int preEI,int[] post,int postSI,int postEI){\\n        if(preSI>preEI){\\n            return null;\\n        }\\n        TreeNode root=new TreeNode(pre[preSI]);\\n        int postIdx=postSI;\\n        if(preSI==preEI){\\n            return root;\\n        }\\n        while(post[postIdx]!=pre[preSI+1]){\\n            postIdx++;\\n        }\\n        int tnel=postIdx-postSI+1;\\n        root.left=construct(pre,preSI+1,preSI+tnel,post,postSI,postIdx-1);\\n        root.right=construct(pre,preSI+tnel+1,preEI,post,postIdx+1,postEI);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255710,
                "title": "a-simple-clean-c-solution",
                "content": "class Solution {\\npublic:\\n    TreeNode* helper(vector<int>& pre, unordered_map<int,int>&mp, int start, int end, int& index)\\n    {\\n        if ( start > end )\\n            return NULL; \\n        \\n        TreeNode* root = new TreeNode(pre[index]);\\n        \\n        index++;\\n        if ( start == end )\\n            return root ; \\n      \\n        int i = mp[pre[index]];\\n        \\n        root->left = helper(pre, mp, start, i, index);\\n        root->right = helper(pre, mp, i+1, end-1, index);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        \\n        unordered_map<int, int> mp;\\n        \\n        for ( int i = 0; i < post.size(); i++)\\n            mp[post[i]]=i; \\n        int index = 0; \\n        return helper(pre, mp, 0, post.size()-1, index);\\n         \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* helper(vector<int>& pre, unordered_map<int,int>&mp, int start, int end, int& index)\\n    {\\n        if ( start > end )\\n            return NULL; \\n        \\n        TreeNode* root = new TreeNode(pre[index]);\\n        \\n        index++;\\n        if ( start == end )\\n            return root ; \\n      \\n        int i = mp[pre[index]];\\n        \\n        root->left = helper(pre, mp, start, i, index);\\n        root->right = helper(pre, mp, i+1, end-1, index);\\n        \\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1204103,
                "title": "c-recursive-solution-with-explanation",
                "content": "We know, **prorder**: Root->Left->Right & **postorder**: Left->Right->Root\\nLet us take the sample test case given,\\npre = [1,2,3,4,5,6,7] & post = [4,5,2,6,7,3,1]\\nLet *n* be the size of vectors.\\nOn observation we can notice two facts:\\n1. **```pre[0]```** will be the root of tree and **```pre[0] = post[n-1]```**\\n2. Second last element of post (**```post[n-2]```**) will be the root of right subtree.\\n\\nUsing these facts we can make recursive calls, and passing the split arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        if(pre.size()<1)\\n            return nullptr;\\n        int n = pre.size();\\n        int val = pre[0];\\n        TreeNode* root = new TreeNode(val);\\n        if(n==1)\\n            return root;\\n        int x = post[n-2];\\n        int ind = 0;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]==x){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        vector<int> preL(pre.begin()+1, pre.begin()+ind);\\n        vector<int> preR(pre.begin()+ind, pre.end());\\n        \\n        vector<int> postL(post.begin(), post.begin()+ind-1);\\n        vector<int> postR(post.begin()+ind-1, post.end()-1);\\n        \\n        root->left = constructFromPrePost(preL, postL);\\n        root->right = constructFromPrePost(preR, postR);\\n        \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```pre[0]```\n```pre[0] = post[n-1]```\n```post[n-2]```\n```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        if(pre.size()<1)\\n            return nullptr;\\n        int n = pre.size();\\n        int val = pre[0];\\n        TreeNode* root = new TreeNode(val);\\n        if(n==1)\\n            return root;\\n        int x = post[n-2];\\n        int ind = 0;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]==x){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        vector<int> preL(pre.begin()+1, pre.begin()+ind);\\n        vector<int> preR(pre.begin()+ind, pre.end());\\n        \\n        vector<int> postL(post.begin(), post.begin()+ind-1);\\n        vector<int> postR(post.begin()+ind-1, post.end()-1);\\n        \\n        root->left = constructFromPrePost(preL, postL);\\n        root->right = constructFromPrePost(preR, postR);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197039,
                "title": "python3-preorder-dfs-36",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        #strategy: Preorder DFS\\n        #pos_pre and pos_post finds the pos of each element in the two arrays\\n        self.pos_pre, self.pos_post = [-1] * (len(pre) + 1), [-1] * (len(pre) + 1)\\n        for i in range(len(pre)):\\n            self.pos_pre[pre[i]] = i\\n            self.pos_post[post[i]] = i\\n        return self.dfs(pre, post, 0, len(pre) - 1)\\n    def dfs(self, pre, post, left, right) -> TreeNode:\\n        #out of bounds\\n        if left > right:\\n            return None\\n        #left will always be the root node since it is preorder\\n        curr = TreeNode(pre[left])\\n        #once they equal there are no more left or right nodes \\n        if left == right:\\n            return curr\\n        #find the right node which is to the left of the node in the post array since post is left, right, root\\n        right_node = post[self.pos_post[curr.val] - 1]\\n        #the starting pos of left will be left + 1 since pre is root, left, right\\n        curr.left = self.dfs(pre, post, left + 1, self.pos_pre[right_node] - 1)\\n        #the starting pos of right will be at the right node to the end\\n        curr.right = self.dfs(pre, post, self.pos_pre[right_node], right)\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        #strategy: Preorder DFS\\n        #pos_pre and pos_post finds the pos of each element in the two arrays\\n        self.pos_pre, self.pos_post = [-1] * (len(pre) + 1), [-1] * (len(pre) + 1)\\n        for i in range(len(pre)):\\n            self.pos_pre[pre[i]] = i\\n            self.pos_post[post[i]] = i\\n        return self.dfs(pre, post, 0, len(pre) - 1)\\n    def dfs(self, pre, post, left, right) -> TreeNode:\\n        #out of bounds\\n        if left > right:\\n            return None\\n        #left will always be the root node since it is preorder\\n        curr = TreeNode(pre[left])\\n        #once they equal there are no more left or right nodes \\n        if left == right:\\n            return curr\\n        #find the right node which is to the left of the node in the post array since post is left, right, root\\n        right_node = post[self.pos_post[curr.val] - 1]\\n        #the starting pos of left will be left + 1 since pre is root, left, right\\n        curr.left = self.dfs(pre, post, left + 1, self.pos_pre[right_node] - 1)\\n        #the starting pos of right will be at the right node to the end\\n        curr.right = self.dfs(pre, post, self.pos_pre[right_node], right)\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183412,
                "title": "o-n-o-n-summary-of-preorder-postorder-lc889-vs-preorder-inorder-lc105-to-construct-tree",
                "content": "I got the idea to solve LC889 problem from LC105. And the solutions are almost same, only small difference. So I summarized it here for all LeetCoders =). It make me feel good that if I can solve problems with similar steps =P\\nTime O(n)\\nSpace O(n)\\nReady? Go!\\nLC889 preorder+postorder:\\n```\\nclass Solution {\\n    \\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preor, int[] post) {\\n        for(int i=0;i<post.length;i++)\\n        {\\n            m.put(post[i],i);\\n        }\\n        return helper(preor,post,0,post.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] post, int l, int r) {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        if(l==r) return root;\\n        \\n        int pos=m.get(preor[id]);  \\n        \\n        root.left=helper(preor,post,l,pos);\\n        root.right=helper(preor,post,pos+1,r-1);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\\n\\nLC105 preorder + inorder:\\n```\\nclass Solution {\\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode buildTree(int[] preor, int[] inor) {\\n        for(int i=0;i<inor.length;i++)\\n        {\\n            m.put(inor[i],i);\\n        }\\n        return helper(preor,inor,0,inor.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] inor, int l, int r) {\\n        if(l>r) return null;\\n        int pos=m.get(preor[id]);\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        root.left=helper(preor,inor,l,pos-1);\\n        root.right=helper(preor,inor,pos+1,r);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\\n\\nBasically, the difference here is \\n1. LC 889 have: **if(l==r) return root;**\\n2. LC899: **id++ need to be before get pos and return!**\\n2. LC 889: root.left=helper(preor,post,l,**pos**);\\n3. LC889: root.right=helper(preor,post,pos+1,**r-1**);\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode constructFromPrePost(int[] preor, int[] post) {\\n        for(int i=0;i<post.length;i++)\\n        {\\n            m.put(post[i],i);\\n        }\\n        return helper(preor,post,0,post.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] post, int l, int r) {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        if(l==r) return root;\\n        \\n        int pos=m.get(preor[id]);  \\n        \\n        root.left=helper(preor,post,l,pos);\\n        root.right=helper(preor,post,pos+1,r-1);\\n        return root;\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    int id=0;\\n    HashMap<Integer,Integer> m=new HashMap<>();\\n    public TreeNode buildTree(int[] preor, int[] inor) {\\n        for(int i=0;i<inor.length;i++)\\n        {\\n            m.put(inor[i],i);\\n        }\\n        return helper(preor,inor,0,inor.length-1);\\n        \\n    }\\n    public TreeNode helper(int[] preor, int[] inor, int l, int r) {\\n        if(l>r) return null;\\n        int pos=m.get(preor[id]);\\n        TreeNode root=new TreeNode(preor[id]);\\n        id++;\\n        root.left=helper(preor,inor,l,pos-1);\\n        root.right=helper(preor,inor,pos+1,r);\\n        return root;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174053,
                "title": "recursive-with-pictures",
                "content": "**Recursive helper, 2 pass :** `time O(N), space O(N)`\\n```\\nclass Solution \\n{\\n    int m_post[31];\\n\\n    TreeNode* f(vector<int>& pre, int i, int j, int J)\\n    {\\n        if(j>J)  return nullptr;\\n        int y{j!=J ? m_post[pre[i+1]] : j-1};\\n        return new TreeNode(pre[i], f(pre, i+1, j, y), f(pre, i+2+y-j, y+1, J-1));\\n    }\\npublic:    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(auto i{0}; i<size(post); m_post[post[i]]=i, ++i);\\n        return f(pre, 0, 0, size(post)-1);     \\n    }\\n};\\n```\\n\\nLookup `m_post` used to quickly search symbol in `post`.\\n\\n![image](https://assets.leetcode.com/users/images/bf10beff-8f36-4818-9fa2-da8479194c87_1620861266.9687319.png)\\n\\nNote that if `pre[i+1]!=post[J-1]` we have no left or no right subtree (we are free to choose, they have the same `pre` and `post`). I chose the left subtree.\\n\\n![image](https://assets.leetcode.com/users/images/7954ab76-2067-455e-8681-cc289d6a0a64_1620861409.2561164.png)\\n\\nThis problem is one of the three similar problems:\\n* [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/1204573/recursive)\\n* [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/1204516/recursive)\\n* [889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) \\u279F [SOLUTION](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/1174053/recursive-with-pictures)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    int m_post[31];\\n\\n    TreeNode* f(vector<int>& pre, int i, int j, int J)\\n    {\\n        if(j>J)  return nullptr;\\n        int y{j!=J ? m_post[pre[i+1]] : j-1};\\n        return new TreeNode(pre[i], f(pre, i+1, j, y), f(pre, i+2+y-j, y+1, J-1));\\n    }\\npublic:    \\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) \\n    {\\n        for(auto i{0}; i<size(post); m_post[post[i]]=i, ++i);\\n        return f(pre, 0, 0, size(post)-1);     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156973,
                "title": "easy-to-understand-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int k=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return construct(pre,post,0,pre.size()-1);\\n        \\n    }\\n     TreeNode* construct(vector<int>& pre, vector<int>& post,int start,int end) {\\n         if(k >= pre.size() || start>end )\\n             return NULL;\\n        TreeNode* node = new TreeNode(pre[k++]);\\n         if(start == end){\\n             return node;\\n         }\\n         int i;\\n         for( i= start;i<=end;i++){\\n             if(post[i] == pre[k])\\n                 break;\\n         }\\n     \\n         node->left = construct(pre,post,start,i);\\n         node->right = construct(pre,post,i+1,end-1);\\n         \\n         return node;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int k=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n       return construct(pre,post,0,pre.size()-1);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1127607,
                "title": "python-3-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        \\n        if not pre or not post:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        \\n        root = TreeNode(pre[0])\\n        \\n        pos = post.index(pre[1]) + 1\\n        root.left = self.constructFromPrePost(pre[1 : 1 + pos], post[ : pos])\\n        root.right = self.constructFromPrePost(pre[1 + pos : ], post[pos : -1])\\n        \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        \\n        if not pre or not post:\\n            return None\\n        if len(pre) == 1:\\n            return TreeNode(pre[0])\\n        \\n        root = TreeNode(pre[0])\\n        \\n        pos = post.index(pre[1]) + 1\\n        root.left = self.constructFromPrePost(pre[1 : 1 + pos], post[ : pos])\\n        root.right = self.constructFromPrePost(pre[1 + pos : ], post[pos : -1])\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083362,
                "title": "javascript-simple-dfs-with-explanation-78-faster",
                "content": "Runtime: 96 ms, faster than 78.00% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\nMemory Usage: 42.3 MB, less than 31.00% of JavaScript online submissions for Construct Binary Tree from Preorder and Postorder Traversal.\\n\\nTo solve this question, you must first identify the pattern of Preorder and Post order.\\nPattern:\\nPreorder: Root -> Left -> Right\\nPostorder: Left -> Right -> Root\\n\\nHow do I find the end of the left and right?\\nthe first value after the root in preorder is the end of the left tree in the post order! :D\\n\\n```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length === 0) {\\n        return null;\\n    }\\n    if(pre.length === 1) {\\n        return new TreeNode(pre[0]);\\n    }\\n    \\n    let root = pre[0];\\n    let leftEndVal = pre[1];\\n    let leftEnd = post.indexOf(leftEndVal);\\n    \\n    let leftTree = constructFromPrePost(pre.slice(1, leftEnd + 2), post.slice(0, leftEnd + 1));\\n    let rightTree = constructFromPrePost(pre.slice(leftEnd + 2,  pre.length), post.slice(leftEnd + 1, post.length));\\n    \\n    return new TreeNode(root, leftTree, rightTree);\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    if(pre.length === 0) {\\n        return null;\\n    }\\n    if(pre.length === 1) {\\n        return new TreeNode(pre[0]);\\n    }\\n    \\n    let root = pre[0];\\n    let leftEndVal = pre[1];\\n    let leftEnd = post.indexOf(leftEndVal);\\n    \\n    let leftTree = constructFromPrePost(pre.slice(1, leftEnd + 2), post.slice(0, leftEnd + 1));\\n    let rightTree = constructFromPrePost(pre.slice(leftEnd + 2,  pre.length), post.slice(leftEnd + 1, post.length));\\n    \\n    return new TreeNode(root, leftTree, rightTree);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015731,
                "title": "python-dfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\npreorder:(root,(left),(right))\\npostorder((left),(right), root)\\nthe key here is to determine the length of left\\nwhich need to be determined by postorder array\\n\\'\\'\\'\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        def dfs(i, j, n):\\n            #1. when n <=0, we have no node to traverse\\n            if n <= 0 :\\n                return None\\n\\n            root = TreeNode(pre[i]) #the first node must be root of the subtree\\n            #2. when n == 1, we know that only one node left\\n            # itself is the subtree\\n            if n == 1:\\n                return root\\n            \\n            # 3 find the length of left subtree\\n            # whose parent is curret root\\n            k = j\\n            while post[k] != pre[i+1]:\\n                k += 1\\n            l = k-j + 1 # this is the length\\n            root.left = dfs(i+1, j, l)\\n            root.right = dfs(i+l+1, k+1, n-l-1)\\n            return root\\n        \\n        return dfs(0, 0, len(pre))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```py\\n\\'\\'\\'\\npreorder:(root,(left),(right))\\npostorder((left),(right), root)\\nthe key here is to determine the length of left\\nwhich need to be determined by postorder array\\n\\'\\'\\'\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        def dfs(i, j, n):\\n            #1. when n <=0, we have no node to traverse\\n            if n <= 0 :\\n                return None\\n\\n            root = TreeNode(pre[i]) #the first node must be root of the subtree\\n            #2. when n == 1, we know that only one node left\\n            # itself is the subtree\\n            if n == 1:\\n                return root\\n            \\n            # 3 find the length of left subtree\\n            # whose parent is curret root\\n            k = j\\n            while post[k] != pre[i+1]:\\n                k += 1\\n            l = k-j + 1 # this is the length\\n            root.left = dfs(i+1, j, l)\\n            root.right = dfs(i+l+1, k+1, n-l-1)\\n            return root\\n        \\n        return dfs(0, 0, len(pre))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992832,
                "title": "c-o-n-recursive-dfs-10ms-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre,post,0,0,pre.size());\\n    }\\n    TreeNode* helper(vector<int>& pre, vector<int>& post, int pi, int poi, int len){\\n        //index pi and poi will tell which part of arrays to consider \\n        //pi tells to take pre from index pi+len same does poi for post\\n        if(len==0)return nullptr;\\n        //creating the root\\n        TreeNode* root = new TreeNode(pre[pi]);\\n        //if no more elemnts left\\n        if(len==1)return root;\\n        //finding length of left subtree\\n        int L;\\n        for(L =0; L<len;L++){\\n            if (pre[pi+1] == post[poi+L]){\\n                break;\\n            }\\n        }\\n        L+=1; //because index starts from zero so length will be 1 more;\\n        //collect the new indexes and construct left and right subtree recursively\\n        root->left = helper(pre,post,pi+1,poi,L);\\n        root->right = helper(pre,post,pi+L+1,poi+L,len-1-L);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        return helper(pre,post,0,0,pre.size());\\n    }\\n    TreeNode* helper(vector<int>& pre, vector<int>& post, int pi, int poi, int len){\\n        //index pi and poi will tell which part of arrays to consider \\n        //pi tells to take pre from index pi+len same does poi for post\\n        if(len==0)return nullptr;\\n        //creating the root\\n        TreeNode* root = new TreeNode(pre[pi]);\\n        //if no more elemnts left\\n        if(len==1)return root;\\n        //finding length of left subtree\\n        int L;\\n        for(L =0; L<len;L++){\\n            if (pre[pi+1] == post[poi+L]){\\n                break;\\n            }\\n        }\\n        L+=1; //because index starts from zero so length will be 1 more;\\n        //collect the new indexes and construct left and right subtree recursively\\n        root->left = helper(pre,post,pi+1,poi,L);\\n        root->right = helper(pre,post,pi+L+1,poi+L,len-1-L);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946704,
                "title": "python3-stack-o-n",
                "content": "**Algo**\\nGo through `pre` and add nodes to the tree. The reletive position can be derived from their order in `post`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        \\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop()\\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexcity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        mp = {x: i for i, x in enumerate(post)}\\n        \\n        root = None \\n        stack = []\\n        for x in pre: \\n            if not root: root = node = TreeNode(x)\\n            elif mp[x] < mp[stack[-1].val]: stack[-1].left = node = TreeNode(x)\\n            else: \\n                while mp[stack[-1].val] < mp[x]: stack.pop()\\n                stack[-1].right = node = TreeNode(x)\\n            stack.append(node)\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 921228,
                "title": "divide-and-conquer-o-n-solution-with-help-of-hashmap-java",
                "content": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Map<Integer, Integer> preIndexMap = new HashMap();\\n        for(int i = 0; i < pre.length; i++) {\\n            preIndexMap.put(pre[i], i);\\n        }\\n        return constructTree(pre, post, 0, pre.length-1, 0, pre.length -1, preIndexMap);\\n    }\\n    \\n    private TreeNode constructTree(int[] pre, int[] post, int preLeft, \\n                                   int preRight, int postLeft, int postRight, \\n                                   Map<Integer, Integer> map) {\\n        if(preLeft > preRight || postLeft > postRight)  return null;\\n        TreeNode root = new TreeNode(post[postRight]);\\n        if(preLeft == preRight) return root;\\n        int elem = post[postRight-1];\\n        int preMid = map.get(elem);\\n        int postMid = postRight-1-preRight+preMid;\\n        root.right = constructTree(pre, post, preMid, preRight, postMid, postRight-1, map);\\n        root.left = constructTree(pre, post, preLeft+1, preMid-1, postLeft, postMid-1, map);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Map<Integer, Integer> preIndexMap = new HashMap();\\n        for(int i = 0; i < pre.length; i++) {\\n            preIndexMap.put(pre[i], i);\\n        }\\n        return constructTree(pre, post, 0, pre.length-1, 0, pre.length -1, preIndexMap);\\n    }\\n    \\n    private TreeNode constructTree(int[] pre, int[] post, int preLeft, \\n                                   int preRight, int postLeft, int postRight, \\n                                   Map<Integer, Integer> map) {\\n        if(preLeft > preRight || postLeft > postRight)  return null;\\n        TreeNode root = new TreeNode(post[postRight]);\\n        if(preLeft == preRight) return root;\\n        int elem = post[postRight-1];\\n        int preMid = map.get(elem);\\n        int postMid = postRight-1-preRight+preMid;\\n        root.right = constructTree(pre, post, preMid, preRight, postMid, postRight-1, map);\\n        root.left = constructTree(pre, post, preLeft+1, preMid-1, postLeft, postMid-1, map);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903457,
                "title": "without-using-4-variables-prestart-preend-poststart-postend-and-with-using-4-variables",
                "content": "2 Methods to do this question :-\\n1) . By using  4 variables (prestart,preend,poststart,postend) \\n     in code i have use [a,b] for pre array and [c,d] for post array.\\n2) By using 2 variables (pre_indx,pos_indx)\\n2nd one is tricky  method\\n**1st One**\\n```\\nclass Solution {\\npublic:           //  indexing based solution\\n    unordered_map<int,int> mp;\\n    \\n    TreeNode* construct(vector<int>& pre,vector<int>& post,int a,int b,int c,int d){\\n        if(a>b)return nullptr;\\n        TreeNode* root=new TreeNode(pre[a]);\\n        \\n        //base case\\n        if(a==b)return root;\\n        //finding the index of pre[a+1] in post[] array\\n        int indx=mp[pre[a+1]];\\n        //finding the length of left_subtree array from post[] array\\n        int len=indx-c+1;   // length of left_subtree \\n        // construct root- left and root- right subtreee\\n        root->left=construct(pre,post,a+1,a+len,c,c+len-1);\\n        root->right=construct(pre,post,a+len+1,b,indx+1,d-1);\\n        return root;\\n    }\\n\\t\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        for(int i=0;i<post.size();i++){\\n            mp[post[i]]=i;\\n        }\\n        return construct(pre,post,0,pre.size()-1,0,post.size()-1);\\n    }\\n};\\n```\\n**Time complexity: O(N^2)**\\n**2nd One**\\n```\\nclass Solution {\\npublic:       // without 4  variables(prestart,preend,posstart,posend)\\n    //     using 2 variables(pre_indx ,pos_indx)\\n     int pre_indx=0,pos_indx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[pre_indx++]);\\n        if(root->val!=post[pos_indx]){\\n            root->left=constructFromPrePost(pre,post);\\n        }\\n        if(root->val!=post[pos_indx]){\\n            root->right=constructFromPrePost(pre,post);\\n        }\\n        pos_indx++;\\n        return root;\\n    }\\n};\\n```\\n**Time complexity: O(N)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:           //  indexing based solution\\n    unordered_map<int,int> mp;\\n    \\n    TreeNode* construct(vector<int>& pre,vector<int>& post,int a,int b,int c,int d){\\n        if(a>b)return nullptr;\\n        TreeNode* root=new TreeNode(pre[a]);\\n        \\n        //base case\\n        if(a==b)return root;\\n        //finding the index of pre[a+1] in post[] array\\n        int indx=mp[pre[a+1]];\\n        //finding the length of left_subtree array from post[] array\\n        int len=indx-c+1;   // length of left_subtree \\n        // construct root- left and root- right subtreee\\n        root->left=construct(pre,post,a+1,a+len,c,c+len-1);\\n        root->right=construct(pre,post,a+len+1,b,indx+1,d-1);\\n        return root;\\n    }\\n\\t\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        for(int i=0;i<post.size();i++){\\n            mp[post[i]]=i;\\n        }\\n        return construct(pre,post,0,pre.size()-1,0,post.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:       // without 4  variables(prestart,preend,posstart,posend)\\n    //     using 2 variables(pre_indx ,pos_indx)\\n     int pre_indx=0,pos_indx=0;\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        TreeNode* root=new TreeNode(pre[pre_indx++]);\\n        if(root->val!=post[pos_indx]){\\n            root->left=constructFromPrePost(pre,post);\\n        }\\n        if(root->val!=post[pos_indx]){\\n            root->right=constructFromPrePost(pre,post);\\n        }\\n        pos_indx++;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898962,
                "title": "linear-space-time-complexity-using-hash",
                "content": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        n = len(pre)\\n        if n == 0:\\n            return None\\n        post_hash = dict(zip(post, range(n)))\\n        root = TreeNode(pre[0])\\n        stack = [root]\\n        i = 1\\n        while i < n:\\n            current = stack[-1]\\n            if post_hash[pre[i]] == post_hash[current.val]:\\n                i += 1\\n            elif post_hash[pre[i]] < post_hash[current.val]:\\n                node = TreeNode(pre[i])\\n                if current.left is None:\\n                    current.left = node\\n                    stack.append(current.left)\\n                else:\\n                    current.right = node\\n                    stack.append(current.right)\\n                i += 1\\n            else:\\n                stack.pop()\\n            \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        n = len(pre)\\n        if n == 0:\\n            return None\\n        post_hash = dict(zip(post, range(n)))\\n        root = TreeNode(pre[0])\\n        stack = [root]\\n        i = 1\\n        while i < n:\\n            current = stack[-1]\\n            if post_hash[pre[i]] == post_hash[current.val]:\\n                i += 1\\n            elif post_hash[pre[i]] < post_hash[current.val]:\\n                node = TreeNode(pre[i])\\n                if current.left is None:\\n                    current.left = node\\n                    stack.append(current.left)\\n                else:\\n                    current.right = node\\n                    stack.append(current.right)\\n                i += 1\\n            else:\\n                stack.pop()\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870006,
                "title": "standard-java-solution",
                "content": "### Theory\\nIf you haven\\'t done this type of problem before - it can be quite tricky to see the pattern. Even if you have seen it before, the hard part will be maintaining four pointers spanning two arrays, and finding the recursive pattern.\\n\\nCredit: https://www.youtube.com/watch?v=3XYxGKeC_Ew\\n\\n### Solution\\n```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return recurse(pre, post, 0, pre.length - 1, 0, post.length - 1);\\n    }\\n    \\n    private TreeNode recurse(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd) {\\n        if (preStart > preEnd) return null;\\n        TreeNode newNode = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return newNode;\\n        int postIndex = postStart;\\n        while (post[postIndex] != pre[preStart + 1]) postIndex++;\\n        int len = postIndex - postStart + 1;\\n            \\n        newNode.left = recurse(pre, post, preStart + 1, preStart + len, postStart, postIndex);\\n        newNode.right = recurse(pre, post, preStart + 1 + len, preEnd, postIndex + 1, postEnd - 1);\\n        return newNode;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        return recurse(pre, post, 0, pre.length - 1, 0, post.length - 1);\\n    }\\n    \\n    private TreeNode recurse(int[] pre, int[] post, int preStart, int preEnd, int postStart, int postEnd) {\\n        if (preStart > preEnd) return null;\\n        TreeNode newNode = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return newNode;\\n        int postIndex = postStart;\\n        while (post[postIndex] != pre[preStart + 1]) postIndex++;\\n        int len = postIndex - postStart + 1;\\n            \\n        newNode.left = recurse(pre, post, preStart + 1, preStart + len, postStart, postIndex);\\n        newNode.right = recurse(pre, post, preStart + 1 + len, preEnd, postIndex + 1, postEnd - 1);\\n        return newNode;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865892,
                "title": "short-python3-recursive-solution-beats-100",
                "content": "Self explanatory clean solution:\\n```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            if pre:\\n                ind = post.index(pre[0])\\n                root.left = self.constructFromPrePost(pre[:ind+1],post[:ind+1])\\n                root.right = self.constructFromPrePost(pre[ind+1:],post[ind+1:])\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if pre:\\n            root = TreeNode(pre.pop(0))\\n            if pre:\\n                ind = post.index(pre[0])\\n                root.left = self.constructFromPrePost(pre[:ind+1],post[:ind+1])\\n                root.right = self.constructFromPrePost(pre[ind+1:],post[ind+1:])\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829141,
                "title": "c-intuitive-o-n-solution-no-complex-indexing-logic",
                "content": "Let x be the current node\\n- the node following x in preorder is x\\'s left child if its not visited already\\n- the node preceding x in postorder is x\\'s right child if its not visited already\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> postIndices, preIndices;\\n    vector<bool> visited;\\n    \\n    void construct(TreeNode* curNode, int index, vector<int>& pre, vector<int>& post) {\\n        if (!curNode)\\n            return;\\n        \\n        int cur = curNode->val;\\n        int leftChildIndex = preIndices[cur] + 1;\\n        int rightChildIndex = postIndices[cur] - 1;\\n        \\n        if (leftChildIndex < pre.size() and !visited[pre[leftChildIndex]]) {\\n            curNode->left = new TreeNode(pre[leftChildIndex]);\\n            visited[pre[leftChildIndex]] = true;\\n        }\\n        \\n        if (rightChildIndex >= 0 and !visited[post[rightChildIndex]]) {\\n            curNode->right = new TreeNode(post[rightChildIndex]);\\n            visited[post[rightChildIndex]] = true;\\n        }\\n        \\n        construct(curNode->left, leftChildIndex, pre, post);\\n        construct(curNode->right, rightChildIndex, pre, post);                \\n    }\\n    \\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        int index = 0;\\n        visited.resize(pre.size()+1);\\n        \\n        for (int i = 0; i < post.size(); i++)\\n            preIndices[pre[i]] = i, postIndices[post[i]] = i;\\n        \\n        auto newNode = new TreeNode(pre[index]);\\n        visited[pre[index]] = true;;\\n        \\n        construct(newNode, index, pre, post);\\n        \\n        return newNode;\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    unordered_map<int, int> postIndices, preIndices;\\n    vector<bool> visited;\\n    \\n    void construct(TreeNode* curNode, int index, vector<int>& pre, vector<int>& post) {\\n        if (!curNode)\\n            return;\\n        \\n        int cur = curNode->val;\\n        int leftChildIndex = preIndices[cur] + 1;\\n        int rightChildIndex = postIndices[cur] - 1;\\n        \\n        if (leftChildIndex < pre.size() and !visited[pre[leftChildIndex]]) {\\n            curNode->left = new TreeNode(pre[leftChildIndex]);\\n            visited[pre[leftChildIndex]] = true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 821866,
                "title": "c-one-pass-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int preInd;\\n    unordered_map<int,int>mp;\\n    TreeNode * rec(vector<int>& pre, vector<int>& post,int l, int r){\\n        if(l == r)return new TreeNode(pre[preInd++]);\\n        if(l > r)return NULL;\\n        TreeNode * curr = new TreeNode(pre[preInd++]);\\n        int t = mp[pre[preInd]];\\n        curr->left = rec(pre,post,l,t);\\n        curr->right = rec(pre,post,t + 1,r-1);\\n        return curr;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        preInd = 0;\\n        for(int i = 0; i < post.size(); i++)mp[post[i]] = i;\\n        return rec(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int preInd;\\n    unordered_map<int,int>mp;\\n    TreeNode * rec(vector<int>& pre, vector<int>& post,int l, int r){\\n        if(l == r)return new TreeNode(pre[preInd++]);\\n        if(l > r)return NULL;\\n        TreeNode * curr = new TreeNode(pre[preInd++]);\\n        int t = mp[pre[preInd]];\\n        curr->left = rec(pre,post,l,t);\\n        curr->right = rec(pre,post,t + 1,r-1);\\n        return curr;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        preInd = 0;\\n        for(int i = 0; i < post.size(); i++)mp[post[i]] = i;\\n        return rec(pre,post,0,post.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767348,
                "title": "java-o-n-dfs-with-explaination-video",
                "content": "The algorithm follows the explaination in the video:\\n[https://www.youtube.com/watch?v=5lWJpTEnyow](http://)\\n```\\npublic class prepost{\\n  int[] pre;\\n  int[] post;\\n  HashMap<Integer,Integer> preMap = new HashMap();\\n  HashMap<Integer,Integer> postMap = new HashMap();\\n  public TreeNode constructFromPrePost(int[] pre, int[] post){\\n    this.pre = pre;\\n    this.post = post;\\n    for(int i=0;i<pre.length;i++){\\n      this.preMap.put(pre[i],i);\\n      this.postMap.put(post[i],i);\\n    }\\n    return helper(0,pre.length-1,0,post.length-1);\\n\\n  }\\n  public TreeNode helper(int pre_left, int pre_right, int post_left, int post_right){\\n    if(post_left>post_right){\\n      return null;\\n    }\\n    int val = pre[pre_left];\\n    TreeNode root = new TreeNode(val);\\n    if(pre_left == pre_right || post_left == post_right){\\n      return root;\\n    }\\n    int postIndex = postMap.get(pre[pre_left+1]);\\n    int preIndex = preMap.get(post[post_right-1]);\\n    root.left = helper(pre_left+1,preIndex-1,post_left,postIndex);\\n    root.left = helper(preIndex,pre_right,postIndex+1,post_right-1);\\n    return root;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class prepost{\\n  int[] pre;\\n  int[] post;\\n  HashMap<Integer,Integer> preMap = new HashMap();\\n  HashMap<Integer,Integer> postMap = new HashMap();\\n  public TreeNode constructFromPrePost(int[] pre, int[] post){\\n    this.pre = pre;\\n    this.post = post;\\n    for(int i=0;i<pre.length;i++){\\n      this.preMap.put(pre[i],i);\\n      this.postMap.put(post[i],i);\\n    }\\n    return helper(0,pre.length-1,0,post.length-1);\\n\\n  }\\n  public TreeNode helper(int pre_left, int pre_right, int post_left, int post_right){\\n    if(post_left>post_right){\\n      return null;\\n    }\\n    int val = pre[pre_left];\\n    TreeNode root = new TreeNode(val);\\n    if(pre_left == pre_right || post_left == post_right){\\n      return root;\\n    }\\n    int postIndex = postMap.get(pre[pre_left+1]);\\n    int preIndex = preMap.get(post[post_right-1]);\\n    root.left = helper(pre_left+1,preIndex-1,post_left,postIndex);\\n    root.left = helper(preIndex,pre_right,postIndex+1,post_right-1);\\n    return root;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640386,
                "title": "go-0ms-recursive-solution",
                "content": "```\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 {\\n        return nil\\n    }\\n    root := &TreeNode{Val: pre[0]}\\n    if len(pre) == 1 {\\n        return root\\n    }\\n    \\n    L := indexOf(pre[1], post) + 1   \\n\\n    root.Left = constructFromPrePost(pre[1:L+1], post[:L])\\n    root.Right = constructFromPrePost(pre[L+1:], post[L:])\\n    \\n    return root\\n}\\n\\nfunc indexOf(element int, data []int) (int) {\\n   for k, v := range data {\\n       if element == v {\\n           return k\\n       }\\n   }\\n   return -1    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 {\\n        return nil\\n    }\\n    root := &TreeNode{Val: pre[0]}\\n    if len(pre) == 1 {\\n        return root\\n    }\\n    \\n    L := indexOf(pre[1], post) + 1   \\n\\n    root.Left = constructFromPrePost(pre[1:L+1], post[:L])\\n    root.Right = constructFromPrePost(pre[L+1:], post[L:])\\n    \\n    return root\\n}\\n\\nfunc indexOf(element int, data []int) (int) {\\n   for k, v := range data {\\n       if element == v {\\n           return k\\n       }\\n   }\\n   return -1    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618997,
                "title": "fully-explained-fast-c-recursive-solution",
                "content": "The solution beats about 80% of the submissions in terms of speed.\\nThe code is similar to [this discuss thread](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/discuss/161286/C%2B%2B-O(N)-recursive-solution), I just explained it a little better and added tons of comments and better variable names.\\n```\\nclass Solution\\n{\\n    unordered_map<int, int> lookup;\\n\\npublic:\\n    TreeNode *constructFromPrePost(vector<int> &pre, vector<int> &post)\\n    {\\n        // create a hashmap for post order array for faster lookup\\n        for (int i = 0; i < post.size(); ++i)\\n        {\\n            lookup[post[i]] = i;\\n        }\\n        return helper(0, pre.size() - 1, 0, post.size() - 1, pre, post);\\n    }\\n\\n    /*\\n    * [root][......left......][...right..]  ---pre\\n    * [......left......][...right..][root]  ---post\\n    */\\n    TreeNode *helper(int preStart, int preEnd, int postStart, int postEnd, vector<int> &pre, vector<int> &post)\\n    {\\n\\n        TreeNode *root = new TreeNode(pre[preStart]);\\n\\n        // this node deosn\\'t have any children\\n        if (preStart == preEnd)\\n        {\\n            return root;\\n        }\\n\\n        // Index of root of left subtree in preorder\\n        int RootLeftSubTree = pre[preStart + 1];\\n        // Index of root of left subtree in postorder\\n        int RootLeftSubTreePostIdx = lookup[RootLeftSubTree];\\n\\n        // Number of elements in the left subtree\\n        int elementsInLeftSubTree = RootLeftSubTreePostIdx - postStart + 1;\\n\\n        /*\\n        * For left subtree\\n        * pre starts from preStart + 1, i.e. the very next element\\n        * pre ends at preStart + elementsInLeftSubTree - 1\\n        * post starts at postStart (remains same)\\n        * post ends at the RootLeftSubTreePostIdx (the rightmost element (the root of left subtree) in the post array)\\n        */\\n        root->left = helper(preStart + 1, preStart + elementsInLeftSubTree, postStart, RootLeftSubTreePostIdx, pre, post);\\n\\n        // if you run out of nodes for right subTree, return the root and\\n        // let root->right remain NULL\\n        if (RootLeftSubTreePostIdx + 1 == postEnd)\\n        {\\n            return root;\\n        }\\n\\n        /*\\n        * For right subtree\\n        * pre starts at 1 position after the last left subtree element\\n        * pre ends at preEnd (remains same)\\n        * post starts at RootLeftSubTreePostIdx + 1\\n        * post ends at 1 position to the left of postEnd (as postEnd is always current root)\\n        */\\n        root->right = helper(preStart + elementsInLeftSubTree + 1, preEnd, RootLeftSubTreePostIdx + 1, postEnd - 1, pre, post);\\n\\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    unordered_map<int, int> lookup;\\n\\npublic:\\n    TreeNode *constructFromPrePost(vector<int> &pre, vector<int> &post)\\n    {\\n        // create a hashmap for post order array for faster lookup\\n        for (int i = 0; i < post.size(); ++i)\\n        {\\n            lookup[post[i]] = i;\\n        }\\n        return helper(0, pre.size() - 1, 0, post.size() - 1, pre, post);\\n    }\\n\\n    /*\\n    * [root][......left......][...right..]  ---pre\\n    * [......left......][...right..][root]  ---post\\n    */\\n    TreeNode *helper(int preStart, int preEnd, int postStart, int postEnd, vector<int> &pre, vector<int> &post)\\n    {\\n\\n        TreeNode *root = new TreeNode(pre[preStart]);\\n\\n        // this node deosn\\'t have any children\\n        if (preStart == preEnd)\\n        {\\n            return root;\\n        }\\n\\n        // Index of root of left subtree in preorder\\n        int RootLeftSubTree = pre[preStart + 1];\\n        // Index of root of left subtree in postorder\\n        int RootLeftSubTreePostIdx = lookup[RootLeftSubTree];\\n\\n        // Number of elements in the left subtree\\n        int elementsInLeftSubTree = RootLeftSubTreePostIdx - postStart + 1;\\n\\n        /*\\n        * For left subtree\\n        * pre starts from preStart + 1, i.e. the very next element\\n        * pre ends at preStart + elementsInLeftSubTree - 1\\n        * post starts at postStart (remains same)\\n        * post ends at the RootLeftSubTreePostIdx (the rightmost element (the root of left subtree) in the post array)\\n        */\\n        root->left = helper(preStart + 1, preStart + elementsInLeftSubTree, postStart, RootLeftSubTreePostIdx, pre, post);\\n\\n        // if you run out of nodes for right subTree, return the root and\\n        // let root->right remain NULL\\n        if (RootLeftSubTreePostIdx + 1 == postEnd)\\n        {\\n            return root;\\n        }\\n\\n        /*\\n        * For right subtree\\n        * pre starts at 1 position after the last left subtree element\\n        * pre ends at preEnd (remains same)\\n        * post starts at RootLeftSubTreePostIdx + 1\\n        * post ends at 1 position to the left of postEnd (as postEnd is always current root)\\n        */\\n        root->right = helper(preStart + elementsInLeftSubTree + 1, preEnd, RootLeftSubTreePostIdx + 1, postEnd - 1, pre, post);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589318,
                "title": "recursion-explained",
                "content": "How it works:\\nwe know there can be many trees possible  for given pre and post order traversal\\n\\nbase case:\\n  tree is empty return null\\n  len==1 return creating node with that value (post orders last element popped)\\n  \\nRecursive step:\\nlast node in post is definately root\\nso we pop it and make treeNode of it\\t\\t\\nThen consider node that is just befor earlier popped node in post\\ni.e. current last node in post\\nwell till position of this node except first value in pre elements are part of left subtree\\nand from this position till last element in pre are of right subtree\\n\\nNote we call right part of subtree first as we are popping last element from post\\nso that should belong to right subtree first\\n\\n\\t\\t\\n\\t\\t\\n\\t\\tdef helper(pre,post):\\n        \\tif not pre:\\n                return None\\n            \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n            \\n            \\n            node=TreeNode(post.pop())\\n            ind=pre.index(post[-1])\\n            \\n            node.right=helper(pre[ind:],post)\\n            node.left=helper(pre[1:ind],post)\\n            \\n            return node\\n        \\n        return helper(pre,post)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "How it works:\\nwe know there can be many trees possible  for given pre and post order traversal\\n\\nbase case:\\n  tree is empty return null\\n  len==1 return creating node with that value (post orders last element popped)\\n  \\nRecursive step:\\nlast node in post is definately root\\nso we pop it and make treeNode of it\\t\\t\\nThen consider node that is just befor earlier popped node in post\\ni.e. current last node in post\\nwell till position of this node except first value in pre elements are part of left subtree\\nand from this position till last element in pre are of right subtree\\n\\nNote we call right part of subtree first as we are popping last element from post\\nso that should belong to right subtree first\\n\\n\\t\\t\\n\\t\\t\\n\\t\\tdef helper(pre,post):\\n        \\tif not pre:\\n                return None\\n            \\n            if len(pre)==1:\\n                return TreeNode(post.pop())\\n            \\n            \\n            node=TreeNode(post.pop())\\n            ind=pre.index(post[-1])\\n            \\n            node.right=helper(pre[ind:],post)\\n            node.left=helper(pre[1:ind],post)\\n            \\n            return node\\n        \\n        return helper(pre,post)",
                "codeTag": "Python3"
            },
            {
                "id": 484209,
                "title": "java-stack-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        int i = 0, j = 0;\\n        while(i < pre.length) {\\n            TreeNode newNode = new TreeNode(pre[i]);\\n            if(!stack.isEmpty()) {\\n                if(post[j] != stack.peek().val) {\\n                    stack.peek().left = newNode;\\n                } else {\\n                    while(stack.peek().val == post[j]) {\\n                        stack.pop();\\n                        ++j;\\n                    }\\n                    stack.peek().right = newNode;\\n                }\\n            }\\n            stack.push(newNode);\\n            ++i;\\n        }\\n        TreeNode root = null;\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n        }\\n\\n        return root;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        int i = 0, j = 0;\\n        while(i < pre.length) {\\n            TreeNode newNode = new TreeNode(pre[i]);\\n            if(!stack.isEmpty()) {\\n                if(post[j] != stack.peek().val) {\\n                    stack.peek().left = newNode;\\n                } else {\\n                    while(stack.peek().val == post[j]) {\\n                        stack.pop();\\n                        ++j;\\n                    }\\n                    stack.peek().right = newNode;\\n                }\\n            }\\n            stack.push(newNode);\\n            ++i;\\n        }\\n        TreeNode root = null;\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n        }\\n\\n        return root;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478961,
                "title": "summary-of-reconstruction-from-traversal",
                "content": "```C++\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <vector>\\nusing namespace std;\\n\\n/**\\n * https://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\\n * Four kinds of traversal: preorder, inorder, postorder, level-order.\\n * Given 2 traversal sequences, if can construct the general binary tree without \\n * ambuigity if and only if one of the sequence is an inorder traversal.\\n * \\n * Example:\\n * A        A\\n *  \\\\      /\\n *   B    B\\n * The above 2 binary trees have the same preorder of AB, postorder of BA, and \\n * level-order of AB. The tree cannot be reconstructed even with 3 of them.\\n */\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\n// utility functions\\nvoid printInorder(TreeNode* node) {\\n    if (node == NULL) return;\\n    printInorder(node->left);\\n    cout << node->val << \" \";\\n    printInorder(node->right);\\n}\\n\\nvoid printTree(TreeNode* node) {\\n    printInorder(node);\\n    cout << endl;\\n}\\n\\n\\n/** Inorder + preorder (1) */\\n// https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/\\n// Time: O(n ^ 2), worst case when tree is skewed. T(n) = T(n-1) + n.\\n//       O(nlgn), if the tree is balanced. T(n) = 2T(n/2) + n.\\nclass ConstructFromPreIn {\\n   private:\\n    int preIndex = 0;\\n\\n    int search(vector<int>& v, int l, int r, int val) {\\n        for (int i = l; i <= r; ++i) {\\n            if (v[i] == val) return i;\\n        }\\n        return -1;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre, int inStart, int inEnd) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = search(in, inStart, inEnd, node->val);\\n        node->left = construct(in, pre, inStart, inIndex - 1);\\n        node->right = construct(in, pre, inIndex + 1, inEnd);\\n\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        return construct(in, pre, 0, in.size() - 1);\\n    }\\n};\\n\\n\\n/** Inorder + preorder (2) */\\n// Time: O(n). Each preIndex takes O(1) time.\\nclass ConstructFromPreInFast {\\n   private:\\n    int preIndex = 0;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& pre, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        node->left = constructHelper(in, pre, inStart, inIndex - 1, map);\\n        node->right = constructHelper(in, pre, inIndex + 1, inEnd, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, pre, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** postorder + inorder */\\n// https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/\\nclass ConstructFromInPost {\\n   private:\\n    int postIndex;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& post, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(post[postIndex--]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        // The order matters\\n        node->right = constructHelper(in, post, inIndex + 1, inEnd, map);\\n        node->left = constructHelper(in, post, inStart, inIndex - 1, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& post) {\\n        this->postIndex = post.size() - 1;\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, post, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** preorder + postorder */\\n// Idea from, slightly different implementation:\\n// https://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/\\nclass PrePost {\\n   public:\\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int preStart, int preEnd,\\n                        int postStart, int postEnd, unordered_map<int, int>& postMap) {\\n        // \"preEnd - preStart == postEnd - postStart\" should be maintained.\\n        if (preStart > preEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return node;\\n\\n        // preStart < preEnd\\n        int postIndex = postMap[pre[preStart + 1]];\\n\\n        int leftPreStart = preStart + 1;\\n        int leftPreEnd = leftPreStart + (postIndex - postStart);\\n        int leftPostStart = postStart;\\n        int leftPostEnd = postIndex;\\n        node->left = construct(pre, post, leftPreStart, leftPreEnd, leftPostStart, leftPostEnd, postMap);\\n\\n        int rightPreStart = leftPreEnd + 1;\\n        int rightPreEnd = preEnd;\\n        int rightPostStart = postIndex + 1;\\n        int rightPostEnd = postEnd - 1;\\n        node->right = construct(pre, post, rightPreStart, rightPreEnd, rightPostStart, rightPostEnd, postMap);\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < post.size(); ++i) map[post[i]] = i;\\n        return construct(pre, post, 0, pre.size() - 1, 0, post.size() - 1, map);\\n    }\\n};\\n\\nvoid preInFunc() {\\n    ConstructFromPreIn* inPre;\\n    ConstructFromPreInFast* inPreFast;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in1, pre1));\\n    printTree(inPreFast->construct(in1, pre1));\\n\\n    vector<int> in2 = {4, 2, 5, 1, 6, 3};\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in2, pre2));\\n    printTree(inPreFast->construct(in2, pre2));\\n}\\n\\nvoid inPostFunc() {\\n    ConstructFromInPost* inPost;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    inPost = new ConstructFromInPost();\\n    printTree(inPost->construct(in1, post1));\\n}\\n\\nvoid prePostFunc() {\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    printTree((new PrePost())->construct(pre1, post1));\\n\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    vector<int> post2 = {4, 5, 2, 6, 3, 1};\\n    printTree((new PrePost())->construct(pre2, post2));\\n}\\n\\nint main() {\\n    preInFunc();\\n    inPostFunc();\\n    prePostFunc();\\n}\\n```",
                "solutionTags": [],
                "code": "```C++\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n#include <vector>\\nusing namespace std;\\n\\n/**\\n * https://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/\\n * Four kinds of traversal: preorder, inorder, postorder, level-order.\\n * Given 2 traversal sequences, if can construct the general binary tree without \\n * ambuigity if and only if one of the sequence is an inorder traversal.\\n * \\n * Example:\\n * A        A\\n *  \\\\      /\\n *   B    B\\n * The above 2 binary trees have the same preorder of AB, postorder of BA, and \\n * level-order of AB. The tree cannot be reconstructed even with 3 of them.\\n */\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\n// utility functions\\nvoid printInorder(TreeNode* node) {\\n    if (node == NULL) return;\\n    printInorder(node->left);\\n    cout << node->val << \" \";\\n    printInorder(node->right);\\n}\\n\\nvoid printTree(TreeNode* node) {\\n    printInorder(node);\\n    cout << endl;\\n}\\n\\n\\n/** Inorder + preorder (1) */\\n// https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/\\n// Time: O(n ^ 2), worst case when tree is skewed. T(n) = T(n-1) + n.\\n//       O(nlgn), if the tree is balanced. T(n) = 2T(n/2) + n.\\nclass ConstructFromPreIn {\\n   private:\\n    int preIndex = 0;\\n\\n    int search(vector<int>& v, int l, int r, int val) {\\n        for (int i = l; i <= r; ++i) {\\n            if (v[i] == val) return i;\\n        }\\n        return -1;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre, int inStart, int inEnd) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = search(in, inStart, inEnd, node->val);\\n        node->left = construct(in, pre, inStart, inIndex - 1);\\n        node->right = construct(in, pre, inIndex + 1, inEnd);\\n\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        return construct(in, pre, 0, in.size() - 1);\\n    }\\n};\\n\\n\\n/** Inorder + preorder (2) */\\n// Time: O(n). Each preIndex takes O(1) time.\\nclass ConstructFromPreInFast {\\n   private:\\n    int preIndex = 0;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& pre, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preIndex++]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        node->left = constructHelper(in, pre, inStart, inIndex - 1, map);\\n        node->right = constructHelper(in, pre, inIndex + 1, inEnd, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& pre) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, pre, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** postorder + inorder */\\n// https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/\\nclass ConstructFromInPost {\\n   private:\\n    int postIndex;\\n\\n    TreeNode* constructHelper(vector<int>& in, vector<int>& post, int inStart,\\n                              int inEnd, unordered_map<int, int>& map) {\\n        if (inStart > inEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(post[postIndex--]);\\n        if (inStart == inEnd) return node;\\n\\n        int inIndex = map[node->val];\\n        // The order matters\\n        node->right = constructHelper(in, post, inIndex + 1, inEnd, map);\\n        node->left = constructHelper(in, post, inStart, inIndex - 1, map);\\n\\n        return node;\\n    }\\n\\n   public:\\n    TreeNode* construct(vector<int>& in, vector<int>& post) {\\n        this->postIndex = post.size() - 1;\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < in.size(); ++i) map[in[i]] = i;\\n        return constructHelper(in, post, 0, in.size() - 1, map);\\n    }\\n};\\n\\n\\n/** preorder + postorder */\\n// Idea from, slightly different implementation:\\n// https://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/\\nclass PrePost {\\n   public:\\n    TreeNode* construct(vector<int>& pre, vector<int>& post, int preStart, int preEnd,\\n                        int postStart, int postEnd, unordered_map<int, int>& postMap) {\\n        // \"preEnd - preStart == postEnd - postStart\" should be maintained.\\n        if (preStart > preEnd) return NULL;\\n\\n        TreeNode* node = new TreeNode(pre[preStart]);\\n        if (preStart == preEnd) return node;\\n\\n        // preStart < preEnd\\n        int postIndex = postMap[pre[preStart + 1]];\\n\\n        int leftPreStart = preStart + 1;\\n        int leftPreEnd = leftPreStart + (postIndex - postStart);\\n        int leftPostStart = postStart;\\n        int leftPostEnd = postIndex;\\n        node->left = construct(pre, post, leftPreStart, leftPreEnd, leftPostStart, leftPostEnd, postMap);\\n\\n        int rightPreStart = leftPreEnd + 1;\\n        int rightPreEnd = preEnd;\\n        int rightPostStart = postIndex + 1;\\n        int rightPostEnd = postEnd - 1;\\n        node->right = construct(pre, post, rightPreStart, rightPreEnd, rightPostStart, rightPostEnd, postMap);\\n        return node;\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& post) {\\n        unordered_map<int, int> map;\\n        for (int i = 0; i < post.size(); ++i) map[post[i]] = i;\\n        return construct(pre, post, 0, pre.size() - 1, 0, post.size() - 1, map);\\n    }\\n};\\n\\nvoid preInFunc() {\\n    ConstructFromPreIn* inPre;\\n    ConstructFromPreInFast* inPreFast;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in1, pre1));\\n    printTree(inPreFast->construct(in1, pre1));\\n\\n    vector<int> in2 = {4, 2, 5, 1, 6, 3};\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    inPre = new ConstructFromPreIn();\\n    inPreFast = new ConstructFromPreInFast();\\n    printTree(inPre->construct(in2, pre2));\\n    printTree(inPreFast->construct(in2, pre2));\\n}\\n\\nvoid inPostFunc() {\\n    ConstructFromInPost* inPost;\\n\\n    vector<int> in1 = {4, 2, 5, 1, 6, 3, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    inPost = new ConstructFromInPost();\\n    printTree(inPost->construct(in1, post1));\\n}\\n\\nvoid prePostFunc() {\\n    vector<int> pre1 = {1, 2, 4, 5, 3, 6, 7};\\n    vector<int> post1 = {4, 5, 2, 6, 7, 3, 1};\\n    printTree((new PrePost())->construct(pre1, post1));\\n\\n    vector<int> pre2 = {1, 2, 4, 5, 3, 6};\\n    vector<int> post2 = {4, 5, 2, 6, 3, 1};\\n    printTree((new PrePost())->construct(pre2, post2));\\n}\\n\\nint main() {\\n    preInFunc();\\n    inPostFunc();\\n    prePostFunc();\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 446833,
                "title": "java-1-ms-recursive-solution",
                "content": "Steps:\\n1. Create node from `pre[preIdx]` \\n2. Recurse left and repeat 1 until `pre[preIdx] == post[postIdx]`\\n3. Increment `postIdx` as we go back up the tree\\n4. Go right\\n5. Repeat\\n\\nBy the end, `preIdx` and `postIdx` will be the length of the arrays.\\n\\nTime: O(n) touches every node once\\nSpace: O(h) callstack is as the height of the tree\\n\\n```\\npublic class ConstructBinaryTreeFromPreorderAndPostorderTraversal {\\n    int preIdx = 0;\\n    int postIdx = 0;\\n\\n    // Time: O(n) every node\\n    // Space: O(h) height of tree\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (preIdx >= pre.length) return null;\\n        \\n        TreeNode curr = new TreeNode(pre[preIdx]);\\n        if (pre[preIdx] == post[postIdx]) {\\n            preIdx++;\\n            postIdx++;\\n            return curr;\\n        }\\n\\n        preIdx++;\\n        curr.left = constructFromPrePost(pre, post);\\n        if (curr.val == post[postIdx]) {\\n            postIdx++;\\n            return curr;\\n        }\\n        \\n        curr.right = constructFromPrePost(pre, post);\\n        postIdx++;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class ConstructBinaryTreeFromPreorderAndPostorderTraversal {\\n    int preIdx = 0;\\n    int postIdx = 0;\\n\\n    // Time: O(n) every node\\n    // Space: O(h) height of tree\\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\\n        if (preIdx >= pre.length) return null;\\n        \\n        TreeNode curr = new TreeNode(pre[preIdx]);\\n        if (pre[preIdx] == post[postIdx]) {\\n            preIdx++;\\n            postIdx++;\\n            return curr;\\n        }\\n\\n        preIdx++;\\n        curr.left = constructFromPrePost(pre, post);\\n        if (curr.val == post[postIdx]) {\\n            postIdx++;\\n            return curr;\\n        }\\n        \\n        curr.right = constructFromPrePost(pre, post);\\n        postIdx++;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393660,
                "title": "go-easy-to-understand-beat-83-for-speed-and-100-for-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    root := TreeNode{pre[0], nil, nil} //the parent node is the first node in pre\\n    if len(pre)==1 {return &root}\\n    pre = pre[1:] //clear the root from the list\\n    \\n    hold := pre[0] //pre[0] is the left child\\n\\n    leftChildren := []int{} \\n    for i, val := range post{\\n        if val == hold{\\n            leftChildren = post[:i+1] //iterate through post until you see the root. everything before that are left children\\n            post = post[i+1:] //everything to the right are the right children\\n            break\\n        }\\n    }\\n    if len(leftChildren) >0{root.Left = constructFromPrePost(pre[:len(leftChildren)], leftChildren)}\\n    \\n    pre = pre[len(leftChildren):] //cut all left children out of pre\\n    if len(pre)>0{root.Right = constructFromPrePost(pre, post)}\\n    \\n    return &root\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    root := TreeNode{pre[0], nil, nil} //the parent node is the first node in pre\\n    if len(pre)==1 {return &root}\\n    pre = pre[1:] //clear the root from the list\\n    \\n    hold := pre[0] //pre[0] is the left child\\n\\n    leftChildren := []int{} \\n    for i, val := range post{\\n        if val == hold{\\n            leftChildren = post[:i+1] //iterate through post until you see the root. everything before that are left children\\n            post = post[i+1:] //everything to the right are the right children\\n            break\\n        }\\n    }\\n    if len(leftChildren) >0{root.Left = constructFromPrePost(pre[:len(leftChildren)], leftChildren)}\\n    \\n    pre = pre[len(leftChildren):] //cut all left children out of pre\\n    if len(pre)>0{root.Right = constructFromPrePost(pre, post)}\\n    \\n    return &root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365015,
                "title": "python-o-n-one-pass-iterative-solution",
                "content": "The idea behind this algorithm is that we traverse through the preorder array once, and add nodes to the tree as we go. The current node that we are at in the tree is determined by a stack of the latest nodes added to the tree. As we are iterating through the preorder array, we have a second pointer for the postorder array that helps us keep track of when we\\'ve reached the end of a branch. \\n\\nIf the current node we are examining (after adding to the tree) is equivalent to the value being pointed to by the posterorder pointer, then we enter the following loop until ```current_node != postorder_pointer_value```: (1) pop the stack, (2) peek at the top node in the stack, and (3) increment ```postorder_pointer``` by 1.\\n\\nBy doing so, this ensures that the preorder traversal still matches the postorder traversal.\\n\\n```\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tif len(pre) == 0 or len(post) == 0:\\n\\t\\treturn None\\n\\n\\troot = TreeNode(pre[0])\\n\\tstack = [root]\\n\\tcurr = root\\n\\tpost_pointer = 0\\n\\tfor i in range(1, len(pre)):\\n\\t\\tif not curr.left:\\n\\t\\t\\tcurr.left = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\telse:\\n\\t\\t\\tcurr.right = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.right)\\n\\t\\tcurr = stack[-1]\\n\\t\\twhile curr.val == post[post_pointer]:\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcurr = stack[-1]\\n\\t\\t\\tpost_pointer += 1\\n\\treturn root\\n```",
                "solutionTags": [],
                "code": "```current_node != postorder_pointer_value```\n```postorder_pointer```\n```\\ndef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\tif len(pre) == 0 or len(post) == 0:\\n\\t\\treturn None\\n\\n\\troot = TreeNode(pre[0])\\n\\tstack = [root]\\n\\tcurr = root\\n\\tpost_pointer = 0\\n\\tfor i in range(1, len(pre)):\\n\\t\\tif not curr.left:\\n\\t\\t\\tcurr.left = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.left)\\n\\t\\telse:\\n\\t\\t\\tcurr.right = TreeNode(pre[i])\\n\\t\\t\\tstack.append(curr.right)\\n\\t\\tcurr = stack[-1]\\n\\t\\twhile curr.val == post[post_pointer]:\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcurr = stack[-1]\\n\\t\\t\\tpost_pointer += 1\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359298,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # [1] [2 4 5] [3 6 7]\\n        # 4 5 [2] 6 7 3 [1]\\n        # the location of pre[1] in post decide how many left children there are\\n        if not pre or not post:\\n            return None\\n        mid = pre[0]\\n        node = TreeNode(mid)\\n        if len(pre) > 1:\\n            leftNum = post.index(pre[1])+1\\n            node.left = self.constructFromPrePost(pre[1:leftNum+1],post[:leftNum])\\n            node.right = self.constructFromPrePost(pre[leftNum+1:],post[leftNum:len(post)-1])\\n        return node\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        # [1] [2 4 5] [3 6 7]\\n        # 4 5 [2] 6 7 3 [1]\\n        # the location of pre[1] in post decide how many left children there are\\n        if not pre or not post:\\n            return None\\n        mid = pre[0]\\n        node = TreeNode(mid)\\n        if len(pre) > 1:\\n            leftNum = post.index(pre[1])+1\\n            node.left = self.constructFromPrePost(pre[1:leftNum+1],post[:leftNum])\\n            node.right = self.constructFromPrePost(pre[leftNum+1:],post[leftNum:len(post)-1])\\n        return node\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 334921,
                "title": "go-golang-0-ms-faster-than-100-00",
                "content": "```golang\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 || len(pre) != len(post) {\\n        return nil\\n    }\\n    \\n    root := &TreeNode{\\n        Val: pre[0],\\n    }\\n    \\n    size := len(post)\\n    if size == 1 {\\n\\t\\treturn root\\n\\t}\\n     \\n    for i:=0; i < size; i++ {\\n\\t\\tif post[i] == pre[1] {\\n\\t\\t\\troot.Left = constructFromPrePost(pre[1:i+2], post[:i+1])\\n\\t        root.Right = constructFromPrePost(pre[i+2:], post[i+1:size-1])\\n\\t\\t    break\\n        }\\n\\t}\\n    \\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc constructFromPrePost(pre []int, post []int) *TreeNode {\\n    if len(pre) == 0 || len(pre) != len(post) {\\n        return nil\\n    }\\n    \\n    root := &TreeNode{\\n        Val: pre[0],\\n    }\\n    \\n    size := len(post)\\n    if size == 1 {\\n\\t\\treturn root\\n\\t}\\n     \\n    for i:=0; i < size; i++ {\\n\\t\\tif post[i] == pre[1] {\\n\\t\\t\\troot.Left = constructFromPrePost(pre[1:i+2], post[:i+1])\\n\\t        root.Right = constructFromPrePost(pre[i+2:], post[i+1:size-1])\\n\\t\\t    break\\n        }\\n\\t}\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329379,
                "title": "python3-recursive-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\t\\t\\tif not pre or not post:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\troot=TreeNode(pre[0])\\n\\t\\t\\tif len(pre)==1:           \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tind=post.index(pre[1])\\n\\t\\t\\troot.left=self.constructFromPrePost(pre[1:ind+2],post[:ind+1])\\n\\t\\t\\troot.right=self.constructFromPrePost(pre[ind+2:],post[ind+1:-1])\\n\\t\\t\\treturn root",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n\\t\\t\\tif not pre or not post:\\n\\t\\t\\t\\treturn None\\n\\t\\t\\troot=TreeNode(pre[0])\\n\\t\\t\\tif len(pre)==1:           \\n\\t\\t\\t\\treturn root\\n\\t\\t\\tind=post.index(pre[1])\\n\\t\\t\\troot.left=self.constructFromPrePost(pre[1:ind+2],post[:ind+1])\\n\\t\\t\\troot.right=self.constructFromPrePost(pre[ind+2:],post[ind+1:-1])\\n\\t\\t\\treturn root",
                "codeTag": "Java"
            },
            {
                "id": 326558,
                "title": "python-recursive",
                "content": "Run time O(n), space O(n)\\n\\n```\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not post:\\n            return None\\n        elif len(post) == 1:\\n            return TreeNode(pre.pop(0))\\n        else:\\n            root = TreeNode(pre.pop(0))\\n            # print(root.val)\\n            pos = post.index(pre[0])\\n            root.left = self.constructFromPrePost(pre, post[:pos+1])\\n            root.right = self.constructFromPrePost(pre, post[pos+1:-1])\\n            return root\\n```",
                "solutionTags": [],
                "code": "```\\n    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:\\n        if not post:\\n            return None\\n        elif len(post) == 1:\\n            return TreeNode(pre.pop(0))\\n        else:\\n            root = TreeNode(pre.pop(0))\\n            # print(root.val)\\n            pos = post.index(pre[0])\\n            root.left = self.constructFromPrePost(pre, post[:pos+1])\\n            root.right = self.constructFromPrePost(pre, post[pos+1:-1])\\n            return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 326238,
                "title": "python-rescursion",
                "content": "This is similar to [my 105 solution](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/326205/Python-Recursion)\\n```python\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        if len(pre) == 0:\\n            return None\\n        head = TreeNode(pre[0])\\n        if len(pre) == 1:\\n            return head\\n        pre.pop(0)\\n        post.pop()\\n        ind = getInd(pre, post)\\n        lpre, rpre = leftAndRight(pre, ind)\\n        lpost, rpost = leftAndRight(post, ind)\\n        head.left = self.constructFromPrePost(lpre,lpost)\\n        head.right = self.constructFromPrePost (rpre,rpost)\\n        return head\\n        \\ndef getInd(preorder, inorder):\\n    i = 0\\n    lp, li, rp, ri = [], [], [], []\\n    while preorder[0] != inorder[i]:\\n        i += 1\\n    return i\\n\\ndef leftAndRight(order, i):\\n    if i == 0:\\n        return [order[0]], order[1:]\\n    if i == len(order):\\n        return order, []\\n    return order[:i+1], order[i+1:]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        if len(pre) == 0:\\n            return None\\n        head = TreeNode(pre[0])\\n        if len(pre) == 1:\\n            return head\\n        pre.pop(0)\\n        post.pop()\\n        ind = getInd(pre, post)\\n        lpre, rpre = leftAndRight(pre, ind)\\n        lpost, rpost = leftAndRight(post, ind)\\n        head.left = self.constructFromPrePost(lpre,lpost)\\n        head.right = self.constructFromPrePost (rpre,rpost)\\n        return head\\n        \\ndef getInd(preorder, inorder):\\n    i = 0\\n    lp, li, rp, ri = [], [], [], []\\n    while preorder[0] != inorder[i]:\\n        i += 1\\n    return i\\n\\ndef leftAndRight(order, i):\\n    if i == 0:\\n        return [order[0]], order[1:]\\n    if i == len(order):\\n        return order, []\\n    return order[:i+1], order[i+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326000,
                "title": "ruby-recursive-beat-100-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val)\\n#         @val = val\\n#         @left, @right = nil, nil\\n#     end\\n# end\\n\\n# @param {Integer[]} pre\\n# @param {Integer[]} post\\n# @return {TreeNode}\\ndef construct_from_pre_post(pre, post)\\n    return nil if pre.empty?\\n    root = TreeNode.new(pre.first)\\n    return root if pre.size == 1\\n    \\n    # case pre / post size >= 2\\n    idx_pre = 0\\n    \\n    # find left branch post\\n    left_val = pre[1]\\n    \\n    left_end_idx = post.find_index(left_val)\\n    post_left = post.slice(0..left_end_idx)\\n    \\n    # find right branch post\\n    post_right = post.slice(left_end_idx+1..-2)\\n    \\n    # find left branch pre\\n    right_val = post_right.last\\n    \\n    if right_val.nil?\\n        pre_left = pre.slice(1..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n    else\\n        right_first_idx = pre.find_index(right_val)\\n        pre_left = pre.slice(1..right_first_idx-1) \\n        # find right branch post\\n        pre_right = pre.slice(right_first_idx..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n        root.right = construct_from_pre_post(pre_right, post_right) \\n    end\\n    \\n    return root\\n    \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val)\\n#         @val = val\\n#         @left, @right = nil, nil\\n#     end\\n# end\\n\\n# @param {Integer[]} pre\\n# @param {Integer[]} post\\n# @return {TreeNode}\\ndef construct_from_pre_post(pre, post)\\n    return nil if pre.empty?\\n    root = TreeNode.new(pre.first)\\n    return root if pre.size == 1\\n    \\n    # case pre / post size >= 2\\n    idx_pre = 0\\n    \\n    # find left branch post\\n    left_val = pre[1]\\n    \\n    left_end_idx = post.find_index(left_val)\\n    post_left = post.slice(0..left_end_idx)\\n    \\n    # find right branch post\\n    post_right = post.slice(left_end_idx+1..-2)\\n    \\n    # find left branch pre\\n    right_val = post_right.last\\n    \\n    if right_val.nil?\\n        pre_left = pre.slice(1..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n    else\\n        right_first_idx = pre.find_index(right_val)\\n        pre_left = pre.slice(1..right_first_idx-1) \\n        # find right branch post\\n        pre_right = pre.slice(right_first_idx..-1) \\n        root.left = construct_from_pre_post(pre_left, post_left)\\n        root.right = construct_from_pre_post(pre_right, post_right) \\n    end\\n    \\n    return root\\n    \\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312017,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nTreeNode* foo(vector<int>& pre,vector<int>& post,int preL,int preR,int postL,int postR)\\n{\\n    if (preL>preR) return NULL;\\n    \\n    TreeNode* root = new TreeNode(pre[preL]);\\n    \\n    if (preL==preR) return root;\\n    \\n    int l = pre[preL+1];\\n    int i = find(post.begin(),post.end(),l)-post.begin();\\n    \\n    int n = i-postL+1;\\n    \\n    root->left = foo(pre,post,preL+1,preL+n,postL,i);\\n    \\n    root->right = foo(pre,post,preL+n+1,preR,i+1,postR-1);\\n    \\n    return root;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        return foo(pre,post,0,pre.size()-1,0,post.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nTreeNode* foo(vector<int>& pre,vector<int>& post,int preL,int preR,int postL,int postR)\\n{\\n    if (preL>preR) return NULL;\\n    \\n    TreeNode* root = new TreeNode(pre[preL]);\\n    \\n    if (preL==preR) return root;\\n    \\n    int l = pre[preL+1];\\n    int i = find(post.begin(),post.end(),l)-post.begin();\\n    \\n    int n = i-postL+1;\\n    \\n    root->left = foo(pre,post,preL+1,preL+n,postL,i);\\n    \\n    root->right = foo(pre,post,preL+n+1,preR,i+1,postR-1);\\n    \\n    return root;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {\\n        \\n        return foo(pre,post,0,pre.size()-1,0,post.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297993,
                "title": "javascript-iterative-w-stack-beats-90",
                "content": "```\\nvar constructFromPrePost = function(pre, post) {\\n    let preIndex = 0;\\n    let postIndex = 0;\\n    let nodeStack = [];\\n    \\n    nodeStack.push(new TreeNode(0));\\n    \\n    while(postIndex < post.length) {\\n        if(nodeStack[nodeStack.length - 1].val == post[postIndex]) {\\n            let child = nodeStack.pop();\\n            let parent = nodeStack.pop();\\n            \\n            if(!parent.left)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            nodeStack.push(parent);\\n            postIndex++;\\n        } else\\n            nodeStack.push(new TreeNode(pre[preIndex++]));\\n    }\\n    \\n    return nodeStack.pop().left;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar constructFromPrePost = function(pre, post) {\\n    let preIndex = 0;\\n    let postIndex = 0;\\n    let nodeStack = [];\\n    \\n    nodeStack.push(new TreeNode(0));\\n    \\n    while(postIndex < post.length) {\\n        if(nodeStack[nodeStack.length - 1].val == post[postIndex]) {\\n            let child = nodeStack.pop();\\n            let parent = nodeStack.pop();\\n            \\n            if(!parent.left)\\n                parent.left = child;\\n            else\\n                parent.right = child;\\n            \\n            nodeStack.push(parent);\\n            postIndex++;\\n        } else\\n            nodeStack.push(new TreeNode(pre[preIndex++]));\\n    }\\n    \\n    return nodeStack.pop().left;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570770,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1569902,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1804336,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1573886,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1938195,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1825069,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            },
            {
                "id": 1745113,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n ![image](https://assets.leetcode.com/users/images/03fe7bd7-8b71-41f0-9985-3a480f2d68a0_1643018166.2277544.png)\\n\\n \\n![image](https://assets.leetcode.com/users/images/ead74384-be98-449e-bafa-b1a4ff357582_1643018327.8876154.png)\\n"
                    },
                    {
                        "username": "Shubhamu68",
                        "content": "We cannot construct a Binary Tree using Preorder and Postorder without being confirmed that this is a Full binary tree.\\nWe actually need InOrder with PreOrder or PostOrder to construct a tree.\\n\\nSo should we assume this tree to be a Full binary Tree?\\n\\nThe problem should be more descriptive actually...\\n\\nCorrect me if i\\'m wrong!!!\\nThanks!!!"
                    },
                    {
                        "username": "mafkavelly",
                        "content": "We can check if parent node has 2, 1 or 0 children. If it is 1 child, then we can assume it is left or right, doesn\\'t matter. That\\'s the only thing we cannot reconstruct."
                    },
                    {
                        "username": "shrey0811",
                        "content": "You have to assume that it is full binary tree(by default), unless or until it\\'s mention in the question  (not to assume full binary tree).."
                    },
                    {
                        "username": "bcb98801xx",
                        "content": "It says that If there exist multiple answers, you can return any of them.\\nSo it does have a change to have multiple diffirent tree with the same preorder and postorder."
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Just to clarify:\npreorder + postorder traversals do not contain complete information of the tree structure. That's why the task description says: \"If there exist multiple answers, you can return any of them.\"\nFor example trees:\n[1,2,null]\n[1,null,2]\nHave the same postorder and preorder."
                    },
                    {
                        "username": "john_112",
                        "content": "Here\\'re few more related problems if anyone interested:\\n\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-preorder-traversal/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and preorder traversal</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-postorder-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and postorder traversals</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-binary-tree-from-inorder-level-order-traversals/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a binary tree from inorder and level order sequence</a>\\n&nbsp;</li>\\n<li><a href=\"//www.techiedelight.com/construct-full-binary-tree-from-preorder-sequence-with-leaf-information/\" target=\"_blank\" rel=\"noopener noreferrer\">Construct a full binary tree from preorder sequence with leaf node information</a>\\n&nbsp;</li>\\n"
                    },
                    {
                        "username": "rakshith_9909",
                        "content": "Assume it as a full binary tree and proceed with the problem"
                    },
                    {
                        "username": "sagar-1209",
                        "content": "please find me \\npreorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\\nwhy it is wrong answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        for(int i=0;i<preorder.size();i++){\\n            mp[preorder[i]] = i;\\n        }\\n        TreeNode* root = buildtree(preorder,0,preorder.size()-1,postorder,0,postorder.size()-1);\\n        return root;\\n    }\\n    TreeNode* buildtree(vector<int>&preorder,int prestart,int preend,vector<int>&postorder,int poststart,int postend){\\n        if(prestart>preend ||  poststart>postend || poststart<0 || prestart<0) return NULL;\\n\\n        TreeNode* root = new TreeNode(postorder[postend]);\\n        int prerootnext; \\n        if(postend>0)\\n           prerootnext = mp[postorder[postend-1]];\\n        else return root;\\n        int numright = preend - prerootnext+1;\\n        root->left = buildtree(preorder,prestart+1,prerootnext-1,postorder,poststart,postend-numright-1);\\n        root->right = buildtree(preorder,prerootnext,preend,postorder,postend-numright,postend-1);\\n        return root;\\n    }\\n};\\n"
                    },
                    {
                        "username": "mrenigmatic_19",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* ans(vector<int>preorder,vector<int>postorder){\\n        vector<int>left,right;\\n        left.clear();\\n        right.clear();\\n        int i,j;\\n        TreeNode*root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1&&postorder.size()==1){\\n            root->left=nullptr;\\n            root->right=nullptr;\\n            return root;\\n        }\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            break;\\n            left.push_back(preorder[i]);\\n        }\\n        for(j=0;j<preorder.size();j++){\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            break;\\n        }\\n        root->left=ans(left,right);\\n        left.clear();\\n        right.clear();\\n        int k=0;\\n        for(i=1;i<preorder.size();i++){\\n            if(preorder[i]==postorder[postorder.size()-2])\\n            k=1;\\n            if(k)\\n            left.push_back(preorder[i]);\\n        }\\n        j++;\\n        k=0;\\n        for(j=0;j<preorder.size()-1;j++){\\n            if(k)\\n            right.push_back(preorder[j]);\\n            if(preorder[1]==postorder[j])\\n            k=1;\\n        }\\n        root->right=ans(left,right);\\n        return root;\\n    }\\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\\n        return ans(preorder,postorder);\\n    }\\n};\\nwhy this is runtime error\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "first of all please learn how to post `CODE` then will talk later"
                    }
                ]
            }
        ]
    }
]