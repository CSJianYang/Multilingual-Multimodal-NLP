[
    {
        "title": "Determine if Two Events Have Conflict",
        "question_content": "You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:\n\n\tevent1 = [startTime1, endTime1] and\n\tevent2 = [startTime2, endTime2].\n\nEvent times are valid 24 hours format in the form of HH:MM.\nA conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).\nReturn true if there is a conflict between two events. Otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\nOutput: true\nExplanation: The two events intersect at time 2:00.\n\nExample 2:\n\nInput: event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\nOutput: true\nExplanation: The two events intersect starting from 01:20 to 02:00.\n\nExample 3:\n\nInput: event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\nOutput: false\nExplanation: The two events do not intersect.\n\n&nbsp;\nConstraints:\n\n\tevnet1.length == event2.length == 2.\n\tevent1[i].length == event2[i].length == 5\n\tstartTime1 <= endTime1\n\tstartTime2 <= endTime2\n\tAll the event times follow the HH:MM format.",
        "solutions": [
            {
                "id": 2734120,
                "title": "java-c-python-easy-1-liner-solutions",
                "content": "# **Similar question**\\n[836. Rectangle Overlap](https://leetcode.com/problems/rectangle-overlap/discuss/132340/C%2B%2BJavaPython-1-line-Solution-1D-to-2D)\\n<br>\\n\\n# **Explanation**\\nGiven 2 segment `[left1, right1]`, `[left2, right2]`,\\nhow can we check whether they overlap?\\nIf these two intervals overlap, it should exist a value `x`,\\n`left1 <= x <= right1 && left2 <= x <= right2`\\nso that\\n`max(left1, left2) <= x <= min(right1, right 2)`\\nso that\\n`left1 <= right2 && left2 <= right1`\\n\\nThese two are the sufficient and necessary conditions,\\nfor two interval overlaps.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n\\n# Solution 1\\n**Java**\\n```java\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n        return e1[0].compareTo(e2[1]) <= 0 && e2[0].compareTo(e1[1]) <= 0;\\n    }\\n```\\n**C++**\\n```cpp\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return e1[0] <= e2[1] && e2[0] <= e1[1];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def haveConflict(self, e1, e2):\\n        return e1[0] <= e2[1] and e2[0] <= e1[1]\\n```\\n<br>\\n\\n# Solution 2\\n**C++**\\n```cpp\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return max(e1[0], e2[0]) <= min(e1[1], e2[1]);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def haveConflict(self, e1, e2):\\n        return max(e1[0],e2[0]) <= min(e1[1],e2[1])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n        return e1[0].compareTo(e2[1]) <= 0 && e2[0].compareTo(e1[1]) <= 0;\\n    }\\n```\n```cpp\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return e1[0] <= e2[1] && e2[0] <= e1[1];\\n    }\\n```\n```py\\n    def haveConflict(self, e1, e2):\\n        return e1[0] <= e2[1] and e2[0] <= e1[1]\\n```\n```cpp\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return max(e1[0], e2[0]) <= min(e1[1], e2[1]);\\n    }\\n```\n```py\\n    def haveConflict(self, e1, e2):\\n        return max(e1[0],e2[0]) <= min(e1[1],e2[1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734266,
                "title": "c-2-solutions-one-liner-explanation-convert-to-minutes",
                "content": "#### Convert the given time to minutes and then compare \\n\\n` example :  14 : 34 then (1 * 10 + 4) * 60 + (3 * 10 + 4)`\\n\\nNote:- This is a very beginner friendly code we can do direct string comparisions too ! one liner and its explanation is given below\\n#### c++ basic solution \\n```c++\\nclass Solution\\n{\\npublic:\\n    bool haveConflict(vector<string> &event1, vector<string> &event2)\\n    {\\n        auto x = event1[0], y = event1[1];\\n        int a1 = ((x[0] - \\'0\\') * 10 + x[1] - \\'0\\') * 60 + ((x[3] - \\'0\\') * 10 + x[4] - \\'0\\');\\n        int b1 = ((y[0] - \\'0\\') * 10 + y[1] - \\'0\\') * 60 + ((y[3] - \\'0\\') * 10 + y[4] - \\'0\\');\\n        x = event2[0], y = event2[1];\\n\\n        int a2 = ((x[0] - \\'0\\') * 10 + x[1] - \\'0\\') * 60 + ((x[3] - \\'0\\') * 10 + x[4] - \\'0\\');\\n        int b2 = ((y[0] - \\'0\\') * 10 + y[1] - \\'0\\') * 60 + ((y[3] - \\'0\\') * 10 + y[4] - \\'0\\');\\n\\t\\t\\n        if (a1 <= a2 && a2 <= b1)\\n            return true;\\n        if (a2 <= a1 && a1 <= b2)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n#### one liner c++\\n* The idea of one liner approach is to compare strings them selves\\n* we know that in a 24 hour clock we have hours as 14 , 15, etc \\n* so given two times we can simply compare the string times\\nWhy Will this work ?? \\n* The comparision operator is overloaded for strings and what it does is \\n` one by one character checking until any one is found greater `\\n`Thus if given times are  `14:26 and 14:30`\\nit checks 1 first they are same move forward then 4 is checked then 2 and 3 are compared \\nascii of 3 > ascii  of 2 (50 , 49 respectively) `\\n\\nHence if **event1.starttime <= event2.starttime <= event1.endTime** holds true or the converse i.e event1 is between event two holds true that means they overlap\\n\\nso using this idea we can check if one start time falls in other interval\\n```c++\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) \\n    {\\n        return (e1[0] <= e2[0] && e2[0] <= e1[1]) || \\n               (e2[0] <= e1[0] && e1[0] <= e2[1]);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution\\n{\\npublic:\\n    bool haveConflict(vector<string> &event1, vector<string> &event2)\\n    {\\n        auto x = event1[0], y = event1[1];\\n        int a1 = ((x[0] - \\'0\\') * 10 + x[1] - \\'0\\') * 60 + ((x[3] - \\'0\\') * 10 + x[4] - \\'0\\');\\n        int b1 = ((y[0] - \\'0\\') * 10 + y[1] - \\'0\\') * 60 + ((y[3] - \\'0\\') * 10 + y[4] - \\'0\\');\\n        x = event2[0], y = event2[1];\\n\\n        int a2 = ((x[0] - \\'0\\') * 10 + x[1] - \\'0\\') * 60 + ((x[3] - \\'0\\') * 10 + x[4] - \\'0\\');\\n        int b2 = ((y[0] - \\'0\\') * 10 + y[1] - \\'0\\') * 60 + ((y[3] - \\'0\\') * 10 + y[4] - \\'0\\');\\n\\t\\t\\n        if (a1 <= a2 && a2 <= b1)\\n            return true;\\n        if (a2 <= a1 && a1 <= b2)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```c++\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) \\n    {\\n        return (e1[0] <= e2[0] && e2[0] <= e1[1]) || \\n               (e2[0] <= e1[0] && e1[0] <= e2[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734075,
                "title": "c-solution-very-simple-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0] <= event1[1] && event2[1] >= event1[0]) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0] <= event1[1] && event2[1] >= event1[0]) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734207,
                "title": "java-1-liner-100-faster",
                "content": "uisng String **CompareTo** logic \\n\\n**if s1 > s2, it returns positive number   \\nif s1 < s2, it returns negative number  \\nif s1 == s2, it returns 0**\\n\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int c1 = event2[0].compareTo(event1[1]);\\n        int c2 = event2[1].compareTo(event1[0]);\\n        return (c1 <= 0) && (c2 >= 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int c1 = event2[0].compareTo(event1[1]);\\n        int c2 = event2[1].compareTo(event1[0]);\\n        return (c1 <= 0) && (c2 >= 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734113,
                "title": "one-liner",
                "content": "**C++**\\n```cpp\\nbool haveConflict(vector<string>& a, vector<string>& b) {\\n    return a[0] < b[0] ? a[1] >= b[0] : b[1] >= a[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool haveConflict(vector<string>& a, vector<string>& b) {\\n    return a[0] < b[0] ? a[1] >= b[0] : b[1] >= a[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734145,
                "title": "line-sweep-learn-this-for-all-time-day-problems",
                "content": "This technique wasn\\'t necessary at all, but it works with many time/day problems. It\\'s easy to implement too.\\n\\nExplanation:\\n* The `HH:MM` is converted in to a line sweep of only minutes. (24*\\\\60 mins array)\\n* We add the event [start_time] and [end_time +1] for both events.\\n* If two events were to conflict, the value in line sweep will be `> 1`.\\n\\n**Method 1 - Line Sweep**\\n```cpp\\nbool haveConflict(vector<string>& e1, vector<string>& e2) {\\n    vector<int> times(16000);\\n    int t1start = stoi(e1[0].substr(0,2)) * 60 + stoi(e1[0].substr(3));\\n    int t1end = stoi(e1[1].substr(0,2)) * 60 + stoi(e1[1].substr(3));\\n\\n    times[t1start] += 1;\\n    times[t1end+1] -= 1;\\n\\n    int t2start = stoi(e2[0].substr(0,2)) * 60 + stoi(e2[0].substr(3));\\n    int t2end = stoi(e2[1].substr(0,2)) * 60 + stoi(e2[1].substr(3));\\n\\n    times[t2start] += 1;\\n    times[t2end+1] -= 1;\\n\\n    int cnt = 0;\\n    for(int t: times){\\n        cnt += t;\\n        if(cnt > 1) \\n            return true;\\n    }\\n\\n    return false;\\n}\\n```\\n\\n**Method 2  - Naive**\\n* Yes, ofcourse line sweep isn\\'t needed.\\n```cpp\\nbool haveConflict(vector<string>& e1, vector<string>& e2) {\\n    int t1start = stoi(e1[0].substr(0,2)) * 60 + stoi(e1[0].substr(3));\\n    int t1end = stoi(e1[1].substr(0,2)) * 60 + stoi(e1[1].substr(3));\\n\\n    int t2start = stoi(e2[0].substr(0,2)) * 60 + stoi(e2[0].substr(3));\\n    int t2end = stoi(e2[1].substr(0,2)) * 60 + stoi(e2[1].substr(3));\\n\\n    if(t2start <= t1end && t2end >= t1start) \\n        return true;\\n\\n    return false;\\n}\\n```\\n\\n\\n**Upvote and lets learn together! :)**",
                "solutionTags": [],
                "code": "```cpp\\nbool haveConflict(vector<string>& e1, vector<string>& e2) {\\n    vector<int> times(16000);\\n    int t1start = stoi(e1[0].substr(0,2)) * 60 + stoi(e1[0].substr(3));\\n    int t1end = stoi(e1[1].substr(0,2)) * 60 + stoi(e1[1].substr(3));\\n\\n    times[t1start] += 1;\\n    times[t1end+1] -= 1;\\n\\n    int t2start = stoi(e2[0].substr(0,2)) * 60 + stoi(e2[0].substr(3));\\n    int t2end = stoi(e2[1].substr(0,2)) * 60 + stoi(e2[1].substr(3));\\n\\n    times[t2start] += 1;\\n    times[t2end+1] -= 1;\\n\\n    int cnt = 0;\\n    for(int t: times){\\n        cnt += t;\\n        if(cnt > 1) \\n            return true;\\n    }\\n\\n    return false;\\n}\\n```\n```cpp\\nbool haveConflict(vector<string>& e1, vector<string>& e2) {\\n    int t1start = stoi(e1[0].substr(0,2)) * 60 + stoi(e1[0].substr(3));\\n    int t1end = stoi(e1[1].substr(0,2)) * 60 + stoi(e1[1].substr(3));\\n\\n    int t2start = stoi(e2[0].substr(0,2)) * 60 + stoi(e2[0].substr(3));\\n    int t2end = stoi(e2[1].substr(0,2)) * 60 + stoi(e2[1].substr(3));\\n\\n    if(t2start <= t1end && t2end >= t1start) \\n        return true;\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736387,
                "title": "easy-1-line-code-explained-on-timeline-with-diagram",
                "content": "**Let\\'s first understand the problem first it states that we need to tell if the given 2 events overlap with each other or not?**\\nThere are two cases when 2 events don\\'t overlap with eachother \\n1) *event1 happened before event2*\\n2) *event1 happens after event2*\\n![image](https://assets.leetcode.com/users/images/c4a3a8b0-d43b-4eb2-bff5-42b113d8e34f_1666676157.7545395.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return !(event1[0] > event2[1] || event1[1] < event2[0]);\\n    }\\n};\\n```\\n***Note: we don\\'t need to convert string to time for comparision as we can compare them directly***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return !(event1[0] > event2[1] || event1[1] < event2[0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734201,
                "title": "easy-comparison-c",
                "content": "**Just compare the starting time for both the events**\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return  ((e1[0]>=e2[0] and e1[0]<=e2[1]) || (e2[0]>=e1[0] and e2[0]<=e1[1])) == true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return  ((e1[0]>=e2[0] and e1[0]<=e2[1]) || (e2[0]>=e1[0] and e2[0]<=e1[1])) == true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734180,
                "title": "python-rust-c-string-timestamps-allow-ordering-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple comparison of string timestamps. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**. \\n\\n**Comment.**  String timestamps allow ordering, thus, the conversion to integer timestamps is not necessary.\\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828379022/) | **31 ms (100.00%)** | **13.9 MB  (33.33%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828401047/) | **0 ms (100.00%)** | **2.1 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828400543/) | **0 ms (100.00%)** | **10.9 MB  (47.62%)** |\\n\\n**Python.**\\n```\\nclass Solution:\\n    def haveConflict(self, e1: List[str], e2: List[str]) -> bool:\\n        \\n        # string timestamps allow ordering, thus, the\\n        # conversion to integer timestamps is not necessary\\n        return e1[0] <= e2[0] <= e1[1] or e2[0] <= e1[0] <= e2[1]\\n```\\n\\n**Rust.**\\n```\\nimpl Solution \\n{\\n    pub fn have_conflict(e1: Vec<String>, e2: Vec<String>) -> bool \\n    {\\n        // string timestamps allow ordering, thus, the\\n        // conversion to integer timestamps is not necessary\\n        (e1[0] <= e2[0] && e2[0] <= e1[1]) || (e2[0] <= e1[0] && e1[0] <= e2[1])\\n    }\\n}\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) \\n    {\\n        // string timestamps allow ordering, thus, the\\n        // conversion to integer timestamps is not necessary\\n        return (e1[0] <= e2[0] && e2[0] <= e1[1]) || \\n               (e2[0] <= e1[0] && e1[0] <= e2[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, e1: List[str], e2: List[str]) -> bool:\\n        \\n        # string timestamps allow ordering, thus, the\\n        # conversion to integer timestamps is not necessary\\n        return e1[0] <= e2[0] <= e1[1] or e2[0] <= e1[0] <= e2[1]\\n```\n```\\nimpl Solution \\n{\\n    pub fn have_conflict(e1: Vec<String>, e2: Vec<String>) -> bool \\n    {\\n        // string timestamps allow ordering, thus, the\\n        // conversion to integer timestamps is not necessary\\n        (e1[0] <= e2[0] && e2[0] <= e1[1]) || (e2[0] <= e1[0] && e1[0] <= e2[1])\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) \\n    {\\n        // string timestamps allow ordering, thus, the\\n        // conversion to integer timestamps is not necessary\\n        return (e1[0] <= e2[0] && e2[0] <= e1[1]) || \\n               (e2[0] <= e1[0] && e1[0] <= e2[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734143,
                "title": "accepted-python-o-1-solution",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        # We know that the events take place on the same day \\n        # so we will find how many minutes have passed since the beginning of the day\\n        \\n        start_event1 = 60 * int(event1[0][0:2]) + int(event1[0][3:])\\n        finish_event1 =  60 * int(event1[1][0:2]) + int(event1[1][3:])\\n        \\n        start_event2 = 60 * int(event2[0][0:2]) + int(event2[0][3:])\\n        finish_event2 =  60 * int(event2[1][0:2]) + int(event2[1][3:])\\n        \\n        # since we don\\'t know which event started first, let\\'s check two cases\\n        \\n        if start_event1 <= start_event2 <= finish_event1 or start_event2 <= start_event1 <= finish_event2:\\n            return True\\n        else:\\n            return False\\n\\n        # O(1) - Time\\n        # O(1) - Space\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        # We know that the events take place on the same day \\n        # so we will find how many minutes have passed since the beginning of the day\\n        \\n        start_event1 = 60 * int(event1[0][0:2]) + int(event1[0][3:])\\n        finish_event1 =  60 * int(event1[1][0:2]) + int(event1[1][3:])\\n        \\n        start_event2 = 60 * int(event2[0][0:2]) + int(event2[0][3:])\\n        finish_event2 =  60 * int(event2[1][0:2]) + int(event2[1][3:])\\n        \\n        # since we don\\'t know which event started first, let\\'s check two cases\\n        \\n        if start_event1 <= start_event2 <= finish_event1 or start_event2 <= start_event1 <= finish_event2:\\n            return True\\n        else:\\n            return False\\n\\n        # O(1) - Time\\n        # O(1) - Space\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878171,
                "title": "javascript-solution-faster-than-96-64-of-other-submissions-array-time",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n```\\nconst toMins = t => {\\n    let bits = t.split(\\':\\');\\n    return bits[0] * 60 + bits[1] * 1;\\n}\\nconst haveConflict = (event1, event2) => Math.max(toMins(event1[0]), toMins(event2[0])) <= Math.min(toMins(event1[1]), toMins(event2[1]));\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst toMins = t => {\\n    let bits = t.split(\\':\\');\\n    return bits[0] * 60 + bits[1] * 1;\\n}\\nconst haveConflict = (event1, event2) => Math.max(toMins(event1[0]), toMins(event2[0])) <= Math.min(toMins(event1[1]), toMins(event2[1]));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744018,
                "title": "python-elegant-short",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(1)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def haveConflict(self, a: List[str], b: List[str]) -> bool:\\n        a_start, a_end = a\\n        b_start, b_end = b\\n        return b_start <= a_start <= b_end or \\\\\\n               b_start <= a_end <= b_end or \\\\\\n               a_start <= b_start <= a_end or \\\\\\n               a_start <= b_end <= a_end\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(1)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def haveConflict(self, a: List[str], b: List[str]) -> bool:\\n        a_start, a_end = a\\n        b_start, b_end = b\\n        return b_start <= a_start <= b_end or \\\\\\n               b_start <= a_end <= b_end or \\\\\\n               a_start <= b_start <= a_end or \\\\\\n               a_start <= b_end <= a_end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734341,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return event1[0] <= event2[0] <= event1[1] or event2[0] <= event1[0] <= event2[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return event1[0] <= event2[0] <= event1[1] or event2[0] <= event1[0] <= event2[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734160,
                "title": "javascript-tc-o-1-sc-o-1",
                "content": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    return (event1[0] <= event2[0] && event2[0] <= event1[1])\\n        || (event1[0] <= event2[1] && event2[1] <= event1[1])\\n        || (event2[0] <= event1[0] && event1[0] <= event2[1])\\n        || (event2[0] <= event1[1] && event1[1] <= event2[1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    return (event1[0] <= event2[0] && event2[0] <= event1[1])\\n        || (event1[0] <= event2[1] && event2[1] <= event1[1])\\n        || (event2[0] <= event1[0] && event1[0] <= event2[1])\\n        || (event2[0] <= event1[1] && event1[1] <= event2[1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734118,
                "title": "later-early-intuition",
                "content": "# Intuition:\\n- The common point will start from **maximum start among the two events**\\n - The common point will end at the **minimum end among the two events**\\n# C++\\n    bool haveConflict(vector<string>& a, vector<string>& b) {\\n        auto convert = [&](string &s){\\n            int val = 0;\\n            for(char i:s)\\n                if(i != \\':\\') val = val * 10 + (i - \\'0\\');\\n            return val;  \\n        };\\n        \\n        return max(convert(a[0]) , convert(b[0])) <= min(convert(a[1]) , convert(b[1]));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "# Intuition:\\n- The common point will start from **maximum start among the two events**\\n - The common point will end at the **minimum end among the two events**\\n# C++\\n    bool haveConflict(vector<string>& a, vector<string>& b) {\\n        auto convert = [&](string &s){\\n            int val = 0;\\n            for(char i:s)\\n                if(i != \\':\\') val = val * 10 + (i - \\'0\\');\\n            return val;  \\n        };\\n        \\n        return max(convert(a[0]) , convert(b[0])) <= min(convert(a[1]) , convert(b[1]));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2979743,
                "title": "python-solution-explanation-and-super-fast",
                "content": "![Screenshot 2023-01-01 at 14.35.35.png](https://assets.leetcode.com/users/images/efb09e0d-eb71-410c-8d24-fc43473e4c8d_1672576587.2719238.png)\\n\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        event1Start = event1[0].split(\\':\\')\\n        event1End = event1[1].split(\\':\\')\\n\\n        event2Start = event2[0].split(\\':\\')\\n        event2End = event2[1].split(\\':\\')\\n\\n        return False if event2Start > event1End or event1Start > event2End else True    \\n```\\n\\n**Explanation**: changing **event1** and **event2** date strings by spliting to **single** **string** **date** **values** and then while comparing the **single date strings** return **True** if it is inbetween or **False** if it isn\\'t.\\n\\nMore solutions of mine at https://github.com/aurimas13/SolutionsToProblems",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        event1Start = event1[0].split(\\':\\')\\n        event1End = event1[1].split(\\':\\')\\n\\n        event2Start = event2[0].split(\\':\\')\\n        event2End = event2[1].split(\\':\\')\\n\\n        return False if event2Start > event1End or event1Start > event2End else True    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734185,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0]<=event1[1] && event2[1]>=event1[0]) {\\n            return true;\\n        }\\n        else\\n        {\\n        return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0]<=event1[1] && event2[1]>=event1[0]) {\\n            return true;\\n        }\\n        else\\n        {\\n        return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522061,
                "title": "o-1-determine-if-two-events-have-conflict-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTime Comparison\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Using String comparison*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[0]<=event2[0] && event2[0]<=event1[1] || event2[0]<=event1[0] && event1[0]<=event2[1])\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Converting time into integers and then comparing*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int event1_starting_time, event2_starting_time, event1_ending_time, event2_ending_time;\\n        \\n        event1_starting_time = (int(event1[0][0])*10 + int(event1[0][1]))*60 + (int(event1[0][3])*10 + int(event1[0][4]));\\n        event2_starting_time = (int(event2[0][0])*10 + int(event2[0][1]))*60 + (int(event2[0][3])*10 + int(event2[0][4]));\\n        event1_ending_time = (int(event1[1][0])*10 + int(event1[1][1]))*60 + (int(event1[1][3])*10 + int(event1[1][4]));\\n        event2_ending_time = (int(event2[1][0])*10 + int(event2[1][1]))*60 + (int(event2[1][3])*10 + int(event2[1][4]));\\n        if(event1_starting_time<=event2_starting_time && event2_starting_time<=event1_ending_time ||\\n           event2_starting_time<=event1_starting_time && event1_starting_time<=event2_ending_time)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/9f357f7d-9c3a-4ed3-b12e-4ebba1f74e02_1684037295.2742863.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[0]<=event2[0] && event2[0]<=event1[1] || event2[0]<=event1[0] && event1[0]<=event2[1])\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int event1_starting_time, event2_starting_time, event1_ending_time, event2_ending_time;\\n        \\n        event1_starting_time = (int(event1[0][0])*10 + int(event1[0][1]))*60 + (int(event1[0][3])*10 + int(event1[0][4]));\\n        event2_starting_time = (int(event2[0][0])*10 + int(event2[0][1]))*60 + (int(event2[0][3])*10 + int(event2[0][4]));\\n        event1_ending_time = (int(event1[1][0])*10 + int(event1[1][1]))*60 + (int(event1[1][3])*10 + int(event1[1][4]));\\n        event2_ending_time = (int(event2[1][0])*10 + int(event2[1][1]))*60 + (int(event2[1][3])*10 + int(event2[1][4]));\\n        if(event1_starting_time<=event2_starting_time && event2_starting_time<=event1_ending_time ||\\n           event2_starting_time<=event1_starting_time && event1_starting_time<=event2_ending_time)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774277,
                "title": "easy-python-solution",
                "content": "\\n# Complexity\\n- Time complexity: As I have not used any kind of loops, the complexity is O(1), or constant time\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        e1s=int(event1[0][:2])*60 + int(event1[0][3:])\\n        e1e=int(event1[1][:2])*60 + int(event1[1][3:])\\n        e2s=int(event2[0][:2])*60 + int(event2[0][3:])\\n        e2e=int(event2[1][:2])*60 + int(event2[1][3:])\\n        if e1s<=e2s<=e1e: return True\\n        if e2s<=e1s<=e2e: return True\\n        if e1s<=e2e<=e1e: return True\\n        if e2s<=e1e<=e2e: return True\\n        else: return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        e1s=int(event1[0][:2])*60 + int(event1[0][3:])\\n        e1e=int(event1[1][:2])*60 + int(event1[1][3:])\\n        e2s=int(event2[0][:2])*60 + int(event2[0][3:])\\n        e2e=int(event2[1][:2])*60 + int(event2[1][3:])\\n        if e1s<=e2s<=e1e: return True\\n        if e2s<=e1s<=e2e: return True\\n        if e1s<=e2e<=e1e: return True\\n        if e2s<=e1e<=e2e: return True\\n        else: return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747754,
                "title": "one-liner-c-solution-with-detailed-explanation",
                "content": "**conflict can occur in 2 cases -**\\n    **1.** if event e1 starts when event e2 is happening i.e. (e1[0] <= e2[0]) && (e2[0] <= e1[1])\\n    **2.** if event e2 starts when event e1 is happening i.e. (e2[0] <= e1[0]) && (e1[0] <= e2[1]) \\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return ((e1[0] <= e2[0]) && (e2[0] <= e1[1])) || ((e2[0] <= e1[0]) && (e1[0] <= e2[1]));\\n    }\\n};\\n```\\n\\n# Please upvote if you found the solution helpful",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        return ((e1[0] <= e2[0]) && (e2[0] <= e1[1])) || ((e2[0] <= e1[0]) && (e1[0] <= e2[1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734247,
                "title": "java-easy-concept-for-all-time-questions-commented",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n\\t\\t//Take out integers for hours and minutes for all events.\\n        int event1startHour = Integer.parseInt(event1[0].substring(0,2));\\n        int event1startMin = Integer.parseInt(event1[0].substring(3));\\n        int event1endHour = Integer.parseInt(event1[1].substring(0,2));\\n        int event1endMin =  Integer.parseInt(event1[1].substring(3));\\n        \\n        int event2startHour = Integer.parseInt(event2[0].substring(0,2));\\n        int event2startMin = Integer.parseInt(event2[0].substring(3));\\n        int event2endHour = Integer.parseInt(event2[1].substring(0,2));\\n        int event2endMin =  Integer.parseInt(event2[1].substring(3));\\n        \\n\\t\\t//This is the common concept, for ex 00:00 starts at 0 and 1:00 will be at 60,\\n\\t\\t//similarly 02:00 will be at 120. So we can distinguish every time uniquely.\\n\\t\\t//The time will end at 23:59 which is 1439.\\n\\t\\t\\n        int event1StartTime = event1startHour*60 + event1startMin;\\n        int event1EndTime = event1endHour*60 + event1endMin;\\n        int event2StartTime = event2startHour*60 + event2startMin;\\n        int event2EndTime = event2endHour*60 + event2endMin;\\n        \\n\\t\\t//So we iterate from the start to end time for one event and check whether the other \\n\\t\\t//event time will intersect here or not. If not intersect return false, else true.\\n\\t\\t\\n        for(int i=event1StartTime ; i<=event1EndTime; i++){\\n            if(i >= event2StartTime && i<= event2EndTime){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n\\t\\t//Take out integers for hours and minutes for all events.\\n        int event1startHour = Integer.parseInt(event1[0].substring(0,2));\\n        int event1startMin = Integer.parseInt(event1[0].substring(3));\\n        int event1endHour = Integer.parseInt(event1[1].substring(0,2));\\n        int event1endMin =  Integer.parseInt(event1[1].substring(3));\\n        \\n        int event2startHour = Integer.parseInt(event2[0].substring(0,2));\\n        int event2startMin = Integer.parseInt(event2[0].substring(3));\\n        int event2endHour = Integer.parseInt(event2[1].substring(0,2));\\n        int event2endMin =  Integer.parseInt(event2[1].substring(3));\\n        \\n\\t\\t//This is the common concept, for ex 00:00 starts at 0 and 1:00 will be at 60,\\n\\t\\t//similarly 02:00 will be at 120. So we can distinguish every time uniquely.\\n\\t\\t//The time will end at 23:59 which is 1439.\\n\\t\\t\\n        int event1StartTime = event1startHour*60 + event1startMin;\\n        int event1EndTime = event1endHour*60 + event1endMin;\\n        int event2StartTime = event2startHour*60 + event2startMin;\\n        int event2EndTime = event2endHour*60 + event2endMin;\\n        \\n\\t\\t//So we iterate from the start to end time for one event and check whether the other \\n\\t\\t//event time will intersect here or not. If not intersect return false, else true.\\n\\t\\t\\n        for(int i=event1StartTime ; i<=event1EndTime; i++){\\n            if(i >= event2StartTime && i<= event2EndTime){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076938,
                "title": "c-fast-1-liner-without-parsing-86ms-98",
                "content": "Provided times are sortable (comparable). We can use it for comparing without parsing string to TimeSpan, int or whatever.\\n\\nTo check if two intervals have common intersection could be used next logic\\n\\nmax(start1, start2) <= min(end1, end2)\\n\\nIt could be simplified. For example for first interval start1 is always less or equal than end1. We do not need to check this by min(..) implicitly. Instead we could use explicit start1 <= end2 from logic above. The same logic apply for second interval and get start2 <= end1. If it is still not clear, check detailed transformation after the code (below)\\n\\nAfter simplification logic will be next\\n\\nstart1 <= end2 && start2 <= end1\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) \\n        => event1[0].CompareTo(event2[1]) <= 0 &&\\n           event2[0].CompareTo(event1[1]) <= 0;\\n}\\n```\\n\\n1) max(start1, start2) <= min(end1, end2)\\n\\n2) start1 <= min(end1, end2) \\n   && \\n   start2 <= min(end1, end2)\\n \\n3) start1 <= end1 && start1 <= end2\\n   && \\n   start2 <= end1 && start2 <= end2\\n\\n4) ~~start1 <= end1~~$ && start1 <= end2  (removing self interval-1)\\n   && \\n   start2 <= end1 && ~~start2 <= end2~~  (removing self interval-2)\\n\\n5) start1 <= end2 && start2 <= end1 \\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) \\n        => event1[0].CompareTo(event2[1]) <= 0 &&\\n           event2[0].CompareTo(event1[1]) <= 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754783,
                "title": "c-very-easy",
                "content": "Please Upvote :)\\n\\n```\\nbool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0]>event1[1] && event2[0]>event1[0])\\n            return 0;\\n        if(event1[0]>event2[1] && event1[0]>event2[0])\\n            return 0;\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0]>event1[1] && event2[0]>event1[0])\\n            return 0;\\n        if(event1[0]>event2[1] && event1[0]>event2[0])\\n            return 0;\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745541,
                "title": "java-determine-if-two-events-have-conflict",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int one=Integer.valueOf(event1[0].substring(0,2)+event1[0].substring(3,5));\\n        int two=Integer.valueOf(event1[1].substring(0,2)+event1[1].substring(3,5));\\n        int three=Integer.valueOf(event2[0].substring(0,2)+event2[0].substring(3,5));\\n        int four=Integer.valueOf(event2[1].substring(0,2)+event2[1].substring(3,5));\\n        if((three<=two&&three>=one)||(one<=four&&four<=two))return true;\\n        if((three<=one&&one<=four)||(three<=two&&two<=four))return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int one=Integer.valueOf(event1[0].substring(0,2)+event1[0].substring(3,5));\\n        int two=Integer.valueOf(event1[1].substring(0,2)+event1[1].substring(3,5));\\n        int three=Integer.valueOf(event2[0].substring(0,2)+event2[0].substring(3,5));\\n        int four=Integer.valueOf(event2[1].substring(0,2)+event2[1].substring(3,5));\\n        if((three<=two&&three>=one)||(one<=four&&four<=two))return true;\\n        if((three<=one&&one<=four)||(three<=two&&two<=four))return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739464,
                "title": "java-easiest-solution-with-explanations",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// if s1 > s2, it returns positive number\\n// if s1 < s2, it returns negative number\\n// if s1 == s2, it returns 0\\n\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n      int c1 = event2[0].compareTo(event1[1]);\\n      int c2 = event2[1].compareTo(event1[0]);\\n      return (c1 <= 0) && (c2 >= 0);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// if s1 > s2, it returns positive number\\n// if s1 < s2, it returns negative number\\n// if s1 == s2, it returns 0\\n\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n      int c1 = event2[0].compareTo(event1[1]);\\n      int c2 = event2[1].compareTo(event1[0]);\\n      return (c1 <= 0) && (c2 >= 0);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736482,
                "title": "one-liner-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735340,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        event1[0] <= event2[1] && event1[1] >= event2[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        event1[0] <= event2[1] && event1[1] >= event2[0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734881,
                "title": "python-js-java-c-simple-sol-for-beginner-w-diagram",
                "content": "**Hint**:\\n\\nThe key point logic behind is to **check whether one event\\'s ending time is enclosed by another event\\'s interval**.\\n\\n---\\n\\n**Visualization**:\\n\\n<img src=\"https://i.imgur.com/Ur1Tm9B.png\">\\n\\n---\\n\\n**Python**:\\n\\n```\\n\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        START, END = 0, 1\\n        \\n        # Event 1\\'s ending time is enclosed by event 2\\n        bounded_by_evt_2 = (event2[START] <= event1[END] <= event2[END])\\n        \\n        # Event 2\\'s ending time is enclosed by event 1\\n        bounded_by_evt_1 = (event1[START] <= event2[END] <= event1[END])\\n        \\n        return bounded_by_evt_1 or bounded_by_evt_2\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar haveConflict = function(event1, event2) {\\n        \\n    const START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        let bounded_by_evt_2 = (event2[START] <= event1[END] && event1[END] <= event2[END]);\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        let bounded_by_evt_1 = (event1[START] <= event2[END] && event2[END] <= event1[END]);\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2 ;        \\n        \\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n        final int START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        boolean bounded_by_evt_2 = (event2[START].compareTo( event1[END] ) * event1[END].compareTo( event2[END] ) ) >= 0;\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        boolean bounded_by_evt_1 = (event1[START].compareTo( event2[END] ) * event2[END].compareTo( event1[END] ) ) >= 0;\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2;        \\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        const int START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        bool bounded_by_evt_2 = (event2[START] <= event1[END] && event1[END] <= event2[END] );\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        bool bounded_by_evt_1 = (event1[START] <= event2[END] && event2[END] <= event1[END] );\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2;        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        START, END = 0, 1\\n        \\n        # Event 1\\'s ending time is enclosed by event 2\\n        bounded_by_evt_2 = (event2[START] <= event1[END] <= event2[END])\\n        \\n        # Event 2\\'s ending time is enclosed by event 1\\n        bounded_by_evt_1 = (event1[START] <= event2[END] <= event1[END])\\n        \\n        return bounded_by_evt_1 or bounded_by_evt_2\\n```\n```\\nvar haveConflict = function(event1, event2) {\\n        \\n    const START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        let bounded_by_evt_2 = (event2[START] <= event1[END] && event1[END] <= event2[END]);\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        let bounded_by_evt_1 = (event1[START] <= event2[END] && event2[END] <= event1[END]);\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2 ;        \\n        \\n};\\n```\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n        final int START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        boolean bounded_by_evt_2 = (event2[START].compareTo( event1[END] ) * event1[END].compareTo( event2[END] ) ) >= 0;\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        boolean bounded_by_evt_1 = (event1[START].compareTo( event2[END] ) * event2[END].compareTo( event1[END] ) ) >= 0;\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2;        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        const int START = 0, END = 1;\\n        \\n        // Event 1\\'s ending time is enclosed by event 2\\n        bool bounded_by_evt_2 = (event2[START] <= event1[END] && event1[END] <= event2[END] );\\n        \\n        // Event 2\\'s ending time is enclosed by event 1\\n        bool bounded_by_evt_1 = (event1[START] <= event2[END] && event2[END] <= event1[END] );\\n        \\n        return bounded_by_evt_1 || bounded_by_evt_2;        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734731,
                "title": "c-very-easy-100-success-simple-easy-solution",
                "content": "# Approach\\n\\nTo compare the starting time for both the events \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0] <= event1[1] && event2[1] >= event1[0]) \\n             return true;\\n        return false; \\n    }\\n};\\n\\n```\\n\\n**KEEP UPVOTING**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event2[0] <= event1[1] && event2[1] >= event1[0]) \\n             return true;\\n        return false; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734343,
                "title": "c-easy-1-line-code",
                "content": "class Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       if(event1[event1.size()-1]  >= event2[0] && event1[0] <= event2[event2.size()-1])\\n       {\\n           return true;\\n       }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       if(event1[event1.size()-1]  >= event2[0] && event1[0] <= event2[event2.size()-1])\\n       {\\n           return true;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2734330,
                "title": "c-easy-1-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return (event1[0] > event2[1] || event1[1] < event2[0]) ? false : true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return (event1[0] > event2[1] || event1[1] < event2[0]) ? false : true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734280,
                "title": "java-easy-to-understand-100-faster-solution",
                "content": "updated solution\\n```\\n return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734202,
                "title": "python3-straight-forward-clean-concise",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0][:2]) * 60 + int(event1[0][3:])\\n        end1 = int(event1[1][:2]) * 60 + int(event1[1][3:])\\n        start2 = int(event2[0][:2]) * 60 + int(event2[0][3:])\\n        end2 = int(event2[1][:2]) * 60 + int(event2[1][3:])\\n        return True if start1 <= start2 <= end1 or start2 <= start1 <= end2 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0][:2]) * 60 + int(event1[0][3:])\\n        end1 = int(event1[1][:2]) * 60 + int(event1[1][3:])\\n        start2 = int(event2[0][:2]) * 60 + int(event2[0][3:])\\n        end2 = int(event2[1][:2]) * 60 + int(event2[1][3:])\\n        return True if start1 <= start2 <= end1 or start2 <= start1 <= end2 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734149,
                "title": "easiest-python-solution",
                "content": "```\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event2[0]<event1[0]:\\n            event1,event2 = event2,event1\\n        if event1[1]<event2[0]:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event2[0]<event1[0]:\\n            event1,event2 = event2,event1\\n        if event1[1]<event2[0]:\\n            return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734122,
                "title": "python-straight-forward-solution",
                "content": "```\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        s1, e1 = event1\\n        s2, e2 = event2\\n        if s1 > e2 or e1 < s2:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        s1, e1 = event1\\n        s2, e2 = event2\\n        if s1 > e2 or e1 < s2:\\n            return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734106,
                "title": "simple-and-easy-2-lines-python",
                "content": "Convert hours to minutes and compare\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        arr = [[(int(event1[0][:2])*60)+int(event1[0][3:]) , (int(event1[1][:2])*60)+int(event1[1][3:])] ,\\n               [(int(event2[0][:2])*60)+int(event2[0][3:]) , (int(event2[1][:2])*60)+int(event2[1][3:])]]\\n        \\n        return (arr[0][0] <= arr[1][1] <= arr[0][1] or\\n                arr[1][0] <= arr[0][1] <= arr[1][1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        arr = [[(int(event1[0][:2])*60)+int(event1[0][3:]) , (int(event1[1][:2])*60)+int(event1[1][3:])] ,\\n               [(int(event2[0][:2])*60)+int(event2[0][3:]) , (int(event2[1][:2])*60)+int(event2[1][3:])]]\\n        \\n        return (arr[0][0] <= arr[1][1] <= arr[0][1] or\\n                arr[1][0] <= arr[0][1] <= arr[1][1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891664,
                "title": "java-easiest-fastest-solution-100-beats",
                "content": "# Code\\n```\\nclass Solution{\\n    public boolean haveConflict(String[] event1, String[] event2){\\n        int st1 = Integer.parseInt(event1[0].substring(0, 2))*60 + Integer.parseInt(event1[0].substring(3));\\n        int et1 = Integer.parseInt(event1[1].substring(0, 2))*60 + Integer.parseInt(event1[1].substring(3));\\n        int st2 = Integer.parseInt(event2[0].substring(0, 2))*60 + Integer.parseInt(event2[0].substring(3));\\n        int et2 = Integer.parseInt(event2[1].substring(0, 2))*60 + Integer.parseInt(event2[1].substring(3));\\n        return st2<=et1 && st1<=et2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public boolean haveConflict(String[] event1, String[] event2){\\n        int st1 = Integer.parseInt(event1[0].substring(0, 2))*60 + Integer.parseInt(event1[0].substring(3));\\n        int et1 = Integer.parseInt(event1[1].substring(0, 2))*60 + Integer.parseInt(event1[1].substring(3));\\n        int st2 = Integer.parseInt(event2[0].substring(0, 2))*60 + Integer.parseInt(event2[0].substring(3));\\n        int et2 = Integer.parseInt(event2[1].substring(0, 2))*60 + Integer.parseInt(event2[1].substring(3));\\n        return st2<=et1 && st1<=et2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833404,
                "title": "kotlin-single-line-solution-easy-explained",
                "content": "\\n# Approach\\n I\\'ve used compareTo to determine, if event1 starts earlier or at the same time as event2 ends and and vice versa. (Compare to returns 0 if values are equal, -1 if value in parentheses is bigger and 1 if opposite)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    fun haveConflict(event1: Array<String>, event2: Array<String>): Boolean = event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun haveConflict(event1: Array<String>, event2: Array<String>): Boolean = event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785803,
                "title": "2446-determine-if-two-events-have-conflict",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        return event2[0] <= event1[1] and event2[1] >= event1[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        return event2[0] <= event1[1] and event2[1] >= event1[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447272,
                "title": "java-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int s1=Integer.parseInt(event1[0].substring(0,2))*60+Integer.parseInt(event1[0].substring(3));\\n        int e1=Integer.parseInt(event1[1].substring(0,2))*60+Integer.parseInt(event1[1].substring(3));\\n        int s2=Integer.parseInt(event2[0].substring(0,2))*60+Integer.parseInt(event2[0].substring(3));\\n        int e2=Integer.parseInt(event2[1].substring(0,2))*60+Integer.parseInt(event2[1].substring(3));\\n        return !(e1<s2||e2<s1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int s1=Integer.parseInt(event1[0].substring(0,2))*60+Integer.parseInt(event1[0].substring(3));\\n        int e1=Integer.parseInt(event1[1].substring(0,2))*60+Integer.parseInt(event1[1].substring(3));\\n        int s2=Integer.parseInt(event2[0].substring(0,2))*60+Integer.parseInt(event2[0].substring(3));\\n        int e2=Integer.parseInt(event2[1].substring(0,2))*60+Integer.parseInt(event2[1].substring(3));\\n        return !(e1<s2||e2<s1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303911,
                "title": "easy-solution-code-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int cal(string a)\\n    {\\n        int ans = 0;\\n        int d = 1;\\n        for(int i=a.length()-1; i>=0; i--)\\n        {\\n            if(a[i]!=\\':\\')\\n            {\\n                ans=ans+(a[i]-48)*d;\\n                d=d*10;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n    \\n        if(cal(event2[0])<=cal(event1[1]) && cal(event2[1])>=cal(event1[0]))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int cal(string a)\\n    {\\n        int ans = 0;\\n        int d = 1;\\n        for(int i=a.length()-1; i>=0; i--)\\n        {\\n            if(a[i]!=\\':\\')\\n            {\\n                ans=ans+(a[i]-48)*d;\\n                d=d*10;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n    \\n        if(cal(event2[0])<=cal(event1[1]) && cal(event2[1])>=cal(event1[0]))\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848709,
                "title": "simple-solution-with-58ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we know that the times can be compared without being formatted or processed, we can have a very simple solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    switch (true) {\\n        case (( event2[0] >= event1[0] && event2[0] <= event1[1]) || (event1[0] >= event2[0] && event1[0] <= event2[1])):\\n            return true;\\n        default:\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    switch (true) {\\n        case (( event2[0] >= event1[0] && event2[0] <= event1[1]) || (event1[0] >= event2[0] && event1[0] <= event2[1])):\\n            return true;\\n        default:\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847044,
                "title": "easy-one-line-typescript-solution",
                "content": "Runtime: 62 ms, faster than 98.15% of TypeScript online submissions for Determine if Two Events Have Conflict.\\nMemory Usage: 43.2 MB, less than 48.15% of TypeScript online submissions for Determine if Two Events Have Conflict.\\n\\n```\\nconst haveConflict = (event1: string[], event2: string[]): boolean  => !(event1[1].replace(/:/, \\'\\') < event2[0].replace(/:/, \\'\\') || event2[1].replace(/:/, \\'\\') < event1[0].replace(/:/, \\'\\'))\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst haveConflict = (event1: string[], event2: string[]): boolean  => !(event1[1].replace(/:/, \\'\\') < event2[0].replace(/:/, \\'\\') || event2[1].replace(/:/, \\'\\') < event1[0].replace(/:/, \\'\\'))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804244,
                "title": "determine-if-two-events-have-conflict-solution-java",
                "content": "class Solution {\\n  public boolean haveConflict(String[] event1, String[] event2) {\\n    return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n  public boolean haveConflict(String[] event1, String[] event2) {\\n    return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2749575,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n      if(((e1[0] <= e2[0]) && (e2[0] <= e1[1])) || ((e2[0] <= e1[0]) && (e1[0] <= e2[1]))){\\n          return true;\\n      }  \\n   return false; }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n      if(((e1[0] <= e2[0]) && (e2[0] <= e1[1])) || ((e2[0] <= e1[0]) && (e1[0] <= e2[1]))){\\n          return true;\\n      }  \\n   return false; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746924,
                "title": "java-string-comparison-solution",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int endTime1StartTime2 = event2[0].compareTo(event1[1]);\\n        int startTime1EndTime2 = event2[1].compareTo(event1[0]);\\n        return (endTime1StartTime2 <= 0) && (startTime1EndTime2 >= 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int endTime1StartTime2 = event2[0].compareTo(event1[1]);\\n        int startTime1EndTime2 = event2[1].compareTo(event1[0]);\\n        return (endTime1StartTime2 <= 0) && (startTime1EndTime2 >= 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739313,
                "title": "javascript",
                "content": "var haveConflict = function(event1, event2) {\\n    if((event1[0]<=event2[0] && event1[1]>=event2[0]) || (event2[0]<=event1[0] && event2[1]>=event1[0])) return true\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var haveConflict = function(event1, event2) {\\n    if((event1[0]<=event2[0] && event1[1]>=event2[0]) || (event2[0]<=event1[0] && event2[1]>=event1[0])) return true\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2738637,
                "title": "one-line-solution",
                "content": "public boolean haveConflict(String[] event1, String[] event2) {\\n        return event1[1].compareTo(event2[0]) >= 0 && event1[0].compareTo(event2[1]) <= 0;\\n    }",
                "solutionTags": [],
                "code": "public boolean haveConflict(String[] event1, String[] event2) {\\n        return event1[1].compareTo(event2[0]) >= 0 && event1[0].compareTo(event2[1]) <= 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2736128,
                "title": "simple-java-code-with-comments",
                "content": "Time complexity: O(1)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n       int scenario1 = event2[1].compareTo(event1[0]);\\n       int scenario2 = event1[1].compareTo(event2[0]);\\n        \\n\\t\\t//if ->> event 2 end >= event 1 start\\n\\t\\t//and event 2 start <= event 1 end, then return true else false\\n       return (scenario1 >= 0 && scenario2 >=0);\\n        \\n    }   \\n}\\n```\\n\\nPlease upvote if you like :)\\nComments are welcomed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        \\n       int scenario1 = event2[1].compareTo(event1[0]);\\n       int scenario2 = event1[1].compareTo(event2[0]);\\n        \\n\\t\\t//if ->> event 2 end >= event 1 start\\n\\t\\t//and event 2 start <= event 1 end, then return true else false\\n       return (scenario1 >= 0 && scenario2 >=0);\\n        \\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735308,
                "title": "java-easy-one-liner-code",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n        return e1[0].compareTo(e2[1]) <= 0 && e2[0].compareTo(e1[1]) <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n        return e1[0].compareTo(e2[1]) <= 0 && e2[0].compareTo(e1[1]) <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735208,
                "title": "easy-java-solution",
                "content": "# Determine if Two Events Have Conflict\\n# Easy Java Solution\\n\\n**Approach:\\n1.) First convert all starting and ending hours and minutes into an integer format suitable for comparision.\\n2.) Then set up conditions that if both the time are same or starting time of one event is earlier then ending time of previous event, the return true.\\n3.) If above conditions aren\\'t satisfied return false.**\\n\\n\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int initial1=(event1[0].charAt(0)-\\'0\\')*10+(event1[0].charAt(1)-\\'0\\');\\n        int initial2=(event2[0].charAt(0)-\\'0\\')*10+(event2[0].charAt(1)-\\'0\\');\\n        int min1=(event1[0].charAt(3)-\\'0\\')*10+(event1[0].charAt(4)-\\'0\\');\\n        int min2=(event2[0].charAt(3)-\\'0\\')*10+(event2[0].charAt(4)-\\'0\\');\\n        int end1=(event1[1].charAt(0)-\\'0\\')*10+(event1[1].charAt(1)-\\'0\\');\\n        int end2=(event2[1].charAt(0)-\\'0\\')*10+(event2[1].charAt(1)-\\'0\\');\\n        int endmin1=(event1[1].charAt(3)-\\'0\\')*10+(event1[1].charAt(4)-\\'0\\');\\n        int endmin2=(event2[1].charAt(3)-\\'0\\')*10+(event2[1].charAt(4)-\\'0\\');\\n        if(initial1<initial2){\\n            System.out.println(end1+\" \"+initial2+\" \"+endmin1+\" \"+min2);\\n            if(end1==initial2 && endmin1>=min2){\\n                return true;\\n            }\\n            else if(end1>initial2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if(initial1==initial2){\\n            return true;\\n        }\\n        else{\\n            if(end2==initial1 && endmin2>=min1){\\n                return true;\\n            }\\n            else if(end2>=initial1){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int initial1=(event1[0].charAt(0)-\\'0\\')*10+(event1[0].charAt(1)-\\'0\\');\\n        int initial2=(event2[0].charAt(0)-\\'0\\')*10+(event2[0].charAt(1)-\\'0\\');\\n        int min1=(event1[0].charAt(3)-\\'0\\')*10+(event1[0].charAt(4)-\\'0\\');\\n        int min2=(event2[0].charAt(3)-\\'0\\')*10+(event2[0].charAt(4)-\\'0\\');\\n        int end1=(event1[1].charAt(0)-\\'0\\')*10+(event1[1].charAt(1)-\\'0\\');\\n        int end2=(event2[1].charAt(0)-\\'0\\')*10+(event2[1].charAt(1)-\\'0\\');\\n        int endmin1=(event1[1].charAt(3)-\\'0\\')*10+(event1[1].charAt(4)-\\'0\\');\\n        int endmin2=(event2[1].charAt(3)-\\'0\\')*10+(event2[1].charAt(4)-\\'0\\');\\n        if(initial1<initial2){\\n            System.out.println(end1+\" \"+initial2+\" \"+endmin1+\" \"+min2);\\n            if(end1==initial2 && endmin1>=min2){\\n                return true;\\n            }\\n            else if(end1>initial2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else if(initial1==initial2){\\n            return true;\\n        }\\n        else{\\n            if(end2==initial1 && endmin2>=min1){\\n                return true;\\n            }\\n            else if(end2>=initial1){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734802,
                "title": "python-plain-solution",
                "content": "https://leetcode.com/contest/weekly-contest-316/submissions/detail/828298837/\\n```\\nclass Solution(object):\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        ## if t1<=t2, return True, else return False\\n        def compareTime(t1, t2): \\n            t1_h, t1_m, t2_h, t2_m = int(t1[:2]), int(t1[3:]), int(t2[:2]), int(t2[3:])\\n            if t1_h>t2_h or (t1_h==t2_h and t1_m>t2_m):\\n                return False\\n            return True\\n        \\n        e1_st, e1_et, e2_st, e2_et = event1[0], event1[1], event2[0], event2[1]\\n        \\n        if ( compareTime(e2_st, e1_st) and compareTime(e1_st, e2_et) ) \\\\\\n        or ( compareTime(e1_st, e2_st) and compareTime(e2_st, e1_et) ):\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        ## if t1<=t2, return True, else return False\\n        def compareTime(t1, t2): \\n            t1_h, t1_m, t2_h, t2_m = int(t1[:2]), int(t1[3:]), int(t2[:2]), int(t2[3:])\\n            if t1_h>t2_h or (t1_h==t2_h and t1_m>t2_m):\\n                return False\\n            return True\\n        \\n        e1_st, e1_et, e2_st, e2_et = event1[0], event1[1], event2[0], event2[1]\\n        \\n        if ( compareTime(e2_st, e1_st) and compareTime(e1_st, e2_et) ) \\\\\\n        or ( compareTime(e1_st, e2_st) and compareTime(e2_st, e1_et) ):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734698,
                "title": "python-and-c-solutions-convert-and-sort",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0][:2])*60 + int(event1[0][3:])\\n        end1 = int(event1[1][:2])*60 + int(event1[1][3:])\\n        start2 = int(event2[0][:2])*60 + int(event2[0][3:])\\n        end2 = int(event2[1][:2])*60 + int(event2[1][3:])\\n        time = [[start1, end1], [start2, end2]]\\n        time.sort()\\n        return time[0][1] >= time[1][0]\\n\\t\\t\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) {\\n        int start1 = 0;\\n        int end1 = 0;\\n        int start2 = 0;\\n        int end2 = 0;\\n        start1 += Int32.Parse(event1[0].Substring(0,2))*60;\\n        start1 += Int32.Parse(event1[0].Substring(3,2));\\n        end1 += Int32.Parse(event1[1].Substring(0,2))*60;\\n        end1 += Int32.Parse(event1[1].Substring(3,2));\\n        start2 += Int32.Parse(event2[0].Substring(0,2))*60;\\n        start2 += Int32.Parse(event2[0].Substring(3,2));\\n        end2 += Int32.Parse(event2[1].Substring(0,2))*60;\\n        end2 += Int32.Parse(event2[1].Substring(3,2));\\n        if (start1 <= start2)\\n        {\\n            return end1 >= start2;\\n        }\\n        else\\n        {\\n            return end2 >= start1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0][:2])*60 + int(event1[0][3:])\\n        end1 = int(event1[1][:2])*60 + int(event1[1][3:])\\n        start2 = int(event2[0][:2])*60 + int(event2[0][3:])\\n        end2 = int(event2[1][:2])*60 + int(event2[1][3:])\\n        time = [[start1, end1], [start2, end2]]\\n        time.sort()\\n        return time[0][1] >= time[1][0]\\n\\t\\t\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) {\\n        int start1 = 0;\\n        int end1 = 0;\\n        int start2 = 0;\\n        int end2 = 0;\\n        start1 += Int32.Parse(event1[0].Substring(0,2))*60;\\n        start1 += Int32.Parse(event1[0].Substring(3,2));\\n        end1 += Int32.Parse(event1[1].Substring(0,2))*60;\\n        end1 += Int32.Parse(event1[1].Substring(3,2));\\n        start2 += Int32.Parse(event2[0].Substring(0,2))*60;\\n        start2 += Int32.Parse(event2[0].Substring(3,2));\\n        end2 += Int32.Parse(event2[1].Substring(0,2))*60;\\n        end2 += Int32.Parse(event2[1].Substring(3,2));\\n        if (start1 <= start2)\\n        {\\n            return end1 >= start2;\\n        }\\n        else\\n        {\\n            return end2 >= start1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734420,
                "title": "java-soluution-one-liner-easy-and-o-1",
                "content": "public boolean haveConflict(String[] event1, String[] event2) {\\n\\n\\t// We can use Integer.valueOf or Integer.parseInt\\n\\n        Integer event1_0 = Integer.valueOf(event1[0].replace(\":\", \"\"));\\n        Integer event1_1 = Integer.valueOf(event1[1].replace(\":\", \"\"));\\n        Integer event2_0 = Integer.parseInt(event2[0].replace(\":\", \"\"));\\n        Integer event2_1 = Integer.parseInt(event2[1].replace(\":\", \"\"));\\n        \\n        if (event2_1 < event1_0) return false;\\n        if (event1_1 >= event2_0) return true;\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "public boolean haveConflict(String[] event1, String[] event2) {\\n\\n\\t// We can use Integer.valueOf or Integer.parseInt\\n\\n        Integer event1_0 = Integer.valueOf(event1[0].replace(\":\", \"\"));\\n        Integer event1_1 = Integer.valueOf(event1[1].replace(\":\", \"\"));\\n        Integer event2_0 = Integer.parseInt(event2[0].replace(\":\", \"\"));\\n        Integer event2_1 = Integer.parseInt(event2[1].replace(\":\", \"\"));\\n        \\n        if (event2_1 < event1_0) return false;\\n        if (event1_1 >= event2_0) return true;\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2734366,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int hrstomin(string s)\\n    {\\n        int h=(s[0]-\\'0\\')*10+(s[1]-\\'0\\');\\n        int min=(s[2]-\\'0\\')*10+(s[3]-\\'0\\');\\n        int tm=h*60+min;\\n        return tm;\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       int startev1=hrstomin(event1[0]);\\n        int endev1=hrstomin(event1[1]);\\n         int startev2=hrstomin(event2[0]);\\n         int endev2=hrstomin(event2[1]);\\n        if(startev1<=endev2&&endev1>=startev2)\\n        {\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL ,PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hrstomin(string s)\\n    {\\n        int h=(s[0]-\\'0\\')*10+(s[1]-\\'0\\');\\n        int min=(s[2]-\\'0\\')*10+(s[3]-\\'0\\');\\n        int tm=h*60+min;\\n        return tm;\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       int startev1=hrstomin(event1[0]);\\n        int endev1=hrstomin(event1[1]);\\n         int startev2=hrstomin(event2[0]);\\n         int endev2=hrstomin(event2[1]);\\n        if(startev1<=endev2&&endev1>=startev2)\\n        {\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734355,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int start1 = Integer.parseInt(event1[0].substring(0,2) + event1[0].substring(3,5));\\n        int end1 = Integer.parseInt(event1[1].substring(0,2) + event1[1].substring(3,5));\\n        int start2 = Integer.parseInt(event2[0].substring(0,2) + event2[0].substring(3,5));\\n        int end2 = Integer.parseInt(event2[1].substring(0,2) + event2[1].substring(3,5));\\n        \\n        \\n        if(start2 > end1  || start1 > end2){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int start1 = Integer.parseInt(event1[0].substring(0,2) + event1[0].substring(3,5));\\n        int end1 = Integer.parseInt(event1[1].substring(0,2) + event1[1].substring(3,5));\\n        int start2 = Integer.parseInt(event2[0].substring(0,2) + event2[0].substring(3,5));\\n        int end2 = Integer.parseInt(event2[1].substring(0,2) + event2[1].substring(3,5));\\n        \\n        \\n        if(start2 > end1  || start1 > end2){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734263,
                "title": "c-one-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event2[0] <= event1[1] and event2[1] >= event1[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event2[0] <= event1[1] and event2[1] >= event1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734256,
                "title": "simple-comparasions",
                "content": "```\\n\\nvar haveConflict = function(event1, event2) {\\n    if(event1[1] < event2[0]) return false;\\n    if(event2[0] <= event1[1] && event2[1] >= event1[0]) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar haveConflict = function(event1, event2) {\\n    if(event1[1] < event2[0]) return false;\\n    if(event2[0] <= event1[1] && event2[1] >= event1[0]) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734168,
                "title": "python-simple-convert-to-time",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def gettime(s):\\n            s=[int(i) for i in s.split(\":\")]\\n            return 60*s[0]+s[1]\\n        event1=[gettime(i) for i in event1]\\n        event2=[gettime(i) for i in event2]        \\n        tmp=[event1,event2]\\n        tmp.sort()\\n        if tmp[1][0]<=tmp[0][1]: return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def gettime(s):\\n            s=[int(i) for i in s.split(\":\")]\\n            return 60*s[0]+s[1]\\n        event1=[gettime(i) for i in event1]\\n        event2=[gettime(i) for i in event2]        \\n        tmp=[event1,event2]\\n        tmp.sort()\\n        if tmp[1][0]<=tmp[0][1]: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734141,
                "title": "c-stoi-use",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int e2m = stoi(event2[0].substr(0,2))*60+stoi(event2[0].substr(3,5));\\n        int e1m = stoi(event1[1].substr(0,2))*60+stoi(event1[1].substr(3,5));\\n        \\n        int e22m = stoi(event2[1].substr(0,2))*60+stoi(event2[1].substr(3,5));\\n        int e11m = stoi(event1[0].substr(0,2))*60+stoi(event1[0].substr(3,5));\\n        return e1m>=e2m && e11m<=e22m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int e2m = stoi(event2[0].substr(0,2))*60+stoi(event2[0].substr(3,5));\\n        int e1m = stoi(event1[1].substr(0,2))*60+stoi(event1[1].substr(3,5));\\n        \\n        int e22m = stoi(event2[1].substr(0,2))*60+stoi(event2[1].substr(3,5));\\n        int e11m = stoi(event1[0].substr(0,2))*60+stoi(event1[0].substr(3,5));\\n        return e1m>=e2m && e11m<=e22m;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2734129,
                "title": "c-brute-force-approach",
                "content": "Hello everyone here is my code for this problem, hope you will likw the approach!!\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int h1=((event1[0][0]-\\'0\\')*10)+(event1[0][1]-\\'0\\'), h2=((event1[1][0]-\\'0\\')*10)+(event1[1][1]-\\'0\\'), m1=((event1[0][3]-\\'0\\')*10)+(event1[0][4]-\\'0\\'), m2=((event1[1][3]-\\'0\\')*10)+(event1[1][4]-\\'0\\'), hh1=((event2[0][0]-\\'0\\')*10)+(event2[0][1]-\\'0\\'), mm1=((event2[0][3]-\\'0\\')*10)+(event2[0][4]-\\'0\\'), hh2=((event2[1][0]-\\'0\\')*10)+(event2[1][1]-\\'0\\'), mm2=((event2[1][3]-\\'0\\')*10)+(event2[1][4]-\\'0\\');\\n        \\n        if(h2==hh1 && m2==mm1){return true;}\\n        if(h1==hh1 && m1==mm1){return true;}\\n        else if(h1==hh1 && m1<mm1){\\n            while(true){\\n                if(mm1==60){\\n                    mm1=0;\\n                    if(hh1==23){\\n                        hh1=0;\\n                    }\\n                    else{\\n                        hh1++;\\n                    }\\n                }\\n                else{\\n                    mm1++;\\n                }\\n                if(h1==hh1 && m1==mm1){\\n                    //cout<<\"hk\"<<endl;\\n                    //cout<<h1<<\" \"<<hh1<<\" \"<<m1<<\" \"<<mm1<<endl;\\n                    return false;\\n                }\\n                if(h2==hh1 && m2==mm1){cout<<\"hhh\"<<endl; return true;}\\n            }\\n        }\\n        else if(h1<hh1){\\n            //cout<<\"here\"<<endl;\\n            while(true){\\n                if(mm1==60){\\n                    mm1=0;\\n                    if(hh1==23){\\n                        hh1=0;\\n                    }\\n                    else{\\n                        hh1++;\\n                    }\\n                }\\n                else{\\n                    mm1++;\\n                }\\n                if(h1==hh1 && m1==mm1){\\n                    //cout<<\"hk\"<<endl;\\n                    //cout<<h1<<\" \"<<hh1<<\" \"<<m1<<\" \"<<mm1<<endl;\\n                    return false;\\n                }\\n                if(h2==hh1 && m2==mm1){cout<<\"hhh\"<<endl; return true;}\\n            }\\n        }\\n        else{\\n            //cout<<\"her\"<<endl;\\n            if(hh2<h1 && mm2<m1){return false;}\\n            if(hh2==h1 && mm2==m1){return true;}\\n            //cout<<h2<<\" \"<<m2<<\" \"<<hh2<<\" \"<<mm2<<endl;\\n            if(h2<hh2){return true;}\\n            else if(h2==hh2 && m2<=mm2){return true;}\\n            else{\\n                while(true){\\n                    if(mm2==60){\\n                        mm2=0;\\n                        if(hh2==23){\\n                            hh2=0;\\n                        }\\n                        else{\\n                            hh2++;\\n                        }\\n                    }\\n                    else{\\n                        mm2++;\\n                    }\\n                    if(h1==hh2 && m1==mm2){\\n                        //cout<<\"chk\"<<endl;\\n                        return false;\\n                    }\\n                    if(h2==hh2 && m2==mm2){return true;}\\n                }\\n            }\\n        }\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        int h1=((event1[0][0]-\\'0\\')*10)+(event1[0][1]-\\'0\\'), h2=((event1[1][0]-\\'0\\')*10)+(event1[1][1]-\\'0\\'), m1=((event1[0][3]-\\'0\\')*10)+(event1[0][4]-\\'0\\'), m2=((event1[1][3]-\\'0\\')*10)+(event1[1][4]-\\'0\\'), hh1=((event2[0][0]-\\'0\\')*10)+(event2[0][1]-\\'0\\'), mm1=((event2[0][3]-\\'0\\')*10)+(event2[0][4]-\\'0\\'), hh2=((event2[1][0]-\\'0\\')*10)+(event2[1][1]-\\'0\\'), mm2=((event2[1][3]-\\'0\\')*10)+(event2[1][4]-\\'0\\');\\n        \\n        if(h2==hh1 && m2==mm1){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2734127,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef int ll;\\npublic:\\n    ll getTime(const string&s){ // get timesin mins\\n        ll ans=stoll(s.substr(3)); // mins\\n        ans+=60*stoll(s.substr(0, 2)); // hours into mins\\n        return ans;\\n    }\\n    bool haveConflict(vector<string>&a, vector<string>&b) {\\n        ll sa=getTime(a[0]), ea=getTime(a[1]), sb=getTime(b[0]), eb=getTime(b[1]); // start of a and b, end of a and b\\n        return ((sb>=sa && sb<=ea) || (sa>=sb && sa<=eb)); // do they intersect in any direction?\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\ntypedef int ll;\\npublic:\\n    ll getTime(const string&s){ // get timesin mins\\n        ll ans=stoll(s.substr(3)); // mins\\n        ans+=60*stoll(s.substr(0, 2)); // hours into mins\\n        return ans;\\n    }\\n    bool haveConflict(vector<string>&a, vector<string>&b) {\\n        ll sa=getTime(a[0]), ea=getTime(a[1]), sb=getTime(b[0]), eb=getTime(b[1]); // start of a and b, end of a and b\\n        return ((sb>=sa && sb<=ea) || (sa>=sb && sa<=eb)); // do they intersect in any direction?\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734099,
                "title": "java-solution-simplest",
                "content": "### **Please Upvote** :D\\nConverting each time into ```XXXX hrs``` format and comparing.\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int s1 = toHrs(event1[0]);\\n        int e1 = toHrs(event1[1]);\\n        int s2 = toHrs(event2[0]);\\n        int e2 = toHrs(event2[1]);\\n\\n        return !(e2 < s1 || e1 < s2);\\n    }\\n\\n    public int toHrs(String time) {\\n        return Integer.valueOf(time.replace(\":\", \"\"));\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```XXXX hrs```\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int s1 = toHrs(event1[0]);\\n        int e1 = toHrs(event1[1]);\\n        int s2 = toHrs(event2[0]);\\n        int e2 = toHrs(event2[1]);\\n\\n        return !(e2 < s1 || e1 < s2);\\n    }\\n\\n    public int toHrs(String time) {\\n        return Integer.valueOf(time.replace(\":\", \"\"));\\n    }\\n}\\n\\n// TC: O(1), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734073,
                "title": "line-sweep-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& a, vector<string>& b) \\n    {\\n        // Calculate the total minutes of given times\\n        int time1= ((a[0][0]-\\'0\\')*10+(a[0][1]-\\'0\\'))*60+(a[0][3]-\\'0\\')*10+(a[0][4]-\\'0\\'); \\n        int time2= ((a[1][0]-\\'0\\')*10+(a[1][1]-\\'0\\'))*60+(a[1][3]-\\'0\\')*10+(a[1][4]-\\'0\\');\\n        int time3= ((b[0][0]-\\'0\\')*10+(b[0][1]-\\'0\\'))*60+(b[0][3]-\\'0\\')*10+(b[0][4]-\\'0\\');\\n        int time4= ((b[1][0]-\\'0\\')*10+(b[1][1]-\\'0\\'))*60+(b[1][3]-\\'0\\')*10+(b[1][4]-\\'0\\');\\n\\n        //A array to represent line (max time can be 1439 ) \\n        vector<int>count(1500,0);\\n        // Mark start=+1 and end( end+1 since its a closed interval] =-1.\\n        count[time1]++;\\n        count[time2+1]--;\\n        count[time3]++;\\n        count[time4+1]--;\\n\\n\\n        int sum=0;\\n        for(auto  it:count)\\n        {\\n            sum+= it;\\n            if(sum==2)return true;  // if sum equal 2 we have an intersecting point \\n        }\\n\\n            return false;\\n    }\\n};\\n\\n\\n//https://leetcode.com/discuss/study-guide/2166045/Line-Sweep-Algorithms\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& a, vector<string>& b) \\n    {\\n        // Calculate the total minutes of given times\\n        int time1= ((a[0][0]-\\'0\\')*10+(a[0][1]-\\'0\\'))*60+(a[0][3]-\\'0\\')*10+(a[0][4]-\\'0\\'); \\n        int time2= ((a[1][0]-\\'0\\')*10+(a[1][1]-\\'0\\'))*60+(a[1][3]-\\'0\\')*10+(a[1][4]-\\'0\\');\\n        int time3= ((b[0][0]-\\'0\\')*10+(b[0][1]-\\'0\\'))*60+(b[0][3]-\\'0\\')*10+(b[0][4]-\\'0\\');\\n        int time4= ((b[1][0]-\\'0\\')*10+(b[1][1]-\\'0\\'))*60+(b[1][3]-\\'0\\')*10+(b[1][4]-\\'0\\');\\n\\n        //A array to represent line (max time can be 1439 ) \\n        vector<int>count(1500,0);\\n        // Mark start=+1 and end( end+1 since its a closed interval] =-1.\\n        count[time1]++;\\n        count[time2+1]--;\\n        count[time3]++;\\n        count[time4+1]--;\\n\\n\\n        int sum=0;\\n        for(auto  it:count)\\n        {\\n            sum+= it;\\n            if(sum==2)return true;  // if sum equal 2 we have an intersecting point \\n        }\\n\\n            return false;\\n    }\\n};\\n\\n\\n//https://leetcode.com/discuss/study-guide/2166045/Line-Sweep-Algorithms\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094676,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return min(event1[1], event2[1]) >= max(event1[0], event2[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return min(event1[1], event2[1]) >= max(event1[0], event2[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088638,
                "title": "too-easy-to-understand-throughly-explained-beats-runtime-100-memory-99",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse String compareTo() function which performs lexicographical comparison and returns values 1, 0, and -1.\\nFirst, compare the starting time of both the events. If both event starts at same time(compareTo() value would be 0), return true else false.\\nSecond, if the event1 start earlier than the event2(compareTo() value would be -1), then compare the ending of the event1 to the start time of the event2, if it is equal or more (compareTo() value >= 0) then return true else false;\\nThird, if the event1 start after the starting of the event2, then compare the ending of the event2 to the start time of the event1. If it is equal or greater (compareTo() value >= 0) return true, else false.\\nIf u still don\\'t get it. See the code below.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/c330fbf0-8886-4435-9f7e-a9c4f5095015_1695645853.1853638.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        //if both event starts at the same time\\n        if(event1[0].compareTo(event2[0]) == 0){\\n            return true;\\n        }\\n\\n        //if event1 start earlier than event2\\n        //start time of event2 > start time of event1\\n       if(event1[0].compareTo(event2[0]) < 0){\\n           //if event2 starts at or before the ending of the event1\\n            //start time of event2 <= end time of event1\\n           if(event1[1].compareTo(event2[0]) >= 0){\\n               return true;\\n           }else{\\n               return false;\\n           }\\n       }\\n        //same as if condition\\n        else{\\n           if(event2[1].compareTo(event1[0]) >= 0){\\n               return true;\\n           }else{\\n               return false;\\n           }\\n       }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        //if both event starts at the same time\\n        if(event1[0].compareTo(event2[0]) == 0){\\n            return true;\\n        }\\n\\n        //if event1 start earlier than event2\\n        //start time of event2 > start time of event1\\n       if(event1[0].compareTo(event2[0]) < 0){\\n           //if event2 starts at or before the ending of the event1\\n            //start time of event2 <= end time of event1\\n           if(event1[1].compareTo(event2[0]) >= 0){\\n               return true;\\n           }else{\\n               return false;\\n           }\\n       }\\n        //same as if condition\\n        else{\\n           if(event2[1].compareTo(event1[0]) >= 0){\\n               return true;\\n           }else{\\n               return false;\\n           }\\n       }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085611,
                "title": "no-parsing-just-string-comparison",
                "content": "# Intuition\\nThere are only two events, and strings are comparable\\n\\n# Approach\\nSee if there is no conflict by checking if either events end before another starts\\n\\n# Complexity\\n- Time complexity:\\nMax two string comparisons O(min(n,m))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        bool noConflict = event1[0] > event2[1] ||\\n                             event1[1] < event2[0];\\n        return !noConflict;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        bool noConflict = event1[0] > event2[1] ||\\n                             event1[1] < event2[0];\\n        return !noConflict;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079445,
                "title": "c-solution",
                "content": "# Approach\\n- Parse time (converting to it)\\n- Compare\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool HaveConflict(string[] event1, string[] event2)\\n    {\\n        var start1 = convertTimeToInt(event1[0]);\\n        var end1 = convertTimeToInt(event1[1]);\\n        var start2 = convertTimeToInt(event2[0]);\\n        var end2 = convertTimeToInt(event2[1]);\\n\\n        return (start1 >= start2 && start1 <= end2) || (start2 >= start1 && start2 <= end1);\\n    }\\n\\n    private static int convertTimeToInt(string time)\\n    {\\n        var splitTime = time.Split(\\':\\');\\n        return int.Parse(splitTime[0]) * 60 + int.Parse(splitTime[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool HaveConflict(string[] event1, string[] event2)\\n    {\\n        var start1 = convertTimeToInt(event1[0]);\\n        var end1 = convertTimeToInt(event1[1]);\\n        var start2 = convertTimeToInt(event2[0]);\\n        var end2 = convertTimeToInt(event2[1]);\\n\\n        return (start1 >= start2 && start1 <= end2) || (start2 >= start1 && start2 <= end1);\\n    }\\n\\n    private static int convertTimeToInt(string time)\\n    {\\n        var splitTime = time.Split(\\':\\');\\n        return int.Parse(splitTime[0]) * 60 + int.Parse(splitTime[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037428,
                "title": "readable-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic strategy is just to check whether the second event starts before the first one ends, or if the first one starts before the second one ends (Like if the event went to the next day)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI first serialized the times into a generic integer format, and the compared them.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n(Not 100% sure about these complexities as I\\'m not very good with algorithms yet but)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDon\\'t know this one\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def conv(str) -> int:\\n            time = str.split(\":\")\\n            return (int(time[0])*60+int(time[1]))\\n        return True if (conv(event2[0]) <= conv(event1[1])) and (conv(event2[1]) >= conv(event1[0])) else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def conv(str) -> int:\\n            time = str.split(\":\")\\n            return (int(time[0])*60+int(time[1]))\\n        return True if (conv(event2[0]) <= conv(event1[1])) and (conv(event2[1]) >= conv(event1[0])) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023408,
                "title": "determine-if-two-events-have-conflict-in-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic boolean haveConflict(String[] event1, String[] event2) {\\n    \\n    String hour1 = event1[1].substring(0,event1[1].indexOf(\\':\\'));\\n    int h1=Integer.parseInt(hour1);\\n    String hour2 = event2[0].substring(0,event2[0].indexOf(\\':\\'));\\n    int h2=Integer.parseInt(hour2);\\n     if(h1==h2)\\n    {\\n            int min1 = Integer.parseInt( event1[1].substring(event1[1].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n            String hour11 = event1[0].substring(0,event1[0].indexOf(\\':\\'));\\n            int h11=Integer.parseInt(hour11);\\n            System.out.println(\"h11 \"+h11);\\n            int min3 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n        if (min2<=min1)\\n        {\\n            if(h2==h11 && min3>min2)\\n                return false;\\n             else   \\n                return true;\\n        }\\n        }\\n    else if(h2 < h1)\\n    {\\n        String hour11 = event1[0].substring(0,event1[0].indexOf(\\':\\'));\\n        int h11=Integer.parseInt(hour11);\\n        if(h2 < h1 && h11 < h2)\\n            return true;\\n        else if(h2==h11)\\n        {\\n            int min1 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n            if (min2 >= min1)\\n                return true;\\n            else\\n            {\\n        String hour22 = event2[1].substring(0,event2[1].indexOf(\\':\\'));\\n        int h22=Integer.parseInt(hour22);\\n        if(h22>h1)\\n            return true;\\n            else if(h22>h11 && h22<h1)\\n            return true;\\n            else\\n        {\\n             min1 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n             min2 = Integer.parseInt( event2[1].substring(event2[1].indexOf(\\':\\') + 1 ));\\n            if (min2<min1)\\n                return true;\\n        }\\n            }\\n        }\\n        else \\n        {\\n        String hour22 = event2[1].substring(0,event2[1].indexOf(\\':\\'));\\n        int h22=Integer.parseInt(hour22);\\n        if(h22==h11)\\n        {\\n            int min1 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[1].substring(event2[1].indexOf(\\':\\') + 1 ));\\n            if (min2>=min1)\\n                return true;\\n        }\\n        else if(h11<h22)\\n            return true;\\n            \\n        }\\n    }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic boolean haveConflict(String[] event1, String[] event2) {\\n    \\n    String hour1 = event1[1].substring(0,event1[1].indexOf(\\':\\'));\\n    int h1=Integer.parseInt(hour1);\\n    String hour2 = event2[0].substring(0,event2[0].indexOf(\\':\\'));\\n    int h2=Integer.parseInt(hour2);\\n     if(h1==h2)\\n    {\\n            int min1 = Integer.parseInt( event1[1].substring(event1[1].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n            String hour11 = event1[0].substring(0,event1[0].indexOf(\\':\\'));\\n            int h11=Integer.parseInt(hour11);\\n            System.out.println(\"h11 \"+h11);\\n            int min3 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n        if (min2<=min1)\\n        {\\n            if(h2==h11 && min3>min2)\\n                return false;\\n             else   \\n                return true;\\n        }\\n        }\\n    else if(h2 < h1)\\n    {\\n        String hour11 = event1[0].substring(0,event1[0].indexOf(\\':\\'));\\n        int h11=Integer.parseInt(hour11);\\n        if(h2 < h1 && h11 < h2)\\n            return true;\\n        else if(h2==h11)\\n        {\\n            int min1 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n            if (min2 >= min1)\\n                return true;\\n            else\\n            {\\n        String hour22 = event2[1].substring(0,event2[1].indexOf(\\':\\'));\\n        int h22=Integer.parseInt(hour22);\\n        if(h22>h1)\\n            return true;\\n            else if(h22>h11 && h22<h1)\\n            return true;\\n            else\\n        {\\n             min1 = Integer.parseInt( event2[0].substring(event2[0].indexOf(\\':\\') + 1 ));\\n             min2 = Integer.parseInt( event2[1].substring(event2[1].indexOf(\\':\\') + 1 ));\\n            if (min2<min1)\\n                return true;\\n        }\\n            }\\n        }\\n        else \\n        {\\n        String hour22 = event2[1].substring(0,event2[1].indexOf(\\':\\'));\\n        int h22=Integer.parseInt(hour22);\\n        if(h22==h11)\\n        {\\n            int min1 = Integer.parseInt( event1[0].substring(event1[0].indexOf(\\':\\') + 1 ));\\n            int min2 = Integer.parseInt( event2[1].substring(event2[1].indexOf(\\':\\') + 1 ));\\n            if (min2>=min1)\\n                return true;\\n        }\\n        else if(h11<h22)\\n            return true;\\n            \\n        }\\n    }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020442,
                "title": "golang-simple-solution",
                "content": "\\n\\n# Code\\n```\\nimport (\\n    \"strings\"\\n    \"strconv\"\\n)\\n\\ntype Range struct {\\n    Start int\\n    End int\\n}\\n\\nfunc (r Range) Intersects(other Range) bool {\\n    return r.Start <= other.End && other.Start <= r.End\\n}\\n\\nfunc haveConflict(event1 []string, event2 []string) bool {\\n    \\n    var (\\n        r1 = Range{Start: toMinutes(event1[0]), End: toMinutes(event1[1])}\\n        r2 = Range{Start: toMinutes(event2[0]), End: toMinutes(event2[1])}\\n    )\\n\\n    return r1.Intersects(r2)\\n}\\n\\nfunc toMinutes(s string) int {\\n\\n    parts := strings.Split(s, \":\")\\n    hh, mm := parts[0], parts[1]\\n\\n    h, err := strconv.Atoi(hh)\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    m, err := strconv.Atoi(mm)\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    return h * 60 + m\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n    \"strings\"\\n    \"strconv\"\\n)\\n\\ntype Range struct {\\n    Start int\\n    End int\\n}\\n\\nfunc (r Range) Intersects(other Range) bool {\\n    return r.Start <= other.End && other.Start <= r.End\\n}\\n\\nfunc haveConflict(event1 []string, event2 []string) bool {\\n    \\n    var (\\n        r1 = Range{Start: toMinutes(event1[0]), End: toMinutes(event1[1])}\\n        r2 = Range{Start: toMinutes(event2[0]), End: toMinutes(event2[1])}\\n    )\\n\\n    return r1.Intersects(r2)\\n}\\n\\nfunc toMinutes(s string) int {\\n\\n    parts := strings.Split(s, \":\")\\n    hh, mm := parts[0], parts[1]\\n\\n    h, err := strconv.Atoi(hh)\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    m, err := strconv.Atoi(mm)\\n    if err != nil {\\n        panic(err)\\n    }\\n\\n    return h * 60 + m\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3999504,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0].replace(\\':\\', \\'\\'))\\n        end1 = int(event1[1].replace(\\':\\', \\'\\'))\\n\\n        start2 = int(event2[0].replace(\\':\\', \\'\\'))\\n        end2 = int(event2[1].replace(\\':\\', \\'\\'))\\n        if start1 <= start2 <= end1 or start1 <= end2 <= end1 or start2 <= start1 <= end2 or start2 <= end1 <= end2:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1 = int(event1[0].replace(\\':\\', \\'\\'))\\n        end1 = int(event1[1].replace(\\':\\', \\'\\'))\\n\\n        start2 = int(event2[0].replace(\\':\\', \\'\\'))\\n        end2 = int(event2[1].replace(\\':\\', \\'\\'))\\n        if start1 <= start2 <= end1 or start1 <= end2 <= end1 or start2 <= start1 <= end2 or start2 <= end1 <= end2:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988259,
                "title": "python-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def fun(s):\\n            hour,mins=s.split(\":\")\\n            val=60*hour+mins\\n            return val\\n        if fun(event2[0])<= fun(event1[1]) and fun(event2[0]) >=fun(event1[0]):\\n            return True\\n        elif fun(event1[0])<= fun(event2[1]) and fun(event1[0]) >=fun(event2[0]):\\n            return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def fun(s):\\n            hour,mins=s.split(\":\")\\n            val=60*hour+mins\\n            return val\\n        if fun(event2[0])<= fun(event1[1]) and fun(event2[0]) >=fun(event1[0]):\\n            return True\\n        elif fun(event1[0])<= fun(event2[1]) and fun(event1[0]) >=fun(event2[0]):\\n            return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988195,
                "title": "java-calculation-and-compare-of-integer-parsed-from-given-strings",
                "content": "# Intuition\\nIt is not given Which event start first, Then when comparing first calculate if second event finished before first started. If so then find conflict between first and second by assuming first event start before second.\\n\\n# Approach\\nCalculate parse Integer values of both events. And compare to return True of False.\\n\\n# Complexity\\n- Time complexity:\\nConstant O(1)\\n\\n- Space complexity:\\nConstant O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        if (event1 == null || event2 == null)\\n            return false;\\n        Integer e1Start = Integer.parseInt(event1[0].replace(\":\",\"\"));\\n        Integer e1End = Integer.parseInt(event1[1].replace(\":\",\"\"));\\n        Integer e2Start = Integer.parseInt(event2[0].replace(\":\",\"\"));\\n        Integer e2End = Integer.parseInt(event2[1].replace(\":\",\"\"));\\n        if (e2End < e1Start)\\n            return false;\\n        if (e1End>=e2Start)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        if (event1 == null || event2 == null)\\n            return false;\\n        Integer e1Start = Integer.parseInt(event1[0].replace(\":\",\"\"));\\n        Integer e1End = Integer.parseInt(event1[1].replace(\":\",\"\"));\\n        Integer e2Start = Integer.parseInt(event2[0].replace(\":\",\"\"));\\n        Integer e2End = Integer.parseInt(event2[1].replace(\":\",\"\"));\\n        if (e2End < e1Start)\\n            return false;\\n        if (e1End>=e2Start)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985530,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        check1 = event1[0] <= event2[0] <= event1[1]\\n        check2 = event2[0] <= event1[0] <= event2[1]\\n\\n        return check1 or check2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        check1 = event1[0] <= event2[0] <= event1[1]\\n        check2 = event2[0] <= event1[0] <= event2[1]\\n\\n        return check1 or check2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962183,
                "title": "js-solution-map",
                "content": "# Code\\n```\\nvar haveConflict = function(event1, event2) {\\n    const intervalMap1 = createIntervalMap(event1[0], event1[1]);\\n    const intervalMap2 = createIntervalMap(event2[0], event2[1]);\\n    return doOverlap(intervalMap1, intervalMap2);\\n};\\n\\nfunction doOverlap(interval1, interval2) {\\n    for (const [key, value] of Object.entries(interval1)) {\\n        if (key in interval2 && \\n            // (startA <= endB) and (endA >= startB)\\n            value[0] <= interval2[key][1] &&\\n            value[1] >= interval2[key][0]\\n        ) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nfunction createIntervalMap(startTime, endTime) {\\n    const intervalMap = {};\\n    const [startTimeHH, startTimeMM] = Array.from(startTime.split(\\':\\'), Number);\\n    const [endTimeHH, endTimeMM] = Array.from(endTime.split(\\':\\'), Number);\\n\\n    for (let h = startTimeHH; h <= endTimeHH; h++) {\\n        if (h === startTimeHH && h === endTimeHH) {\\n            intervalMap[h] = [startTimeMM, endTimeMM];\\n        }\\n        else if (h === startTimeHH) {\\n            intervalMap[h] = [startTimeMM, 59];\\n        }\\n        else if (h === endTimeHH) {\\n            intervalMap[h] = [0, endTimeMM];\\n        }\\n        else {\\n            intervalMap[h] = [0, 59];\\n        }\\n    }\\n    return intervalMap;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar haveConflict = function(event1, event2) {\\n    const intervalMap1 = createIntervalMap(event1[0], event1[1]);\\n    const intervalMap2 = createIntervalMap(event2[0], event2[1]);\\n    return doOverlap(intervalMap1, intervalMap2);\\n};\\n\\nfunction doOverlap(interval1, interval2) {\\n    for (const [key, value] of Object.entries(interval1)) {\\n        if (key in interval2 && \\n            // (startA <= endB) and (endA >= startB)\\n            value[0] <= interval2[key][1] &&\\n            value[1] >= interval2[key][0]\\n        ) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nfunction createIntervalMap(startTime, endTime) {\\n    const intervalMap = {};\\n    const [startTimeHH, startTimeMM] = Array.from(startTime.split(\\':\\'), Number);\\n    const [endTimeHH, endTimeMM] = Array.from(endTime.split(\\':\\'), Number);\\n\\n    for (let h = startTimeHH; h <= endTimeHH; h++) {\\n        if (h === startTimeHH && h === endTimeHH) {\\n            intervalMap[h] = [startTimeMM, endTimeMM];\\n        }\\n        else if (h === startTimeHH) {\\n            intervalMap[h] = [startTimeMM, 59];\\n        }\\n        else if (h === endTimeHH) {\\n            intervalMap[h] = [0, endTimeMM];\\n        }\\n        else {\\n            intervalMap[h] = [0, 59];\\n        }\\n    }\\n    return intervalMap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951727,
                "title": "c-100-only-one-line-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949995,
                "title": "java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        String[] st1 = event1[0].split(\":\");\\n        String[] et1 = event1[1].split(\":\");\\n        \\n        String[] st2 = event2[0].split(\":\");\\n        String[] et2 = event2[1].split(\":\");\\n        \\n        int s1 = Integer.parseInt(st1[0])*60+Integer.parseInt(st1[1]);\\n        int e1 = Integer.parseInt(et1[0])*60+Integer.parseInt(et1[1]);\\n        \\n        int s2 = Integer.parseInt(st2[0])*60+Integer.parseInt(st2[1]);\\n        int e2 = Integer.parseInt(et2[0])*60+Integer.parseInt(et2[1]);\\n        \\n        return e2>=s1 && s2<=e1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        String[] st1 = event1[0].split(\":\");\\n        String[] et1 = event1[1].split(\":\");\\n        \\n        String[] st2 = event2[0].split(\":\");\\n        String[] et2 = event2[1].split(\":\");\\n        \\n        int s1 = Integer.parseInt(st1[0])*60+Integer.parseInt(st1[1]);\\n        int e1 = Integer.parseInt(et1[0])*60+Integer.parseInt(et1[1]);\\n        \\n        int s2 = Integer.parseInt(st2[0])*60+Integer.parseInt(st2[1]);\\n        int e2 = Integer.parseInt(et2[0])*60+Integer.parseInt(et2[1]);\\n        \\n        return e2>=s1 && s2<=e1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948381,
                "title": "c-count-overlapping-intervals-pattern",
                "content": "# Intuition\\nUse overlapping intervals pattern\\n\\n# Approach\\nConvert string representation of time into integer (minutes), Then apply overlapping intervals count pattern.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        vector<vector<string>> events;\\n        events.push_back(event1);\\n        events.push_back(event2);\\n        int n = 2;\\n        vector<vector<int>> events2;\\n\\n        for (int i = 0; i < n; i++) {\\n            vector<int> timestamps;\\n            \\n            for (int j = 0; j < 2; j++) {\\n                string time = events[i][j];\\n                int h = stoi(time.substr(0, 2));\\n                int m = stoi(time.substr(3, 2));\\n                int timestamp = h * 60 + m;\\n                timestamps.push_back(timestamp);\\n            }\\n\\n            events2.push_back(timestamps);\\n        }\\n\\n        sort(events2.begin(), events2.end());\\n        priority_queue<int, vector<int>, greater<int>> minq;\\n        minq.push(events2[0][1]);\\n\\n        for (int i = 1; i < n; i++) {\\n            int s = events2[i][0];\\n            int e = events2[i][1];\\n\\n            while (minq.size() > 0 && minq.top() < s) {\\n                minq.pop();\\n            }\\n\\n            minq.push(e);\\n\\n            if (minq.size() > 1) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        vector<vector<string>> events;\\n        events.push_back(event1);\\n        events.push_back(event2);\\n        int n = 2;\\n        vector<vector<int>> events2;\\n\\n        for (int i = 0; i < n; i++) {\\n            vector<int> timestamps;\\n            \\n            for (int j = 0; j < 2; j++) {\\n                string time = events[i][j];\\n                int h = stoi(time.substr(0, 2));\\n                int m = stoi(time.substr(3, 2));\\n                int timestamp = h * 60 + m;\\n                timestamps.push_back(timestamp);\\n            }\\n\\n            events2.push_back(timestamps);\\n        }\\n\\n        sort(events2.begin(), events2.end());\\n        priority_queue<int, vector<int>, greater<int>> minq;\\n        minq.push(events2[0][1]);\\n\\n        for (int i = 1; i < n; i++) {\\n            int s = events2[i][0];\\n            int e = events2[i][1];\\n\\n            while (minq.size() > 0 && minq.top() < s) {\\n                minq.pop();\\n            }\\n\\n            minq.push(e);\\n\\n            if (minq.size() > 1) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946692,
                "title": "easy-code-to-beat-94-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        a1=\\'\\'.join([x for x in event1[0] if x !=\\':\\'])\\n        a1=int(a1)\\n\\n        b1=\\'\\'.join([x for x in event1[1] if x !=\\':\\'])\\n        b1=int(b1)\\n\\n        a2=\\'\\'.join([x for x in event2[0] if x !=\\':\\'])\\n        a2=int(a2)\\n\\n        b2=\\'\\'.join([x for x in event2[1] if x !=\\':\\'])\\n        b2=int(b2)\\n\\n        if max(a1,a2) >min(b1,b2):\\n            return False\\n        return True\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        a1=\\'\\'.join([x for x in event1[0] if x !=\\':\\'])\\n        a1=int(a1)\\n\\n        b1=\\'\\'.join([x for x in event1[1] if x !=\\':\\'])\\n        b1=int(b1)\\n\\n        a2=\\'\\'.join([x for x in event2[0] if x !=\\':\\'])\\n        a2=int(a2)\\n\\n        b2=\\'\\'.join([x for x in event2[1] if x !=\\':\\'])\\n        b2=int(b2)\\n\\n        if max(a1,a2) >min(b1,b2):\\n            return False\\n        return True\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920097,
                "title": "two-events-js-convert-str-to-minutes-48-ms",
                "content": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    a = strToTime(event1[0])\\n    b = strToTime(event1[1])\\n    c = strToTime(event2[0])\\n    d = strToTime(event2[1])\\n\\n    if (c >= a && c <= b) return true\\n    if (a >= c && a <= d) return true\\n\\n    function strToTime(str) {\\n        hours = Number(str[0] + str[1])\\n        minutes = Number(str[3] + str[4])\\n        return hours * 60 + minutes\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n    a = strToTime(event1[0])\\n    b = strToTime(event1[1])\\n    c = strToTime(event2[0])\\n    d = strToTime(event2[1])\\n\\n    if (c >= a && c <= b) return true\\n    if (a >= c && a <= d) return true\\n\\n    function strToTime(str) {\\n        hours = Number(str[0] + str[1])\\n        minutes = Number(str[3] + str[4])\\n        return hours * 60 + minutes\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917894,
                "title": "beats-98-03-one-line-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to convert the string to intiger and then answer it. But it was very time consuming and creating some test cases to fail so i came up with this solution. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In this questions we need to tell there is any intersection or not you can understan that thing by a simple example\\n- Lets see when the intersection is possible \\n1. When the ending time of first and the starting time of second are matching.( when e1[1]==e2[0] )\\nevent1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\\n\\n\\n\\u2014---------| 1:15 --------------------------------------|2:00  -----------------------------------                                \\n  \\u2014-----------------------------------------------------|2:00   ---------------------------|3:00----\\n\\n\\n2. Now the second case when the intersection is possible is when the ending time of event 1 is greater than that of starting time of second.\\n                  event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\\n\\n.\\n\\u2014---------| 1:00 --------------------------------------|2:00    -------------------------\\n                                        \\n  \\u2014-----------------------|1:20  --------------------------------------|3:00  -----------------------\\n\\n\\n3. Now the third is the case when the starting time of first is lesser than the ending time of second.\\n\\n\\u2014-------------------------------------|2:00--------------------------------------|4:00                                    ----------\\n                               \\n  \\u2014-----------------------|1:20--------------------------------------|3:00-------------------\\n\\n\\n4. Forth case is when the starting time of first is matching with the ending time of second \\n\\n--------------------------------|2:00   --------------------------------------|4:00 ----------------\\n\\n-----1:30 ----------------------|2:00------------------------------------------------------------\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        return(event1[1]>=event2[0] and event1[0]<=event2[1])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        \\n        return(event1[1]>=event2[0] and event1[0]<=event2[1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917572,
                "title": "rust-3-lines-formula",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        let r = event1[1].clone().min(event2[1].clone());\\n        let l = event1[0].clone().max(event2[0].clone());\\n        l <= r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        let r = event1[1].clone().min(event2[1].clone());\\n        let l = event1[0].clone().max(event2[0].clone());\\n        l <= r\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901983,
                "title": "shortest-solution-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cal(string s){\\n        string str;\\n        for(int i = 0; i < s.size(); i++) if(s[i] != \\':\\') str += s[i];\\n        return stoi(str);\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(cal(event2[0]) <= cal(event1[1]) && cal(event1[0]) <= cal(event2[1])) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(string s){\\n        string str;\\n        for(int i = 0; i < s.size(); i++) if(s[i] != \\':\\') str += s[i];\\n        return stoi(str);\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(cal(event2[0]) <= cal(event1[1]) && cal(event1[0]) <= cal(event2[1])) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890542,
                "title": "determine-if-two-events-have-conflicts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if (event1[1]>=event2[0] and event1[0]<=event2[0]) or (event2[1]>=event1[0] and event2[0]<=event1[0]):\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if (event1[1]>=event2[0] and event1[0]<=event2[0]) or (event2[1]>=event1[0] and event2[0]<=event1[0]):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886817,
                "title": "beginner-level-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        // Because I don\\'t know which event will begin first, I will \\n        // first determine which event will begin first \\n        // then determine whether the event that began first should also end before the other event begins.\\n\\n        \\n    return event1[0]<event2[0] ? event1[1]>=event2[0] : event2[1]>=event1[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        // Because I don\\'t know which event will begin first, I will \\n        // first determine which event will begin first \\n        // then determine whether the event that began first should also end before the other event begins.\\n\\n        \\n    return event1[0]<event2[0] ? event1[1]>=event2[0] : event2[1]>=event1[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874654,
                "title": "java-0ms-beats-100-00",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n\\n        // they overlap if:\\n        // - they start at the same time\\n        // - they end at the same time\\n        // - one starts while the other is in progress\\n\\n        // case: they start at the same time\\n        if (event1[0].equals(event2[0])) {\\n            return true;\\n        }\\n\\n        // case: they end at the same time\\n        if (event1[1].equals(event2[1])) {\\n            return true;\\n        }\\n\\n        // case: event1 starts while event2 is in progress\\n        int event1_start = convertTimeToMinutes(event1[0]); \\n        if (event1_start > convertTimeToMinutes(event2[0]) && event1_start <= convertTimeToMinutes(event2[1])) {\\n            return true;\\n        }\\n\\n        // case: event2 starts while event1 is in progress\\n        int event2_start = convertTimeToMinutes(event2[0]); \\n        if (event2_start > event1_start && event2_start <= convertTimeToMinutes(event1[1])) {\\n            return true;\\n        }\\n\\n        // case: no conflict!\\n        return false;\\n    }\\n\\n    private int convertTimeToMinutes(String time) {\\n        int hours = (time.charAt(0) - \\'0\\') * 10 + (time.charAt(1) - \\'0\\');\\n        int minutes = (time.charAt(3) - \\'0\\') * 10 + (time.charAt(4) - \\'0\\');\\n        return hours * 60 + minutes;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n\\n        // they overlap if:\\n        // - they start at the same time\\n        // - they end at the same time\\n        // - one starts while the other is in progress\\n\\n        // case: they start at the same time\\n        if (event1[0].equals(event2[0])) {\\n            return true;\\n        }\\n\\n        // case: they end at the same time\\n        if (event1[1].equals(event2[1])) {\\n            return true;\\n        }\\n\\n        // case: event1 starts while event2 is in progress\\n        int event1_start = convertTimeToMinutes(event1[0]); \\n        if (event1_start > convertTimeToMinutes(event2[0]) && event1_start <= convertTimeToMinutes(event2[1])) {\\n            return true;\\n        }\\n\\n        // case: event2 starts while event1 is in progress\\n        int event2_start = convertTimeToMinutes(event2[0]); \\n        if (event2_start > event1_start && event2_start <= convertTimeToMinutes(event1[1])) {\\n            return true;\\n        }\\n\\n        // case: no conflict!\\n        return false;\\n    }\\n\\n    private int convertTimeToMinutes(String time) {\\n        int hours = (time.charAt(0) - \\'0\\') * 10 + (time.charAt(1) - \\'0\\');\\n        int minutes = (time.charAt(3) - \\'0\\') * 10 + (time.charAt(4) - \\'0\\');\\n        return hours * 60 + minutes;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867082,
                "title": "esy-solution-just-by-if-else",
                "content": "\\n\\n# Approach\\nJust if-else\\n\\n# Complexity\\n- Time complexity:**O(1)**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        double e2s=(event2[0][0]-48)*10+(event2[0][1]-48)+ .01*((event2[0][3]-48)*10+(event2[0][4]-48));\\n        double e2e=(event2[1][0]-48)*10+(event2[1][1]-48)+ .01*((event2[1][3]-48)*10+(event2[1][4]-48));\\n        double e1s=(event1[0][0]-48)*10+(event1[0][1]-48)+ .01*((event1[0][3]-48)*10+(event1[0][4]-48));\\n        double e1e=(event1[1][0]-48)*10+(event1[1][1]-48)+ .01*((event1[1][3]-48)*10+(event1[1][4]-48));       \\n        if((e1e>=e2s && e1e<=e2e) || (e1s>=e2s && e1s<=e2e) || (e2s>=e1s && e2e<=e1e) || (e1s>=e2s && e1e<=e2e)){\\n            return true;\\n        }\\n        else{\\n        return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        double e2s=(event2[0][0]-48)*10+(event2[0][1]-48)+ .01*((event2[0][3]-48)*10+(event2[0][4]-48));\\n        double e2e=(event2[1][0]-48)*10+(event2[1][1]-48)+ .01*((event2[1][3]-48)*10+(event2[1][4]-48));\\n        double e1s=(event1[0][0]-48)*10+(event1[0][1]-48)+ .01*((event1[0][3]-48)*10+(event1[0][4]-48));\\n        double e1e=(event1[1][0]-48)*10+(event1[1][1]-48)+ .01*((event1[1][3]-48)*10+(event1[1][4]-48));       \\n        if((e1e>=e2s && e1e<=e2e) || (e1s>=e2s && e1s<=e2e) || (e2s>=e1s && e2e<=e1e) || (e1s>=e2s && e1e<=e2e)){\\n            return true;\\n        }\\n        else{\\n        return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863692,
                "title": "easy-java-solution-using-if-else-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int startHrs1 = Integer.parseInt(event1[0].substring(0, 2));\\n        int startMins1 = Integer.parseInt(event1[0].substring(3, 5));\\n        int endHrs1 = Integer.parseInt(event1[1].substring(0, 2));\\n        int endMins1 = Integer.parseInt(event1[1].substring(3, 5));\\n        int startHrs2 = Integer.parseInt(event2[0].substring(0, 2));\\n        int startMins2 = Integer.parseInt(event2[0].substring(3, 5));\\n        int endHrs2 = Integer.parseInt(event2[1].substring(0, 2));\\n        int endMins2 = Integer.parseInt(event2[1].substring(3, 5));\\n\\n        if((startHrs1 < startHrs2) || (startHrs1 == startHrs2 && endMins1 <= endMins2)) {\\n            if(endHrs1 > startHrs2) return true;\\n            else if(endHrs1 == startHrs2 && endMins1 >= startMins2) return true;\\n            else return false;\\n        }\\n        else {\\n            if(endHrs2 > startHrs1) return true;\\n            else if(endHrs2 == startHrs1 && endMins2 >= startMins1) return true;\\n            else return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int startHrs1 = Integer.parseInt(event1[0].substring(0, 2));\\n        int startMins1 = Integer.parseInt(event1[0].substring(3, 5));\\n        int endHrs1 = Integer.parseInt(event1[1].substring(0, 2));\\n        int endMins1 = Integer.parseInt(event1[1].substring(3, 5));\\n        int startHrs2 = Integer.parseInt(event2[0].substring(0, 2));\\n        int startMins2 = Integer.parseInt(event2[0].substring(3, 5));\\n        int endHrs2 = Integer.parseInt(event2[1].substring(0, 2));\\n        int endMins2 = Integer.parseInt(event2[1].substring(3, 5));\\n\\n        if((startHrs1 < startHrs2) || (startHrs1 == startHrs2 && endMins1 <= endMins2)) {\\n            if(endHrs1 > startHrs2) return true;\\n            else if(endHrs1 == startHrs2 && endMins1 >= startMins2) return true;\\n            else return false;\\n        }\\n        else {\\n            if(endHrs2 > startHrs1) return true;\\n            else if(endHrs2 == startHrs1 && endMins2 >= startMins1) return true;\\n            else return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859979,
                "title": "beginner-python-easy-o-1-98-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nConvert time strings to integer and check for overlaps. \\nIf there are overlaps then return True.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nEnd of early event should be smaller than start of later event to  prevent overlapping.\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        \\n       e10= int(event1[0][0] + event1[0][1] + event1[0][3] + event1[0][4])\\n\\n       e11= int(event1[1][0] + event1[1][1] + event1[1][3] + event1[1][4])\\n\\n       e20= int(event2[0][0] + event2[0][1] + event2[0][3] + event2[0][4])\\n\\n       e21= int(event2[1][0] + event2[1][1]+ event2[1][3] + event2[1][4])\\n\\n\\n       if e10<e20:\\n\\n           if e11>=e20:\\n               return True\\n\\n       if e20<=e10:\\n           if e21>=e10:\\n               return True\\n\\n       return False                \\n\\n                  \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        \\n       e10= int(event1[0][0] + event1[0][1] + event1[0][3] + event1[0][4])\\n\\n       e11= int(event1[1][0] + event1[1][1] + event1[1][3] + event1[1][4])\\n\\n       e20= int(event2[0][0] + event2[0][1] + event2[0][3] + event2[0][4])\\n\\n       e21= int(event2[1][0] + event2[1][1]+ event2[1][3] + event2[1][4])\\n\\n\\n       if e10<e20:\\n\\n           if e11>=e20:\\n               return True\\n\\n       if e20<=e10:\\n           if e21>=e10:\\n               return True\\n\\n       return False                \\n\\n                  \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839561,
                "title": "easy-intuitive-python-solution",
                "content": "\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5bdcaf5d-6f92-487f-90e8-2a179145f136_1690739123.713907.png)\\n\\n\\n# Intuition\\nThe first thought I had was that it is basically hard to deal with str numbers, which include a semicolumn in the middle. Hence, I replaced the semicolumns with points in order to later transform the numbers into the float format. HOWEVER, it appears that it works even without changing the nums\\' format because the semicolumn is at the same place in both numbers.\\n\\n# Approach\\n1.) The first event intersepts with the other if the starting point of the first event is between the starting and ending points of the second event, including both of them in the inequality.\\n\\n2.) The same is with the ending point. Copypaste, add \\'or\\'.\\n\\n3.) However the first event might be beyond boundaries, as it starts before the second and ends after. Therefore, we do the same thing we did before in point 1 and point 2, just switching the events\\' names.\\n\\n>\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return  event1[1] >= event2[0] >= event1[0] or event1[1] >= event2[1] >= event1[0] or  event2[1] >= event1[0] >= event2[0] or event2[1] >= event1[1] >= event2[0]\\n\\n```\\n\\n# *Hope this will help.*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return  event1[1] >= event2[0] >= event1[0] or event1[1] >= event2[1] >= event1[0] or  event2[1] >= event1[0] >= event2[0] or event2[1] >= event1[1] >= event2[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832546,
                "title": "convert-to-minutes-and-compare",
                "content": "# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        def minutes(time):\\n            return int(time[:2]) * 60 + int(time[-2:])\\n            \\n        return not (minutes(event1[0]) > minutes(event2[1])\\n                    or minutes(event2[0]) > minutes(event1[1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        def minutes(time):\\n            return int(time[:2]) * 60 + int(time[-2:])\\n            \\n        return not (minutes(event1[0]) > minutes(event2[1])\\n                    or minutes(event2[0]) > minutes(event1[1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831073,
                "title": "swift-one-liner-using-ranges-and-overlaps",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func haveConflict(_ event1: [String], _ event2: [String]) -> Bool {\\n        (event1[0]...event1[1]).overlaps(event2[0]...event2[1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func haveConflict(_ event1: [String], _ event2: [String]) -> Bool {\\n        (event1[0]...event1[1]).overlaps(event2[0]...event2[1])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829287,
                "title": "determine-if-two-events-have-conflict",
                "content": "# Intuition\\nThe startTime of the event1 must be inferior or equal to the endTime of the event2\\nThe endTime of the event1 must be superior or equal to the startTime of the event2\\n\\n# Approach\\nComparing endTime and startTime in minutes\\n\\n\\n# Code\\n```\\nbool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool haveConflict(char ** event1, int event1Size, char ** event2, int event2Size){\\n    //First retrieve the hour\\n    char *evt1 = strtok(event1[0], \":\");\\n    //Convert it in minutes\\n    int et1 = atoi(evt1) * 60;\\n    //Then retrieve the minutes\\n    evt1 = strtok(NULL, \":\"); \\n    //Add it up\\n    et1 = et1 + atoi(evt1);\\n    // So on for every startTime and endTime\\n    char *evt11 = strtok(event1[1], \":\");\\n    int et11 = atoi(evt11) * 60; evt11 = strtok(NULL, \":\");\\n    et11 = et11 + atoi(evt11);\\n    char *evt2 = strtok(event2[0], \":\");\\n    int et2 = atoi(evt2) * 60;\\n    evt2 = strtok(NULL, \":\");\\n    et2 = et2 + atoi(evt2);\\n    char *evt22 = strtok(event2[1], \":\");\\n    int et22 = atoi(evt22) * 60;\\n    evt22 = strtok(NULL, \":\");\\n    et22 = et22 + atoi(evt22);\\n    if ((et11 >= et2) && (et1 <= et22)){\\n        return true;\\n    }else{\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821231,
                "title": "python",
                "content": "# Approach\\n1. \\u0421\\u043E\\u0437\\u0434\\u0430\\u0435\\u043C \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0435 \\u0434\\u043B\\u044F \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u0438 \\u043A\\u043E\\u043D\\u0446\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u0438\\u0437 \\u0441\\u043E\\u0431\\u044B\\u0442\\u0438\\u0439, \\u043F\\u0435\\u0440\\u0435\\u0432\\u043E\\u0434\\u0438\\u043C\\n\\u0441\\u0442\\u0440\\u043E\\u043A\\u0443 \\u0432 float.\\n2. \\u0421\\u0440\\u0430\\u0432\\u043D\\u0438\\u0432\\u0430\\u0435\\u043C \\u044D\\u0442\\u0438 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0435, \\u0434\\u043B\\u044F \\u043D\\u0430\\u0445\\u043E\\u0436\\u0434\\u0435\\u043D\\u0438\\u044F \\u043F\\u0435\\u0440\\u0435\\u0441\\u0435\\u0447\\u0435\\u043D\\u0438\\u0439 \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u0438.\\n3. \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u043C \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        ev1_start = float(event1[0][:2] + \\'.\\' + event1[0][3:])\\n        ev1_end = float(event1[1][:2] + \\'.\\' + event1[1][3:])\\n        ev2_start = float(event2[0][:2] + \\'.\\' + event2[0][3:])\\n        ev2_end = float(event2[1][:2] + \\'.\\' + event2[1][3:])\\n        if (ev2_start > ev1_start and ev2_start <= ev1_end) or (ev2_start <= ev1_start and ev2_end >= ev1_start):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        ev1_start = float(event1[0][:2] + \\'.\\' + event1[0][3:])\\n        ev1_end = float(event1[1][:2] + \\'.\\' + event1[1][3:])\\n        ev2_start = float(event2[0][:2] + \\'.\\' + event2[0][3:])\\n        ev2_end = float(event2[1][:2] + \\'.\\' + event2[1][3:])\\n        if (ev2_start > ev1_start and ev2_start <= ev1_end) or (ev2_start <= ev1_start and ev2_end >= ev1_start):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819712,
                "title": "java-easy-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n\\n      int e10=Integer.parseInt(e1[0].replace(\":\",\"\"));\\n      int e11=Integer.parseInt(e1[1].replace(\":\",\"\"));\\n      int e20=Integer.parseInt(e2[0].replace(\":\",\"\"));\\n      int e21=Integer.parseInt(e2[1].replace(\":\",\"\"));\\n      \\n      \\n      if(e21<e10) return false;\\n      if(e20<=e11) return true;\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] e1, String[] e2) {\\n\\n      int e10=Integer.parseInt(e1[0].replace(\":\",\"\"));\\n      int e11=Integer.parseInt(e1[1].replace(\":\",\"\"));\\n      int e20=Integer.parseInt(e2[0].replace(\":\",\"\"));\\n      int e21=Integer.parseInt(e2[1].replace(\":\",\"\"));\\n      \\n      \\n      if(e21<e10) return false;\\n      if(e20<=e11) return true;\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817745,
                "title": "python-simple-solution-string-comparison",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n    if event1[1] == event2[0] or event1[0] == event2[1]:\\n      return True\\n    elif event1[1] < event2[0]:\\n      return event1[0] > event2[1]\\n    return event1[0] < event2[1]\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n  def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n    if event1[1] == event2[0] or event1[0] == event2[1]:\\n      return True\\n    elif event1[1] < event2[0]:\\n      return event1[0] > event2[1]\\n    return event1[0] < event2[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814883,
                "title": "python-simple-logic-42ms",
                "content": "# Intuition\\nThink of joining strings.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust split the time and compare by converting into integers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        s = event1[1].split(\\':\\')\\n        s = int(\\'\\'.join(s))\\n        a = event2[0].split(\\':\\')\\n        a = int(\\'\\'.join(a))\\n        b = event1[0].split(\\':\\')\\n        b = int(\\'\\'.join(b))\\n        c = event2[1].split(\\':\\')\\n        c = int(\\'\\'.join(c))\\n        if a in range(b, s + 1):\\n            return 1\\n        if c in range(b, s + 1):\\n            return 1\\n        if s in range(a, c + 1):\\n            return 1\\n        if b in range(a, c + 1):\\n            return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        s = event1[1].split(\\':\\')\\n        s = int(\\'\\'.join(s))\\n        a = event2[0].split(\\':\\')\\n        a = int(\\'\\'.join(a))\\n        b = event1[0].split(\\':\\')\\n        b = int(\\'\\'.join(b))\\n        c = event2[1].split(\\':\\')\\n        c = int(\\'\\'.join(c))\\n        if a in range(b, s + 1):\\n            return 1\\n        if c in range(b, s + 1):\\n            return 1\\n        if s in range(a, c + 1):\\n            return 1\\n        if b in range(a, c + 1):\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810994,
                "title": "easy-python-solution-with-explanation-and-approach",
                "content": "# Intuition\\nFind the conditions for which we\\'ll find no intersections.\\nThese conditions are:\\n1. If event1 starts earlier than event2, then it should finish before the start of event2.\\n2. If event2 starts earlier than event1, then it should finish before the start of event1.\\n\\n**For the above conditions 1&2 we\\'ll have no intersections, hence we\\'ll return false and for any other conditions, events will intersect, hence we\\'ll return true.**\\n\\n# Approach\\n\\nJust use if else statements for the above intuition.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution(object):\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \\n        if event1[0] < event2[0]: \\n            \\n            if event1[1] < event2[0]:\\n                return False\\n            \\n            else:\\n                return True\\n\\n        else:\\n            if event1[0] > event2[1]:\\n                return False\\n            else:\\n                return True\\n            \\n      \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def haveConflict(self, event1, event2):\\n        \"\"\"\\n        :type event1: List[str]\\n        :type event2: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        \\n        if event1[0] < event2[0]: \\n            \\n            if event1[1] < event2[0]:\\n                return False\\n            \\n            else:\\n                return True\\n\\n        else:\\n            if event1[0] > event2[1]:\\n                return False\\n            else:\\n                return True\\n            \\n      \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809145,
                "title": "no-coding-question-but-just-so-logical",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n               \\n       if((event2[0]>=event1[0] && event2[0]<=event1[1]) \\n          || (event1[0]>=event2[0] && event1[0]<=event2[1])){\\n           return true;\\n       }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n               \\n       if((event2[0]>=event1[0] && event2[0]<=event1[1]) \\n          || (event1[0]>=event2[0] && event1[0]<=event2[1])){\\n           return true;\\n       }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807918,
                "title": "event-conflict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        time_1 = []\\n        time_2 = []\\n        for  time in event1:\\n            times = time.split(\":\")\\n            times = int(\\'\\'.join(times))\\n            time_1.append(times)\\n        for  time in event2:\\n            times = time.split(\":\")\\n            times = int(\\'\\'.join(times))\\n            time_2.append(times)\\n        \\n        \\n        if time_2[0] >= time_1[0] and time_2[0] <= time_1[1]:\\n            return True\\n        elif time_2[1] >= time_1[0] and time_2[1] <= time_1[1]:\\n            return True\\n        elif time_2[0] < time_1[0] and time_2[1] > time_1[1]: #\\n            return True\\n        else:\\n            return False\\n\\n        del time_1,time_2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        time_1 = []\\n        time_2 = []\\n        for  time in event1:\\n            times = time.split(\":\")\\n            times = int(\\'\\'.join(times))\\n            time_1.append(times)\\n        for  time in event2:\\n            times = time.split(\":\")\\n            times = int(\\'\\'.join(times))\\n            time_2.append(times)\\n        \\n        \\n        if time_2[0] >= time_1[0] and time_2[0] <= time_1[1]:\\n            return True\\n        elif time_2[1] >= time_1[0] and time_2[1] <= time_1[1]:\\n            return True\\n        elif time_2[0] < time_1[0] and time_2[1] > time_1[1]: #\\n            return True\\n        else:\\n            return False\\n\\n        del time_1,time_2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803135,
                "title": "java-100-hardcore-solution-no-compare-and-integer-parseint",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] time1, String[] time2) {\\n        int time11 = proccesTime(time1[0]);\\n        int time12 = proccesTime(time1[1]);\\n        int time21 = proccesTime(time2[0]);\\n        int time22 = proccesTime(time2[1]);\\n\\n        return time11 < time21 ? time12 >= time21 : time22 >= time11;\\n\\n    }\\n\\n    private int proccesTime(String time) {\\n        int result = 0;\\n        result += time.charAt(0) - \\'0\\';\\n        result = result * 10 + time.charAt(1) - \\'0\\';\\n        result = result * 10 + time.charAt(3) - \\'0\\';\\n        result = result * 10 + time.charAt(4) - \\'0\\';\\n        return result;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] time1, String[] time2) {\\n        int time11 = proccesTime(time1[0]);\\n        int time12 = proccesTime(time1[1]);\\n        int time21 = proccesTime(time2[0]);\\n        int time22 = proccesTime(time2[1]);\\n\\n        return time11 < time21 ? time12 >= time21 : time22 >= time11;\\n\\n    }\\n\\n    private int proccesTime(String time) {\\n        int result = 0;\\n        result += time.charAt(0) - \\'0\\';\\n        result = result * 10 + time.charAt(1) - \\'0\\';\\n        result = result * 10 + time.charAt(3) - \\'0\\';\\n        result = result * 10 + time.charAt(4) - \\'0\\';\\n        return result;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802318,
                "title": "pls-don-t-curse",
                "content": "# I came up with my own approach, this might not be the best one so please don\\'t curse me if it\\'s not good.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        vector<int> e1,e2;\\n\\n        for(auto i:event1)\\n        {\\n            string temp = i.substr(0,2)+i.substr(3,2);\\n            int time = stoi(temp);\\n\\n            e1.push_back(time);\\n        }\\n\\n        for(auto i:event2)\\n        {\\n            string temp = i.substr(0,2)+i.substr(3,2);\\n            int time = stoi(temp);\\n\\n            e2.push_back(time);\\n        }\\n\\n        int cs,ce,ns,ne;\\n        //cs ->current_start\\n        //ce ->current_end\\n        //ns ->next_start\\n        //ne ->next_end\\n\\n        if(e1[0] <= e2[0])\\n        {\\n            cs = e1[0];\\n            ce = e1[1];\\n            ns = e2[0];\\n            ne = e2[1];\\n        }\\n        else{\\n            cs = e2[0];\\n            ce = e2[1];\\n            ns = e1[0];\\n            ne = e1[1];\\n        }\\n\\n        if(ns<=ce)\\n            return true;\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return false;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/5c5dca4c-ebf2-4dc1-a59b-21f9b876ddef_1690048886.6761012.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        vector<int> e1,e2;\\n\\n        for(auto i:event1)\\n        {\\n            string temp = i.substr(0,2)+i.substr(3,2);\\n            int time = stoi(temp);\\n\\n            e1.push_back(time);\\n        }\\n\\n        for(auto i:event2)\\n        {\\n            string temp = i.substr(0,2)+i.substr(3,2);\\n            int time = stoi(temp);\\n\\n            e2.push_back(time);\\n        }\\n\\n        int cs,ce,ns,ne;\\n        //cs ->current_start\\n        //ce ->current_end\\n        //ns ->next_start\\n        //ne ->next_end\\n\\n        if(e1[0] <= e2[0])\\n        {\\n            cs = e1[0];\\n            ce = e1[1];\\n            ns = e2[0];\\n            ne = e2[1];\\n        }\\n        else{\\n            cs = e2[0];\\n            ce = e2[1];\\n            ns = e1[0];\\n            ne = e1[1];\\n        }\\n\\n        if(ns<=ce)\\n            return true;\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798722,
                "title": "line-sweep-algorithm-using-map",
                "content": "# Intuition\\nConvert string to time in mins then applay line sweep, if sum ever goes more than one that means there is conflict;\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) {constant map space used}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int toMins(string& t)\\n    {\\n        int h = (t[0]-\\'0\\')*10 + (t[1]-\\'0\\');\\n        int m = (t[3]-\\'0\\')*10 + (t[4]-\\'0\\');\\n\\n        return h*60 + m;\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        pair<int, int> e1 = {toMins(event1[0]), toMins(event1[1])}; \\n        pair<int, int> e2 = {toMins(event2[0]), toMins(event2[1])}; \\n\\n        map<int, int> mp;\\n        mp[e1.first] += 1;\\n        mp[e1.second + 1] -= 1;\\n        mp[e2.first] += 1;\\n        mp[e2.second + 1] -= 1;\\n\\n\\n        int sum = 0;\\n        for(auto it : mp)\\n        {\\n            sum += it.second;\\n            if(sum > 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int toMins(string& t)\\n    {\\n        int h = (t[0]-\\'0\\')*10 + (t[1]-\\'0\\');\\n        int m = (t[3]-\\'0\\')*10 + (t[4]-\\'0\\');\\n\\n        return h*60 + m;\\n    }\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        pair<int, int> e1 = {toMins(event1[0]), toMins(event1[1])}; \\n        pair<int, int> e2 = {toMins(event2[0]), toMins(event2[1])}; \\n\\n        map<int, int> mp;\\n        mp[e1.first] += 1;\\n        mp[e1.second + 1] -= 1;\\n        mp[e2.first] += 1;\\n        mp[e2.second + 1] -= 1;\\n\\n\\n        int sum = 0;\\n        for(auto it : mp)\\n        {\\n            sum += it.second;\\n            if(sum > 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796823,
                "title": "one-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>&e1 , vector<string>&e2){\\n        return (e1[0]<=e2[0] && e2[0]<=e1[1]) || (e2[0]<=e1[0] && e1[0]<=e2[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>&e1 , vector<string>&e2){\\n        return (e1[0]<=e2[0] && e2[0]<=e1[1]) || (e2[0]<=e1[0] && e1[0]<=e2[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791637,
                "title": "c-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) {\\n        var event1StartArr = event1[0].Split(\\':\\');\\n        var event2StartArr = event2[0].Split(\\':\\');\\n        var event1EndArr = event1[1].Split(\\':\\');\\n        var event2EndArr = event2[1].Split(\\':\\');\\n\\n        int startHour1 = Convert.ToInt32(event1StartArr[0]);\\n        int startMin1 = startHour1*60 + Convert.ToInt32(event1StartArr[1]);\\n        int startHour2 = Convert.ToInt32(event2StartArr[0]);\\n        int startMin2 = startHour2*60 + Convert.ToInt32(event2StartArr[1]);\\n\\n        int endHour1 = Convert.ToInt32(event1EndArr[0]);\\n        int endMin1 = endHour1*60 + Convert.ToInt32(event1EndArr[1]);\\n        int endHour2 = Convert.ToInt32(event2EndArr[0]);\\n        int endMin2 = endHour2*60 + Convert.ToInt32(event2EndArr[1]);\\n\\n        return !(endMin1 < startMin2 || startMin1 > endMin2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) {\\n        var event1StartArr = event1[0].Split(\\':\\');\\n        var event2StartArr = event2[0].Split(\\':\\');\\n        var event1EndArr = event1[1].Split(\\':\\');\\n        var event2EndArr = event2[1].Split(\\':\\');\\n\\n        int startHour1 = Convert.ToInt32(event1StartArr[0]);\\n        int startMin1 = startHour1*60 + Convert.ToInt32(event1StartArr[1]);\\n        int startHour2 = Convert.ToInt32(event2StartArr[0]);\\n        int startMin2 = startHour2*60 + Convert.ToInt32(event2StartArr[1]);\\n\\n        int endHour1 = Convert.ToInt32(event1EndArr[0]);\\n        int endMin1 = endHour1*60 + Convert.ToInt32(event1EndArr[1]);\\n        int endHour2 = Convert.ToInt32(event2EndArr[0]);\\n        int endMin2 = endHour2*60 + Convert.ToInt32(event2EndArr[1]);\\n\\n        return !(endMin1 < startMin2 || startMin1 > endMin2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790397,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        string curr_1 = event1[0];\\n        string end_1 = event1[1];\\n        \\n        string curr_2 = event2[0];\\n        string end_2 = event2[1];\\n        \\n        \\n        if(end_1 >= curr_2 && curr_1 <= end_2) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        string curr_1 = event1[0];\\n        string end_1 = event1[1];\\n        \\n        string curr_2 = event2[0];\\n        string end_2 = event2[1];\\n        \\n        \\n        if(end_1 >= curr_2 && curr_1 <= end_2) {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3790285,
                "title": "simple-conditonal-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    Dictionary<char, int> lookup;\\n    public bool HaveConflict(string[] event1, string[] event2)\\n    {\\n        int start = 0, end = 1;\\n        lookup = new Dictionary<char, int>();\\n        lookup.Add(\\'0\\', 0);\\n        lookup.Add(\\'1\\', 1);\\n        lookup.Add(\\'2\\', 2);\\n        lookup.Add(\\'3\\', 3);\\n        lookup.Add(\\'4\\', 4);\\n        lookup.Add(\\'5\\', 5);\\n        lookup.Add(\\'6\\', 6);\\n        lookup.Add(\\'7\\', 7);\\n        lookup.Add(\\'8\\', 8);\\n        lookup.Add(\\'9\\', 9);\\n\\n        List<int> eventList = new List<int>();\\n        foreach (string e in event1)\\n        {\\n            int ev = 0;\\n            ev = ev *10 + lookup[e[0]];\\n            ev = ev * 10 + lookup[e[1]];\\n            ev = ev * 10 + lookup[e[3]];\\n            ev = ev * 10 + lookup[e[4]];\\n            eventList.Add(ev);\\n        }\\n\\n        int[] event1Arr = eventList.ToArray();\\n\\n        eventList = new List<int>();\\n        foreach (string e in event2)\\n        {\\n            int ev = 0;\\n            ev = ev * 10 + lookup[e[0]];\\n            ev = ev * 10 + lookup[e[1]];\\n            ev = ev * 10 + lookup[e[3]];\\n            ev = ev * 10 + lookup[e[4]];\\n            eventList.Add(ev);\\n        }\\n        int[] event2Arr = eventList.ToArray();\\n\\n        if ((event2Arr[start] <= event1Arr[start] && event1Arr[start] <= event2Arr[end]) || (event2Arr[start] <= event1Arr[end] && event1Arr[end] <= event2Arr[end]))\\n            return true;\\n\\n        if ((event1Arr[start] <= event2Arr[start] && event2Arr[start] <= event1Arr[end]) || (event1Arr[start] <= event2Arr[end] && event2Arr[end] <= event1Arr[end]))\\n            return true;\\n\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution\\n{\\n    Dictionary<char, int> lookup;\\n    public bool HaveConflict(string[] event1, string[] event2)\\n    {\\n        int start = 0, end = 1;\\n        lookup = new Dictionary<char, int>();\\n        lookup.Add(\\'0\\', 0);\\n        lookup.Add(\\'1\\', 1);\\n        lookup.Add(\\'2\\', 2);\\n        lookup.Add(\\'3\\', 3);\\n        lookup.Add(\\'4\\', 4);\\n        lookup.Add(\\'5\\', 5);\\n        lookup.Add(\\'6\\', 6);\\n        lookup.Add(\\'7\\', 7);\\n        lookup.Add(\\'8\\', 8);\\n        lookup.Add(\\'9\\', 9);\\n\\n        List<int> eventList = new List<int>();\\n        foreach (string e in event1)\\n        {\\n            int ev = 0;\\n            ev = ev *10 + lookup[e[0]];\\n            ev = ev * 10 + lookup[e[1]];\\n            ev = ev * 10 + lookup[e[3]];\\n            ev = ev * 10 + lookup[e[4]];\\n            eventList.Add(ev);\\n        }\\n\\n        int[] event1Arr = eventList.ToArray();\\n\\n        eventList = new List<int>();\\n        foreach (string e in event2)\\n        {\\n            int ev = 0;\\n            ev = ev * 10 + lookup[e[0]];\\n            ev = ev * 10 + lookup[e[1]];\\n            ev = ev * 10 + lookup[e[3]];\\n            ev = ev * 10 + lookup[e[4]];\\n            eventList.Add(ev);\\n        }\\n        int[] event2Arr = eventList.ToArray();\\n\\n        if ((event2Arr[start] <= event1Arr[start] && event1Arr[start] <= event2Arr[end]) || (event2Arr[start] <= event1Arr[end] && event1Arr[end] <= event2Arr[end]))\\n            return true;\\n\\n        if ((event1Arr[start] <= event2Arr[start] && event2Arr[start] <= event1Arr[end]) || (event1Arr[start] <= event2Arr[end] && event2Arr[end] <= event1Arr[end]))\\n            return true;\\n\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789884,
                "title": "easy-100-time-100-mem-efficient-direct-string-cmp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[0]>event2[0]) swap(event1,event2);\\n        return event1[1]>=event2[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[0]>event2[0]) swap(event1,event2);\\n        return event1[1]>=event2[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789545,
                "title": "simple-and-straight-forward-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n\\n        //parse time to int.\\n\\n        int ev1begin=1000*(static_cast<int>(event1[0][0])-48)\\n                    + 100*(static_cast<int>(event1[0][1])-48)\\n                    +  10*(static_cast<int>(event1[0][3])-48)\\n                    +  (static_cast<int>(event1[0][4])-48);\\n        \\n        int ev1end=1000*(static_cast<int>(event1[1][0])-48)\\n                    + 100*(static_cast<int>(event1[1][1])-48)\\n                    +  10*(static_cast<int>(event1[1][3])-48)\\n                    +  (static_cast<int>(event1[1][4])-48);\\n\\n        int ev2begin=1000*(static_cast<int>(event2[0][0])-48)\\n                    + 100*(static_cast<int>(event2[0][1])-48)\\n                    +  10*(static_cast<int>(event2[0][3])-48)\\n                    +  (static_cast<int>(event2[0][4])-48);\\n\\n        int ev2end= 1000*(static_cast<int>(event2[1][0])-48)\\n                    + 100*(static_cast<int>(event2[1][1])-48)\\n                    +  10*(static_cast<int>(event2[1][3])-48)\\n                    +  (static_cast<int>(event2[1][4])-48);\\n\\n\\n        if (ev2begin <= ev1end && ev2begin > ev1begin)return true;\\n        if (ev2begin <= ev1end && ev2end >= ev1begin) return true; \\n\\n\\n        return false; \\n                     \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n\\n        //parse time to int.\\n\\n        int ev1begin=1000*(static_cast<int>(event1[0][0])-48)\\n                    + 100*(static_cast<int>(event1[0][1])-48)\\n                    +  10*(static_cast<int>(event1[0][3])-48)\\n                    +  (static_cast<int>(event1[0][4])-48);\\n        \\n        int ev1end=1000*(static_cast<int>(event1[1][0])-48)\\n                    + 100*(static_cast<int>(event1[1][1])-48)\\n                    +  10*(static_cast<int>(event1[1][3])-48)\\n                    +  (static_cast<int>(event1[1][4])-48);\\n\\n        int ev2begin=1000*(static_cast<int>(event2[0][0])-48)\\n                    + 100*(static_cast<int>(event2[0][1])-48)\\n                    +  10*(static_cast<int>(event2[0][3])-48)\\n                    +  (static_cast<int>(event2[0][4])-48);\\n\\n        int ev2end= 1000*(static_cast<int>(event2[1][0])-48)\\n                    + 100*(static_cast<int>(event2[1][1])-48)\\n                    +  10*(static_cast<int>(event2[1][3])-48)\\n                    +  (static_cast<int>(event2[1][4])-48);\\n\\n\\n        if (ev2begin <= ev1end && ev2begin > ev1begin)return true;\\n        if (ev2begin <= ev1end && ev2end >= ev1begin) return true; \\n\\n\\n        return false; \\n                     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789479,
                "title": "simple-string-comparison-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       string temp3 = event1[0];\\n       int hours = (temp3[0]-\\'0\\')*10 + (temp3[1]-\\'0\\');\\n       int minutes = (temp3[3]-\\'0\\')*10 + (temp3[4]-\\'0\\');\\n       int starttime1 = hours*60+minutes;\\n\\n       string temp = event1[1];\\n       hours = (temp[0]-\\'0\\')*10 + (temp[1]-\\'0\\');\\n       minutes = (temp[3]-\\'0\\')*10 + (temp[4]-\\'0\\');\\n       int endtime1 = hours*60+minutes;\\n       \\n       string temp2 = event2[0];\\n       int hours2 = (temp2[0]-\\'0\\')*10 + (temp2[1]-\\'0\\');\\n       int minutes2 = (temp2[3]-\\'0\\')*10 + (temp2[4]-\\'0\\');\\n       int starttime2 = hours2*60+minutes2;\\n\\n       string temp4 = event2[1];\\n        hours = (temp4[0]-\\'0\\')*10 + (temp4[1]-\\'0\\');\\n       minutes = (temp4[3]-\\'0\\')*10 + (temp4[4]-\\'0\\');\\n       int endtime2 = hours*60+minutes;\\n\\n       if(starttime1<=starttime2 && endtime1>=starttime2 ||\\n       starttime2<=starttime1 && endtime2>=starttime1)\\n       return true;\\n       return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       string temp3 = event1[0];\\n       int hours = (temp3[0]-\\'0\\')*10 + (temp3[1]-\\'0\\');\\n       int minutes = (temp3[3]-\\'0\\')*10 + (temp3[4]-\\'0\\');\\n       int starttime1 = hours*60+minutes;\\n\\n       string temp = event1[1];\\n       hours = (temp[0]-\\'0\\')*10 + (temp[1]-\\'0\\');\\n       minutes = (temp[3]-\\'0\\')*10 + (temp[4]-\\'0\\');\\n       int endtime1 = hours*60+minutes;\\n       \\n       string temp2 = event2[0];\\n       int hours2 = (temp2[0]-\\'0\\')*10 + (temp2[1]-\\'0\\');\\n       int minutes2 = (temp2[3]-\\'0\\')*10 + (temp2[4]-\\'0\\');\\n       int starttime2 = hours2*60+minutes2;\\n\\n       string temp4 = event2[1];\\n        hours = (temp4[0]-\\'0\\')*10 + (temp4[1]-\\'0\\');\\n       minutes = (temp4[3]-\\'0\\')*10 + (temp4[4]-\\'0\\');\\n       int endtime2 = hours*60+minutes;\\n\\n       if(starttime1<=starttime2 && endtime1>=starttime2 ||\\n       starttime2<=starttime1 && endtime2>=starttime1)\\n       return true;\\n       return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789477,
                "title": "simple-string-comparison-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       string temp3 = event1[0];\\n       int hours = (temp3[0]-\\'0\\')*10 + (temp3[1]-\\'0\\');\\n       int minutes = (temp3[3]-\\'0\\')*10 + (temp3[4]-\\'0\\');\\n       int starttime1 = hours*60+minutes;\\n\\n       string temp = event1[1];\\n       hours = (temp[0]-\\'0\\')*10 + (temp[1]-\\'0\\');\\n       minutes = (temp[3]-\\'0\\')*10 + (temp[4]-\\'0\\');\\n       int endtime1 = hours*60+minutes;\\n       \\n       string temp2 = event2[0];\\n       int hours2 = (temp2[0]-\\'0\\')*10 + (temp2[1]-\\'0\\');\\n       int minutes2 = (temp2[3]-\\'0\\')*10 + (temp2[4]-\\'0\\');\\n       int starttime2 = hours2*60+minutes2;\\n\\n       string temp4 = event2[1];\\n        hours = (temp4[0]-\\'0\\')*10 + (temp4[1]-\\'0\\');\\n       minutes = (temp4[3]-\\'0\\')*10 + (temp4[4]-\\'0\\');\\n       int endtime2 = hours*60+minutes;\\n\\n       if(starttime1<=starttime2 && endtime1>=starttime2 ||\\n       starttime2<=starttime1 && endtime2>=starttime1)\\n       return true;\\n       return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n       string temp3 = event1[0];\\n       int hours = (temp3[0]-\\'0\\')*10 + (temp3[1]-\\'0\\');\\n       int minutes = (temp3[3]-\\'0\\')*10 + (temp3[4]-\\'0\\');\\n       int starttime1 = hours*60+minutes;\\n\\n       string temp = event1[1];\\n       hours = (temp[0]-\\'0\\')*10 + (temp[1]-\\'0\\');\\n       minutes = (temp[3]-\\'0\\')*10 + (temp[4]-\\'0\\');\\n       int endtime1 = hours*60+minutes;\\n       \\n       string temp2 = event2[0];\\n       int hours2 = (temp2[0]-\\'0\\')*10 + (temp2[1]-\\'0\\');\\n       int minutes2 = (temp2[3]-\\'0\\')*10 + (temp2[4]-\\'0\\');\\n       int starttime2 = hours2*60+minutes2;\\n\\n       string temp4 = event2[1];\\n        hours = (temp4[0]-\\'0\\')*10 + (temp4[1]-\\'0\\');\\n       minutes = (temp4[3]-\\'0\\')*10 + (temp4[4]-\\'0\\');\\n       int endtime2 = hours*60+minutes;\\n\\n       if(starttime1<=starttime2 && endtime1>=starttime2 ||\\n       starttime2<=starttime1 && endtime2>=starttime1)\\n       return true;\\n       return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789423,
                "title": "simple-cpp-one-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        //if start of event 1 is greater than end of event 2 or \\n        //start of event 2 is greater than end of event 1 we will return false because there will no any overlapping.\\n        return (event1[0] > event2[1]) || (event1[1] < event2[0]) ?  false:true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        //if start of event 1 is greater than end of event 2 or \\n        //start of event 2 is greater than end of event 1 we will return false because there will no any overlapping.\\n        return (event1[0] > event2[1]) || (event1[1] < event2[0]) ?  false:true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788503,
                "title": "simple-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def convert(event):\\n            start = event[0]\\n            end = event[1]\\n            return [int(start[:2] + start[3:]), int(end[:2] + end[3:])]\\n        time1 = convert(event1)\\n        time2 = convert(event2)\\n        if time1[0] <= time2[0] <= time1[1] or time2[0] <= time1[0] <= time2[1]:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def convert(event):\\n            start = event[0]\\n            end = event[1]\\n            return [int(start[:2] + start[3:]), int(end[:2] + end[3:])]\\n        time1 = convert(event1)\\n        time2 = convert(event2)\\n        if time1[0] <= time2[0] <= time1[1] or time2[0] <= time1[0] <= time2[1]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788038,
                "title": "java-split-and-merge",
                "content": "# Intuition\\nSplit the timestamp by \":\" and then merge the parts to make it a numeric string. After that it becomes easy to parse it to integer and compare.\\n\\n# Approach\\n1. There is an overlap between two intervals if minimum of the end times is more than or equal to the maximum of the start times.\\n2. We write a function to split the timestamp by \\':\\' and then join the parts.\\n3. Then calculate the minimum of the end times of the intervals and maximum of the start times of the intervals. \\n4. Return if the minimum of the end times is more than or equal to the maximum of the start times.\\n\\n# Complexity\\n- Time complexity:\\nO(c) since the input is just two arguments.\\n\\n- Space complexity:\\nO(c) since no additional data structures are used.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int [] e1 = new int[2], e2 = new int[2];\\n        return overlap(event1, event2);\\n    }\\n\\n    private boolean overlap(String [] first, String [] second) {\\n        int min_end = Math.min(Integer.parseInt(splitAndMerge(first[1])), \\n            Integer.parseInt(splitAndMerge(second[1])));\\n        int max_start = Math.max(Integer.parseInt(splitAndMerge(first[0])), \\n            Integer.parseInt(splitAndMerge(second[0])));\\n        return max_start <= min_end;\\n    }\\n\\n    private String splitAndMerge(String time) {\\n        String [] part = time.split(\":\");\\n        StringBuilder split = new StringBuilder();\\n        split.append(part[0]);\\n        split.append(part[1]);\\n        return split.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int [] e1 = new int[2], e2 = new int[2];\\n        return overlap(event1, event2);\\n    }\\n\\n    private boolean overlap(String [] first, String [] second) {\\n        int min_end = Math.min(Integer.parseInt(splitAndMerge(first[1])), \\n            Integer.parseInt(splitAndMerge(second[1])));\\n        int max_start = Math.max(Integer.parseInt(splitAndMerge(first[0])), \\n            Integer.parseInt(splitAndMerge(second[0])));\\n        return max_start <= min_end;\\n    }\\n\\n    private String splitAndMerge(String time) {\\n        String [] part = time.split(\":\");\\n        StringBuilder split = new StringBuilder();\\n        split.append(part[0]);\\n        split.append(part[1]);\\n        return split.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786643,
                "title": "c-one-linar-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n         return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n         return event1[1] >= event2[0] && event1[0] <= event2[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786414,
                "title": "c-easiest-soln-runtime-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/1982169f-9aba-4fa5-b46d-5410599e2033_1689749928.219483.png)\\n\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void stringInt(vector<string> event, int& st, int& ed)\\n    {\\n        string start = event[0];\\n        string end = event[1];\\n\\n        for(int i=0; i<start.length(); i++)\\n        {\\n            if(start[i]==\\':\\')   continue;\\n            else    st = st*10 + (int)(start[i]) - 48;\\n        }\\n        for(int i=0; i<end.length(); i++)\\n        {\\n            if(end[i]==\\':\\')   continue;\\n            else    ed = ed*10 + (int)(end[i]) - 48;\\n        }\\n    }\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        int st1=0, ed1=0;\\n        int st2=0, ed2=0;\\n        stringInt(event1,st1,ed1);\\n        stringInt(event2,st2,ed2);\\n\\n        return st1<=ed2 && ed1>=st2 ;\\n\\n        // another way to compare\\n        // event1[0]<=event2[1] && event1[1]>=event2[0];\\n        // if( st1<=st2 && st2<=ed1)\\n        //     return true;\\n        // else\\n        // {\\n        //     if( st2<=st1 && st1<=ed2 )\\n        //         return true;\\n        //     else\\n        //         return false;\\n        // }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void stringInt(vector<string> event, int& st, int& ed)\\n    {\\n        string start = event[0];\\n        string end = event[1];\\n\\n        for(int i=0; i<start.length(); i++)\\n        {\\n            if(start[i]==\\':\\')   continue;\\n            else    st = st*10 + (int)(start[i]) - 48;\\n        }\\n        for(int i=0; i<end.length(); i++)\\n        {\\n            if(end[i]==\\':\\')   continue;\\n            else    ed = ed*10 + (int)(end[i]) - 48;\\n        }\\n    }\\n\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        int st1=0, ed1=0;\\n        int st2=0, ed2=0;\\n        stringInt(event1,st1,ed1);\\n        stringInt(event2,st2,ed2);\\n\\n        return st1<=ed2 && ed1>=st2 ;\\n\\n        // another way to compare\\n        // event1[0]<=event2[1] && event1[1]>=event2[0];\\n        // if( st1<=st2 && st2<=ed1)\\n        //     return true;\\n        // else\\n        // {\\n        //     if( st2<=st1 && st1<=ed2 )\\n        //         return true;\\n        //     else\\n        //         return false;\\n        // }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786090,
                "title": "python-readable-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy initial thought is comparing hours and minutes seperately, but this would be complicated as I need to think on many scenarios, like hours are different, hours are the same but minutes are different, whould event happen first...\\n\\nThen I think maybe I can solve it by calculating the time range differeniating from \"00:00\", which is the start of a day. Therefore, the problem can be converted into a classical interval problem.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1, end1 = event1[0], event1[1]\\n        start2, end2 = event2[0], event2[1]\\n        t1 = [int(start1[:2]) * 60 + int(start1[3:]), int(end1[:2]) * 60 + int(end1[3:])]\\n        t2 = [int(start2[:2]) * 60 + int(start2[3:]), int(end2[:2]) * 60 + int(end2[3:])]\\n        if t1[0] > t2[0]:\\n            t1, t2 = t2, t1\\n        return t2[0] <= t1[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        start1, end1 = event1[0], event1[1]\\n        start2, end2 = event2[0], event2[1]\\n        t1 = [int(start1[:2]) * 60 + int(start1[3:]), int(end1[:2]) * 60 + int(end1[3:])]\\n        t2 = [int(start2[:2]) * 60 + int(start2[3:]), int(end2[:2]) * 60 + int(end2[3:])]\\n        if t1[0] > t2[0]:\\n            t1, t2 = t2, t1\\n        return t2[0] <= t1[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786081,
                "title": "python3-using-slicing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        i,j=1,0\\n        e1=int(event1[i][0:2]+event1[i][3:])\\n        e2=int(event2[j][0:2]+event2[j][3:])\\n        e3=int(event2[i][0:2]+event2[i][3:])\\n        e4=int(event1[j][0:2]+event1[j][3:])\\n        if e1>=e2 and e4<=e3:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        i,j=1,0\\n        e1=int(event1[i][0:2]+event1[i][3:])\\n        e2=int(event2[j][0:2]+event2[j][3:])\\n        e3=int(event2[i][0:2]+event2[i][3:])\\n        e4=int(event1[j][0:2]+event1[j][3:])\\n        if e1>=e2 and e4<=e3:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785271,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n\\n\\n      int startEventOneMinutes = toMinutes(event1[0]);\\n      int endEventOneMinutes = toMinutes(event1[1]);\\n\\n      int startEventTwoMinutes = toMinutes(event2[0]);\\n      int endEventTwoMinutes = toMinutes(event2[1]);\\n\\n      return intersects(startEventOneMinutes, endEventOneMinutes, startEventTwoMinutes, endEventTwoMinutes) || \\n             intersects(startEventTwoMinutes, endEventTwoMinutes, startEventOneMinutes, endEventOneMinutes);\\n    }\\n\\n    int toMinutes(String event) {\\n      int hours = event.charAt(0) == \\'0\\' ? Integer.valueOf(event.substring(1,2)) : Integer.valueOf(event.substring(0,2));\\n      int minutes = event.charAt(3) == \\'0\\' ? Integer.valueOf(event.substring(4)) : Integer.valueOf(event.substring(3));\\n      return hours * 60 +  minutes;\\n    }\\n\\n    boolean intersects(int startEventOneMinutes, int endEventOneMinutes, int startEventTwoMinutes, int endEventTwoMinutes) {\\n      boolean startIntersects = startEventOneMinutes >= startEventTwoMinutes && startEventOneMinutes <= endEventTwoMinutes;\\n      boolean endIntersects = endEventOneMinutes >= startEventTwoMinutes && endEventOneMinutes <= endEventTwoMinutes;\\n      return startIntersects || endIntersects;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n\\n\\n      int startEventOneMinutes = toMinutes(event1[0]);\\n      int endEventOneMinutes = toMinutes(event1[1]);\\n\\n      int startEventTwoMinutes = toMinutes(event2[0]);\\n      int endEventTwoMinutes = toMinutes(event2[1]);\\n\\n      return intersects(startEventOneMinutes, endEventOneMinutes, startEventTwoMinutes, endEventTwoMinutes) || \\n             intersects(startEventTwoMinutes, endEventTwoMinutes, startEventOneMinutes, endEventOneMinutes);\\n    }\\n\\n    int toMinutes(String event) {\\n      int hours = event.charAt(0) == \\'0\\' ? Integer.valueOf(event.substring(1,2)) : Integer.valueOf(event.substring(0,2));\\n      int minutes = event.charAt(3) == \\'0\\' ? Integer.valueOf(event.substring(4)) : Integer.valueOf(event.substring(3));\\n      return hours * 60 +  minutes;\\n    }\\n\\n    boolean intersects(int startEventOneMinutes, int endEventOneMinutes, int startEventTwoMinutes, int endEventTwoMinutes) {\\n      boolean startIntersects = startEventOneMinutes >= startEventTwoMinutes && startEventOneMinutes <= endEventTwoMinutes;\\n      boolean endIntersects = endEventOneMinutes >= startEventTwoMinutes && endEventOneMinutes <= endEventTwoMinutes;\\n      return startIntersects || endIntersects;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783910,
                "title": "intuitive-o-1-typescript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Convert time from \\'HH:MM\\' to minutes only \\n2. Check if any time intersect with the opposite ones;\\n\\n# Code\\n```\\nconst convertToMinutes = (time: string) => {\\n    const [hours, minutes] = time.split(\\':\\');\\n    return +hours * 60 + +minutes;\\n}\\n\\nfunction haveConflict(event1: string[], event2: string[]): boolean {\\n    const [startTime1, endTime1] = [convertToMinutes(event1[0]), convertToMinutes(event1[1])];\\n    const [startTime2, endTime2] = [convertToMinutes(event2[0]), convertToMinutes(event2[1])];\\n\\n    return (\\n    (startTime1 >= startTime2 && startTime1 <= endTime2)\\n    || (endTime1 >= startTime2 && endTime1 <= endTime2)\\n    || (startTime2 >= startTime1 && startTime2 <= endTime1)\\n    || (endTime2 >= startTime1 && endTime2 <= endTime1)\\n    );\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst convertToMinutes = (time: string) => {\\n    const [hours, minutes] = time.split(\\':\\');\\n    return +hours * 60 + +minutes;\\n}\\n\\nfunction haveConflict(event1: string[], event2: string[]): boolean {\\n    const [startTime1, endTime1] = [convertToMinutes(event1[0]), convertToMinutes(event1[1])];\\n    const [startTime2, endTime2] = [convertToMinutes(event2[0]), convertToMinutes(event2[1])];\\n\\n    return (\\n    (startTime1 >= startTime2 && startTime1 <= endTime2)\\n    || (endTime1 >= startTime2 && endTime1 <= endTime2)\\n    || (startTime2 >= startTime1 && startTime2 <= endTime1)\\n    || (endTime2 >= startTime1 && endTime2 <= endTime1)\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782511,
                "title": "java-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int f=Integer.parseInt(event1[0].substring(0,2))*60 + Integer.parseInt(event1[0].substring(3,5));\\n        int l=Integer.parseInt(event1[1].substring(0,2))*60 + Integer.parseInt(event1[1].substring(3,5));\\n\\n        int c= Integer.parseInt(event2[0].substring(0,2))*60 + Integer.parseInt(event2[0].substring(3,5));\\n        int c2=Integer.parseInt(event2[1].substring(0,2))*60 + Integer.parseInt(event2[1].substring(3,5));\\n        if( f <= c  && c <= l) return true ;\\n        if(c  < f && c2 >= f && c2 <= l) return true;\\n        if( c < f && c2 >= f && l <= c2) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int f=Integer.parseInt(event1[0].substring(0,2))*60 + Integer.parseInt(event1[0].substring(3,5));\\n        int l=Integer.parseInt(event1[1].substring(0,2))*60 + Integer.parseInt(event1[1].substring(3,5));\\n\\n        int c= Integer.parseInt(event2[0].substring(0,2))*60 + Integer.parseInt(event2[0].substring(3,5));\\n        int c2=Integer.parseInt(event2[1].substring(0,2))*60 + Integer.parseInt(event2[1].substring(3,5));\\n        if( f <= c  && c <= l) return true ;\\n        if(c  < f && c2 >= f && c2 <= l) return true;\\n        if( c < f && c2 >= f && l <= c2) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781467,
                "title": "beats-55-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo, basically firstly the strings are converted to integers (basically minutes). So that it gets easier for us to compare. \\n\\nThen imagine if we initialise the start as +1 and end as -1. then we can never get the sum > 1 if the events are not overlapping. So just check the sum. If it comes out to be greater than 1 then overlapping is happening and we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        string s1=event1[0];\\n        string s2=event1[1];\\n        string s3=event2[0];\\n        string s4=event2[1];\\n        int a=stoi(s1.substr(0,2))*60 + stoi(s1.substr(3,2));\\n        int b=stoi(s2.substr(0,2))*60 + stoi(s2.substr(3,2));\\n        int c=stoi(s3.substr(0,2))*60 + stoi(s3.substr(3,2));\\n        int d=stoi(s4.substr(0,2))*60 + stoi(s4.substr(3,2));\\n        map<int,int> mp;\\n        mp[a]++;\\n        mp[b]--;\\n        mp[c]++;\\n        mp[d]--;\\n        int sum=0;\\n        if(b==c || a==d)\\n            return true;\\n        for(auto it:mp)\\n        {\\n            sum+=it.second;\\n            if(sum>1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        string s1=event1[0];\\n        string s2=event1[1];\\n        string s3=event2[0];\\n        string s4=event2[1];\\n        int a=stoi(s1.substr(0,2))*60 + stoi(s1.substr(3,2));\\n        int b=stoi(s2.substr(0,2))*60 + stoi(s2.substr(3,2));\\n        int c=stoi(s3.substr(0,2))*60 + stoi(s3.substr(3,2));\\n        int d=stoi(s4.substr(0,2))*60 + stoi(s4.substr(3,2));\\n        map<int,int> mp;\\n        mp[a]++;\\n        mp[b]--;\\n        mp[c]++;\\n        mp[d]--;\\n        int sum=0;\\n        if(b==c || a==d)\\n            return true;\\n        for(auto it:mp)\\n        {\\n            sum+=it.second;\\n            if(sum>1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780609,
                "title": "c-bit-manipulation-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        int t11 = 0, t12 = 0, t21 = 0 , t22 = 0;\\n        t11 = (t11 << 4) | ((int)(e1[0][0]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][1]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][3]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][4]-\\'0\\') & 0xF);\\n\\n        t12 = t12 <<  4 | ((int)(e1[1][0]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][1]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][3]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][4]-\\'0\\') & 0xF);\\n\\n        t21 = t21 <<  4 | ((int)(e2[0][0]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][1]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][3]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][4]-\\'0\\') & 0xF);\\n\\n        t22 = t22 <<  4 | ((int)(e2[1][0]-\\'0\\') & 0xF);\\n        t22 = t22 << 4  | ((int)(e2[1][1]-\\'0\\') & 0xF);\\n        t22 = t22 <<  4 | ((int)(e2[1][3]-\\'0\\') & 0xF);\\n        t22 = t22 <<  4 | ((int)(e2[1][4]-\\'0\\') & 0xF);\\n        cout<<t11<<\\' \\'<<t12<<endl;\\n        cout<<t21<<\" \"<<t22;\\n        if(((t11 > t21) & (t11 > t22)) || ((t21 > t11) & (t21 > t12))){return false;}\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& e1, vector<string>& e2) {\\n        int t11 = 0, t12 = 0, t21 = 0 , t22 = 0;\\n        t11 = (t11 << 4) | ((int)(e1[0][0]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][1]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][3]-\\'0\\') & 0xF);\\n        t11 = t11 << 4 | ((int)(e1[0][4]-\\'0\\') & 0xF);\\n\\n        t12 = t12 <<  4 | ((int)(e1[1][0]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][1]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][3]-\\'0\\') & 0xF);\\n        t12 = t12 <<  4 | ((int)(e1[1][4]-\\'0\\') & 0xF);\\n\\n        t21 = t21 <<  4 | ((int)(e2[0][0]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][1]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][3]-\\'0\\') & 0xF);\\n        t21 = t21 <<  4 | ((int)(e2[0][4]-\\'0\\') & 0xF);\\n\\n        t22 = t22 <<  4 | ((int)(e2[1][0]-\\'0\\') & 0xF);\\n        t22 = t22 << 4  | ((int)(e2[1][1]-\\'0\\') & 0xF);\\n        t22 = t22 <<  4 | ((int)(e2[1][3]-\\'0\\') & 0xF);\\n        t22 = t22 <<  4 | ((int)(e2[1][4]-\\'0\\') & 0xF);\\n        cout<<t11<<\\' \\'<<t12<<endl;\\n        cout<<t21<<\" \"<<t22;\\n        if(((t11 > t21) & (t11 > t22)) || ((t21 > t11) & (t21 > t12))){return false;}\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3776790,
                "title": "simple-shortcut-trick-to-solve-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n\\n       if(event1[1] >= event2[0] && event1[0] <= event2[1])\\n        return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n\\n       if(event1[1] >= event2[0] && event1[0] <= event2[1])\\n        return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773586,
                "title": "intuitive-c-solution",
                "content": "\\n# Approach\\nConverted everything to the timeframe in terms of integer as the format is 24 hours which is 60m and also adding the seconds which is less than 60m\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        int start1 = stoi(event1[0].substr(0,2))*60 + stoi(event1[0].substr(3,2));\\n        int end1 = stoi(event1[1].substr(0,2))*60 + stoi(event1[1].substr(3,2));\\n        int start2 = stoi(event2[0].substr(0,2))*60 + stoi(event2[0].substr(3,2));\\n        int end2 = stoi(event2[1].substr(0,2))*60 + stoi(event2[1].substr(3,2));\\n        \\n        \\n        if(start1 <= start2 && start2 <= end1){\\n            return true;\\n        }else if(start2 < start1 && start1 <= end2){\\n            return true;\\n        }\\n\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        int start1 = stoi(event1[0].substr(0,2))*60 + stoi(event1[0].substr(3,2));\\n        int end1 = stoi(event1[1].substr(0,2))*60 + stoi(event1[1].substr(3,2));\\n        int start2 = stoi(event2[0].substr(0,2))*60 + stoi(event2[0].substr(3,2));\\n        int end2 = stoi(event2[1].substr(0,2))*60 + stoi(event2[1].substr(3,2));\\n        \\n        \\n        if(start1 <= start2 && start2 <= end1){\\n            return true;\\n        }else if(start2 < start1 && start1 <= end2){\\n            return true;\\n        }\\n\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762404,
                "title": "0ms-100-beats-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        return event1[0].compareTo(event2[1]) <= 0 && event2[0].compareTo(event1[1]) <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760472,
                "title": "java-100-space-time-simplest-easy-solution-understandable",
                "content": "# Approach\\nDont compare time as string, better to imagine time as minutes passed since 0 hour, means `01:30` means 90 minutes etc. now just check any one start time comes between other starttime and endtime\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int start1 = makeTime(event1[0]);\\n        int start2 = makeTime(event2[0]);\\n        if(start1 < start2) {\\n            if(start2 <= makeTime(event1[1])) return true;\\n            else return false;\\n        } else {\\n            if(start1 <= makeTime(event2[1])) return true;\\n            else return false;\\n        }\\n    }\\n    private int makeTime(String time){\\n        int hour = Integer.parseInt(time.substring(0,2));\\n        int mins = Integer.parseInt(time.substring(3,5));\\n        return hour*60 + mins;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int start1 = makeTime(event1[0]);\\n        int start2 = makeTime(event2[0]);\\n        if(start1 < start2) {\\n            if(start2 <= makeTime(event1[1])) return true;\\n            else return false;\\n        } else {\\n            if(start1 <= makeTime(event2[1])) return true;\\n            else return false;\\n        }\\n    }\\n    private int makeTime(String time){\\n        int hour = Integer.parseInt(time.substring(0,2));\\n        int mins = Integer.parseInt(time.substring(3,5));\\n        return hour*60 + mins;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744159,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        String[] event1StartTime = event1[0].split(\":\");\\n        String[] event1EndTime = event1[1].split(\":\");\\n        String[] event2StartTime = event2[0].split(\":\");\\n        String[] event2EndTime = event2[1].split(\":\");\\n        int e1StartMinutes = 60 * Integer.parseInt(event1StartTime[0]) + Integer.parseInt(event1StartTime[1]);\\n        \\n        int e2StartMinutes = 60 * Integer.parseInt(event2StartTime[0]) + Integer.parseInt(event2StartTime[1]);\\n        int e1EndMinutes = 60 * Integer.parseInt(event1EndTime[0]) + Integer.parseInt(event1EndTime[1]);\\n        int e2EndMinutes = 60 * Integer.parseInt(event2EndTime[0]) + Integer.parseInt(event2EndTime[1]);\\n        if((e1StartMinutes < e2StartMinutes && e1EndMinutes < e2StartMinutes) || (e2StartMinutes < e1StartMinutes && e2EndMinutes < e1StartMinutes)) return false;\\n        return true;\\n\\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        String[] event1StartTime = event1[0].split(\":\");\\n        String[] event1EndTime = event1[1].split(\":\");\\n        String[] event2StartTime = event2[0].split(\":\");\\n        String[] event2EndTime = event2[1].split(\":\");\\n        int e1StartMinutes = 60 * Integer.parseInt(event1StartTime[0]) + Integer.parseInt(event1StartTime[1]);\\n        \\n        int e2StartMinutes = 60 * Integer.parseInt(event2StartTime[0]) + Integer.parseInt(event2StartTime[1]);\\n        int e1EndMinutes = 60 * Integer.parseInt(event1EndTime[0]) + Integer.parseInt(event1EndTime[1]);\\n        int e2EndMinutes = 60 * Integer.parseInt(event2EndTime[0]) + Integer.parseInt(event2EndTime[1]);\\n        if((e1StartMinutes < e2StartMinutes && e1EndMinutes < e2StartMinutes) || (e2StartMinutes < e1StartMinutes && e2EndMinutes < e1StartMinutes)) return false;\\n        return true;\\n\\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723198,
                "title": "runtime-beats-97-43-easy-js-or-gate",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n   let start1 = parseInt(event1[0].substring(0,2)) * 60 + parseInt(event1[0].substring(3)),\\n        end1 = parseInt(event1[1].substring(0,2)) * 60 + parseInt(event1[1].substring(3)),\\n        start2 = parseInt(event2[0].substring(0,2)) * 60 + parseInt(event2[0].substring(3))\\n        end2 = parseInt(event2[1].substring(0,2)) * 60 + parseInt(event2[1].substring(3))\\n\\n    return ((start2 >= start1 && start2 <= end1) ||\\n             (end2 >= start1 && end2 <= end1) || \\n             (start1 >= start2 && start1 <= end2)) ? true : false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} event1\\n * @param {string[]} event2\\n * @return {boolean}\\n */\\nvar haveConflict = function(event1, event2) {\\n   let start1 = parseInt(event1[0].substring(0,2)) * 60 + parseInt(event1[0].substring(3)),\\n        end1 = parseInt(event1[1].substring(0,2)) * 60 + parseInt(event1[1].substring(3)),\\n        start2 = parseInt(event2[0].substring(0,2)) * 60 + parseInt(event2[0].substring(3))\\n        end2 = parseInt(event2[1].substring(0,2)) * 60 + parseInt(event2[1].substring(3))\\n\\n    return ((start2 >= start1 && start2 <= end1) ||\\n             (end2 >= start1 && end2 <= end1) || \\n             (start1 >= start2 && start1 <= end2)) ? true : false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722522,
                "title": "c-easy-one-liner",
                "content": "# Intuition\\nTo get a merge event1 ending time should be >= event2\\'s starting time and event1\\'s starting time should be <= event2\\'s ending time\\n\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n- Space complexity:\\n0(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event1[1] >= event2[0] and event1[0] <= event2[1]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        return event1[1] >= event2[0] and event1[0] <= event2[1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719175,
                "title": "python-golang-simple-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the time to minutes and check the overlap.\\n\\n# Code Go\\n```\\nfunc haveConflict(event1 []string, event2 []string) bool {\\n    toMinutes := func(t string) int {\\n        timeParts := strings.Split(t, \":\")\\n        start, _ := strconv.Atoi(timeParts[0])\\n        end, _ := strconv.Atoi(timeParts[1])\\n        return start * 60 + end\\n    }\\n\\n    overlap := func(x, y, u, z int) bool {\\n\\t\\treturn z >= x && y >= u\\n\\t}\\n\\n    event1InMinutes := make([]int, len(event1))\\n    event2InMinutes := make([]int, len(event2))\\n\\n    for i, x := range event1 {\\n        event1InMinutes[i] = toMinutes(x)\\n    }\\n\\n    for i, e := range event2 {\\n\\t\\tevent2InMinutes[i] = toMinutes(e)\\n\\t}\\n\\n    return overlap(event1InMinutes[0], event1InMinutes[1], event2InMinutes[0], event2InMinutes[1]) || overlap(event2InMinutes[0], event2InMinutes[1], event1InMinutes[0], event1InMinutes[1])\\n\\n}\\n\\n```\\n\\n# Code Python\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def to_minute(t):\\n            start, end = (int(x) for x in t.split(\\':\\'))\\n            return start * 60 + end\\n        \\n        def overlap(x, y, u, z):\\n            return z >= x and y >= u\\n\\n        event1 = [to_minute(x) for x in event1]\\n        event2 = [to_minute(x) for x in event2]\\n\\n        return overlap(*event1, *event2) or overlap(*event2, *event1)\\n```\\n\\n# P.S\\nI\\'ve noticed that a lot of companies ask this question. Does anyone have insights on what typically follows or how to respond to it?\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nfunc haveConflict(event1 []string, event2 []string) bool {\\n    toMinutes := func(t string) int {\\n        timeParts := strings.Split(t, \":\")\\n        start, _ := strconv.Atoi(timeParts[0])\\n        end, _ := strconv.Atoi(timeParts[1])\\n        return start * 60 + end\\n    }\\n\\n    overlap := func(x, y, u, z int) bool {\\n\\t\\treturn z >= x && y >= u\\n\\t}\\n\\n    event1InMinutes := make([]int, len(event1))\\n    event2InMinutes := make([]int, len(event2))\\n\\n    for i, x := range event1 {\\n        event1InMinutes[i] = toMinutes(x)\\n    }\\n\\n    for i, e := range event2 {\\n\\t\\tevent2InMinutes[i] = toMinutes(e)\\n\\t}\\n\\n    return overlap(event1InMinutes[0], event1InMinutes[1], event2InMinutes[0], event2InMinutes[1]) || overlap(event2InMinutes[0], event2InMinutes[1], event1InMinutes[0], event1InMinutes[1])\\n\\n}\\n\\n```\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def to_minute(t):\\n            start, end = (int(x) for x in t.split(\\':\\'))\\n            return start * 60 + end\\n        \\n        def overlap(x, y, u, z):\\n            return z >= x and y >= u\\n\\n        event1 = [to_minute(x) for x in event1]\\n        event2 = [to_minute(x) for x in event2]\\n\\n        return overlap(*event1, *event2) or overlap(*event2, *event1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704256,
                "title": "clean-shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& v1, vector<string>& v2) {\\n        map<int,int>mp;\\n        string s1=\"\",s2=\"\",s3=\"\",s4=\"\";\\n        s1+=v1[0][0];\\n        s1+=v1[0][1];\\n        s1+=v1[0][3];\\n        s1+=v1[0][4];\\n        s2+=v1[1][0];\\n        s2+=v1[1][1];\\n        s2+=v1[1][3];\\n        s2+=v1[1][4];\\n        s3+=v2[0][0];\\n        s3+=v2[0][1];\\n        s3+=v2[0][3];\\n        s3+=v2[0][4];\\n        s4+=v2[1][0];\\n        s4+=v2[1][1];\\n        s4+=v2[1][3];\\n        s4+=v2[1][4];\\n        int a=stoi(s1),b=stoi(s2),c=stoi(s3),d=stoi(s4);\\n        for(int i=a;i<=b;i++)mp[i]++;\\n        for(int i=c;i<=d;i++)mp[i]++;\\n        for(auto i:mp)if(i.second>1)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& v1, vector<string>& v2) {\\n        map<int,int>mp;\\n        string s1=\"\",s2=\"\",s3=\"\",s4=\"\";\\n        s1+=v1[0][0];\\n        s1+=v1[0][1];\\n        s1+=v1[0][3];\\n        s1+=v1[0][4];\\n        s2+=v1[1][0];\\n        s2+=v1[1][1];\\n        s2+=v1[1][3];\\n        s2+=v1[1][4];\\n        s3+=v2[0][0];\\n        s3+=v2[0][1];\\n        s3+=v2[0][3];\\n        s3+=v2[0][4];\\n        s4+=v2[1][0];\\n        s4+=v2[1][1];\\n        s4+=v2[1][3];\\n        s4+=v2[1][4];\\n        int a=stoi(s1),b=stoi(s2),c=stoi(s3),d=stoi(s4);\\n        for(int i=a;i<=b;i++)mp[i]++;\\n        for(int i=c;i<=d;i++)mp[i]++;\\n        for(auto i:mp)if(i.second>1)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677071,
                "title": "c-intervals",
                "content": "# Intuition\\nConvert the strings to absolute times and comparing the two.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) \\n    {\\n        string startTime1 = event1[0];\\n        string endTime1 = event1[1];\\n\\n        string startTime2 = event2[0];\\n        string endTime2 = event2[1];\\n\\n        float event1starthours = Int32.Parse(startTime1.Substring(0,2));\\n\\n        float event1startminutes = Int32.Parse(startTime1.Substring(3,2));\\n\\n        event1startminutes = event1startminutes/60;\\n\\n        float event1startTime = event1starthours + event1startminutes;\\n\\n        float event2starthours = Int32.Parse(startTime2.Substring(0,2));\\n\\n        float event2startminutes = Int32.Parse(startTime2.Substring(3,2));\\n\\n        event2startminutes = event2startminutes/60;\\n\\n        float event2startTime = event2starthours + event2startminutes;\\n\\n        float event1endhours = Int32.Parse(endTime1.Substring(0,2));\\n\\n        float event1endminutes = Int32.Parse(endTime1.Substring(3,2));\\n\\n        event1endminutes = event1endminutes/60;\\n\\n        float event1endTime = event1endhours + event1endminutes;\\n\\n        float event2endhours = Int32.Parse(endTime2.Substring(0,2));\\n\\n        float event2endminutes = Int32.Parse(endTime2.Substring(3,2));\\n\\n        event2endminutes = event2endminutes/60;\\n\\n        float event2endTime = event2endhours + event2endminutes;\\n\\n\\n        if(event1startTime < event2startTime)\\n        {\\n           if(event2startTime <= event1endTime)\\n           {\\n              return true;\\n           }\\n        }\\n        else\\n        {\\n           if(event1startTime <= event2endTime)\\n           {\\n              return true;\\n           }\\n        }\\n        return false;     \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool HaveConflict(string[] event1, string[] event2) \\n    {\\n        string startTime1 = event1[0];\\n        string endTime1 = event1[1];\\n\\n        string startTime2 = event2[0];\\n        string endTime2 = event2[1];\\n\\n        float event1starthours = Int32.Parse(startTime1.Substring(0,2));\\n\\n        float event1startminutes = Int32.Parse(startTime1.Substring(3,2));\\n\\n        event1startminutes = event1startminutes/60;\\n\\n        float event1startTime = event1starthours + event1startminutes;\\n\\n        float event2starthours = Int32.Parse(startTime2.Substring(0,2));\\n\\n        float event2startminutes = Int32.Parse(startTime2.Substring(3,2));\\n\\n        event2startminutes = event2startminutes/60;\\n\\n        float event2startTime = event2starthours + event2startminutes;\\n\\n        float event1endhours = Int32.Parse(endTime1.Substring(0,2));\\n\\n        float event1endminutes = Int32.Parse(endTime1.Substring(3,2));\\n\\n        event1endminutes = event1endminutes/60;\\n\\n        float event1endTime = event1endhours + event1endminutes;\\n\\n        float event2endhours = Int32.Parse(endTime2.Substring(0,2));\\n\\n        float event2endminutes = Int32.Parse(endTime2.Substring(3,2));\\n\\n        event2endminutes = event2endminutes/60;\\n\\n        float event2endTime = event2endhours + event2endminutes;\\n\\n\\n        if(event1startTime < event2startTime)\\n        {\\n           if(event2startTime <= event1endTime)\\n           {\\n              return true;\\n           }\\n        }\\n        else\\n        {\\n           if(event1startTime <= event2endTime)\\n           {\\n              return true;\\n           }\\n        }\\n        return false;     \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648718,
                "title": "java-beats-100-0ms",
                "content": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int st1,dec11,ed1,dec12;\\n        st1=Integer.parseInt(event1[0].substring(0,2));\\n        dec11=Integer.parseInt(event1[0].substring(3,5));\\n     \\n        ed1=Integer.parseInt(event1[1].substring(0,2));\\n        dec12=Integer.parseInt(event1[1].substring(3,5));\\n        \\n        int st2,ed2,dec21,dec22;\\n        st2=Integer.parseInt(event2[0].substring(0,2));\\n        dec21=Integer.parseInt(event2[0].substring(3,5));\\n        \\n        \\n        ed2=Integer.parseInt(event2[1].substring(0,2));\\n        dec22=Integer.parseInt(event2[1].substring(3,5));\\n        \\n        double start1,end1,start2,end2;\\n        start1=(double)st1+(double)dec11/100;\\n        end1=(double)ed1+(double)dec12/100;\\n        start2=(double)st2+(double)dec21/100;\\n        end2=(double)ed2+(double)dec22/100;\\n       \\n        if(start2>=start1 && start2<=end1)return true;\\n        if(end2>=start1 && end2<=end1)return true;\\n        \\n        if(start1>=start2 && start1<=end2)return true;\\n        if(end1>=start2 && end1<=end2)return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int st1,dec11,ed1,dec12;\\n        st1=Integer.parseInt(event1[0].substring(0,2));\\n        dec11=Integer.parseInt(event1[0].substring(3,5));\\n     \\n        ed1=Integer.parseInt(event1[1].substring(0,2));\\n        dec12=Integer.parseInt(event1[1].substring(3,5));\\n        \\n        int st2,ed2,dec21,dec22;\\n        st2=Integer.parseInt(event2[0].substring(0,2));\\n        dec21=Integer.parseInt(event2[0].substring(3,5));\\n        \\n        \\n        ed2=Integer.parseInt(event2[1].substring(0,2));\\n        dec22=Integer.parseInt(event2[1].substring(3,5));\\n        \\n        double start1,end1,start2,end2;\\n        start1=(double)st1+(double)dec11/100;\\n        end1=(double)ed1+(double)dec12/100;\\n        start2=(double)st2+(double)dec21/100;\\n        end2=(double)ed2+(double)dec22/100;\\n       \\n        if(start2>=start1 && start2<=end1)return true;\\n        if(end2>=start1 && end2<=end1)return true;\\n        \\n        if(start1>=start2 && start1<=end2)return true;\\n        if(end1>=start2 && end1<=end2)return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646941,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        string SH1, SH2, SM1, SM2, EH1, EH2, EM1, EM2;\\n    SH1 = event1[0].substr(0, 2);\\n    SH2 = event2[0].substr(0, 2);\\n    SM1 = event1[0].substr(3, 2);\\n    SM2 = event2[0].substr(3, 2);\\n    EH1 = event1[1].substr(0, 2);\\n    EH2 = event2[1].substr(0, 2);\\n    EM1 = event1[1].substr(3, 2);\\n    EM2 = event2[1].substr(3, 2);\\n\\n        int startHour1 = stoi(SH1);\\n        int startHour2 = stoi(SH2);\\n        int endHour1 = stoi(EH1);\\n        int endHour2 = stoi(EH2);\\n        if (endHour1 < startHour2 || endHour2 < startHour1) {\\n            cout<<\"1\";\\n        return false; // No overlap in hours, no conflict\\n    }\\n    \\n    if (endHour1 == startHour2 && stoi(EM1) < stoi(SM2)) {\\n        cout<<\"2\";\\n        return false; // Same end hour and event1 ends before event2 starts, no conflict\\n    }\\n    \\n    if (endHour2 == startHour1 && stoi(EM2) < stoi(SM1)) {\\n        cout<<\"3\";\\n        return false; // Same end hour and event2 ends before event1 starts, no conflict\\n    }\\n    \\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        \\n        string SH1, SH2, SM1, SM2, EH1, EH2, EM1, EM2;\\n    SH1 = event1[0].substr(0, 2);\\n    SH2 = event2[0].substr(0, 2);\\n    SM1 = event1[0].substr(3, 2);\\n    SM2 = event2[0].substr(3, 2);\\n    EH1 = event1[1].substr(0, 2);\\n    EH2 = event2[1].substr(0, 2);\\n    EM1 = event1[1].substr(3, 2);\\n    EM2 = event2[1].substr(3, 2);\\n\\n        int startHour1 = stoi(SH1);\\n        int startHour2 = stoi(SH2);\\n        int endHour1 = stoi(EH1);\\n        int endHour2 = stoi(EH2);\\n        if (endHour1 < startHour2 || endHour2 < startHour1) {\\n            cout<<\"1\";\\n        return false; // No overlap in hours, no conflict\\n    }\\n    \\n    if (endHour1 == startHour2 && stoi(EM1) < stoi(SM2)) {\\n        cout<<\"2\";\\n        return false; // Same end hour and event1 ends before event2 starts, no conflict\\n    }\\n    \\n    if (endHour2 == startHour1 && stoi(EM2) < stoi(SM1)) {\\n        cout<<\"3\";\\n        return false; // Same end hour and event2 ends before event1 starts, no conflict\\n    }\\n    \\n    return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3617811,
                "title": "simple-comparision-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif there is conflict it does mean that timing of second event will lie in between the first event \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        if(event1[1]>=event2[0]&&event1[0]<=event2[1])\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) \\n    {\\n        if(event1[1]>=event2[0]&&event1[0]<=event2[1])\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581087,
                "title": "100-time-beat-solution",
                "content": "# Intuition :- Simple string comparison\\n# Complexity\\n- Time complexity :- constant\\n- Space complexity :- constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[1]<=event2[1] and event1[1]>=event2[0])\\n            return true;\\n        if(event2[1]<=event1[1] and event2[1]>=event1[0])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        if(event1[1]<=event2[1] and event1[1]>=event2[0])\\n            return true;\\n        if(event2[1]<=event1[1] and event2[1]>=event1[0])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577420,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        auto time1Start = 60 * (10 * (event1[0][0] - \\'0\\') + event1[0][1] - \\'0\\') + 10 * (event1[0][3] - \\'0\\') + event1[0][4] - \\'0\\';\\n        auto time1End = 60 * (10 * (event1[1][0] - \\'0\\') + event1[1][1] - \\'0\\') + 10 * (event1[1][3] - \\'0\\') + event1[1][4] - \\'0\\';\\n        auto time2Start = 60 * (10 * (event2[0][0] - \\'0\\') + event2[0][1] - \\'0\\') + 10 * (event2[0][3] - \\'0\\') + event2[0][4] - \\'0\\';\\n        auto time2End = 60 * (10 * (event2[1][0] - \\'0\\') + event2[1][1] - \\'0\\') + 10 * (event2[1][3] - \\'0\\') + event2[1][4] - \\'0\\';\\n        return  min(time1End, time2End) - max(time1Start, time2Start) >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\\n        auto time1Start = 60 * (10 * (event1[0][0] - \\'0\\') + event1[0][1] - \\'0\\') + 10 * (event1[0][3] - \\'0\\') + event1[0][4] - \\'0\\';\\n        auto time1End = 60 * (10 * (event1[1][0] - \\'0\\') + event1[1][1] - \\'0\\') + 10 * (event1[1][3] - \\'0\\') + event1[1][4] - \\'0\\';\\n        auto time2Start = 60 * (10 * (event2[0][0] - \\'0\\') + event2[0][1] - \\'0\\') + 10 * (event2[0][3] - \\'0\\') + event2[0][4] - \\'0\\';\\n        auto time2End = 60 * (10 * (event2[1][0] - \\'0\\') + event2[1][1] - \\'0\\') + 10 * (event2[1][3] - \\'0\\') + event2[1][4] - \\'0\\';\\n        return  min(time1End, time2End) - max(time1Start, time2Start) >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568036,
                "title": "0ms-time-100-java-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        if (event2[0].charAt(0) > event1[1].charAt(0)) {\\n            return false;\\n        } else if (event2[0].charAt(0) == event1[1].charAt(0)) {\\n            if (event2[0].charAt(1) > event1[1].charAt(1)) {\\n                return false;\\n            } else if (event2[0].charAt(1) == event1[1].charAt(1)) {\\n                if (event2[0].charAt(3) > event1[1].charAt(3)) {\\n                    return false;\\n                } else if (event2[0].charAt(3) == event1[1].charAt(3)) {\\n                    if (event2[0].charAt(4) > event1[1].charAt(4))\\n                        return false;\\n                }\\n            }\\n        }\\n        if (event1[0].charAt(0) > event2[1].charAt(0)) {\\n            return false;\\n        } else if (event1[0].charAt(0) == event2[1].charAt(0)) {\\n            if (event1[0].charAt(1) > event2[1].charAt(1)) {\\n                return false;\\n            } else if (event1[0].charAt(1) == event2[1].charAt(1)) {\\n                if (event1[0].charAt(3) > event2[1].charAt(3)) {\\n                    return false;\\n                } else if (event1[0].charAt(3) == event2[1].charAt(3)) {\\n                    if (event1[0].charAt(4) > event2[1].charAt(4))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        if (event2[0].charAt(0) > event1[1].charAt(0)) {\\n            return false;\\n        } else if (event2[0].charAt(0) == event1[1].charAt(0)) {\\n            if (event2[0].charAt(1) > event1[1].charAt(1)) {\\n                return false;\\n            } else if (event2[0].charAt(1) == event1[1].charAt(1)) {\\n                if (event2[0].charAt(3) > event1[1].charAt(3)) {\\n                    return false;\\n                } else if (event2[0].charAt(3) == event1[1].charAt(3)) {\\n                    if (event2[0].charAt(4) > event1[1].charAt(4))\\n                        return false;\\n                }\\n            }\\n        }\\n        if (event1[0].charAt(0) > event2[1].charAt(0)) {\\n            return false;\\n        } else if (event1[0].charAt(0) == event2[1].charAt(0)) {\\n            if (event1[0].charAt(1) > event2[1].charAt(1)) {\\n                return false;\\n            } else if (event1[0].charAt(1) == event2[1].charAt(1)) {\\n                if (event1[0].charAt(3) > event2[1].charAt(3)) {\\n                    return false;\\n                } else if (event1[0].charAt(3) == event2[1].charAt(3)) {\\n                    if (event1[0].charAt(4) > event2[1].charAt(4))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567195,
                "title": "java-simple",
                "content": "# Intuition\\nConvert to numbers, and check if the start of one event falls into the interval of the other event.\\n\\n# Approach\\nUsing built in parsing and removing the colon to conver to integers.\\n\\n# Complexity\\n- Time complexity:\\nDepends on the complexity of converting to Integers, since the comparison once we have the numbers is O(1).\\n\\n- Space complexity:\\nThe storage will always be 4 variables. This is O(1). If this were a different question where we didn\\'t know how many events there would be, it would depend on that, but we know there are only 2 events for this problem.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int e1s = Integer.parseInt(event1[0].replace(\":\",\"\"));\\n        int e1e = Integer.parseInt(event1[1].replace(\":\",\"\"));\\n        int e2s = Integer.parseInt(event2[0].replace(\":\",\"\"));\\n        int e2e = Integer.parseInt(event2[1].replace(\":\",\"\"));\\n\\n        return (e1s >= e2s && e1s <= e2e) || (e2s >= e1s && e2s <= e1e);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean haveConflict(String[] event1, String[] event2) {\\n        int e1s = Integer.parseInt(event1[0].replace(\":\",\"\"));\\n        int e1e = Integer.parseInt(event1[1].replace(\":\",\"\"));\\n        int e2s = Integer.parseInt(event2[0].replace(\":\",\"\"));\\n        int e2e = Integer.parseInt(event2[1].replace(\":\",\"\"));\\n\\n        return (e1s >= e2s && e1s <= e2e) || (e2s >= e1s && e2s <= e1e);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536526,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event1[0] > event2[0]:\\n            event1, event2 = event2, event1\\n        return event2[0] <= event1[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event1[0] > event2[0]:\\n            event1, event2 = event2, event1\\n        return event2[0] <= event1[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535614,
                "title": "easy-python-string-comparison-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString comparison\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif part of one event found between parts of second\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event1[0] <= event2[0] <= event1[1] or event1[0] <= event2[1] <= event1[1]:\\n            return True\\n        elif event2[0] <= event1[0] <= event2[1] or event2[0] <= event1[1] <= event2[1]:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        if event1[0] <= event2[0] <= event1[1] or event1[0] <= event2[1] <= event1[1]:\\n            return True\\n        elif event2[0] <= event1[0] <= event2[1] or event2[0] <= event1[1] <= event2[1]:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534045,
                "title": "lc-2446-e-python3-a-plain-solution",
                "content": "Just write the process as requested.\\n\\n```Python3 []\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return max(event1[0], event2[0]) <= min(event1[1], event2[1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return max(event1[0], event2[0]) <= min(event1[1], event2[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532279,
                "title": "using-magic-function-le",
                "content": "# Code\\n```\\nclass STime:\\n    def __init__(self, s):\\n        f = s.split(\":\")\\n        self.hour = int(f[0])\\n        self.mins = int(f[1])\\n\\n    def __le__(self, t2):\\n        if self.hour < t2.hour:\\n            return True\\n        if self.hour == t2.hour:\\n            return self.mins <= t2.mins\\n        return False\\n\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        e1s = STime(event1[0])\\n        e1e = STime(event1[1])\\n\\n        e2s = STime(event2[0])\\n        e2e = STime(event2[1])\\n\\n        if e2s <= e1e and e1s <= e2e:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass STime:\\n    def __init__(self, s):\\n        f = s.split(\":\")\\n        self.hour = int(f[0])\\n        self.mins = int(f[1])\\n\\n    def __le__(self, t2):\\n        if self.hour < t2.hour:\\n            return True\\n        if self.hour == t2.hour:\\n            return self.mins <= t2.mins\\n        return False\\n\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        e1s = STime(event1[0])\\n        e1e = STime(event1[1])\\n\\n        e2s = STime(event2[0])\\n        e2e = STime(event2[1])\\n\\n        if e2s <= e1e and e1s <= e2e:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529415,
                "title": "simples-py-solution",
                "content": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        if event1[0]>event2[1]:\\n            return False\\n\\n        elif event2[0]>event1[1]:\\n            return False\\n\\n        else:\\n            return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n\\n        if event1[0]>event2[1]:\\n            return False\\n\\n        elif event2[0]>event1[1]:\\n            return False\\n\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519638,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def convert(time_str):        \\n            t_list = time_str.split(\\':\\')\\n            return float(t_list[0] + \\'.\\' + t_list[1])\\n        \\n        e1_start = convert(event1[0])\\n        e1_end = convert(event1[1])\\n\\n        e2_start = convert(event2[0])\\n        e2_end = convert(event2[1])\\n\\n        # include\\n        if e1_start <= e2_start and e2_end <= e1_end:\\n            return True\\n        if e2_start <= e1_start and e1_end <= e2_end:\\n            return True\\n        # intersect\\n        if e1_start <= e2_start and e2_start <= e1_end:\\n            return True\\n        if e2_start <= e1_start and e1_start <= e2_end:\\n            return True\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        def convert(time_str):        \\n            t_list = time_str.split(\\':\\')\\n            return float(t_list[0] + \\'.\\' + t_list[1])\\n        \\n        e1_start = convert(event1[0])\\n        e1_end = convert(event1[1])\\n\\n        e2_start = convert(event2[0])\\n        e2_end = convert(event2[1])\\n\\n        # include\\n        if e1_start <= e2_start and e2_end <= e1_end:\\n            return True\\n        if e2_start <= e1_start and e1_end <= e2_end:\\n            return True\\n        # intersect\\n        if e1_start <= e2_start and e2_start <= e1_end:\\n            return True\\n        if e2_start <= e1_start and e1_start <= e2_end:\\n            return True\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510616,
                "title": "simplest-python-solution-ever-one-liner",
                "content": "# Intuition\\nStrings are compared using ASCII values in Python. So we can just natively compare two time strings and get a correct result. Meaning we can compare \"11:00\" and \"11:30\" using the Python operators (>, <, =).\\n\\n# Approach\\nTwo intervals overlap if the end time of **event1** is greater than the start time of **event2** and the end time of **event2** is greater than the start time of **event1**\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return event1[1] >= event2[0] and event2[1] >= event1[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\\n        return event1[1] >= event2[0] and event2[1] >= event1[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498048,
                "title": "rust-o-1-solution",
                "content": "# Intuition\\nThe solution to this problem can be found by checking if the events have any conflicts, in this case, by having the intervals overlap each other.\\n\\n# Approach\\nThe objective is to check for conflicts between two events, i.e., whether they overlap. The have_conflict function takes two vectors of strings as input, representing the time intervals of the two events.\\n\\nThe first step is to determine if event 1 overlaps event 2. This is done by comparing the lower and upper bounds of the time intervals. If the lower bound of event 1 is less than or equal to the lower bound of event 2, and the upper bound of event 1 is greater than or equal to the lower bound of event 2, then event 1 overlaps event 2.\\n\\nNext, it checks if event 2 overlaps event 1. This is done by comparing the lower and upper bounds of the time intervals in the same way as done previously.\\n\\nFinally, the function returns true if there is any overlap between the events (i.e., if event 1 overlaps event 2 or if event 2 overlaps event 1), and false otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        // Stores if event 1 overlaps event 2\\n        let event_1_overlaps = event1[0] <= event2[0] && event1[1] >= event2[0];\\n\\n        // Stores if event 2 overlaps event 1\\n        let event_2_overlaps = event2[0] <= event1[0] && event2[1] >= event1[0];\\n\\n        // Returns if any event was overlapped\\n        event_1_overlaps || event_2_overlaps\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\\n        // Stores if event 1 overlaps event 2\\n        let event_1_overlaps = event1[0] <= event2[0] && event1[1] >= event2[0];\\n\\n        // Stores if event 2 overlaps event 1\\n        let event_2_overlaps = event2[0] <= event1[0] && event2[1] >= event1[0];\\n\\n        // Returns if any event was overlapped\\n        event_1_overlaps || event_2_overlaps\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477479,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university::accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n {\\n    public boolean haveConflict(String[] event1, String[] event2)\\n     {\\n        \\n        int hours1=Integer.parseInt(event1[0].substring(0,2));\\nint minutes1=Integer.parseInt(event1[0].substring(3));\\nint total1=hours1*60+minutes1;    \\n\\n//second event1.endTime1\\nint hours2=Integer.parseInt(event1[1].substring(0,2));\\nint minutes2=Integer.parseInt(event1[1].substring(3));\\nint total2=hours2*60+minutes2;\\n\\n//System.out.println(\"total1 \"+total1);\\n//System.out.println(\"total2 \"+total2);\\n\\nint first=2147483647;\\nfor (int i=0;i<event2.length;i++)\\n{\\n    int hours3=Integer.parseInt(event2[i].substring(0,2));\\n    int minutes3=Integer.parseInt(event2[i].substring(3));\\n    int total3=hours3*60+minutes3;\\n   // System.out.println(\"total3 \"+total3);\\n    if (total3>=total1 && total3<=total2)\\n    { \\n      //  System.out.println(\"true\");\\n        return true;\\n    }\\n    else if (first<total1 && total3>total2 )\\n    {\\n        //System.out.println(\"true\");\\n        return true;\\n    }\\n    first=total3;\\n}\\n\\n//System.out.println(\"false\");\\nreturn false;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n {\\n    public boolean haveConflict(String[] event1, String[] event2)\\n     {\\n        \\n        int hours1=Integer.parseInt(event1[0].substring(0,2));\\nint minutes1=Integer.parseInt(event1[0].substring(3));\\nint total1=hours1*60+minutes1;    \\n\\n//second event1.endTime1\\nint hours2=Integer.parseInt(event1[1].substring(0,2));\\nint minutes2=Integer.parseInt(event1[1].substring(3));\\nint total2=hours2*60+minutes2;\\n\\n//System.out.println(\"total1 \"+total1);\\n//System.out.println(\"total2 \"+total2);\\n\\nint first=2147483647;\\nfor (int i=0;i<event2.length;i++)\\n{\\n    int hours3=Integer.parseInt(event2[i].substring(0,2));\\n    int minutes3=Integer.parseInt(event2[i].substring(3));\\n    int total3=hours3*60+minutes3;\\n   // System.out.println(\"total3 \"+total3);\\n    if (total3>=total1 && total3<=total2)\\n    { \\n      //  System.out.println(\"true\");\\n        return true;\\n    }\\n    else if (first<total1 && total3>total2 )\\n    {\\n        //System.out.println(\"true\");\\n        return true;\\n    }\\n    first=total3;\\n}\\n\\n//System.out.println(\"false\");\\nreturn false;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1823631,
                "content": [
                    {
                        "username": "ChrisPops",
                        "content": "This is a fine problem, but I\\'d suggest that the title use a word like \"intersection\" rather than \"conflict\". To me, a label like \"conflict\" doesn\\'t make sense because there\\'s no actual real-world conflict when you have Meeting A ending at 2pm and Meeting B starting at 2pm. The times might touch, but there\\'s no overlap. "
                    },
                    {
                        "username": "dnox",
                        "content": "while I somewhat agree, sometimes vague requirements or instructions could be part of the problem"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "tip : try converting to minutes of give time !\\u270C\\uFE0F"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Just Compare strings, no need of conversion to integer."
                    },
                    {
                        "username": "native_element",
                        "content": "I am thinking || operation."
                    }
                ]
            },
            {
                "id": 1742666,
                "content": [
                    {
                        "username": "ChrisPops",
                        "content": "This is a fine problem, but I\\'d suggest that the title use a word like \"intersection\" rather than \"conflict\". To me, a label like \"conflict\" doesn\\'t make sense because there\\'s no actual real-world conflict when you have Meeting A ending at 2pm and Meeting B starting at 2pm. The times might touch, but there\\'s no overlap. "
                    },
                    {
                        "username": "dnox",
                        "content": "while I somewhat agree, sometimes vague requirements or instructions could be part of the problem"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "tip : try converting to minutes of give time !\\u270C\\uFE0F"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Just Compare strings, no need of conversion to integer."
                    },
                    {
                        "username": "native_element",
                        "content": "I am thinking || operation."
                    }
                ]
            },
            {
                "id": 1921975,
                "content": [
                    {
                        "username": "ChrisPops",
                        "content": "This is a fine problem, but I\\'d suggest that the title use a word like \"intersection\" rather than \"conflict\". To me, a label like \"conflict\" doesn\\'t make sense because there\\'s no actual real-world conflict when you have Meeting A ending at 2pm and Meeting B starting at 2pm. The times might touch, but there\\'s no overlap. "
                    },
                    {
                        "username": "dnox",
                        "content": "while I somewhat agree, sometimes vague requirements or instructions could be part of the problem"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "tip : try converting to minutes of give time !\\u270C\\uFE0F"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Just Compare strings, no need of conversion to integer."
                    },
                    {
                        "username": "native_element",
                        "content": "I am thinking || operation."
                    }
                ]
            },
            {
                "id": 1742773,
                "content": [
                    {
                        "username": "ChrisPops",
                        "content": "This is a fine problem, but I\\'d suggest that the title use a word like \"intersection\" rather than \"conflict\". To me, a label like \"conflict\" doesn\\'t make sense because there\\'s no actual real-world conflict when you have Meeting A ending at 2pm and Meeting B starting at 2pm. The times might touch, but there\\'s no overlap. "
                    },
                    {
                        "username": "dnox",
                        "content": "while I somewhat agree, sometimes vague requirements or instructions could be part of the problem"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "tip : try converting to minutes of give time !\\u270C\\uFE0F"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Just Compare strings, no need of conversion to integer."
                    },
                    {
                        "username": "native_element",
                        "content": "I am thinking || operation."
                    }
                ]
            }
        ]
    }
]