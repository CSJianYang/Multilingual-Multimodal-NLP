[
    {
        "title": "Gray Code",
        "question_content": "An n-bit gray code sequence is a sequence of 2n integers where:\n\n\tEvery integer is in the inclusive range [0, 2n - 1],\n\tThe first integer is 0,\n\tAn integer appears no more than once in the sequence,\n\tThe binary representation of every pair of adjacent integers differs by exactly one bit, and\n\tThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\nExample 2:\n\nInput: n = 1\nOutput: [0,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 16",
        "solutions": [
            {
                "id": 29891,
                "title": "share-my-solution",
                "content": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "solutionTags": [],
                "code": "My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2. \\n00,01,11,10 -> (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness.\\nCode is simple:\\n\\n----------\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> rs=new ArrayList<Integer>();\\n        rs.add(0);\\n        for(int i=0;i<n;i++){\\n            int size=rs.size();\\n            for(int k=size-1;k>=0;k--)\\n                rs.add(rs.get(k) | 1<<i);\\n        }\\n        return rs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 29881,
                "title": "an-accepted-three-line-solution-in-java",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new LinkedList<>();\\n        for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);\\n        return result;\\n    }\\n\\nThe idea is simple. G(i) = i^ (i/2).",
                "codeTag": "Unknown"
            },
            {
                "id": 29893,
                "title": "one-liner-python-solution-with-demo-in-comments",
                "content": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "solutionTags": [],
                "code": "All you need is a bit of careful thought.\\n\\nBtw, it's extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. \\n\\nEven if you do not solve the problem finally, the interviewer at least get to know what you're thinking. \\n\\nAnd if you don't get the problem right, he/she will have a chance to correct you.\\n\\n    class Solution:\\n        # @return a list of integers\\n        '''\\n        from up to down, then left to right\\n        \\n        0   1   11  110\\n                10  111\\n                    101\\n                    100\\n                    \\n        start:      [0]\\n        i = 0:      [0, 1]\\n        i = 1:      [0, 1, 3, 2]\\n        i = 2:      [0, 1, 3, 2, 6, 7, 5, 4]\\n        '''\\n        def grayCode(self, n):\\n            results = [0]\\n            for i in range(n):\\n                results += [x + pow(2, i) for x in reversed(results)]\\n            return results",
                "codeTag": "Java"
            },
            {
                "id": 29880,
                "title": "backtracking-c-solution",
                "content": "    class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }\\n            else {\\n                utils(bits, result, k-1);\\n                bits.flip(k-1);\\n                utils(bits, result, k-1);\\n            }\\n        }\\n    public:\\n        vector<int> grayCode(int n) {\\n            bitset<32> bits;\\n            vector<int> result;\\n            utils(bits, result, n);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        void utils(bitset<32>& bits, vector<int>& result, int k){\\n            if (k==0) {\\n                result.push_back(bits.to_ulong());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30028,
                "title": "4-lines-c-code",
                "content": "You can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }\\n    };\\n\\nI try to give a simple proof here. Let's denote i^(i>>1) as f(i). To proof f(i) is the ith gray code, we only need to prove the following statements:\\n\\n 1. f(0) = 0\\n 2. (i) and f(i+1) only differs in one digit\\n 3. f(i) is bijective, e.g. f(i) = f(j) if and only if i = j.\\n\\nThe first one is obvious. \\n\\nFor the second , f(i) ^ f(i+1) = i^(i>>1)^(i+1)^((i+1)>>1) = (i^(i+1)) ^ ((i^(i+1)) >> 1). Let's denote g(i) = i^(i+1), g(i) has the form of 0000111...111. So f(i) ^ f(i+1) = g(i) ^ g(i)>>1 = 00001000...000.\\n\\nThe third part can be proved alike.",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> ans(1<<n);\\n            for (int i=0; i<(1<<n); i++) \\n                ans[i] = i^(i>>1);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 29884,
                "title": "what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion",
                "content": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "  I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution?  (I combined the base cases in the loop as mike3 does. Thanks mike3!)\\n\\n    vector<int> grayCode(int n) \\n    {         \\n        vector<int> result(1, 0);        \\n        for (int i = 0; i < n; i++) {\\n            int curCount = result.size();\\n            // push back all element in result in reverse order\\n            while (curCount) {\\n                curCount--;\\n                int curNum = result[curCount];\\n                curNum += (1<<i);\\n                result.push_back(curNum);\\n            } \\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1308570,
                "title": "python-short-recursive-solution-explained",
                "content": "The idea is to use recursion, if we have gray code for `n-1`, than we can construct gray code for `n` easily. Imagine, that `n = 4` and we have code `[0,1,3,2,6,7,5,4]`. Then we need to add numbers in `[8, 15]`. Let us add `8` to each number, so we have `[8, 9, 11, 10, 14, 15, 13, 12]` which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get `[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]`.\\n\\n#### Complexity\\nTime complexity is `O(2^n)`, space as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n):\\n        if n == 0: return [0]\\n        t = self.grayCode(n-1)\\n        return t + [i+(1<<(n-1)) for i in t][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245076,
                "title": "4-lines-elegant-fast-and-easy-understand-python-solution",
                "content": "Fisrt, we can explore the data and try to figure out the pattern. \\nFor example, when n=3, **results** start from 000, we can **XOR** last number in results with **X** .\\n`result[i+1] = X[i] ^ result[i]`\\nBelow we can figure out the pattern of **X**:\\n```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\\nSo the keypoint is to generate **X** sequence. Here is the trick, actually **X** is **lowest one-bit** of **Y** (natural number set).\\nAccording to bit-manipulation, we can get lowest one-bit of number by\\n`X = Y & -Y`\\nFinally, we can get this elegant and easy-understand solution:\\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nresult          X                  Y\\n0 0 0         0 0 1           0 0 1 (1)\\n0 0 1         0 1 0           0 1 0 (2)\\n0 1 1         0 0 1           0 1 1 (3)\\n0 1 0         1 0 0           1 0 0 (4)\\n1 1 0         0 0 1           1 0 1 (5)\\n1 1 1         0 1 0           1 1 0 (6)\\n1 0 1         0 0 1           1 1 1 (7)\\n1 0 0\\n```\n```\\ndef grayCode(self, n: int) -> \\'List[int]\\':\\n\\tres = [0]\\n\\tfor i in range(1, 2**n):\\n\\t\\tres.append(res[-1] ^ (i & -i))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1308562,
                "title": "gray-code-c-python-iterative-solution-explained",
                "content": "The main idea is to use previously calculated values\\nLook the examples in bit representation =>>\\nn=0  =>   [0]\\nn=1  =>  [0, 1] \\nn=2 => [00, 01, 11, 10]   => [00, 01] + [11, 01]  => ( 0 + [result(n-1)] ) +  ( 1 + [result(n-1)] )\\nn=3 => [000, 001, 011, 010, 110, 111, 101, 100] => ( 0 + [result(n-1) ) + ( 1+ [result(n-1)] )\\nso on ...\\nNow we can implement the above pattern easily\\nWe can make it more simple, if we observe that, Every time we just twiced the values in the prev result ans new values are just made on the folling pattern =>\\nn=0 =>  [0000]\\nn=1 => [0000, 0001]  // observe the we had just set (n-1)th bit to 1, iterating from right in the prev result ;\\nn=2 => [0000, 0001, 0011, 0010]\\nn=3 => [0000, 0001, 0011, 0010, 0110, 0111, 0101, 0100]\\nso on ...\\nmask containes (n-1)th bit as 1,   \\nif result for n=2, 0001 =>  **mask = 0010** hence newRes = (**res | mask**) = 0011; \\nHope it helped you to understand the logic.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Python =>**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```\\n**If you find it helpful, plz upvote**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> result;\\n        result.push_back(0);\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int prevLength = result.size();\\n            int mask = 1 << (i - 1);\\n            for (int j = prevLength - 1; j >= 0; j--) {\\n                result.push_back(mask + result[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        arr = []\\n        arr.append(0)\\n        for i in range(1,n+1):\\n            prevLength = len(arr)\\n            mask = 1 << (i-1)\\n            for j in range(prevLength, 0, -1):\\n                arr.append(mask + arr[j-1])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30045,
                "title": "share-my-simple-way-of-this-problem",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }\\n            return result;\\n        }\\n    };\\n\\nAs we known:\\n\\n    Gi = Bi+1 xor Bi\\n\\nFor example, trans binay '001' to gray code:\\n\\n    tmp = 001 << 1\\n\\nthen,\\n\\n    bin 0 0 0 1\\n    tmp 0 0 1 0\\n    -xor------------\\n        0 0 1 1\\nand the gray code is:\\n\\n    0 0 1 1 >> 1 (ignore last bit) => 0 0 1",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int N(1 << n), tmp;\\n            vector<int> result;\\n            for(int i(0); i < N; i++)\\n            {\\n                tmp = i << 1;\\n                result.push_back((tmp^i) >> 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3440293,
                "title": "easy-to-understand-concise-c",
                "content": "`Idea`:\\nGray code for a number n is n^(n/2), and we push the same for every number in range [0, pow(2,x)).\\n\\n`Explanation`\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits i.e. g[i] = b[i] ^ b[i-1].\\n\\n`Lets take 13`: 1101\\n`Gray code will b`e:\\n1 + 1^1 + 0^1 + 1^0\\n\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30007,
                "title": "python-easy-bit-manipulation-solution",
                "content": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "For n=1: 0 1\\n\\nFor n=2: 00 01 11 10\\n\\nNotice that the second half (11 and 10) are mirror of the first half (0 1) with additional 1 before it (10 11).\\nNow we have (00 01 11 10), in order to do n=3 we need to do the same. The 4 elements of n=2 will be our first half, to do the second half we mirror them to get (10 11 01 00) and add additional 1 before it (110 111 101 100). We get:\\n\\nFor n=3: 000 001 011 010 110 111 101 100\\n\\n\\n    def grayCode(n):\\n        if not n:\\n            return [0]\\n        res = [0,1]\\n        for i in range(2,n+1):\\n            for j in range(len(res)-1,-1,-1):\\n                res.append(res[j] | 1<<i-1)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 29953,
                "title": "java-easy-version-to-understand",
                "content": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static List<Integer> grayCode(int n) {\\n\\t\\tif (n < 0)\\n\\t\\t\\treturn new ArrayList<Integer>();\\n\\t\\tif (n == 0) {\\n\\t\\t\\tList<Integer> list = new ArrayList<Integer>();\\n\\t\\t\\tlist.add(0);\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t\\tList<Integer> tmp = grayCode(n - 1);\\n\\t\\tList<Integer> result = new ArrayList<Integer>(tmp);\\n\\t\\tint addNumber = 1 << (n - 1);\\n\\t\\tfor (int i = tmp.size() - 1; i >= 0; i--) {\\n\\t\\t\\tresult.add(addNumber + tmp.get(i));\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 30084,
                "title": "4ms-simple-iterative-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int> result = { 0 };\\n        int t = 1;\\n        for(int i = 0; i<n; i++) {\\n            for(int j = result.size() - 1; j >= 0; j--)\\n                result.push_back(result[j]^t);\\n            t <<= 1;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30092,
                "title": "one-line-python-solution-with-comments",
                "content": "These characteristics suggest a simple and fast method of translating a binary value into the corresponding Gray code. Each bit is inverted if the next higher bit of the input value is set to one. This can be performed in parallel by a bit-shift and exclusive-or operation if they are available: g(b) = x(b) XOR x(b+1)\\n\\n    class Solution:\\n    # @param {integer} n\\n    # @return {integer[]}\\n    def grayCode(self, n):\\n        return [(i>>1)^i for i in xrange(2**n)]",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 1308685,
                "title": "c-python-easy-to-understand-100-fast",
                "content": "**Idea:** \\nGray code for a number **```n```** is **```n^(n/2)```**, and we push the same for every number in range ```[0, pow(2,x))```.\\n\\n**Explanation**\\nFor the explanation part, we copy the MSB from binary as it is in the code and xor the remaining bits **i.e. ```g[i] = b[i] ^ b[i-1]```.**\\n\\nLets take 13: 1101\\nGray code will be:\\n```1 + 1^1 + 0^1 + 1^0```\\nIf you see carefully, the xored number is actually \\'0110\\' which is equal to n/2.\\n\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```n```\n```n^(n/2)```\n```[0, pow(2,x))```\n```g[i] = b[i] ^ b[i-1]```\n```1 + 1^1 + 0^1 + 1^0```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int p=(1<<n);\\n        for(int i=0; i<p; i++){\\n            v.push_back(i^(i/2));\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i//2) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400651,
                "title": "java-solutions-with-detailed-comments-and-explanations-backtracking-prepending",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/gray-code/) <span class=\"gray\">EPI 15.11</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> The gray code is a binary numeral system where two successive values **differ in only one bit**.\\n\\nGiven a non-negative integer `n` representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with `0`.\\n\\n**Example:** \\n\\n```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\\n\\n\\n## Analysis\\n\\n### Backtracking\\n\\nInstead of enumerating all possible permutations, which takes `O(2^{n * 2^n})`, we construct the gray code by a step-by-step approach.\\n\\nFirst, we design a function that checks if two numbers `n1` and `n2` differ only in one bit.\\n\\n- `n1 == n2`: `xor == 0`, returns false.\\n- Differ in more than one bit: `(xor & (xor - 1)) != 0`, returns false.\\n- Differ in one bit: `(xor & (xor - 1)) == 0`, returns true.\\n\\n**Note:** `num & (num - 1)` can remove the rightmost one-bit of `num`.\\n\\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\\n\\nConsider we have a number `0110`. How many differ-in-one numbers can we have for `0110`? The answer is `[1110, 0010, 0100, 0111]`. We can write it out right away because we just need to do XOR operation for each bit. In other words, we XOR `0110` with `[1000, 0100, 0010, 0001]`.\\n\\nBased on this idea, we can take the latest generated number in the result list, and try out all differ-in-one possibilities. In order to know if the new candidate is qualified, we use a hash set to store all previously constructed numbers.\\n\\nIf the candidate is not in the hash set, we add it to the hash set and also append it to the result list. Then we construct the next number based on the number we\\'ve just added.\\n\\nAt last, when we have `2^n` numbers in the result list, we need to check if the first and the last elements are compatible via `isValid(n1, n2)`. If yes, everything is done; if no, backtrack and construct a new possible number, and try again.\\n\\n**Note:** `2^i` can be computed by `1 << i`.\\n\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\\n\\n**Time:** `O(2^N)` <span class=\"purple\">I don\\'t know how to get it~</span>\\n**Space:** `O(2^N)`\\n\\n\\n\\n### Prepending 0 and 1\\n\\nThe idea is simple. Based on the `result` in `n = k`, we add $0$ before each element to get the first half; we add $1$ before each element of `result` and **reverse** the list to get the second half. Then concatenate them to get the result for `n = k + 1`. **See the example below to understand it!**.\\n\\nConsider how we generate gray codes from `n = 0` to `n = 3`.\\n\\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\\n\\n**Note:** Consider the corner cases when `n = 0` and `n = 1`, and then decide `i` should start from $0$.\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(2^N)`\\n- `n = 0` (`[0]`), prepending \"1\" takes `1` operation (**allocating extra space takes `1` operation and reversing takes $1$ operation, but they are proportional to number of prepending operations**).\\n- `n = 1` (`[0, 1]`), prepending \"1\" takes `2` operations.\\n- `n = 2` (`[00, 01, 11, 10]`), prepending \"1\" takes `4` operations.\\n- `n = 3` (`[000, 001, 011, 010, 110, 111, 101, 100]`), prepending \"1\" takes `8` operations.\\n- `n = k`, prepending \"1\" takes `2^k` operations.\\n- In total, `T(N) = 1 + 2 + 4 + 8 + ... + 2^N = 2^N`.\\n\\n**Space:** `O(2^N)`\\n\\n**Without allocating extra space (In-Place):**\\n\\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\nSame complexity.\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nInput: 2\\nOutput: [0,1,3,2]\\nExplanation:\\n00 - 0\\n01 - 1\\n11 - 3\\n10 - 2\\n\\nFor a given n, a gray code sequence may not be uniquely defined.\\nFor example, [0,2,3,1] is also a valid gray code sequence.\\n\\n00 - 0\\n10 - 2\\n11 - 3\\n01 - 1\\n\\nInput: 0\\nOutput: [0]\\n\\nInput: 1\\nOutput: [0, 1]\\n```\n```java\\nprivate boolean isValid(int n1, int n2) {\\n  int xor = n1 ^ n2;\\n  return xor != 0 && (xor & (xor - 1)) == 0;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  Set<Integer> history = new HashSet<>();\\n  generateGrayCode(n, history, result);\\n  return result;\\n}\\n\\nprivate boolean generateGrayCode(int n, Set<Integer> history, List<Integer> result) {\\n  // base case\\n  if (result.size() == (1 << n)) {\\n    // check the first element and the last element\\n    return isValid(result.get(0), result.get(result.size() - 1));\\n  }\\n  for (int i = 0; i < n; ++i) {\\n    int prevCode = result.get(result.size() - 1);\\n    int candCode = prevCode ^ (1 << i);\\n    if (!history.contains(candCode)) {\\n      history.add(candCode);\\n      result.add(candCode);\\n      boolean found = generateGrayCode(n, history, result);\\n      if (found) return true;\\n      history.remove(candCode);\\n      result.remove(result.size() - 1);\\n    }\\n  }\\n  return false;\\n}\\n```\n```java\\nn = 0, we have [0].\\n\\nn = 1, we previously have [0] and then construct [0, 1].\\n\\nJust add 1 (actually add 1, which is 1 << n = 1)\\n\\nn = 2, we previously have [0, 1] and construct [00, 01, 11, 10].\\n\\nBy adding 0 before each element, we get [00, 01] (actually do nothing in the code)\\nBy adding 1 before each element, we get [10, 11] (actually add 10, which is 1 << n = 10)\\nReverse [10, 11] to get [11, 10]\\nCombine [00, 01] and [11, 10], we have [00, 01, 11, 10].\\n\\nn = 3, we previously have [00, 01, 11, 10].\\n\\nAdd 0:   [000, 001, 011, 010]\\nAdd 1:   [110, 111, 101, 100] (reversed) (actually add 100, which is 1 << n = 1 << 3 = 100)\\nCombine: [000, 001, 011, 010, 110, 111, 101, 100]\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    List<Integer> res1 = result;\\n    List<Integer> res2 = new ArrayList<>(res1);\\n    Collections.reverse(res2);\\n    // prepend \"1\"\\n    int prependVal = (1 << i);\\n    for (int j = 0; j < res2.size(); ++j) {\\n      res2.set(j, res2.get(j) + prependVal);\\n    }\\n    res1.addAll(res2);\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<Integer> grayCode(int n) {\\n  List<Integer> result = new ArrayList<>(Arrays.asList(0));\\n  for (int i = 0; i < n; ++i) {\\n    int prependVal = (1 << i);\\n    int oldSize = result.size();\\n    for (int j = oldSize - 1; j >= 0; --j) {\\n      result.add(result.get(j) + prependVal);\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451928,
                "title": "c-bit-manipulation-easy-to-understand-explained-beginner",
                "content": "# ***Appraoch***\\n```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```\\n# ***If you liked the solution , please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nWe are required to find n-bit gray codes and return them in a vector\\n\\nThis is a pretty good bit-manipulation + backtracking problem\\nI would say backtracking part is really easy but bit-manipulation logic is really good for this particular problem\\n\\nLogic is very simple\\n\\nsuppose we are given n = 1 [means we are required all 1-bit gray codes]\\ngray codes : differ only by 1 bit in their binary representation!!!\\n    \\nfor n = 1 => codes [0 , 1]\\nfor n = 2 => codes [00 , 01 , 11 , 10]\\nfor n = 3 => codes [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n\\nObservation : for n , we have (2 ^ n ) codes\\n\\nalso for finding we can find all n-bit gray codes if we already know (n-1) bit codes\\n\\nlet\\'s find out how?\\n    \\n    suppose we are given all codes for n = 2 , [00 , 01 , 11 , 10]\\n    and required to find for n = 3\\n        \\n        means n = 3,\\n\\t\\tfor n = 3 , we have 2 ^ 3 = 8 codes [4 created by putting 0 in front of 2-bit codes + 4 created by putting 1 in front of 2-bit codes in reverse fashion]\\n\\t\\t\\n        find n-bit codes with the help of (n-1) bit codes\\n        actually 3-bit codes can be build using 2-bit codes by first placing 0 in front of all codes and then 1 bit codes in reverse fashion\\n        \\n        Put 0 in front of all 2-bit codes\\n        00  => 000\\n        01  => 001\\n        11  => 011\\n        10  => 010\\n            \\n        half of 3-bit codes are ready!!\\n            \\n        Other half can be build putting 1 in front of all 2-bit codes in reverse fashion[because if we put in forward order we get 2 changed bits in one pair]\\n        \\n        Put 1 in front of all 2-bit codes in reverse fashion\\n\\n        10  => 110\\n        11  => 111\\n        01  => 101\\n        00  => 100\\n\\n        so 3-bit codes are = [000 , 001 , 011 , 010 , 110 , 111 , 101 , 100]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> codes;\\n        \\n        for(string s : get_n_bit_gray_code(n))\\n            codes.push_back(stoi(s , 0 , 2)); // converting string-binary-num to int : \"100\" = 4\\n        return codes;\\n    }\\n    \\n    vector<string> get_n_bit_gray_code(int n)\\n    {\\n        if(n == 1) // base case\\n            return {\"0\" , \"1\"};\\n        \\n        vector<string> v = get_n_bit_gray_code(n - 1);\\n        \\n        vector<string> codes;\\n        \\n        for(int i = 0 ; i < v.size() ; ++i) // forward-fashion traversal to add 0 to front\\n            codes.push_back(\"0\" + v[i]);\\n        \\n        for(int i = v.size() - 1 ; i >= 0 ; --i) // reverse-fashion traversal to add 1 to front\\n            codes.push_back(\"1\" + v[i]);\\n        \\n        return codes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393673,
                "title": "python-recursive-implementation",
                "content": "This uses property of gray codes, that you can mirror and add prefix to get these codes. This is shown in the following image. \\n\\n\\n![image](https://assets.leetcode.com/users/msminhas93/image_1569797075.png)\\n\\nThe code uses basic recursion to add the appropirate prefixes to the original codes and the mirrored codes [obtained by reversing the list of original codes.].\\n\\n```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==0:\\n            return [0]\\n        if n==1:\\n            return [0,1]\\n        if n==2:\\n            return [0,1,3,2]\\n        else:\\n            return self.grayCode(n-1) + [x + (2**(n-1)) for x in self.grayCode(n-1)[::-1]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30006,
                "title": "6-line-java-solution-very-concise",
                "content": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "All we need to do is to add an '1' to the top digit of the binary string and reversely added the new number to the list.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        \\n        for(int i = 0; i < n ; i++)\\n            for(int j = ans.size()-1; j>=0; j--)\\n                ans.add(ans.get(j)+(1<<i));\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 741620,
                "title": "intuitive-solution-using-inputs-cpp-hard-till-you-understand-logic-xd",
                "content": "n==0 {0}  //base case\\nn==1 {0,1} //base case\\nn==2 {00,01,11,10} //traversing from left to right through for n==1 add 0 to the front and traversing from right to left add 1 at the front. \\nn==3 {000,001,011,010,110,111,101,100} // similar as above\\nn==4 {0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1111,1110,1010,1011,1001,1000} \\nNow write for n==5 yourself. \\nNow code ---> \\n```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```\\nPS:Thumbs up if you like it, It will encourage me. Have a nice day :).\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bin(string c)\\n    {\\n        int ans = 0;\\n        for(auto x:c)\\n        {\\n            ans = ans*2  + (x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> grayCode(int n) {\\n        if(n==0)return {0};\\n        if(n==1)return {0,1};\\n        vector<string>vect;\\n        vector<string>ans;\\n        ans.push_back(\"0\");\\n        ans.push_back(\"1\");\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<string>temp;\\n            for(auto c: ans)\\n            {\\n                c.insert(c.begin(),\\'0\\');\\n                temp.push_back(c);\\n            }\\n            for(int k=ans.size()-1;k>=0;k--)\\n            {\\n                ans[k].insert(ans[k].begin(),\\'1\\');\\n                temp.push_back(ans[k]);\\n            }\\n           ans = temp;\\n        }\\n        vector<int>ans1;\\n        for(auto c: ans)\\n        {\\n            ans1.push_back(bin(c));\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29938,
                "title": "simplest-fastest-easiest-solution",
                "content": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        int count = (int)Math.pow(2,n);\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < count; i++){\\n            res.add((i) ^ (i >> 1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30106,
                "title": "recursive-solution-c-6-ms-with-explaination",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            } else {\\n                result.push_back(0);\\n            }\\n            return result;\\n        }\\n        \\n        void grayCodeHelper(int n, vector<int>& res) {\\n            if (n == 1) {\\n                res.push_back(0);\\n                res.push_back(1);\\n                return;\\n            }\\n            \\n            grayCodeHelper(n-1, res);\\n            int size = res.size()-1;\\n            // n elements in res are already a part of\\n            // current gray code as they start with 0 as the MSB\\n            // we need to traverse the res in reverse order, or it \\n            // with 1 to get the next numbers.\\n            // If dont understand, then try making gray code seq\\n            // with 1 and then see how to get graycode(2) from 1.\\n            \\n            for (int i = size; i >= 0; --i) {\\n                int num = res[i] | (1<<(n-1));\\n                res.push_back(num);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result;\\n            if (n > 0) {\\n                grayCodeHelper(n, result);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 681993,
                "title": "java-solution-without-using-any-bitwise-operation-1ms-runtime-complexity",
                "content": "Ping in comment if anybody does not understand the login behind the answer.\\n```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList();\\n        res.add(0);\\n        for(int i=1;i<=n;i++){\\n            int count = res.size()-1;\\n            int add = (int)Math.pow(2,i-1);\\n            while(count>=0)\\n                   res.add(add+res.get(count--));\\n            }\\n     return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 29954,
                "title": "dp-python-solution",
                "content": "dp is a good way to solve this problem. Every time when you increase the n by 1, you add 1 more digit in the front, which means you add 2**(n-1) to dp[n-1][-1] for you  second half number list\\n\\nn = 1: [0,1]\\nn = 2: [0,1]+ [2+0, 2+1][::-1] = [0,1,3,2]\\nn = 3: [0,1,3,2] + [4 + 0, 4 +1, 4 +3, 4 + 2][::-1] = [0,1,3,2,6,7,5,4]\\n\\n```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\n    def grayCode(self, n):\\n        dp = [[0]]\\n        for i in range(1,n+1):\\n            dp.append(dp[i-1] + [2**(i-1) + j for j in dp[i-1]][::-1])\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1921930,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func grayCode(_ n: Int) -> [Int] {\\n        var arr: [Int] = [0]\\n        var e = -1\\n        \\n        func povv(_ n: Int, _ e: Int) -> Int { return Int(pow(Double(n), Double(e))) }\\n        \\n        for i in 1..<povv(2, n) {\\n            if i == povv(2, e + 1) { e += 1 }\\n            \\n            let index = povv(2, e + 1) - i - 1\\n            let num = povv(2, e) + arr[index]\\n            arr.append(num)\\n        }\\n        \\n        return arr\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309424,
                "title": "python3-1-line-solution-list-comprehension",
                "content": "Using List Comprehension, we can easily solve this problem statement in 1 line.\\n```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#   Gray Code Formula:\\n#   n <= 16\\n#   Gray_Code(n) = n XOR (n / 2)\\n\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [i ^ (i // 2) for i in range(pow(2, n))]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110683,
                "title": "python-js-c-go-o-2-n-by-toggle-bitmask-w-example",
                "content": "Python O(2^n) by toggle bitmask\\n\\n---\\n\\nExample with n = 2:\\n\\n1st iteration\\n\\u3000\\u3000 0 0\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 0 \\n  \\n  We get 0\\'b 00 = **0**\\n\\n---\\n\\n2nd iteration\\n\\u3000\\u3000 0 1\\n\\u2295\\u3000  0 0\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30000 1 \\n  \\n  We get 0\\'b 01 = **1**\\n\\n---\\n\\n3rd iteration\\n\\u3000\\u3000 1 0\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 1 \\n  \\n  We get 0\\'b 11 = **3**\\n\\n---\\n\\n4th iteration\\n\\u3000\\u3000 1 1\\n\\u2295\\u3000  0 1\\n\\u2014\\u2014\\u2014\\u2014\\u2014\\n\\u3000\\u30001 0 \\n  \\n  We get 0\\'b 10 = **2**\\n  \\n---\\n\\nFinally, we have gray codes with n=2: \\n[**0**, **1**, **3**, **2**]\\n\\n---\\n\\n**Implementation** in Python:\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\n\\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```\\n\\n</details>\\n\\n---\\nReference:\\n\\n[1] [Wiki: Gray code](https://en.wikipedia.org/wiki/Gray_code)\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        # total 2^n codes for bit length n\\n        code_count = 1 << n\\n        \\n        # generate gray code from 0, and toggle 1 bit on each iteration\\n        # toggle mask: ( i >> 1 )\\n        \\n        gray_codes =[ i ^ ( i >> 1 ) for i in range(code_count) ]\\n        \\n        return gray_codes\\n```\n```\\n\\nvar grayCode = function(n) {\\n\\n    // toal 2^n codes for bit length n\\n    const codeCount = 1 << n;\\n    \\n    let result = [];\\n    \\n    // generate gray code from 0, and toggle 1 bit on each iteration\\n    // toggle mask: ( i >> 1 )\\n    \\n    for(let i = 0 ; i < codeCount ; i++){\\n        \\n        code = i ^ ( i >> 1);\\n        result.push( code );\\n    }\\n    \\n    return result\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        // toal 2^n codes for bit length n\\n        const int codeCount = 1 << n;\\n        \\n        vector<int> result;\\n\\n        // generate gray code from 0, and toggle 1 bit on each iteration\\n        // toggle mask: ( i >> 1 )\\n        \\n        for( int i = 0 ; i < codeCount ; i++ ){\\n            \\n            int mask = i >> 1;\\n            result.push_back( i ^ mask );\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nfunc grayCode(n int) []int {\\n    \\n    // total 2^n codes for bit length n\\n    code_count := 1 << n\\n    \\n    // slice to store gray codes\\n    gray_codes := make([]int, code_count)\\n    \\n    for i:=0 ; i < code_count ; i+=1 {\\n        \\n        toggle_mask := ( i >> 1 )\\n        \\n        gray_codes[ i ] = i ^ toggle_mask\\n    }\\n    \\n    return gray_codes\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280958,
                "title": "1-line-python-recursion",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\\nReferences to [@girikuncoro\\'s solution](https://leetcode.com/problems/gray-code/discuss/30007/Python-Easy-Bit-Manipulation-Solution)\\n\\nOr, you can just use the method of \\'Gray Code\\'\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return (lambda r: r + [x | 1<<n-1 for x in r[::-1]])(self.grayCode(n-1)) if n else [0]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i ^ i >> 1  for i in range(1 << n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216001,
                "title": "python-solution",
                "content": "Recursion. `grayCode(n)` can be obtained by first constructing `grayCode(n-1)` and append `grayCode(n-1)[::-1]` with a bit `1` added in front of every binary number in `grayCode(n-1)[::-1]`. The base case: `grayCode(0) = [0]`.\\n\\nConsider the example `n = 3`. With `n = 2`, we have `grayCode(2) = [00, 01, 11, 10] = [0, 1, 3, 2]`. For `n = 3`, the 4 binary numbers in `grayCode(2)` still show up, i.e., it will contain `[000, 001, 011, 010] = [0, 1, 3, 2]`. To obtain the other 4 binary numbers, we simply flip the first binary digit to `1`, i.e., `[100, 101, 111, 110] = [4, 5, 7, 6]`. Finally, we append `[6, 7, 5, 4]` to `[0, 1, 3, 2]` to obtain the output for `grayCode(3) = [0, 1, 3, 2, 6, 7, 5, 4]`. Note that we have to reverse the second list because `6 (110)` can be obtained from `2 (010)` by flipping one bit, whereas `4 (100)` cannot.\\n\\nTime complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        if n == 1:\\n            return [0, 1]\\n        res = self.grayCode(n-1)\\n        num = 2**(n-1)\\n        res += res[::-1]\\n        for i in range(num,len(res)):\\n            res[i] ^= num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29979,
                "title": "typical-backtracking-solution-without-using-bit-manipulation",
                "content": "This problem is very similar with permutation pronblem. so we can use DFS and backtracking to solve this problem.But the gray code is binary numeral system where two successive values differ in only one bit, so we need to reverse the array which store 0 and 1,  when we add 1 to list which store the binary numbers. When the list's size equal n , convert binary to deciamal and add deciamal to result.\\n\\n`\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }\\n            int[] a = {0, 1};\\n            solver(result, grayCode, a, n);\\n            return result;\\n        }\\n        public void solver (List<Integer> result, List<Integer> grayCode, int[] a, int n) {\\n            if (grayCode.size() == n) {\\n                double sum = 0;\\n                for (int i = 0 ; i < grayCode.size(); i++) {\\n                    if (grayCode.get(i) == 1) {\\n                        sum += Math.pow(2, grayCode.size() - 1 - i);\\n                    }\\n                }\\n                result.add((int)sum);\\n                return;\\n            }\\n            for (int i = 0 ; i < 2; i++) {\\n                grayCode.add(a[i]);\\n                if (a[i] == 0) {\\n                    solver(result, grayCode, a, n);\\n                } else {\\n                    swap(a);\\n                    solver(result, grayCode, a, n);\\n                    swap(a);\\n                }\\n                grayCode.remove(grayCode.size() - 1);\\n            }\\n        }\\n        public void swap (int[] a) {\\n            int temp = a[0];\\n            a[0] = a[1];\\n            a[1] = temp;\\n        }\\n    }`",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<>();\\n            List<Integer> grayCode = new ArrayList<>();\\n            // if (n == 0) {\\n            //     return result;\\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 2212006,
                "title": "c-3-approaches-recursion-iteration-gray-code-property-4-lines",
                "content": "The idea is simple. if we have gray code for n-1, then we can construct gray code for n easily. Imagine, that n = 4 and we have code for n-1 i.e, n=3 [0,1,3,2,6,7,5,4]. \\nThen we need to add numbers in [8, 15].\\nLet us add 8 to each number, so we have [8, 9, 11, 10, 14, 15, 13, 12] which is also code with property that every two adjacent number differ by one bit. All we need to do is to concatenate these two lists, but first we need to invert one of them to get [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8].\\n\\n**Iterative Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\\n**Recursive Code in C++**\\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\\n\\nThe third approach needs the property of gray code.\\n*G ( i ) = i ^ ( i / 2 )*\\nUsing the above property, we can easily generate gray code for any integer.\\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```\\n**Please support me. If you like my effort !!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans={0};\\n        int value;\\n        for(int i=0;i<n;i++){\\n           vector<int> curr;\\n            for(auto it=ans.rbegin();it!=ans.rend();it++){\\n                curr.push_back((1<<i) | (*it) );\\n            }\\n            ans.insert(ans.end(),curr.begin(),curr.end());\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        if(n==0) return {0};\\n        vector<int> curr;\\n        vector<int> prev=grayCode(n-1);\\n        for(int i=prev.size()-1;i>=0;i--){\\n            int value =(1<<(n-1)|prev[i]);\\n            curr.push_back(value);\\n        }\\n        curr.insert(curr.begin(),prev.begin(),prev.end());\\n        return curr;\\n    }\\n```\n```\\n\\tvector<int> grayCode(int n) {\\n        vector<int> ans;\\n        int value;\\n        for(int i=0;i<(1<<n);i++){\\n            value = i^(i>>1); // G(i) = i ^ (i/2)\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310706,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039828,
                "title": "java-simple-backtracking-just-like-permutation-detailed-explanation",
                "content": "Since this problem is tagged with backtracking and I also admit that it\\'s hard for me to come up with a smart algorithm to generate the gray code directly, here I share a pretty standard backtracking solution can be used in other backtracking problems.\\n\\nBit manipulations you need to know:\\n1. `1 << n = 2 ^ n`, in this problem, there\\'s `n` bits in code, so the total number is `2^n` (i.e. 0,1,...,2^n -1). Also, `1 << n` means left shift `1` by `n` bit, the mask in the example below is obtained by `1 << 1`.\\n2. `XOR(^)` operation can toggle/flip a bit, e.g. \\n```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\\n\\nThe problem is basically permutation of `2^n` numbers so that 2 successive numbers in the permutation differ in only one bit. The input size is can be `n = 16`, though `n` is small, generating all permutation of `2^16` numbers and check the validity would definitely lead to TLE. So we need to prune while we do the permutation. \\n\\nTo meet the 2 number differ in 1 bit constraint, we found that `XOR` operation is useful to generate the next valid number. Also, we only need ANY ONE of the valid permutaion, so when we find one, just return it, avoid further search. Like in the [permutations](https://leetcode.com/problems/permutations/) problem, we need to track the number is used or not since we can use different number only once.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nTime Complexity: `O(2^n)`, a very loose bound\\nSapce: `O(2^n)`",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n    1 1 0  (original)\\n^   0 1 0  (mask)\\n----------\\n    1 0 0  (result)\\n\\t\\nThe middle bit of original is flipped, so that original and result only differ by 1 bit.\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> curr = new ArrayList<>();\\n        curr.add(0);\\n        boolean[] used = new boolean[1 << n];\\n        used[0] = true;\\n        backtrack(n, curr, used);\\n        return curr;\\n    }\\n    \\n    private boolean backtrack(int n, List<Integer> curr, boolean[] used) {\\n        if (curr.size() == 1 << n) {\\n            return true;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int nex = (1 << i) ^ curr.get(curr.size() - 1); // (1 << i) is the mask in example, nex is next valid number\\n            if (used[nex]) continue;\\n            used[nex] = true;\\n            curr.add(nex);\\n            if (backtrack(n, curr, used)) return true;\\n            used[nex] = false;\\n            curr.remove(curr.size() - 1);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30069,
                "title": "short-and-clear-iterative-c-solution",
                "content": "Very easy to understand, just generate the results using already generated values. Used a few intermediate variables for clarity.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0};\\n            for (int i = 0; i < n ; ++i)\\n            {\\n                int p = 1<<i;\\n                int s = out.size();\\n                while (s)\\n                {\\n                    int v = p | out[--s];\\n                    out.push_back(v);\\n                }\\n            }\\n    \\n            return out;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            \\n            vector<int> out = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2340177,
                "title": "simple-java-solution",
                "content": "Total no bits =1<<n,\\n   ![image](https://assets.leetcode.com/users/images/98335758-385b-4a2d-9ba4-9b3cd077c2c8_1658910773.2479193.png)\\n for n=3 total no bits=8.\\ni=0,   j=i>>1 = 0    i ^ j=0\\ni=1,    j=i>>1 = 0    i ^ j=1\\ni=2    j=i>>1 = 1     i ^ j=3          \\ni=3    j=i>>1 = 1     i ^ j=2        \\ni=4    j=i>>1 = 2     i ^ j=6\\ni=5    j=i>>1 = 2     i ^ j=7\\ni=6    j=i>>1 = 3     i ^ j=5\\ni=7    j=i>>1=3        i^j=4\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }\\n         return list;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public List<Integer> grayCode(int n) {\\n      ArrayList list=new ArrayList();\\n       for(int i=0;i<(1<<n);i++){\\n         list.add(i^(i>>1));\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 852558,
                "title": "detailed-explanation-with-example-100-faster",
                "content": "This is very basic problem of generating the first n numbers in `GRAY CODE` representation.\\nDefinition of GRAY Code is already described in the description of the problem statement. So I\\'m skipping that here. And if it\\'s not cleared from there then probably by going through what I\\'ve described below it will make it more clearer.\\n\\nSo first lets take a look how BINARY and GRAY codes are different from one another.\\n\\n| Binary \\t| Gray \\t|\\n|--------\\t|------\\t|\\n| 0000   \\t| 0000 \\t|\\n| 0001   \\t| 0001 \\t|\\n| 0010   \\t| 0011 \\t|\\n| 0011   \\t| 0010 \\t|\\n| 0100   \\t| 0110 \\t|\\n| 0101   \\t| 0111 \\t|\\n| 0110   \\t| 0101 \\t|\\n| 0111   \\t| 0100 \\t|\\n| 1000   \\t| 1100 \\t|\\n| 1001   \\t| 1101 \\t|\\n| 1010   \\t| 1111 \\t|\\n| 1011   \\t| 1110 \\t|\\n| 1100   \\t| 1010 \\t|\\n| 1101   \\t| 1011 \\t|\\n| 1110   \\t| 1001 \\t|\\n| 1111   \\t| 1000 \\t|\\n\\nNow try to see some pattern how the numbers are generated. At every 2<sup>x</sup> where x = [0,n) element you put mirror of `x` index and copy the same number of elements in reverse order as you see them in mirror and add 2<sup>x</sup> to it.\\n\\nLet me explain it with an example\\n\\nInitial element that will be present in the list = [0]\\n\\nlist = [0]\\n\\nNow put mirror of length x = 0 at 2<sup>0</sup>=1 index \\n```\\n0\\n-\\n```\\n\\nNow  copy the same number of elements and add 2<sup>0</sup> to it\\n```\\n0\\n-\\n0 + 1 = 1\\n```\\n\\nthis was for n = 1, now for n=2 lets do the same thing, put mirror of length x = 1 at 2<sup>1</sup>=2 index and add 2<sup>1</sup> to it.\\n\\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\\n\\nNow for 2 bit, the gray number in decimal format looks like\\n```\\n0\\n1\\n3\\n2\\n```\\n\\nNow for 3 bit, lets do the same thing, put mirror at length x = 2 at 2<sup>2</sup> index and add 2<sup>2</sup> to all of them\\n\\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\\n\\nand so on. \\n\\nIf it is still not clear please comment below I\\'ll try to make it more clearer by adding more examples\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```\\n\\nPlease do upvote if the explaination helped you in understanding the solution.",
                "solutionTags": [],
                "code": "```\\n0\\n-\\n```\n```\\n0\\n-\\n0 + 1 = 1\\n```\n```\\n0 = 00\\n1 = 01\\n-\\n1(binary) + 10 (binary)  = 11\\n0(binary) + 10 (binary) = 10\\n```\n```\\n0\\n1\\n3\\n2\\n```\n```\\n00 = 000\\n01 = 001\\n11 = 011\\n10 = 010\\n--\\n10 (binary) + 100 (binary) = 110\\n11 (binary) + 100 (binary) = 111\\n01 (binary) + 100 (binary) = 101\\n00 (binary) + 100 (binary) = 100\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\t\\n\\t\\t// Handling negative n\\n        if (n < 0) {\\n            return list;\\n        }\\n\\t\\t// Initial value\\n        list.add(0);\\n\\t\\t\\n        int mirror = 0;\\n        while (mirror < n) {\\n            int count = list.size();\\n            for (int i = count-1; i >= 0; i--) {\\n                list.add((1 << mirror) | list.get(i)); // this will get the value from list and add 2^mirror to the number as we discussed above\\n            }\\n            mirror++;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29978,
                "title": "java-short-code-with-explanation",
                "content": "how to go from  i = 1 [0,1] to i=2?\\n\\n1.copy list of i=1 in reverse order\\n\\n0, 1 || 1, 0\\n\\n\\n2 append \"1\" in front all numbers of the copy\\n\\n0, 1 || 11, 10\\n \\n\\n\\n\\n       public class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }\\n                    mask <<= 1;\\n                }\\n                return list;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public List<Integer> grayCode(int n) {\\n                List<Integer> list = new ArrayList<>();\\n                list.add(0);\\n                int mask = 1;\\n                for (int i = 1; i <= n; i++) {\\n                    // change from len i-1 to i\\n                    for (int j = list.size() - 1; j >= 0; j--) {\\n                        list.add(list.get(j) | mask);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 30108,
                "title": "java-solution-use-a-stack-easy-to-figure-out-simple-and-interesting",
                "content": "    0\\t\\t0\\n    1\\t\\t1\\n    \\n    00  \\t\\t0\\n    01\\t\\t1\\t\\t+1\\n    11\\t\\t3\\t\\t--------\\n    10\\t\\t2\\t\\t-1\\n    \\n    000\\t\\t0\\n    001\\t\\t1\\t\\t+1\\n    011\\t\\t3\\t\\t+2\\n    010\\t\\t2\\t\\t-1\\t\\n    110\\t\\t6\\t\\t-----------\\n    111\\t\\t7\\t\\t+1\\t\\t\\t\\n    101\\t\\t5\\t\\t-2\\n    100\\t\\t4\\t\\t-1\\n    \\n    \\n    0000\\t\\t0\\n    0001\\t\\t1\\t\\t+1\\n    0011\\t\\t3\\t\\t+2\\n    0010\\t\\t2\\t\\t-1\\n    0110\\t\\t6\\t\\t+4\\n    0111\\t\\t7\\t\\t+1\\n    0101\\t\\t5\\t\\t-2\\n    0100\\t\\t4\\t\\t-1\\n    1100\\t\\t12\\t\\t-----------\\n    1101\\t\\t13\\t\\t+1\\n    1111\\t\\t15\\t\\t+2\\t\\n    1110\\t\\t14\\t\\t-1\\n    1010\\t\\t10\\t\\t-4\\n    1011\\t\\t11\\t\\t+1\\n    1001\\t\\t9\\t\\t-2\\n    1000\\t\\t8\\t\\t-1\\n\\n\\nFrom the above example, I believe you will find out that why use a stack here, all the post half is the pre half plus the Math.pow(2, i) in the symmetric form!!!\\n\\n\\n    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }\\n                while(!stack.isEmpty()) {\\n                    list.add(stack.pop() + inc);\\n                }\\n                i++;\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<Integer> stack = new Stack<Integer>();\\n            list.add(0);\\n            int i = 0;\\n            while(i < n) {\\n                int len = list.size();\\n                int inc = (int)(Math.pow(2, i));\\n                for(int j=0; j<len; j++) {\\n                    stack.push(list.get(j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2697032,
                "title": "c-java-go-3-line-code-easy-to-understand",
                "content": "***Explain:***\\nGray code is a binary numeral system where two successive values differ in only one bit.\\nFor example, the sequence of Gray codes for 3-bit numbers is: 000, 001, 011, 010, 110, 111, 101, 100.\\nFor more details read this blog ([Gray Code](https://cp-algorithms.com/algebra/gray-code.html))\\n\\n**C++ Solution:** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n\\n\\n**JAVA Solution:**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\\n\\n\\n**GO Solution:**\\n\\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        for(int i=0; i<1<<n; i++) {\\n            v.push_back(i^i>>1);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n       List<Integer> v = new ArrayList<Integer>();\\n        for(int i=0; i<1<<n; i++) {\\n            v.add(i^(i>>1));\\n        }\\n        return v;\\n    }\\n}\\n```\n```\\nfunc grayCode(n int) []int {\\n    var v []int\\n    for i:=0; i<1<<n; i++ {\\n        v =append(v, i^(i>>1));\\n    }\\n    return v;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308829,
                "title": "gray-code-bitmanip-c",
                "content": "### What\\'s the Problem?\\nIn this problem, we have to frame a list of numbers from 0 to 2^n, such that the adjacent numbers and the first and last numbers should have only 1 bit difference.\\n\\n### What to Do?\\nFor any number, if we divide it by 2, it gets 1 bit shifted. \\nEg: 2 = 00**10**\\n2/2 = 1 = 00**01**\\n\\nif the values are XORed, it gives the number with 1 bit difference of the previous number.\\nEg. \\n0 ^ (0/2) = 0 = 00**00**\\n1 ^ (1/2) = 1 ^ 0 = 1 = 00**01**\\n2 ^ (2/2) = 2 ^ 1 = 3 = 00**11**\\n3 ^ (3/2) = 3 ^ 1 = 2 = 00**10**\\n\\nThis idea can be used to solve the problem.\\n\\nHope that Helps!\\n\\n### My C++ Code:\\n```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> grayCode(int n) {\\n        int x = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < (1 << n); ++i) {\\n            x = (i/2) ^ i;\\n            ans.push_back(x);\\n        } return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 971284,
                "title": "bits-backtracking-explanation-visual-python",
                "content": "## Use Traditional Backtrack Template\\n\\nTL;DR using a traditional backtracking template \\n\\n```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\\n\\n### Walkthrough\\n\\n![image](https://assets.leetcode.com/users/images/0b9fd653-8a79-4918-bac7-354f33a9f9a1_1607888555.8872228.png)\\n\\n### Explanation\\n\\nGray Code: to get to next code in seqeunce, flip exactly 1 bit.\\nour return values should be the value the gray code represents in binary. \\n\\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\\n##### Number of Possible Gray Codes\\nGiven ```N``` bits, there are ```2^N``` possible gray codes. All adjacent gray codes in the sequence differ by ```1``` bit. for every bit we make a choice to turn this bit on or off. our decision is ***binary*** and this is done for all ```N``` bits. Our result will contain ```2^N``` gray codes. \\n\\n#### Algorithm\\n1. To generate the next candidate in the sequence, a single bit must be flipped. we flip the left most bit (excluding leading zeros). \\n\\n2. To flip the left most bit we use a mask, the last known candidate, and the XOR operation. \\n3. If we ever generate a candidate that has aready been seen, it is not added to the result and no recursive call is made. instead generate a new candidate, by generating a larger mask. \\n\\t* Becuase we only make recursive call when a valid candidate is found and then immedaitely return, there is no need for the traditional undoing found in most backtracking problems. all that must be done is to ignore duplicate codes generated. \\n\\nThis problem isnt as ```backtracking like``` as i initially thought. \\n\\n\\n***Note:***\\nthe recursion tree ends up always resulting in a linked list regardless of N, because we keep going as deep as possible until we have all possible gray codes.\\n\\n\\n[code courtesy of fabrizio3](https://leetcode.com/problems/gray-code/discuss/30087/Backtracking-Solution)\\n\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```python\\n  def grayCode(self, n: int) -> List[int]:\\n\\t\\tresult = [0]  \\n\\t\\t# 2^n possible gray codes \\n\\t\\tself.backtrack(result, n, 0, pow(2, n))\\n\\t\\treturn result\\n\\t\\t\\n  def backtrack(self, result, n, curr, size):\\n\\t\\t# all gray codes same length \\n        if len(result) == size: return \\n        for i in range(n):\\n            mask = 1 << i \\n\\t\\t\\t#generate candidate by flipping left most bit\\n            candidate = curr ^ mask\\n\\t\\t\\t# avoid duplicates \\n            if candidate not in result:\\n                result.append(int(candidate))\\n                self.backtrack(result, n, candidate, size\\n\\t\\t\\t\\t# reduce number of recursive calls made\\n                if len(result) == size: return \\n```\n```      \\nGray Code -> Return Value \\n00 ->  0\\n01 ->  1\\n11 ->  3\\n10 ->  2\\n```\n```N```\n```2^N```\n```1```\n```N```\n```2^N```\n```backtracking like```",
                "codeTag": "Python3"
            },
            {
                "id": 534055,
                "title": "python-5-line-solution-without-prior-knowledge-of-gray-code",
                "content": "If we already have the array R<sub>n</sub> consisting of 2<sup>n</sup> numbers of n bits in the gray code order, then the next 2<sup>n</sup> numbers is just the reversed R<sub>n</sub> with additional value 2<sup>n</sup> on every number.\\n```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```\\nVote up if find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef grayCode(self, n: int) -> List[int]:\\n    b, r = 1, [0]\\n    for _ in range(n):\\n        r += [i|b for i in reversed(r)]\\n        b <<= 1\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 29909,
                "title": "javascript-recursive-solution-using-reflected-gray-code",
                "content": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```\\nThe strategy is described [here](https://en.wikipedia.org/wiki/Gray_code#Constructing_an_n-bit_Gray_code) and can also be done iteratively.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar grayCode = function(n) {\\n    if (n === 0) return [0];\\n    const res = grayCode(n - 1);\\n    const mask = 1 << n - 1;\\n    for (let i = res.length - 1; i >= 0; i--) {\\n        res.push(res[i] | mask);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30027,
                "title": "1ms-java-solution-with-explaination",
                "content": "    public class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }\\n            \\n            //add the new generated value to the result list\\n            //the new generated value is the last result add front value\\n            int size=result.size();\\n            //we want to loop through the (n-1) result from end to start. This is just because want to make the test case match the Leetcode answer. You can use other way loop through the (n-1) result.\\n            for(int k=size-1; k>=0; k--){\\n                result.add(result.get(k)+front);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //analyze the pattern\\n    //n=0  -> 0\\n    //n=1  -> 0, 1\\n    //n=2  -> (00,  01),  (10,  11)\\n    //n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)\\n    \\n    //so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)\\n    //                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)\\n    \\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList();\\n        result.add(0);\\n        \\n        for(int i=1; i<=n; i++){\\n            int front=1;\\n            //Create the correct value for binary format (10...0) which the value has i digi\\n            //so shift 1 to right (i-1) times\\n            for(int j=1; j<i; j++){\\n                front = front<<1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30109,
                "title": "backtracking-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }\\n        public void helper(List<Integer> result,List<Integer> list,int n){\\n            \\n            if(list.size() == Math.pow(2,n)){\\n                result.addAll(list);\\n                return;\\n            }\\n            int last = list.get(list.size() - 1);\\n            \\n            for(int i = 0; i < n; i++){\\n                int off = 1 << i;\\n                int cur = last ^ off;\\n                \\n                if(list.contains(cur)) continue;\\n                \\n                list.add(cur);\\n                helper(result,list,n);\\n                \\n                if(result.size() > 0) return;\\n                list.remove(list.size() - 1);\\n            }\\n            \\n        } \\n    }\\n    }\\n\\nUsing backtracking without knowing gray code knowledge. Find one solution and return.",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            helper(result,list,n);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3433391,
                "title": "c-java-remember-this-formula",
                "content": "## Explanation\\nIt is not very intuitive to come up with a solution for this problem in an interview if you haven\\'t solved this already. But there is a simple formula/ technique to remember to solve this one without much hassle !!\\n\\nIf n = 0 => {0}\\nIf n = 1 => {0,1} `{0 , 0 + pow(2,0)}`\\nIf n = 2 => {0,1,3,2} `{0 , 1 , 1 + pow(2,1) , 0 + pow(2,1)}`\\nIf n = 3 => {0,1,3,2,6,7,5,4} `{0 , 1 , 3 , 2 , 2 + pow(2,2) , 3 + pow(2,2) , 1 + pow(2,2) , 0 + pow(2,2)}`\\n\\nHere you can observe a pattern !!\\n\\nAt each step where we\\'re supposed to calculate the gray code of `i` , **Reverse the gray code list of i-1 and add the value pow(2,i-1) to all the elements of the reversed list. Append the modified and reversed list to the (i-1) list.**\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res{0};\\n        for(int i = 1; i <= n; i++) {\\n            vector<int> rev = res;\\n            reverse(begin(rev), end(rev));\\n            int val = pow(2,i-1);\\n            for(int v : rev) res.push_back(v+val);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n\\n        for(int i = 1; i <= n; i++){\\n            List<Integer> rev = new ArrayList<>(list);\\n            Collections.reverse(rev);\\n            int val = (int)Math.pow(2,i-1);\\n            for(int v : rev) list.add(v+val);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630427,
                "title": "2-lines-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```\\n**Find helpful Upvote it**\\n**For Detailed DSA Applications refer to respective README files**\\nhttps://github.com/teja963/Advanced-DSA",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>current;\\n\\t\\t/*\\n\\t\\t0 1 2 3 4 5 6 7 -- in range(0,2^n-1) \\n\\t\\t0 1 3 2 6 7 5 4 - required answer order(now observe difference with xor\\n\\t\\t--------------------------------------------------\\n\\t\\t0 0 1 1 2 2 3 3  - for getting these values i >> 1\\n\\t\\t*/\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            current.push_back(i ^ i>>1);\\n        }\\n        return current;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334453,
                "title": "java-simple-and-easy-iterative-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        List<Integer> codes = new ArrayList((1 << n));\\n        codes.add(0);\\n        \\n        for(int i = 0; i < n; i++){\\n            int size = codes.size();\\n            \\n            //most significant bit\\n            int msb = 1 << i;\\n            \\n            for(int j = size - 1; j >= 0; j--){\\n                //append msb\\n                int num = codes.get(j) | msb;\\n                \\n                codes.add(num);\\n            }\\n        }\\n        \\n        return codes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319275,
                "title": "python-easy-to-understand-3-line-recursive-solution",
                "content": "We see the pattern:\\n```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\\nNotice the following recursive relation:\\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\\n`new_part` consists of `1` added to the left of each item in reversed sequence of `grayCode(n-1)`.\\n\\nThis leads us to the following code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```\\nTime complexity: `O(n)`.",
                "solutionTags": [],
                "code": "```\\n1: [0,1]\\n2: [00,01,11,10]\\n3: [000,001,011,010,110,111,101,100]\\n```\n```\\ngrayCode(n) = [grayCode(n-1), new_part]\\n```\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n==1: return [0,1]\\n        prev = self.grayCode(n-1)\\n        return prev + [2**(n-1)+i for i in prev[::-1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309277,
                "title": "easy-to-understand-solution",
                "content": "The idea is that we can leverage the fact that the last bits reverse when we move from n-1 to n and we have to concat the bit `1` as the prefix.\\n\\nEg:\\nFor `n=2`: Gray-code sequence is\\n```\\n00\\n01\\n11\\n10\\n```\\n\\nNow for `n=3` we copy the above sequence in reverse order and add prefix `0` to existing codes and `1` to newly generated codes\\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n00\\n01\\n11\\n10\\n```\n```\\n0 | 00\\n0 | 01\\n0 | 11\\n0 | 10\\n-------\\n1 | 10\\n1 | 11\\n1 | 01\\n1 | 00\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        String[] grayCodes = binaryGrayCodes(n);\\n        List<Integer> result = new ArrayList<>();\\n        for(String grayCode: grayCodes){\\n            result.add(Integer.parseInt(grayCode,2));\\n        }\\n        return result;\\n    }\\n    \\n    private String[] binaryGrayCodes(int n) {\\n        int total = (int) Math.pow(2,n);\\n        String[] grayCode = new String[total];\\n        grayCode[0]=\"0\";\\n        grayCode[1]=\"1\";\\n        \\n        for(int i=2;i<=n;i++){\\n            int start = (int) Math.pow(2,i-1);\\n            for(int j=0;j<start;j++){\\n                if(grayCode[start-j-1].length()<i-1){\\n                    grayCode[start-j-1] = \"0\".concat(grayCode[start-j-1]);\\n                }\\n                grayCode[start+j]=\"1\".concat(grayCode[start-j-1]);\\n            }\\n        }\\n        \\n        return grayCode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30009,
                "title": "11-lines-c-solution-4ms",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int  len = 1 << n;\\n            vector<int> res(len,0);\\n            for(int i = 0;i != len;++i){\\n                res[i] =i ^ (i >> 1); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30046,
                "title": "ac-python-44ms-solution",
                "content": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n        ans = [0]\\n        for i in xrange(n):\\n            for j in xrange(len(ans) - 1, -1, -1):\\n                ans.append(1 << i | ans[j])\\n        return ans\\n\\n\\n    # 12 / 12 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 44 ms\\n    # 92.86%\\n\\n\\nAppend a bit of 1 in front of on every number to generate next batch.",
                "codeTag": "Python3"
            },
            {
                "id": 30079,
                "title": "this-is-the-standard-backtracking-method",
                "content": "Well, I write a method using standard backtracking way. \\n\\n    class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }\\n            return sum;\\n        }\\n    \\n        void backtrack(bitset<32> &c, int k, int n, vector<int> &result)\\n        {\\n            if(++k == n)\\n                result.push_back(Bit2Int(c, n));\\n            else\\n            {\\n                backtrack(c, k, n, result);\\n                c.flip(k);\\n                backtrack(c, k, n, result);\\n            }\\n        }\\n    \\n        vector<int> grayCode(int n) {\\n            if(!n)\\n                return vector<int>{0};\\n            else if(n == 1)\\n                return vector<int>{0, 1};\\n            vector<int> result;\\n            bitset<32> c;\\n            backtrack(c, -1, n, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        int Bit2Int(bitset<32> &c, int n)\\n        {\\n            int sum = 0;\\n            for(int i = 0; i < n; i++)\\n            {\\n                sum <<= 1;\\n                sum += c[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3065429,
                "title": "simple-solution-in-c-with-explanation",
                "content": "# Intuition\\nThis was a pattern I noticed on writing out some examples:\\nn=1 -> 0,1\\nn=2 -> **0,1**,3,2\\nn=3 -> **0,1,3,2**,6,7,5,4\\nn=4 -> **0,1,3,2,6,7,5,4**,12,13,15,14,10,11,9,8\\n\\nNoticed for all cases above n>1, it took the first part from the previous case for n-1 and for the remaining half, the values were formed by going through the list in reverse order and adding a factor(pow(2,n-1)) to each number.\\n\\nFor n=3,\\nthe first bold half is taken from n=2 -> 0,1,3,2 and we added 4 (pow(2,2)) to each number from the reverse order. i.e we appended 2+4=**6**, 3+4=**7**, 1+4=**5**, 0+4=**4** in that specific order.\\n\\n# Approach\\nWe used the logic derived at the intution to implement the code below:\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        \\n        int iteration = 1;\\n        int fac = 1;\\n        vector<int> result{0, 1};\\n\\n        for( ; iteration < n ; iteration++ ){\\n            fac = fac*2;\\n            int l = result.size()-1;\\n            for( ; l>=0 ; l-- ){\\n                int val = result[l] + fac;\\n                result.push_back(val);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769433,
                "title": "java-solutionjs-easy",
                "content": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n\\tpublic List<Integer> grayCode(int n) \\n\\t{\\n\\t\\t// 0: [0]\\n\\t\\t// 1: [0,1]\\n\\t\\t// 2: [0,1,3,2]\\n\\t\\t// 3: [0,1,3,2,6,7,5,4]\\n\\t\\t// 4: [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n\\n\\t\\tint edge = 1 << n; // (1 << n) == 2 ** n\\n\\t\\tInteger[] ans = new Integer[edge];\\n\\t\\tans[0] = 0;\\n\\t\\tint lngth = 1; // is the length of the previous block\\n\\t\\tint i, j = 1;\\n\\n\\t\\twhile (j != edge)\\n\\t\\t{\\n\\t\\t\\tlngth = j;\\n\\n\\t\\t\\tfor(i = lngth - 1; i >= 0; i--)\\n\\t\\t\\t\\tans[j++] = ans[i] | lngth; // ans[i] | lngth  == ans[i] + lngth \\n\\t\\t}\\n\\n\\t\\treturn Arrays.asList(ans);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104825,
                "title": "c-short-recursive-approach-without-bit-manipulation",
                "content": "To calculate Graycode(n), we basically need to prefix 0 to each number GrayCode(n-1), prefix 1 to each number in reversed GrayCode(n-1), and add them up. \\n\\nPrefixing 1 can be done by adding 2^(n-1).\\n\\nExample GrayCode(2) to GrayCode(3) :\\n0 00\\n0 01\\n0 11\\n0 10\\n1 10\\n1 11\\n1 01\\n1 00\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nI hope this helps :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1){\\n            return {0,1};\\n        }\\n        vector<int> ans = grayCode(n-1);\\n        int ans_size = ans.size();\\n        int a = pow(2,n-1);\\n        for(int i=ans_size-1;i>=0; i--){\\n            ans.push_back(ans[i]+a);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492687,
                "title": "java-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        \\n        if(n == 1)\\n        {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(0);list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<>();\\n        \\n        for(int i=0;i<pres.size();i++)\\n            mres.add(0+2*pres.get(i));\\n        \\n        for(int i=pres.size()-1;i>=0;i--)\\n            mres.add(1+2*pres.get(i));\\n        \\n        return mres;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309954,
                "title": "c-mirroring-previous-result-solution-explained-100-time-95-space",
                "content": "The tricky part of this problem is to spot a pattern.\\n\\nLet\\'s assume we have a given 2<sup>n</sup> elements that correctly match the requirements, like:\\n\\n```cpp\\n0, 1, 3, 2\\n```\\n\\nYou can find the next expected 2<sup>n</sup> of them (thus going up to 2<sup>n + 1</sup>) by mirroring those numbers and adding 2<sup>n</sup> to all of them, thus obtaining:\\n\\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\\n\\nNow, we that in mind, we can start working on what we know we need to do, creating a variable `res` already of the correct size (2<sup>n - 1</sup> or rather `2 << --n`), to avoid reallocations.\\n\\nWe will then loop `n + 1` times, with `a` and `b` (the latter initially set to `0`) and:\\n* set `a` to be `b + 1` -  both the starting index and the added value of our sequence;\\n* right shift `b` by `1` position;\\n* add `1` to `b` as its least significant bit;\\n* loop `a` times with `j` and having `k` initially set to `b`, increasing `j` and decreasing `k` at each iteration and:\\n\\t* set `res[k]` to be `res[j] + a` (with `j` and `k` pointing at mirrored cells in the same subsequence).\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n0, 1, 3, 2\\n```\n```cpp\\n0, 1, 3, 2, 6, 7, 5, 4\\n// ie: 0, 1, 3, 2, 2 + 4, 3 + 4, 1 + 4, 0 + 4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        // support variables\\n        vector<int> res(2 << --n);\\n        for (int i = 0, a, b = 0; i <= n; i++) {\\n            // updating variables\\n            a = b + 1;\\n            b <<= 1;\\n            ++b;\\n            // building the next a elements as a mirror of the previous a, plus a\\n            for (int j = 0, k = b; j < a; j++, k--) res[k] = res[j] + a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308565,
                "title": "c-simple-and-short-solution-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res = {0};\\n        int size;\\n        \\n        for (int i = 0; i < n; i++) {\\n            size = res.size();\\n            for (int j = size - 1; j >= 0; j--) {\\n                res.push_back(res[j] | 1 << i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504836,
                "title": "javascript-solution",
                "content": "### The idea\\n*Based on top voted discussion*\\nSimulation:\\n| n=0 | n=1 | n=2 | n=3 |\\n|----:|----:|----:|----:|\\n| 000 | 000 | 000 | 000 |\\n|     | 001 | 001 | 001 |\\n|     |     | 011 | 011 |\\n|     |     | 010 | 010 |\\n|     |     |     | **110** |\\n|     |     |     | **111** |\\n|     |     |     | **101** |\\n|     |     |     | **100** |\\n1. From observation, we can see that at every level, we keep the previous results as the first part. The second part is just adding `1` at the begining in reverse order.\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\\n**Shorter Ver.**\\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        for (let j=arr.length-1;j>=0;j--) {\\n            arr.push(arr[j] | 1<<i);\\n        }\\n    }\\n    return arr;\\n};\\n```\n```\\nvar grayCode = function(n) {\\n    let arr = [0];\\n    for (let i=0;i<n;i++) {\\n        arr.push(...arr.map((v)=>v|1<<i).reverse());\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485439,
                "title": "java-solution-with-explanation-7-lines-code",
                "content": "This problem is not complicated, we just need to find the regularity.\\nn = 1: (0, 1)-> (0,1);\\nn = 2: (00, 01, 11, 10)->(0, 1, 3, 2);\\nn = 3: (000, 001, 011, 010, 110, 111, 101, 100) -> (0, 1, 3, 2, 6, 7, 5, 4);\\n\\nAt first we compare n = 1 and n = 2. we find that :\\n0 appends (0,1) = (00, 01);  0 + 0 = 0, 0 + 1 = 1; \\nrevese (0,1) -> (1, 0)\\n1 appends (1,0) = (11, 10);  2 + 1= 3,  2 + 0 = 2; \\n\\nThen we compare n = 2 and n =3. we find that:\\n0 appends (00, 01, 11, 10) = (000, 001, 011, 010); 0 + 0 = 0, 0 + 1 = 1, 0 + 3 = 3, 0 + 2 = 2;\\nrevese (00, 01, 11, 10) -> (10, 11, 01, 00)\\n1 appends (10, 11, 01, 00) = (110, 111, 101, 100); 4 + 2 = 6, 4 + 3 = 7, 4 + 1 = 5, 4 + 0 = 4;\\nThe regularity is very obvious.\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(0);\\n        for(int i = 0; i < n; i++){\\n            for(int j = ans.size() - 1; j >= 0; j--){\\n                ans.add(ans.get(j) + (int)Math.pow(2, i));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393991,
                "title": "java-beats-100-with-explaination",
                "content": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * n=0, \\u987A\\u5E8F:0\\n * n=1, \\u987A\\u5E8F:0,1\\n * n=2, \\u987A\\u5E8F:00,01,11,10\\n * n=3, \\u53EF\\u4EE5\\u8FD9\\u4E48\\u6784\\u6210,\\u7B2C\\u4E00\\u4E2A\\u6570\\u662F110(100 + 10),\\u5373\\u7B2Cn\\u4F4D\\u7F6E1,\\u52A0\\u4E0An=2\\u7684\\u6700\\u540E\\u4E00\\u4E2A\\u6570;\\u7B2C\\u4E8C\\u4E2A\\u6570\\u5C31\\u662F111(100+11),\\u5982\\u6B64\\u9006\\u5E8F\\u904D\\u5386\\u5B8Cn=2\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u5373\\u53EF.\\n * n=4, \\u540Cn=3\\u7684\\u89C4\\u5F8B.\\n*/\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(1<<n);\\n        res.add(0);\\n        if (n == 0) {\\n            return res;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            int lastIdx = res.size() - 1;\\n            int add = 1 << (i - 1);\\n            for (int j = lastIdx; j >= 0; j--) {\\n                res.add(add + res.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280620,
                "title": "java-beats-100-and-100-memoryemory",
                "content": "reference \\uFF1Ahttps://en.wikipedia.org/wiki/Gray_code\\nBinary to Gray Code\\uFF1A    \\n![image](https://assets.leetcode.com/users/u2647/image_1557797884.png)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int len = (int) Math.pow(2, n);\\n        List<Integer> ans = new ArrayList<>(len);\\n        for (int i = 0; i < len; i++) {\\n            ans.add(i ^ (i >> 1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279206,
                "title": "very-intuitive-o-n-c-solution-11-lines-explained-with-examples",
                "content": "Okay so this question is actually pretty simple once you figure out the pattern:\\n\\nfor 2:\\n00\\n01\\n11\\n10\\n\\nfor 3: (pay attention to how the right part is same as 2 until 5th line)\\n(0)-00\\n(0)-01\\n(0)-11\\n(0)-10 (you can see it is just reversed after this point)\\n(1)-10\\n(1)-11\\n(1)-01\\n(1)-00\\n\\nLikewise, for each step, you only have to go backwards in your vector and then add the newdigit which will be powers of 2 since it is binary count.\\n\\nExample:\\nif my current vector is {0,1,3,2} for n = 2, \\nthen for n = 3 --> {0,1,3,2, (2+4), (3+4), (1+4), (0+4)} --> {0,1,3,2,6,7,5,4}\\n\\n``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\n    vector<int> grayCode(int n) {\\n        vector<int> gray;\\n        gray.push_back(0);\\n        int newdigit = 1;\\n        while(n>0){\\n            for(int i = gray.size() - 1; i >= 0; i--){\\n                gray.push_back(gray[i]+newdigit);\\n            }\\n            newdigit *= 2;\\n            n--;\\n        }\\n        return gray;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261362,
                "title": "java-beats-100-in-time-and-100-in-space",
                "content": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> grayCode(int n) {\\n        list.add(0);\\n        for(int i=0;i<n;i++){\\n            recur(i);\\n        }\\n        return list;\\n    }\\n    \\n    public void recur(int j){\\n        int diff = (int)Math.pow(2,j);\\n        int size = list.size();\\n        for(int i=size-1;i>=0;i--){\\n            int x = list.get(i);\\n            list.add(x+diff);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210895,
                "title": "c-with-picture",
                "content": "For each new bit, we are reusing the existing gray code sequence. We are combining the new bit with the reflection of the existing sequence, so that newly added numbers comply with the 1-bit difference rule.\\n![image](https://assets.leetcode.com/users/votrubac/image_1546070487.png)\\n```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n  vector<int> res = { 0 };\\n  for (auto f = 1; n > 0; f <<= 1, --n)\\n    for (int j = f - 1; j >= 0; --j) \\n        res.push_back(res[j] + f);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29933,
                "title": "o-2-n-time-complexity-o-1-space-with-my-explanation",
                "content": "The obvious way when I first saw this question is using backtracking/brute-force. By Grey Code definition, \\n1. from 0, I try to modify each bits from very right to left. \\n2. after modify this bits, If there is no such num in my hashSet, put it into hashSet and also result list, if there is such num in my hashSet, move to higher bits and repeat step 2, until get 2^n numbers\\n\\nI assume n bits must have a way to transfer 0-2^n-1 to gray code. The following is proof. \\nI use induction to proof this. So we proof If k bits can get 2^k gray code, then k+1 bits can get 2^(k+1) gray code. For the k + 1 bits gray codes, the first 2^k gray codes' highest bit is \"0\", with the same order of k bits's gray code. the second 2^k gray codes' highest bit is \"1\" with the symmetrical order of k bits' gray code. Such, we get the 2^(k+1) gray code.\\nFor this solution, time complexity is n*2^n, 2^n numbers and to get each numbers, at most n bits to modify.\\n\\nIt is far away from optimization. So I try another way. \\n```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```\\ni ^ (i >> 1) means for i-th gray code, we can get it by the following way:\\n1. invert bits if higher bit is \"1\"\\n2. keep the original bit if higher bit is \"0\"\\n\\nWhy? Generally because we get our gray code by \"recursive symmetry with 2^k\". \\nLet we take 6-th gray code as example. 6 is \"110\", The first bits \"1\" means 6-th gray code is on the second half part, in this part, second bit \"1\" shows 6-th gray code is on the second half part of second half part, third bit \"0\" shows the gray code is one the first half of the second half of the second part. By inverting, we can get symmetric position of 6-th, which is \"001\". Considering the 6-th is in the second part, also add 1 to the highest bit of \"001\", which leads to our 6-th gray code \"101\"",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < (1 << n); i++) {\\n            res.add(i ^ (i >> 1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29976,
                "title": "quite-simple-solution-accepted-as-best-in-c-well-explained",
                "content": "\\nIt's quite a math problem and the formula to convert **n** to its **gray code** is as follows:\\n\\n> grayCode = n^(n>>1)\\n\\nIf you never heard of this, please read [wiki][1] first and if you are still eager to understand this equation, you may check this [post][2] for reasoning details. \\n\\n- space cost O(2^n)\\n- time cost O(2^n)\\n\\n----------\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }\\n    };\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Gray_code\\n  [2]: https://www.quora.com/I-came-across-this-code-which-generates-the-nth-gray-code-number-G-n-n-n-1-How-can-we-proof-that-it-is-correct\\n  [3]: https://en.wikipedia.org/w/index.php?title=Gray_code&oldid=631353193#Converting_to_and_from_Gray_code",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) \\n        {\\n            vector<int> v;\\n            for(int i = 0, a = 1<<n; i < a; ++i) v.push_back(i^(i>>1));\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30018,
                "title": "few-lines-of-java-code-1ms-no-recursion",
                "content": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(0);\\n\\t\\t\\n\\t\\tfor(int i=1; i<=n; i++){\\n        \\tint size = result.size()-1;\\n        \\tfor(int j=size; j>=0; j--){\\n        \\t\\tresult.add(result.get(j) | 1<<i-1);\\n        \\t}\\n        }\\n\\t\\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30035,
                "title": "simple-2ms-java-solution",
                "content": "    public class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }\\n            return next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n) {\\n            if(n == 0) return Arrays.asList(0);\\n            List<Integer> prev = grayCode(n-1);\\n            List<Integer> next = new ArrayList<Integer>(prev);\\n            int pow = 1 << (n-1);\\n            for(int i=prev.size()-1; i >= 0; i--){\\n                next.add(prev.get(i) | pow);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30039,
                "title": "python-recursive-solution-easy-understanding",
                "content": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n\\n        \"\"\"\\n        if n<1:\\n            return [0]\\n        if (n==1):\\n            return [0,1]\\n        res = self.grayCode( n-1)\\n        x=pow(2,n-1)\\n        for i in range(x-1,-1,-1):\\n            res.append(res[i]+x)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 30087,
                "title": "backtracking-solution",
                "content": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "        public static List<Integer> grayCode(int n) {\\n    \\t\\tList<Integer> code = new ArrayList<Integer>();\\n    \\t\\tcode.add(0);\\n    \\t\\tgenCodes(code,n,0,1<<n);\\n    \\t\\treturn code;\\n    \\t}\\n    \\tpublic static void genCodes(List<Integer> code, int n, int curr, int size) {\\n    \\t\\tif(code.size()==size) return;\\n    \\t\\tfor(int i=0;i<n;i++) {\\n    \\t\\t\\tint mask = 1<<i;\\n    \\t\\t\\tint el = (curr^mask);\\n    \\t\\t\\tif(!code.contains(el)) {\\n    \\t\\t\\t\\tcode.add(el);\\n    \\t\\t\\t\\tgenCodes(code,n,el,size);\\n    \\t\\t\\t\\tif(code.size()==size) return;\\n    \\t\\t\\t\\tcode.remove(new Integer(el));\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3362071,
                "title": "easy-java-solution-using-xor",
                "content": "# Intuition\\n* The problem requires us to generate a sequence of n-bit gray codes that satisfy the given conditions.\\n * The gray code sequence has the property that the binary representation of every adjacent integer differs by only one bit.\\n * The first integer is 0 and the last integer differs from the first integer by only one bit.\\n * We can generate the gray code sequence using the following approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe start with a list that contains only 0 as the first element.\\nThen, we iterate from 0 to (2^n - 1) and perform the following steps:\\n 1. We compute the XOR of the current index i with (i & -i).\\n     This operation flips the least significant bit that is set in i.\\n     For example, if i = 3 (011), then (i & -i) = 1 (001).\\n     So, num = num ^ (i & -i) will set the least significant bit of num to 1 if it is 0, and vice versa.\\n  2. We add the computed num to the answer list.\\n  3. Repeat steps 1 and 2 for all indices from 0 to (2^n - 1).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans = new ArrayList<>();\\n        int num = 0;\\n        for (int i = 0; i < (1 << n); i++) {\\n            // Compute the XOR of the current index i with (i & -i) to generate the next gray code.\\n            num ^= i & (-i);\\n            // Add the generated gray code to the answer list.\\n            ans.add(num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196995,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        int cnt=1;\\n        vector<int>v;\\n        v.push_back(0);\\n        v.push_back(1);\\n        for(int i=1; i<n; i++){\\n            cnt*=2;\\n            int l=v.size();\\n            for(int j=l-1; j>=0; j--){\\n                v.push_back(v[j]+cnt);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185748,
                "title": "gray-code-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an initial list with 0\\n2. For each bit in n, starting from the 0th bit:\\n   1. Traverse the current list in reverse and add the current bit to each number by doing bitwise OR with (1 << i)\\n   2. This step is repeated until we have processed all the bits in n\\n3. Return the final list as the result\\n\\nExample: n = 2\\n\\n- Initial list: [0]\\n- 1st iteration: i = 0, [0, 1 | (1 << 0) = 1] = [0, 1]\\n- 2nd iteration: i = 1, [0, 1, 3 | (1 << 1) = 3, 2 | (1 << 1) = 2] = [0, 1, 3, 2]\\n- Result: [0, 1, 3, 2]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        for i in range(n):\\n            for j in range(len(res) - 1, -1, -1):\\n                res.append(res[j] | (1 << i))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722095,
                "title": "c-simple-recursive-solution-backtracking",
                "content": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "//for video explaination u can watch  pepcoding video on youtube\\n\\n           *    vector<string> solve(int n){\\n                   if(n==1){\\n                     return {\"0\",\"1\"};\\n                    }\\n        \\n             vector<string>ans=solve(n-1);\\n        \\n            vector<string> mainAns;\\n        \\n           for(int i=0;i<ans.size();i++){\\n            string s=ans[i];\\n              mainAns.push_back(\"0\"+s);\\n          }\\n          for(int i=ans.size()-1;i>=0;i--){\\n              string s=ans[i];\\n              mainAns.push_back(\"1\"+s);\\n          }\\n         return mainAns;\\n         }\\n        vector<int> grayCode(int n) {\\n            vector<string> strRes = solve(n);\\n           vector<int> result;\\n\\t\\t   // converting string to int \\n            for(int i=0;i<strRes.size();i++)\\n               {\\n              int val = stoi(strRes[i], 0, 2);\\n                 result.push_back(val);\\n             }\\n            return result;\\n            }\\n// in our problem we have binary-number-strings, we want them to convert to integers of base 10\\n\\nSTOI[string to integer] , stoi(string_to_be_converted , position[optional] , base of string : in our case its binary so we used 2)\\nFor more info, you can follow official documentation or the link given at the top..\\n       \\n      \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1407039,
                "title": "python-very-easy-solution-using-or-operator",
                "content": "Example where n=2:\\n==> Output = [0,1,3,2]\\n\\nStep 1: write the binary of the output.\\n              00 = 0\\n\\t\\t\\t  01 = 1\\n\\t\\t\\t  11 = 3\\n\\t\\t\\t  10 = 2\\nStep 2: If you can see the pattern i.e. it is just OR operation of its n-1 output array\\n\\t\\t\\twhich has been reversed with 2**n (n is the power of 2) \\n               like : for n=2:\\n\\t\\t\\t   n-1 output will be [0,1]\\n\\t\\t\\t   so we OR it with reverse array output i.e. [1,0]\\n\\t\\t\\t        01 OR 10 = 11 = 3\\n\\t\\t\\t\\t\\t00 OR 10 = 10 = 2\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```\\n\\n**Please Upvote this solution if you like......**",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        \\n        k = 2**n-1\\n        lt = [0]\\n        x=0\\n        while(x<n):\\n            p = len(lt)\\n            two = 2**x\\n            for i in range(p-1, -1, -1): #Reverse the output array of n-1\\n                lt.append(two | lt[i])\\n            x+=1\\n        return lt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309394,
                "title": "c-2-approaches-clear-explanation-with-code",
                "content": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Simple Recursion)\\n/*\\n    Example : n = 2\\n    helper(n-1) calls-> helper(1)\\n    \\n    Now, helper(1) returns {\"0\", \"1\"}; Which is correct gray code sequence for n = 1 (# elements = 2^1)\\n    \\n    Now, juts append \"0\" to each element , you will get {\"00\", \"01\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result1\\n    \\n    Now, juts append \"1\" to each element , you will get {\"10\", \"11\"} which is Gray code as well\\n    because each element differ in only 1 bit  ----> Result2\\n    \\n    So, after combining Result1 and Result2 (for n = 2),  {\"00\", \"01\", \"10\", \"11\"}\\n    BUT, you notice that if we combine them, the 1st and 2nd string differ in 2 bits i.e. \"01\", \"10\"\\n    SO, \\n    instead of combining them face to face, reverse the Result2 and then combine it with Result1.\\n    \\n    That\\'s why my 2nd for loop below starts from i = temp.size()-1 and goes till i >=0 .\\n    \\n*/\\nclass Solution {\\npublic:\\n    vector<string> helper(int n) {\\n        if(n == 1) {\\n            return {\"0\", \"1\"};\\n        }\\n        \\n        vector<string> temp = helper(n-1); //To get the result of n, we fetch result from (n-1)\\n        \\n        vector<string> padded;\\n        \\n        for(int i = 0; i<temp.size(); i++) {\\n            padded.push_back(\"0\" + temp[i]); //Just add \"0\" in the beginning\\n        }\\n        \\n        for(int i = temp.size()-1; i >= 0; i--) {\\n            padded.push_back(\"1\" + temp[i]); //Just add \"1\" in the beginning\\n        }\\n        \\n        return padded;\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        vector<string> result = helper(n);\\n        \\n        vector<int> finalR;\\n        \\n        //Just convert them to integer and you got your answer\\n        for(string &s : result) {\\n            bitset<32> bt(s);\\n            finalR.push_back(bt.to_ulong());\\n        }\\n        return finalR;\\n    }\\n};\\n```\n```\\n//Approach-2\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    void helper(bitset<32>& bt, int n) {\\n        if(n == 0) {\\n            //It means we have generate all n elements\\n            result.push_back(bt.to_ulong());\\n            return;\\n        }\\n        \\n        //Generate the remaining (n-1) numbers from bt\\n        helper(bt, n-1);\\n        \\n        //flip the (n-1)th bit (to create a difference of just one bit)\\n        bt.flip(n-1);\\n        \\n        //Generate the remaining (n-1) numbers from bt but this time (n-1)th bit flipped (to create a difference of just one bit)\\n        helper(bt, n-1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        bitset<32> bt; //by default all bits are 0 i.e. {0000000.....000}\\n        \\n        result.clear();\\n        \\n        helper(bt, n);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308590,
                "title": "c-recursive-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1) return vector<int>{0,1};\\n        vector<int>prev = grayCode(n-1);\\n        \\n        for(int i=prev.size()-1;i>=0;i--)\\n            prev.push_back(prev[i]+pow(2,n-1));\\n        \\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773096,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        for(int i=0;i<(1<<n);i++){\\n            ans.push_back(i^(i>>1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736419,
                "title": "fastest-solution-c",
                "content": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> grayCode(int n) {\\n        int c=pow(2,n);\\n        vector<int> ans(c);\\n        for(int i=0;i<c;i++)\\n            ans[i]=i^(i>>1);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 702123,
                "title": "java-0ms-three-simple-approaches",
                "content": "# Approach 1: Dynamic Programming\\n`grayCode(n) = (1 << n - 1) | each code in grayCode(n - 1))`\\n``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n).\\nSpace complexity: O(1) excluding the output list.\\n# Approach 2: Iterative\\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)\\n# Approach 3: Formula\\nRefer to [wiki/gray code](https://en.wikipedia.org/wiki/Gray_code).\\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\\n</br>\\n\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```\\n**Complexity Analysis**\\nTime complexity: O(2^n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n        code.add(0);\\n\\n        for (int mask = 0; mask < n; mask++) {\\n            for (int prev = code.size() - 1; prev >= 0; prev--) {\\n                code.add((1 << mask) | code.get(prev));\\n            }\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nwhile (count < (1 << n))\\n    1st first change the rightmost bit\\n    or\\n    2st second change the left bit of the rightmost 1 bit\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        int prev = 0;\\n        for (int i = 0; i < 1 << n; i++) {\\n            prev ^= (i & 1) == 1 ? 1 : (prev & -prev) << 1;\\n            code.add(prev);\\n        }\\n\\n        return code;\\n    }\\n}\\n```\n```\\nBINARYTOGRAY(num)\\n    return num ^ (num >> 1)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> code = new ArrayList<>();\\n\\n        // i-th code sequence of the graycode\\n        for (int i = 0; i < 1 << n; i++) {\\n            code.add(i ^ (i >> 1));\\n        }\\n\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651316,
                "title": "python3-easy-to-understand-beats-99-41-solutions",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n\\n        result = [0,1]\\n        iterations = 1\\n\\t\\t# calculate till row-1, reverse result and add 2^(iteration -1)\\n        # [0,1] + [1+2,0+2] => [0,1,3,2]\\n        # [0,1,3,2] + [2 + 4, 3 + 4, 1 + 4, 0 + 4] => [0,1,3,2,6,7,5,4]\\n        while iterations < n:\\n            iterations += 1\\n            temp = result\\n            increment_val = 2 ** (iterations-1)\\n            new_array = []\\n            for i in range(len(temp)-1, -1, -1):\\n                result.append(temp[i] + increment_val)\\n        \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 475200,
                "title": "python-a-very-very-easy-understanding-solution",
                "content": "# I think this python version is more easy to understand\\n\\n## explain\\nAt first glance, we find that for a gray code sequence  with n = 1 `0, 1`, its reversed sequence `1, 0` is also a gray code sequence too. \\n\\nWe can add `1` to the front of every element,  and this new sequence `10, 11` is also a gray code sequence.  It is also valid if we add `0`s to the sequence. `00, 01`.\\n\\nSince the first element of sequence is as same as the last one of its reverse, we can find that we can get a gray code sequence with n = 2 by add zeros to the sequence of n=1\\nand ones to its reverse. That are `00, 01` and `11, 10`.  Then we concatenate them to get the result -- `00, 01, 11, 10`.\\n\\nThe general scheme is   \\n\\n`seq(n) =  concatenate(  padding seq(n-1) with zeros,   padding  seq(n-1)\\'s reverse with ones )`\\n\\n## example\\n\\n1.   `01, 10`  -- reverse --> `10,  01`\\n2.   `01, 10`  --padding with zeros--> `001, 010`\\n       `10,  01` --padding with ones--> `110, 101`\\n3.    `001, 010` + `110, 101`  --concatenate--> `001, 010, 110, 101`\\n\\n## tip:\\nA number padded with zero is still itself, and is equal to plus `pow(2, n)` if it is padded with one at `n th` bit.  \\n\\n## code:\\n```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = [0]\\n        bit = 1\\n        while n > 0:\\n            layer = res[::-1]\\n            for i in layer:\\n                res.append(i+bit)\\n            bit += bit\\n            n -= 1\\n        return res      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 441028,
                "title": "c-0ms-beats-100-on-time-and-space-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}; i < totalCombos; ++i) {\\n\\t\\t\\tourVec.push_back(i^(i>>1));\\n\\t\\t}\\n        return ourVec;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n\\t    // Total number of combinations.\\n        int totalCombos = (int)pow(2, n);\\n        vector<int> ourVec;\\n        v.reserve(totalCombos);\\n        for (int i{}",
                "codeTag": "Java"
            },
            {
                "id": 354466,
                "title": "simple-python-solution-dfs",
                "content": "Not every path leads to the complete combination. eg.\\n(n = 3) 000 -> 001 -> 011 -> 111 -> 110 -> 100 -> 101 -> X\\n\\nThe goal is to find a path which reaches the level == 2^n\\nRevert bit one at a time (always from the right most one) and append to the ans list if it is not already.\\nIf the len(ans) == target, stop.\\n\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        targetLevel = 2**n\\n        ans = []\\n        \\n        self.DFS(n, ans, 0, 1, targetLevel)   # Start with number = 0 (000), level = 1\\n        \\n        return ans\\n    \\n    \\n    def DFS(self, n, ans, num, level, targetLevel):\\n        if num in ans:\\n            return\\n        \\n        ans.append(num)\\n        \\n        if level == targetLevel:\\n            return\\n        \\n        for i in range(0, n):\\n            self.DFS(n, ans, num ^ (1 << i), level+1, targetLevel)  # num ^ (1 << i): revert a bit at a time\\n            \\n            if len(ans) == targetLevel: return  # result found. Stop.\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322062,
                "title": "beats-100-c-n-n-1-one-line",
                "content": "**if u like hit vote**\\n```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> ans;\\n       for(int i=0;i<(1<<n);i++)\\n        ans.push_back(i^(i>>1));\\n       return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30053,
                "title": "simple-python-method-52-ms",
                "content": "\\tclass Solution(object):\\n        ```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\t\\tdef grayCode(self, n): \\n\\t\\t\\t\\t\\tif n==0: return [0]\\n\\t\\t\\t\\t\\treturn self.back(n) \\n            \\n        def back(self, n):\\n            if n==1:\\n                return [0,1] \\n            cur = [] \\n            pre= self.back(n-1)\\n            for x in xrange(len(pre)-1,-1,-1):\\n                cur.append(2**(n-1)+pre[x])  \\n            return pre+cur\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 30105,
                "title": "iterative-5-lines-in-java",
                "content": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea is standard: we have n iterations and at each iteration \"i\" we run through our list (which is a gray code for \"i-1\") in reverse adding 1 to the front of bit-wise representation of a current number.\\n\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>(Arrays.asList(0));\\n        for (int i = 1; i < (1 << n); i <<= 1)\\n            for (int j = res.size()-1; j >= 0; j--)\\n                res.add(i | res.get(j));\\n        return res;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 3125514,
                "title": "very-easy-way-gray-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>v;\\n        int m=pow(2,n);\\n        for(int i=0; i<m; i++){\\n            int x=i^(i>>1);\\n           \\n            v.push_back(x);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970359,
                "title": "world-simplest-way-to-solve-this-question",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        n = pow(2, n)-1;\\n        for(int i=0; i<=n; ++i)\\n            v.push_back(i^(i>>1));\\n        return v;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741505,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N+2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        oldArr = [0,1]\\n        i = 1\\n        while i< n:\\n            Arr = list(oldArr)\\n            for j in range(len(oldArr)-1,-1,-1):\\n                Arr.append((2**i)+oldArr[j])\\n            oldArr = Arr\\n            i+=1\\n        return oldArr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570947,
                "title": "gray-codes-explained-c-easy-solution",
                "content": "__Algorithm__\\n```                                                         upvote if helpful```\\n- Gray code => a sequence of numbers where binary representation of any 2 consecutive numbers differ by exactly one bit\\n- For exaple for n = 1 => [ 0 , 1 ]\\n                          n = 2 => [00 , 01 , 11 , 10]\\n- To solve this we can understand to find gray code of n bits we need the gray code of n-1 bits and then add 0 and 1 at the front of those numbers\\n- for n = 2 we first find gray code for n = 1 which is [0 , 1] now we add 0 and 1 at the front of all elements in vectro 00 , 01 , 10 , 11 but here there is a discontinuity in 01 and 10 as to bits change\\n- so to resolve this we will add 0 to all integers in the order in which elements are there is vector and for adding 1 we will go in reverse order and push them accordingly . Like -> after adding o in front array will be 00 , 01 after adding 1 array will be 00 , 01 ,11 , 10 as for adding 1 in front the last element ie 1 is used and we go in reverse order\\n- During implementation we don\\'t add 0 as the binary representation already consists of 0 for adding 1 we use bitmask ie 1<<(n-1) as for n = 2 we need to add 1 to 2nd place ie shift 1 by 1 place \\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```                                                         upvote if helpful```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n == 1){\\n            vector<int> vec = {0,1};\\n            return vec;\\n        }\\n        vector<int> ans(grayCode(n-1));\\n        for(int i = ans.size()-1 ; i>= 0 ;i--){\\n            ans.push_back((ans[i] | 1<<(n-1)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316165,
                "title": "c-easy-to-understand-simple-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> ans;\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        for(int i=1;i<n;i++)\\n        {\\n            int sz=ans.size();\\n            int add=pow(2,i);\\n            for(int j=sz-1;j>=0;j--){\\n                ans.push_back(ans[j]+add);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130452,
                "title": "c-almost-in-one-line",
                "content": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\\n\\nSo, the solution is:\\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nGray[i] = i ^ (i >> 1); // That is all you need to know\\n```\n```\\nclass Solution\\n{\\npublic:\\n\\tvector<int> grayCode(int n)\\n\\t{\\n\\t\\tvector<int> res;\\n\\t\\tfor (int i = 0; i < (1 << n); ++i) res.push_back(i ^ (i >> 1));\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999295,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 1:\\n            return [0, 1]\\n        \\n        code = self.grayCode(n - 1)\\n        k = 2 ** (n-1)\\n        return code + [k + i for i in reversed(code)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942255,
                "title": "easy-100-mathematical",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    vector<int> grayCode(int n) {\\n        \\n        vector<int>ans;\\n        for(int i=0;i<=(pow(2,n)-1);i++)\\n        {\\n            ans.push_back(i ^ (i>>1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1721825,
                "title": "java-o-2-n-with-clear-explanation",
                "content": "First, let\\'s analyse these kind of results:\\n\\nn = 1:\\n```\\nGray code = [0,1]\\n```\\nn = 2:\\n```\\nGray code = [0,1,3,2]\\n```\\nn = 3:\\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\\nn = 4\\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\\nWhat are the patterns here?\\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\\nand\\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\\nand\\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\\nFor example: With the pattern above, n = 3, assume that we somehow already have gray code of n = 2 How can we calculate the second half?\\n```\\n[0,1,3,2,A,B,C,4]\\n```\\nTurns out:\\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\\n\\nSo we implement like this:\\n* Declare an array with 2^n elements.\\n* Init it with the last number of all gray code from 1 to n\\n* Then calculate the right half for each gray code of n (from 1 to n)\\n\\nLike this (with n = 4)\\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\\n\\nCode:\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nGray code = [0,1]\\n```\n```\\nGray code = [0,1,3,2]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4]\\n```\n```\\nGray code = [0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\\n```\n```\\nThe last number of gray code of n is 2^(n-1). For example for gray code of n = 4, the last number is 2^3 = 8\\n```\n```\\nThe first half of gray code of n is the gray code of n - 1\\n```\n```\\nThe second half of gray code of n can be constructed from the first half as in the example below:\\n```\n```\\n[0,1,3,2,A,B,C,4]\\n```\n```\\nA = 2 + 4 = 6 (element of gray code 2 at position [3] plus the last element of gray cod 3)\\nB = 3 + 4 = 7 (element of gray code 2 at position [2] plus the last element of gray cod 3)\\nC = 1 + 4 = 5 (element of gray code 2 at position [1] plus the last element of gray cod 3)\\n```\n```\\n_____________________________________ (array with 2^4 elements)\\n0_1___2_______4_____________________8 (last number of all gray code from 1 to 4)\\n0,1,3,2_______4_____________________8 (calculate the right half of gray code 2)\\n0,1,3,2,6,7,5,4_____________________8 (calculate the right half of gray code 3)\\n0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8 (calculate the right half of gray code 4)\\n```\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        int s = 1 << n;\\n        int[] result = new int[s];\\n\\n\\t\\t/* Init it with the last number of all gray code from 1 to n */\\n        int val = s >> 1;\\n        while (s > 0) {\\n            result[s - 1] = val;\\n            val >>= 1;\\n            s >>= 1;\\n        }\\n\\n\\t\\t/* Construct the right half for each n from 1 to n */\\n        for(int i = 4; i <= result.length; i <<= 1) {\\n            addMoreValues(result, i);\\n        }\\n\\n        return arrayToList(result);\\n    }\\n\\n    private List<Integer> arrayToList(int[] array) {\\n        List<Integer> result = new ArrayList<>();\\n        for(int i = 0; i < array.length; ++i) {\\n            result.add(array[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addMoreValues(int[] result, int m) {\\n        int mid = m >> 1;\\n        int addValue = result[m - 1];\\n        for(int i = 0; mid + i < m - 1; ++i) {\\n            result[mid + i] = result[mid - i - 1] + addValue;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579716,
                "title": "my-python-one-liner-using-logic-gates",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(num ^ (num<<1))>>1 for num in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568408,
                "title": "c-recursive-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1}; //base case\\n        vector<int> prevRes = grayCode(n-1); //dfs call\\n        vector<int> curRes;\\n        for(int i=0; i<prevRes.size(); ++i){\\n            curRes.push_back(prevRes[i]);\\n        }\\n        for(int i=prevRes.size()-1; i>=0; --i){\\n            curRes.push_back((1<<n-1) + prevRes[i]);\\n        }\\n        return curRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422842,
                "title": "how-to-approach-initial-approach-brute-force-backtracking-javascript",
                "content": "1. Initialize result array with 0 repeated n times (n bits)\\n2. toggle each bit and check if the conditions for it being the next in the sequence match, if nothing matches, the current position of this needs to be changed => backtracking.\\n3. The first element will always be 0 and the last element will always be yth power of 2.\\n \\n PS: This is only to understand the initial approach after which we can move on to using bitwise manipulations and undertsanding other more optimised way of solving the problem\\n```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar grayCode = function(n) {\\n// build the first binary string. No. of bits == n;\\n\\tlet binary = \\'0\\'.repeat(n);\\n\\tlet resultBinary = [binary];\\n\\tlet set = new Set();\\n\\tset.add(binary);\\n\\tbacktrack(binary, n, set,  resultBinary);\\n\\tresult = resultBinary.map(binary => convertBinary(binary));\\n\\treturn result;\\n}\\n\\nvar backtrack = function(binary, n, set,  result) {\\n\\tif(result.length === 2 ** n) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlet called = false, found;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tlet binArray = binary.split(\\'\\');\\n\\t\\tbinArray[i] = binArray[i] === \\'0\\'  ?  \\'1\\' : \\'0\\';\\n\\t\\tlet newBinary = binArray.join(\\'\\');\\n\\t\\tif(newBinary === 10 ** (n - 1) + \\'\\' && result.length !== (2 ** n - 1)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tif(!set.has(newBinary)) {\\n\\t\\t\\tresult.push(newBinary);\\n\\t\\t\\tset.add(newBinary);\\n\\t\\t\\tcalled = true;\\n\\t\\t\\tfound = backtrack(newBinary, n, set, result);\\n\\t\\t}\\n\\t\\tif(found === false) {\\n\\t\\t\\tresult.pop();\\n\\t\\t\\tset.delete(newBinary);\\n\\t\\t\\tcalled = false;\\n\\t\\t}\\n\\t}\\n\\tif(!called) {\\n\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nvar convertBinary = function(binary) {\\n\\tlet decimal = 0, exp = 0;\\n\\tfor(let i=binary.length-1; i>=0; i--) {\\n\\t\\tdecimal += parseInt(binary[i]) * Math.pow(2, exp++);\\n\\t}\\n\\treturn decimal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416588,
                "title": "c-easy-5-lines-solution-with-explanation",
                "content": "The idea is simple; for example, consider `n = 2`, we have `{00, 01, 11, 10}` in binary.\\nNotice that the first half of the array starts with `0` and the second half starts with `1`. If we remove all the first bit, the array we have is **symmetric**, in which the first half is `{0, 1}` - the solution to `n = 1`\\n\\nConsider `n = 3`, we have the array `{0, 1, 3, 2, 6, 7, 5, 4}`, or `{000, 001, 011, 010, 110, 111, 101, 100}` in binary. You can notice the same pattern: if we remove all the first bit, the first half of the remaining array is `{00, 01, 11, 10}` - the solution to `n = 2`.\\n\\nSo we can build the array as follow: start with `{0}`, for each additional bit (`ith` bit) you copy each element `a[j]` in the array *backward*, and add a bit `1` in front of it - equivalent to `a[j] | (1 << i)` \\n-\\n*Note: the `1<<i` part is `100...0` with `i` bits `0`, when you use the operator `| - OR`, it will put the bit `1` in front of an `i` bit number - `a[j]` in this case*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> a = {0};\\n        for (int i = 0; i < n; i++) \\n            for (int size = a.size(), j = size-1; j >= 0; --j)\\n                a.push_back(a[j] | (1 << i));\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346758,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> v;       \\n        for(int i=0;i<(1<<n);i++){\\n            v.push_back(i^(i>>1));\\n            \\n            // 00 ^ (00)\\n            // 01 ^ (00)\\n            // 10 ^ (01)\\n            // 11 ^ (01)\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316592,
                "title": "c-easy-and-short",
                "content": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        std::vector<int> grayCode(int n)\\n        {\\n            int limit = (int)std::pow(2, n);\\n            std::vector<int> code{};\\n\\n            code.push_back(0);\\n\\n            // i xor i >> 1 will give you the gray code for i.\\n            for (int i = 1; i < limit; i++) {\\n                code.push_back(i ^ (i >> 1));\\n            }\\n\\n            return code;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310242,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n)\\n    {\\n        vector<int>ans;\\n        long itr = pow(2,n); //pow function for computing the base no. raised to the power of exponent\\n        \\n        for(int i=0;i<itr;i++)\\n        {\\n            ans.push_back(i^(i/2));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310225,
                "title": "c-dfs-backtracking",
                "content": "\\n**Explanation:**\\n**Neighbours of curr node are all nodes with one bit difference with curr**\\n1. Assume 0 as the source and neighbours {powers of 2 - 1,2,4,8,16.....}\\n2. Recursively follow the below steps on each neighbour:\\n\\t* \\tMark neighbour as visited, push in vector and proceed ahead with next neighbours\\n\\t* \\tIf you reach a dead end ,backtrack - (mark visited false and pop from vector and proceed with another neighbour)\\n\\t* \\tIf you reach the answer, you will have all values in vector, just return\\n\\nYou can also draw edges between neighbours for better visualization.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int curr, vector<bool> &visited, vector<int> &v, int n){\\n        v.push_back(curr);\\n        visited[curr] = true;\\n        if(v.size()==(1<<n)){\\n            return true;\\n        }\\n            \\n        for(int i = 0; i < n; i++){\\n            int next = curr ^ (1<<i);\\n            if(!visited[next] && dfs(next,visited,v,n))\\n                return true;\\n        }\\n        \\n        v.pop_back();\\n        visited[curr] = false;\\n        return false;\\n    }\\n    vector<int> grayCode(int n) {\\n        vector<int> v;\\n        int curr = 0;\\n        vector<bool> visited(1<<n,false);\\n        dfs(curr,visited,v,n);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309869,
                "title": "java-simple-iterative-clean",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```\\n\\nMain Points to be taken care of,\\n1) There will be exactly 2^n number of gray codes for n bit,\\n2) We need to think of the fact that, can we obtain the gray code using current number,\\n\\nFor eg:\\nif current number = 0\\nthe gray code will be = 0\\n\\nif current number = 1\\nthe gray code will be = 1\\n\\nif current number = 2\\nthe gray code will be = 3\\n\\nIf we carefully observe for every number \"num\",\\nthe gray code will be = num ^ (num>>1),\\nwhy?\\nbecause it is making sure that there will be difference of 1 bit between the number and gray code to be formed,\\nLet us take the eg of num=2\\nin Binary = 10\\n(10>>1) = 01\\n10 ^ (10>>1) = 11 (3 in decimal)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> ans= new ArrayList<>();   \\n        for(int i=0;i<(1<<n);i++)\\n            ans.add(i^(i>>1));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309431,
                "title": "scala-1-line-solution",
                "content": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef grayCode(n: Int) = List.tabulate(1 << n)(i => i ^ i >> 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1309419,
                "title": "c-two-easy-solutions-recursion-and-without-recursion",
                "content": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//With Recursion\\nvector<int> grayCode(int n) \\n    {\\n       if(n == 1) \\n            return {0, 1};\\n        vector<int>prev = grayCode(n - 1);\\n        \\n        for(int i = prev.size() - 1; i >= 0; i--)\\n            prev.push_back(prev[i] + pow(2, n - 1));\\n        \\n        return prev;  \\n}\\n\\n//Without recursion\\nvector<int> grayCode(int n) \\n    {\\n        vector<int> v;\\n        long long int p = pow(2, n);   //1<<n;\\n        for(int i = 0; i < p; i++)\\n          v.push_back(i ^ (i / 2));    //i>>1\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309155,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(0);\\n        if(n==0){return list;}\\n        list.add(1);\\n        int prev_Bit = 1;\\n        for(int i = 2;i<=n;i++){\\n            prev_Bit *=2;\\n            for(int j = list.size()-1;j>=0;j--){\\n                list.add(prev_Bit+list.get(j));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006682,
                "title": "python-solution-with-xor-explained",
                "content": "Here is the list for n=2, as provided in the example\\n```\\ngray_code = [0,1,3,2]\\n```\\nLets XOR the values with their own indexes, which would mean,\\n```\\ngray_code[i]^i\\n```\\nDoing the above operation on the example given yields,\\n```\\n[0,0,1,1]\\n```\\nThat list looks a lot like every element is just floor(i/2). Lets hold onto that for a while.\\n\\nXOR has the interesting property: ```if A^B = C, then B^C = A```.\\nWhich implies, \\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\\nOne last thing: floor(i/2) is same as i >> 1, and 2^n is same as 1<<n (n!=0), where n is the number of bits.\\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "solutionTags": [],
                "code": "```\\ngray_code = [0,1,3,2]\\n```\n```\\ngray_code[i]^i\\n```\n```\\n[0,0,1,1]\\n```\n```if A^B = C, then B^C = A```\n```\\nif gray_code[i]^i = x, then x^i = gray_code[i], where x is floor(i/2)\\n```\n```\\ndef grayCode(self, n):\\n       lim = 1 << n\\n       return [(i>>1)^i for i in range(0, lim)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 881932,
                "title": "simple-c-solution-0ms-faster-than-100-6-7mb",
                "content": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> grayCode(int n) {\\n        vector<int> res;\\n        for(int i=0;i<(1<<n);i++)\\n            res.push_back(i^(i>>1));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825353,
                "title": "c-simple-technique-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        n = (1<<n);\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int x = ((i)^(i>>1));\\n            v.push_back(x);\\n                     \\n        }\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808416,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [(i >> 1) ^ i for i in range(2**n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749462,
                "title": "fastest-c-solution-0ms-with-only-4-5-lines-of-code",
                "content": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        int c = pow(2,n);\\n        for(int i=0;i<c;i++){\\n            res.push_back(i^i>>1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 514818,
                "title": "python-bitwise-100",
                "content": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        res = []\\n        for i in range(1 << n):\\n            res.append(i ^ (i >> 1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434639,
                "title": "python-bit-manipulation-easy-to-understand-with-explanation",
                "content": "This solution uses bit manipulation. It is much easier to see the pattern if you change n=2 to n=3\\nIf I make a loop count from 0 to 2^n then take the difference of what the output and the input should be to find a mask to use the XOR operator with. See the table be low.\\n_________________________  \\n\\t0 = 000 --->0 = 000          difference = 000\\n\\t1 = 001 --->1 = 001          difference = 000\\n\\t2 = 010 --->3 =011           difference = 001\\n\\t3 =011 --->2 = 010           difference = 001\\n\\t4 =100 --->6 =110            difference = 010\\n\\t5 =101 --->7 =111            difference = 010\\n\\t6 =110 --->5 =101            difference = 011\\n\\t7 =111 --->4 =100            difference = 011\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        if n ==0:\\n            return [0]\\n        \\n        out = [0,1]\\n        mask =0\\n        for j in range(2,2**n):\\n            if j%2 ==0:\\n                mask +=1\\n            out.append(j^mask)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423263,
                "title": "two-python-solutions-with-video-explanations",
                "content": "**Solution 1**\\n```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\\n\\n**Solution 2**\\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```\\n\\n**Video explanation for Gray Code**\\nhttps://www.youtube.com/watch?v=oVMOTNqVYns\\n\\n**Video explanation for both solutions**\\nhttps://www.youtube.com/watch?v=CHr3V8JDa1w\\n",
                "solutionTags": [],
                "code": "```\\ndef grayCode(self, n):\\n\\tres = []\\n\\tfor i in range(1 << n):\\n\\t\\tres.append(i ^ (i >> 1))\\n\\treturn res\\n```\n```\\ndef grayCode(self, n):\\n\\tdef helper(n):\\n\\t\\tif n == 0:\\n\\t\\t\\treturn [\\'0\\']\\n\\t\\tif n == 1:\\n\\t\\t\\treturn [\\'0\\', \\'1\\']\\n\\t\\tres = helper(n - 1)\\n\\t\\treturn [\\'0\\' + s for s in res] + [\\'1\\' + s for s in res[::-1]]\\n\\n\\treturn [int(s, 2) for s in helper(n)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 259921,
                "title": "python-20ms-2-methods",
                "content": "Method 1 : according to the Gray Code generation principle (you can check it on the Internet)\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\\n\\nMethod 2 :  iteration and mirror\\n\\nSuch as n = 1 , the gray code is [0,1] ;\\nand when n = 2 ,  the gray code is [0,1,3,2] , equal to [0,1] + [1,0](each element plus 2**(n-1))\\nso when n = 3 , the gray code is [0,1,3,2] + [2,3,1,0](each element plus 2**2) , just [0,1,3,2,6,7,5,4]\\n\\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        for i in range(1<<n):\\n            res.append(i^(i>>1))      \\n        return res\\n```\n```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if n == 0:\\n            return [0]\\n        temp = self.grayCode(n-1)\\n        temp1 = [i+2**(n-1) for i in temp[::-1]]\\n        res = temp + temp1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204179,
                "title": "simple-java-solution",
                "content": "Recursion and the mirror image property of gray codes+ add pow(2,n-1) can be used.\\n```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==0){\\n            List<Integer> result = new ArrayList<Integer>();\\n            result.add(0);\\n            return result;\\n        }\\n        \\n        List<Integer> result= grayCode(n-1);\\n        int numToAdd= 1<<(n-1);\\n        for(int i=result.size()-1;i>=0;i--) {\\n            result.add(numToAdd+result.get(i));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156204,
                "title": "simple-java-solution-with-comments",
                "content": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> grayCode(int n) {\\n        List<Integer> arr=new ArrayList<>();\\n        \\n        if(n==0)\\n        {\\n            arr.add(0);\\n            return arr;\\n        }\\n        arr.add(0);\\n        arr.add(1);\\n        int ptr=1;\\n\\n        while(ptr<n){\\n            for(int i=arr.size()-1;i>=0;i--){\\n                arr.add((1<<ptr)+arr.get(i));\\n            }\\n            ptr++;\\n        }\\n        // initially \\n        // 0\\n        // 1\\n        // arr = [0, 1]\\n        // now - for ptr=1, following is added\\n        // 11\\n        // 10\\n        // arr = [0, 1, 3, 2]\\n        // now for ptr=2, following is added\\n        // 101\\n        // 111\\n        // 101\\n        // 100\\n        // arr = [0, 1, 3, 2, 6, 7, 5, 4]\\n        // for each new ptr we add 1<<ptr to the reverse order of previous ptr values.\\n        // eg  6=(1<<2)+2\\n        // eg  7=(1<<2)+3\\n        // eg  5=(1<<2)+1\\n        // eg  4=(1<<2)+0\\n        // and [2, 3, 1, 0] are reverse of previous ptr arr values\\n        \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123663,
                "title": "just-share-some-more-about-gray-code-tower-of-hanoi",
                "content": "First I definitely agree with other commentors that this is not a great interview question since it doesn\\'t really reveal much about candidates\\'s competency. I just want to share more about what I read recently about gray code. Knuth devoted a lot of pages to gray code in his The Art of Programming Volume 4A starting at page 281.  The idea is to have a variable i iterate over 0 to 1 << N. And for each i, find the first bit set, and flip that bit on the previous value. NO credit belongs to me here. Here is my code:\\n\\n```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nIf you read more of Knuth\\'s book, it also says it\\'s related to ancient Chinese puzzle \\u4E5D\\u8FDE\\u73AF. If you buy one from Amazon and play with it, you would find graycode truly amazing. It\\'s also related to iterative solution of tower of hanoi.",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> r;\\n        int m = 0;\\n        r.push_back(m);\\n        for (int i = 1; i < (1 << n); ++i) {\\n            for (int j = 0; j < 32; ++j) {\\n                if ((1<<j) & i) {\\n                    m = m ^ (1<<j);\\n                    r.push_back(m); // Of course we can use built in functions in C/C++ like ffs\\n                    break;\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 29885,
                "title": "python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```\\n\\n*By Yangshun*",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def grayCode(self, n):\\n        return [(num ^ (num >> 1)) for num in range(2 ** n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 29999,
                "title": "6-lines-4ms-easy-c-solution",
                "content": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> grayCode(int n) {\\n        vector<int>res;\\n        for(int i=0;i<(1<<n);i++){\\n            res.push_back(i^(i>>1));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30010,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "After seeing the top voted post, I find their idea is really elegant. We just need to double expand the previous layer element by adding 1 to all the element of the previous layer.\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> result(1, 0);\\n            /** level-by-level expand the result **/\\n            /** add 1 to prefix of each int the previous layer ***/\\n            for(int i=0; i<n; i++){\\n                int cur=result.size();\\n                while(cur){\\n                    cur--;\\n                    int temp=result[cur];\\n                    temp+=(1<<i);\\n                    result.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 30022,
                "title": "multiple-approaches-topdown-bottom-up-recursive",
                "content": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "\\n**Build up, DP table** \\n\\n    vector<int> grayCode_dp(int n) {\\n        if( n == 0) return {0};\\n        vector<int> prev={0};\\n        \\n        for( int cur=1; cur<=n; cur++)\\n            for( int j=prev.size()-1; j>=0; j--)\\n                    prev.push_back( (1<<(cur-1))|prev[j]);    \\n        return prev;\\n    }\\n\\n**top down, Just recursive**\\n\\n\\n    vector<int> grayCode_rec(int n) {\\n        \\n        if( n == 0) return {0};\\n        if( n == 1) return {0,1};\\n        \\n        vector<int> cur;\\n        vector<int> prev=grayCode(n-1);\\n        for( auto val : prev )\\n        {\\n            cur.push_back( (0<<n)|val);    \\n        }\\n        for( int j=prev.size()-1;j>=0;j--)\\n        {\\n            cur.push_back( (1<<(n-1))|prev[j]);    \\n        }\\n        return cur;\\n    }\\n};\\n\\n\\n**Truncated BFS with O(1 shft by n) space**\\n\\n        vector<int> res;\\n    void gc(int n, int cur, vector<bool> &exists )\\n    {\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int temp= cur^ (1<<i);\\n            \\n            if(exists[temp] == false)\\n            {\\n                exists[temp]=true;\\n                res.push_back(temp);\\n                gc(n, temp, exists);\\n                break;\\n            }\\n        }\\n        \\n    }\\n    vector<int> grayCode(int n , int cur=0) {\\n        \\n        \\n        vector<bool> exists(1<<n,false);\\n        exists[0]=true;\\n        res.push_back(0);\\n        gc(n,0, exists);\\n        \\n        return res;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30066,
                "title": "my-java-solution-6-lines-easy-to-understand",
                "content": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "solutionTags": [],
                "code": "    public List<Integer> grayCode(int n) {\\n    \\tList<Integer> output = new ArrayList<Integer>();\\t\\n    \\toutput.add(0);\\n    \\tfor (int i = 1; i <= n; i++)\\n    \\t\\tfor (int j = output.size() - 1; j >= 0; j--)\\n    \\t\\t\\toutput.add(output.get(j) + (int)Math.pow(2, i - 1));   \\t\\n    \\treturn output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30068,
                "title": "share-my-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0};\\n            if (n == 0) {\\n                return seq;\\n            }\\n            \\n            seq = grayCode(n-1);\\n            int len = seq.size();\\n            int mask = 1 << (n-1);\\n            for (int i = len-1; i >= 0; i--) {\\n                seq.push_back(seq[i] | mask);\\n            }\\n            return seq;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            vector<int> seq = {0}",
                "codeTag": "Java"
            },
            {
                "id": 30070,
                "title": "java-solution-with-explanation",
                "content": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> grayCode(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        res.add(0);\\n        if (n == 0) return res;\\n        for (int i = 0; i < n; i++) {\\n            List<Integer> temp = new ArrayList<>();\\n            temp.addAll(res);\\n            for (int j = temp.size() - 1; j >= 0; j--) {\\n                res.add((1<<i) + temp.get(j));\\n            }\\n        }\\n        return res;\\n    }\\n\\n - 000\\n - 001\\n - 011\\n - 010\\n - ---------\\n - 110\\n - 111\\n - 101\\n - 100\\n\\n\\n----------\\nThink about how to get gray code when n is 3: the first 4 gray codes is the same with when n equals to 2, and the last gray codes is adding 1 in front of the gray codes when n is 2. The first 4 is symmetric to the last 4.",
                "codeTag": "Unknown"
            },
            {
                "id": 30078,
                "title": "python-5-lines-no-recursive-just-generate-the-result",
                "content": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def grayCode(self, n):\\n            ret = [0]\\n            for k in range(0, n):\\n                for i in range(len(ret)-1, -1, -1):\\n                    ret.append(ret[i]+(2**k))\\n            return ret\\n\\nThe idea as below.\\n\\nf(n=1) :\\n\\n    0\\n    1\\n\\nf(n=2) :  \\nafter got result of f(n = 1), add 1 to every elements's binary value, add result to the f(n = 1) reversed order.\\n\\n          00 \\n          01 \\n    1 --> 11\\n    0 --> 10\\n\\nf(n=3) :  do as above.\\n\\n           000 \\n           001 \\n           011\\n           010\\n    10 --> 110\\n    11 --> 111\\n    01 --> 101\\n    00 --> 100\\n\\nn = 4, 5, 6... as above.",
                "codeTag": "Python3"
            },
            {
                "id": 30061,
                "title": "solution-using-binary-tree",
                "content": "We can represent binary numbers as paths of binary tree.  \\nLeft node value is parent value times 2. \\nRight node value is parent value times 2 plus 1.\\nWe can only change a single part of a path at a time.\\nWe will look for a pattern to accomplish this.\\n\\n         /*\\n    \\t *                                  _____0_____                     000                      0000\\n    \\t *                                 /           \\\\                    001                      0001\\n    \\t *                              __0_           _1__                 011                      0011\\n    \\t *                             /    \\\\         /    \\\\                010                      0010\\n    \\t *                            0      1       2      3               110                      0110 \\n    \\t *                           / \\\\    / \\\\     / \\\\    / \\\\              111                      0111\\n    \\t *                          0   1  2   3   4   5  6   7             101                      0101 \\n    \\t *                                                                  100                      0100\\n    \\t *              n=0                                  0                                       1100\\n    \\t *              n=1                    0                            1                        1101 \\n    \\t *              n=2             0            1              3                2               1111 \\n    \\t *              n=3         0      1     3       2       6     7         5       4           1110   \\n    \\t *              n=4        0,1    3,2   6,7     5,4    12,13 15,14      10,11   9,8          1010    \\n    \\t *                                                                                           1011 \\n    \\t *                                                                                           1001\\n    \\t *                                                                                           1000\\n    \\t */\\n    public class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tsmallerFirst=!smallerFirst;\\n    \\t\\t\\t}\\n    \\t\\t\\tresult = temp;\\n    \\t\\t}\\n    \\t\\treturn result;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> grayCode(int n){\\n    \\t\\tList<Integer> result = new ArrayList<Integer>();\\n    \\t\\tresult.add(0);\\n    \\t\\t\\n    \\t\\tfor (int i=0;i<n;i++){\\n    \\t\\t\\tboolean smallerFirst=true;\\n    \\t\\t\\tList<Integer> temp = new ArrayList<Integer>();\\n    \\t\\t\\tfor (int val:result){\\n    \\t\\t\\t\\tif (smallerFirst){\\n    \\t\\t\\t\\t\\ttemp.add(val*2);\\n    \\t\\t\\t\\t\\ttemp.add(val*2+1);\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 30088,
                "title": "accepted-4ms-c-recursive-solution-only-6-lines-easy-understand",
                "content": "If n = 2, the result will be:\\n\\n    00\\n    01\\n    11\\n    10\\n\\nIf n = 3, the result will be:\\n\\n    0  00\\n    0  01\\n    0  11\\n    0  10\\n    -----\\n    1  10\\n    1  11\\n    1  01\\n    1  00\\n\\nEasy to get the accepted solution:\\n\\n    class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::vector<int> grayCode(int n) {\\n    \\t\\tif (!n) \\n    \\t\\t\\treturn std::vector<int>(1);\\n            std::vector<int> res = grayCode(n - 1);\\n    \\t\\tfor (int i = res.size() - 1; i >= 0; --i)\\n    \\t\\t\\tres.push_back(res[i] + (1 << (n - 1))); // or res.push_back(res[i] | (1 << (n - 1)));\\n    \\t\\treturn res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 30097,
                "title": "my-c-solution-7ms-17lines",
                "content": "The basic idea is following:\\nif n = 3<br>\\n000<br>\\n001<br>\\n011<br>\\n010<br>\\n100<br>\\n101<br>\\n111<br>\\n110<br>\\nLook the columns, it is a repeat of {0, 1, 1, 0}. The first column (from the right) is 0110, the send column is 00111100, every element repeat twice, the third column is 0000111111110000, every element repeat four times.\\n\\n    class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0};\\n            for (int i = 0; i < num; ++i) {\\n                sum = 0;\\n                for (int j = 0; j < n; ++j) {\\n                    sum += t[i/(1 << j) % 4] * (1 << j);\\n                }\\n                res.push_back(sum);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> grayCode(int n) {\\n            int num = 1 << n;\\n            int sum = 0;\\n            vector<int> res;\\n            int t[] = {0, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 3831538,
                "title": "c-very-easy-solution-beats-100-users-with-0ms-runtime",
                "content": "# Intuition\\nFor each adjacent pair to be differing by a bit the difference between them should be a 2 power.\\n\\n# Approach\\nBy observation we can get to a conclusion that for every increment of n, adding 1<<n to previous elements in the vector all the way till beginning starting from end and adding them into the vector simultaneously gives the differenec between each adjacent elements in the vector a power of 2 i.e., 1, 2, 4, 8, ....\\n\\n# Complexity\\n- Time complexity : $$O(1<<n)$$\\n\\n- Space complexity : $$O(1<<n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> p = {0, 1};\\n        n--;\\n\\n        int prod = 1;\\n        while(n>0){\\n            prod = prod*2;\\n            for(int i=p.size()-1; i>-1; i--) p.emplace_back(p[i]+prod);\\n            n--;\\n        }\\n\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737460,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151508,
                "title": "gray-code-rust-fast-and-easy-solution-beats-100-in-both-time-and-space-complexity",
                "content": "# Intuition\\nI knew there was some technique to calculate gray code from the binary number. I had learnt that in the first semester in the subject Digital Logic class. So wanted to convert that technique to bitwise operations.\\n\\n# Approach\\nEssentially, what you need to do is, you have to XOR the first bit with the next bit, and do it sequencially till the end. The very first bit is copied as it is, and all the subsequent bits is computed from the XOR operation between adjacent bits, till the end.\\n\\nLet us understand from the example below:\\n101110011:\\n```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\\nSo, all you need to do is iterate from 0 to 2^n and convert all the numbers into gray code.\\n\\nNow, 2^n can be done very cheaply using ` 1 << n`, and the operation shown above can be achieved by the bitwise operation `n ^ (n >> 1)`.\\n\\nWe can see that from following:\\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\\n\\nFrom that, we can just use the iterator, map each element to it\\'s equivalent gray code, and collect it to a vector.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity would be $$O(2^n)$$, since we have to create 2^n elements in output, which is created one by one.\\n\\n- Space complexity:\\nSpace complexity would also be $$O(2^n)$$, for the same reason as time complexity (we have to create vector list containint 2^n elements.)\\n\\n# Code\\nThe code is as simple as it looks:\\nIt iterates from 0 to 2^n, converts each one to equivalent gray code, and collects it to a vector.\\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n1   0   1   1   1   0   0   1   1\\n|\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\\\  |\\n| \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ | \\\\ |\\n|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|  \\\\|\\n1   1   1   0   0   1   0   1   0\\n```\n```\\nRemember, second binary number is the first binary number right shifted once.\\n 1  0  1  1  1  0  0  1  1\\n^0  1  0  1  1  1  0  0  1\\n-|--|--|--|--|--|--|--|--|-\\n 1  1  1  0  0  1  0  1  0\\n```\n```\\nimpl Solution {\\n    pub fn gray_code(n: i32) -> Vec<i32> {\\n        (0..(1<<n)).map(into_gray).collect()\\n    }\\n}\\n#[inline]\\nfn into_gray(n : i32) -> i32 {\\n    n ^ (n >> 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695237,
                "title": "easy-to-understand-python-solution-faster-than-95",
                "content": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# logic is:\\n# for 1- [0,1]\\n# for 2 - [0,1,3,2] - not that first half of array is same as for n=1 addition for i=2 is (2**1)+1 => 3, (2**1)+0 => 2\\n# that is [0,1,1,0] => first half of array + concatenate reverse part of array and add powers of 2 to it  \\noldArr = [0,1]\\ni = 1\\nwhile i< n:\\n\\t# add old array\\n\\tnewArr = list(oldArr)\\n\\t# now add bit value to old reversed values\\n\\tfor j in range(len(oldArr)-1,-1,-1):\\n\\t\\tnewArr.append((2**i)+oldArr[j])\\n\\toldArr = newArr\\n\\ti+=1\\nreturn oldArr",
                "codeTag": "Unknown"
            },
            {
                "id": 2501346,
                "title": "easy-simple-small-in-o-n-n-2-time-complexity",
                "content": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        n2=2**n\\n        ans=[]\\n        for j in range(n2):\\n            st=0\\n            for i in range(n):\\n                if(((1<<i)&j>0 and (1<<(i+1))&j==0) or ((1<<i)&j==0 and (1<<(i+1))&j>0)):\\n                    st+=2**i\\n            ans.append(st)\\n        return(ans)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472189,
                "title": "direct-solution-faster-than-99-53-submissions",
                "content": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```\\n\\nSo, gray code works as follows :  Instead of 3 i.e 110 : It is 101\\nHow?? Each bit position stays the same if the next bit is 0, else flips. \\nIn place of 0b\\'abcd : we get a1_b1_c1_d1. d1==d, if c1 is 0. else flips\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tc1=c, if b1=0. else flips\\nThus the output current bit depends on the input next bit.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tvector<int> out;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            out.push_back(i ^(i>>1));\\n        }\\n        return out;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406111,
                "title": "clean-code",
                "content": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint gray(int n) {\\n        return n ^ (n >> 1);\\n    }\\n    \\n    vector<int> grayCode(int n) {\\n        n=1<<n;\\n        vector<int> ans(n); // specifying size of vector is important, otherwise Runtime Error\\n        for(int i=0; i<n; i++){\\n            ans[i]= gray(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171923,
                "title": "one-liner-python-solution-using-xor-and-right-shift",
                "content": "**Algorithm:**\\n1) Traverse from 0 to 2**n\\n2) In each iteration, right shift the number once and xor it with the original number to obtain the gray code.\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        ans = []\\n        for i in range(2**n):\\n            ans.append(i ^ (i>>1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105684,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = [0]\\n        visited = set()\\n        visited.add(0)\\n        self.grayCodeHelper(n, visited, result)\\n        return result\\n    \\n    def grayCodeHelper(self, n, visited, result):\\n        \\n        if len(result) == 1 << n:\\n            return True\\n        \\n        \\n        last_number = result[-1]\\n        \\n        for i in range(0,n):\\n            new_number = last_number ^ (1 << i)\\n                \\n            if new_number not in visited:\\n                visited.add(new_number)\\n                result.append(new_number)\\n                if self.grayCodeHelper(n, visited, result):\\n                    return True\\n                result.pop(-1)\\n                visited.remove(new_number)\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 2046672,
                "title": "observation-easy-c-solution-bit-manipulation",
                "content": "// Just observe the pattern how there is difference between bits in the input and accordingly perform the bits //operation\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE IF YOU FIND IT HELPFUL:)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>answer;               // create a vector to store the answer\\n        for(int i=0;i<=pow(2,n)-1;i++){      // traverse till 2^n-1 and push (i^(i>>1)) in the answer\\n            answer.push_back(i^(i>>1));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770100,
                "title": "gray-code-solution-java",
                "content": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n  public List<Integer> grayCode(int n) {\\n    List<Integer> ans = new ArrayList<>();\\n    ans.add(0);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (int j = ans.size() - 1; j >= 0; --j)\\n        ans.add(ans.get(j) | 1 << i);\\n\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1749052,
                "title": "several-ways-to-solve-it-cpp-can-t-be-more-simpler",
                "content": "**Way 1 : **\\n\\n![image](https://assets.leetcode.com/users/images/df66a229-1c9b-49d8-b2c8-6b4dcca8a620_1644127722.321113.png)\\n\\nIf you observe carefully gray(n) = gray(n-1) above the lines + gray(n-1) in reverse bellow the lines with extra 1!!\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\\n\\n\\n**Way 2 **\\n\\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        if(n==1) return {0,1};\\n        \\n        vector<int> p= grayCode(n-1);\\n        vector<int> q=p;reverse(q.begin(),q.end());\\n        int inc= 1<<(n-1);\\n        for(auto &i : q) i+=inc;\\n        p.insert(p.end(),q.begin(),q.end());\\n        \\n        return p;\\n    }\\n};\\n\\n```\n```\\nvector<int> grayCode(int n) {\\n      vector<int>ans;\\n        ans.push_back(0);\\n        if(n == 0) return ans;\\n        ans.push_back(1);\\n        \\n        int curr = 1;\\n        for(int i = 2; i <= n; i++){\\n          curr*=2;\\n            for(int j = ans.size()-1; j >= 0; j--) \\n                ans.push_back(curr+ans[j]);\\n        }    \\n        return ans;\\n    }: \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714940,
                "title": "c-97-faster-nth-gray-code",
                "content": "For a given number `n`, the n-bit gray code can be found as `n^(n/2)`\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> grayCode(int n) \\n    {\\n        vector<int> ans;\\n        int t = pow(2,n);\\n        int i=0;\\n        while(i<t)\\n        {\\n            ans.push_back(i^(i/2));\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663568,
                "title": "light-weight-python-solution",
                "content": "My solution:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\\n\\nThat was evolved from my first submission which is this:\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        if n == 0:\\n            return [0]\\n        rest = self.grayCode(n - 1)\\n        # everytime it builds one set, reverse the front part\\n        return [ r << 1 for r in rest] + [ (r << 1) + 1 for r in rest[::-1]]\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        result = set()\\n        def backtrack(i):\\n            if i == 0:\\n                return [[]]\\n            rest = backtrack(i - 1)\\n            result = []\\n            for r in rest:\\n                result.append(r + [\\'0\\'])\\n            for r in rest[::-1]:\\n                result.append(r + [\\'1\\'])\\n            return result\\n        \\n        return [ int(\"\".join(ar), 2) for ar in backtrack(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519011,
                "title": "python-one-liner-short-explanation",
                "content": "Picture a cube. 2x2.\\n\\nYou start at the top-left-front corner, labeled `000`. Move back along an edge to the top-left-back corner to get `001`. Looks like just increasing by 1 each time, but if we go to 2 (corner `010`) we change two bits. Hop to the right to 3 instead, which is at corner `011`. Then, we can go to 2 `010`.\\n\\nSo, when we switch to the right side of the cube (i.e. when we switch the second digit to `1`) we go the opposite direction, starting from the top (3) and decreasing (to 2), in effect inverting the third digit.\\n\\nAs we continue this reversing onto the bottom side of the cube (go for a tesseract if you\\'re feeling particularly marvelous), a bitwise pattern emerges. Take the binary representations of the counting numbers (the boringest way to say `000`, `001`, `010`, `011`, `100`, etc.) and whenever there is a `1` (the equivalent of being on the \"backwards\" side of the cube), invert the next bit. In a truth table, with the current bit on the side and previous bit on the top, you get\\n\\n```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\\n\\nOh neat! That looks like `XOR`! So we just want to `XOR` each number with itself, but pushed over one to the right. Bit of golf to iterate through the numbers from 0 to 2^n, right shift it over once, and then save the `XOR` result in a list.\\n\\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```\\n\\nAlso, this provides a O(1) function to retrieve the value in the sequence at *any* index. Which is neat.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    0  1\\n    ----\\n0 | 0  1\\n1 | 1  0\\n```\n```\\nclass Solution:\\n    def grayCode(self, n: int) -> List[int]:\\n        return [i^(i>>1) for i in range(1<<n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498963,
                "title": "gray-code-solution-in-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> grayCode(int n) {\\n        if(n==1){\\n            List<Integer> list = new ArrayList<Integer>();\\n            list.add(0);\\n            list.add(1);\\n            return list;\\n        }\\n        \\n        List<Integer> pres = grayCode(n-1);\\n        List<Integer> mres = new ArrayList<Integer>();\\n        for(int i=0;i<pres.size();i++){\\n            mres.add(0+2*pres.get(i));\\n        }\\n        for(int i=pres.size()-1 ; i>=0;i--){\\n            mres.add(1+2*pres.get(i));\\n        }\\n        \\n        return mres;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1564717,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1565251,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1566741,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568912,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1766371,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1571197,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1786326,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1785411,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1573702,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 2006483,
                "content": [
                    {
                        "username": "wuqia",
                        "content": "A simple Google search will reveal the secret behind Gray Code, of course. Knowing the formula, this question can be solved within 5 minutes. But what if I've never known anything about Gray Code? Is it feasible for someone to derive the formula during an interview? I think I would just get stuck for 45 minutes trying to figure out how to generate an algorithm for it. Is this question intended to test one's knowledge base?"
                    },
                    {
                        "username": "hynmj",
                        "content": "How can you comment in 2013 ?"
                    },
                    {
                        "username": "benjewmin",
                        "content": "I usually mess around in a little header area, ended up seeing something feasible for the n = 4 case. Made enough sense logically, but it was probably just lucky."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I think Gray Code is something common, even if you studied little during your first year, you know about it. "
                    },
                    {
                        "username": "zeroand1only",
                        "content": "the best one I found was tube video k5UYQtKXJGo. Some other videos were B.S."
                    },
                    {
                        "username": "pingtianli",
                        "content": "I started using search algorithms and I thought I was smart, lamo"
                    },
                    {
                        "username": "Samuri",
                        "content": "n = 0 mean the length is 0, so the program should return [].\\n\\nGo fix the test case please."
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "if n = 0, 2**0 is 1 and hence length is 1"
                    },
                    {
                        "username": "sanjeet_choudhary",
                        "content": "In the given problem constraints n>=1. So no need to look the n==0."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "The question says the solution length is 2^n, and includes numbers within the range [0,2^n -1]. 2^0=1, and 2^0-1=0, so if n=0 the solution is a 1 item array with a value in the range [0,0]."
                    },
                    {
                        "username": "Jack84283",
                        "content": "Input: \\t0\\nOutput: \\t[]\\nExpected: \\t[0]"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "who make this question? Why do you assume everyone should know what is Gray Code?"
                    },
                    {
                        "username": "alex_lanes",
                        "content": "This is a valid representation of rules on description, but [ 0, 8, 12, 14, 15, 7, 3, 1 ] is not a valid answer\\n0000\\n1000\\n1100\\n1110\\n1111\\n0111\\n0011\\n0001"
                    },
                    {
                        "username": "avidsiman",
                        "content": "that's because your solution is not complete.  In this particular example, all values in range 0-15 are in the solution set.  The trick is how to organize them."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "Input:\\n3\\nOutput:\\n[0,1,3,2,6,4,5,7]\\nExpected:\\n[0,1,3,2,6,7,5,4]"
                    },
                    {
                        "username": "pr20sh01ant",
                        "content": "6 saal ho gaye abhi bhi aise chapri mistakes karta hai kya?"
                    },
                    {
                        "username": "bikcrum",
                        "content": "Note this from the description. \"The binary representation of the first and last integers differs by exactly one bit.\""
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Why so many dislikes? It is a genuine question in my opinion."
                    },
                    {
                        "username": "Chandra15",
                        "content": "Well its a easy problem related if you already know what is gray code and know the formula but with out that it can be tough to figure it out on your own especially during an interview"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "How this can be backtracking problem? We are finding out just adjacent bits with difference 1, we cannot backtrack otherwise we may end up in two adjacent numbers with more than one bit difference."
                    },
                    {
                        "username": "lidaivet",
                        "content": "I initially thought about bit manipulation and I spent all my time trying to figure out a backtrack way because I got to this problem from a backtrack tagged list. Thoughts on changing the tag?"
                    },
                    {
                        "username": "gorman",
                        "content": "The problem description states that we can return **any valid n-bit gray code sequence**.  The test cases however consider some other unstated rule(s).\\n\\nFor example, the sequence [0,1,3,7,6,4] qualifies for n=3 based on the stated rules:\\n* Every integer is in the inclusive range [0, 2n - 1].:   True.\\n* The first integer is 0,:   True.\\n* An integer appears no more than once in the sequence.:   True.\\n* The binary representation of every pair of adjacent integers differs by exactly one bit.:   True.\\n* The binary representation of the first and last integers differs by exactly one bit.:   True.\\n\\nYet, this is considered a \"Wrong Answer\" when run, expecting [0,1,3,2,6,7,5,4].\\nIt appears that it wants every possible integer between [0, 1<<n) to be in the return sequence.  If this is a requirement, it should be explicitly stated in the problem text."
                    },
                    {
                        "username": "kanaktanwarpro",
                        "content": "It is stated that an n-bit gray code should have 2^n numbers. That is not satisfied by your example.\\n"
                    }
                ]
            },
            {
                "id": 1568911,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1996171,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1571198,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1573155,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2059245,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2022337,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 2016675,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1990286,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1960932,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            },
            {
                "id": 1906517,
                "content": [
                    {
                        "username": "douglasleer",
                        "content": "OJ's test case of n = 0 has a result of [0].\\n\\nBut I think the result of n = 0 should be [], i.e., an empty list, instead of a list with 0.\\n\\nMy argument is that, n is the number of bits. If n = 0, it means 0 bits, i.e., no bits!\\nWhat number can have not bits? Even 0 has at list one bit, which is 0.\\n\\nIf you assume that [0] should be returned when n = 0, then, you mean 0 has no bits.\\nThen you need to remove 0 from [0, 1], which is the result when n = 1. This doesn't make sense.\\n\\nAnyone agree with me?"
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "0 is not in constraints"
                    },
                    {
                        "username": "davendano",
                        "content": "I believe the python3 solution is broken:\\n\\nwhen trying to Run or Submit there is a SyntaxError:\\n\\nSyntaxError: invalid syntax\\n                                    ^\\n    if len(arr) != sz or arr[0] != 0:\\nLine 11  (Solution.py)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Same as JS"
                    },
                    {
                        "username": "steamgjk",
                        "content": "In my opinion, when n=0, the answer should be null. But the test data is {0}. I think it needs a better explanation. Except for this, the problem is okay."
                    },
                    {
                        "username": "guochun",
                        "content": "\\nvar grayCode = function (n) {\\n  return Array.from({ length: Math.pow(2, n) }, (_, i) => i ^ (i >>> 1))\\n}\\n\\nvar grayCode = function(n) {\\n  return Array.apply(null,{length: Math.pow(2,n)}).map((_,i) => i ^ (i >>> 1))\\n}\\n"
                    },
                    {
                        "username": "rnilawar",
                        "content": "`\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> list = new ArrayList<>();\n        list.add(0);\n        int prev=0;\n        int len=(int)Math.pow(2,n);\n\n\n        for(int i=1;i<len/2;i++){\n            int bitCount=getBitCount(i);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i+1);\n                list.add(i);\n                i++;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n        for(int i=len-1;i>=len/2;i--){\n            int bitCount=getBitCount(i);\n\n            System.out.println(Math.abs(bitCount-prev)+\" \"+i+\" \"+bitCount+\" \"+prev);\n\n            if(Math.abs(bitCount-prev)!=1){\n                list.add(i-1);\n                list.add(i);\n                i--;\n            }\n            else{\n                list.add(i);\n            }\n             prev=bitCount;\n        }\n\n\n        return list;\n    }\n    public int getBitCount(int n){\n        int count=0;\n        while(n>0){\n            if((n&1)!=0)count++;\n            n=n>>1;\n        }\n        return count;\n    }\n}\n`\n\nThis solution is correct as well as satisfies the conditions mentioned in the question, Can any one please help me by telling what's wrong in it?\n\n\nInput\nn =\n4\nOutput\n[0,1,3,2,5,4,6,7,15,14,12,13,10,11,9,8]\nExpected\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]\n\n1 1\n3 2\n2 1\n5 2\n4 1\n6 2\n7 3\n15 4\n14 3\n12 2\n13 3\n10 2\n11 3\n9 2\n8 1\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "why does somany people disliked it\\n"
                    },
                    {
                        "username": "zuigetsu",
                        "content": "Wrong Answer\nn =3\nOutput\n[0,1,3,7,5,2,6,4]\nExpected\n[0,1,3,2,6,7,5,4]\n\nbut [0,1,3,7,5,2,6,4] is correct:\n000\n001\n011\n111\n101\n010\n110\n100"
                    },
                    {
                        "username": "neebaok",
                        "content": "I\\'ve googled how gray code works. \\nAnd for N = 3 situation, My code Output is [0,1,3,2,7,6,4,5] which seems right to me.\\nhow come the expected answer is [0,1,3,2,6,7,5,4] ???\\n010 of 3 and 111 of 4 is not differs by exactly one bit!\\n"
                    },
                    {
                        "username": "bmolutov",
                        "content": "1. Consider all numbers from 0 to 2^n-1\\n2. Convert them to Gray code representation\\n\\nHow to convert?\\n1) Take Most Significant Bit (leftmost bit), save it\\n2) Do xor of all neighboring values, save results\\n\\nexample:\\nif we have 1011 (11)\\nMSB = 1\\n1 xor 0 = 1\\n0 xor 1 = 1\\n1 xor 1 = 0\\nresult = 1110"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "What is wrong here?\\n\\nInput: n=5\\n\\nOutput:\\n[0,1,3,2,6,4,5,7,15,11,9,8,10,14,12,13,29,21,17,19,18,22,20,28,24,25,27,26,30,31,23,16]\\n\\nExpected:\\n[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]"
                    }
                ]
            }
        ]
    },
    {
        "title": "Rotate Array",
        "question_content": "<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>Output:</strong> [5,6,7,1,2,3,4]\n<strong>Explanation:</strong>\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-100,3,99], k = 2\n<strong>Output:</strong> [3,99,-1,-100]\n<strong>Explanation:</strong> \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.</li>\n\t<li>Could you do it in-place with <code>O(1)</code> extra space?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 54250,
                "title": "easy-to-read-java-solution",
                "content": "I really don't like those _*something little*_ line solutions as they are incredibly hard to read. Below is my solution.\\n\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, 0, k - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I really don't like those _*something little*_ line solutions as they are incredibly hard to read. Below is my solution.\\n\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, 0, k - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54277,
                "title": "summary-of-c-solutions",
                "content": "#1. Make an extra copy and then rotate. \\nTime complexity: O(n). Space complexity: O(n).\\n    \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }\\n                \\n                // Make a copy of nums\\n                vector<int> numsCopy(n);\\n                for (int i = 0; i < n; i++)\\n                {\\n                    numsCopy[i] = nums[i];\\n                }\\n                \\n                // Rotate the elements.\\n                for (int i = 0; i < n; i++)\\n                {\\n                    nums[(i + k)%n] = numsCopy[i];\\n                }\\n            }\\n        };\\n\\n#2. Start from one element and keep rotating until we have rotated n different elements.\\nTime complexity: O(n). Space complexity: O(1).\\n    \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }\\n                \\n                int cntRotated = 0;\\n                int start = 0;\\n                int curr = 0;\\n                int numToBeRotated = nums[0];\\n                int tmp = 0;\\n                // Keep rotating the elements until we have rotated n \\n                // different elements.\\n                while (cntRotated < n)\\n                {\\n                    do\\n                    {\\n                        tmp = nums[(curr + k)%n];\\n                        nums[(curr+k)%n] = numToBeRotated;\\n                        numToBeRotated = tmp;\\n                        curr = (curr + k)%n;\\n                        cntRotated++;\\n                    } while (curr != start);\\n                    // Stop rotating the elements when we finish one cycle, \\n                    // i.e., we return to start.\\n                    \\n                    // Move to next element to start a new cycle.\\n                    start++;\\n                    curr = start;\\n                    numToBeRotated = nums[curr];\\n                }\\n            }\\n        };\\n    \\n#3. Reverse the first n - k elements, the last k elements, and then all the n elements.\\nTime complexity: O(n). Space complexity: O(1).\\n        \\n        class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                k = k%n;\\n        \\n                // Reverse the first n - k numbers.\\n                // Index i (0 <= i < n - k) becomes n - k - i.\\n                reverse(nums, nums + n - k);\\n                \\n                // Reverse tha last k numbers.\\n                // Index n - k + i (0 <= i < k) becomes n - i.\\n                reverse(nums + n - k, nums + n);\\n                \\n                // Reverse all the numbers.\\n                // Index i (0 <= i < n - k) becomes n - (n - k - i) = i + k.\\n                // Index n - k + i (0 <= i < k) becomes n - (n - i) = i.\\n                reverse(nums, nums + n);\\n            }\\n        };\\n\\n#4. Swap the last k elements with the first k elements.\\nTime complexity: O(n). Space complexity: O(1).\\n\\n    class Solution \\n    {\\n    public:\\n        void rotate(int nums[], int n, int k) \\n        {\\n            for (; k = k%n; n -= k, nums += k)\\n            {\\n                // Swap the last k elements with the first k elements. \\n                // The last k elements will be in the correct positions\\n                // but we need to rotate the remaining (n - k) elements \\n                // to the right by k steps.\\n                for (int i = 0; i < k; i++)\\n                {\\n                    swap(nums[i], nums[n - k + i]);\\n                }\\n            }\\n        }\\n    };\\n\\n#5. Keep swapping two subarrays.\\nTime complexity: O(n). Space complexity: O(1).\\n    \\n    class Solution \\n    {\\n    public:\\n        void rotate(int nums[], int n, int k) \\n        {\\n            if ((n == 0) || (k <= 0) || (k%n == 0))\\n            {\\n                return;\\n            }\\n            \\n            k = k%n;\\n            // Rotation to the right by k steps is equivalent to swapping \\n            // the two subarrays nums[0,...,n - k - 1] and nums[n - k,...,n - 1].\\n            int start = 0;\\n            int tmp = 0;\\n            while (k > 0)\\n            {\\n                if (n - k >= k)\\n                {\\n                    // The left subarray with size n - k is longer than \\n                    // the right subarray with size k. Exchange \\n                    // nums[n - 2*k,...,n - k - 1] with nums[n - k,...,n - 1].\\n                    for (int i = 0; i < k; i++)\\n                    {\\n                        tmp = nums[start + n - 2*k + i];\\n                        nums[start + n - 2*k + i] = nums[start + n - k + i];\\n                        nums[start + n - k + i] = tmp;\\n                    }\\n                    \\n                    // nums[n - 2*k,...,n - k - 1] are in their correct positions now.\\n                    // Need to rotate the elements of nums[0,...,n - k - 1] to the right \\n                    // by k%n steps.\\n                    n = n - k;\\n                    k = k%n;\\n                }\\n                else\\n                {\\n                    // The left subarray with size n - k is shorter than \\n                    // the right subarray with size k. Exchange \\n                    // nums[0,...,n - k - 1] with nums[n - k,...,2*(n - k) - 1].\\n                    for (int i = 0; i < n - k; i++)\\n                    {\\n                        tmp = nums[start + i];\\n                        nums[start + i] = nums[start + n - k + i];\\n                        nums[start + n - k + i] = tmp;\\n                    }\\n                    \\n                    // nums[n - k,...,2*(n - k) - 1] are in their correct positions now.\\n                    // Need to rotate the elements of nums[n - k,...,n - 1] to the right \\n                    // by k - (n - k) steps.\\n                    tmp = n - k;\\n                    n = k;\\n                    k -= tmp;\\n                    start += tmp;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n        {\\n        public:\\n            void rotate(int nums[], int n, int k) \\n            {\\n                if ((n == 0) || (k <= 0))\\n                {\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1730142,
                "title": "java-c-python-a-very-very-well-detailed-explanation",
                "content": "```\\nWell, to be honest with you all. This is really not a hard problem! It\\'s an easy one\\n```\\n\\nAlright, what the question is saying that we have **given an array & we have to rotate the array to the right by k steps, where k is non-negative.**\\n```\\nOkay so, we have one thing that k will always be > 0.\\nBut, I will teach you, one bonus point as well what if k < 0 i.e. k is -ve then how can you rotate the array.\\n```\\nLet\\'s undertsand this problem using an example,\\n**Input:** nums = [1,2,3,4,5,6,7], k = 3\\n**Output:** [5,6,7,1,2,3,4]\\n\\n```\\n\"K all possible rotation\"\\n\\n[7,1,2,3,4,5,6], k = 1\\n[6,7,1,2,3,4,5], k = 2\\n[5,6,7,1,2,3,4], k = 3\\n[4,5,6,7,1,2,3], k = 4\\n[3,4,5,6,7,1,2], k = 5\\n[2,3,4,5,6,7,1], k = 6\\n[1,2,3,4,5,6,7], k = 7\\n```\\n\\nWe have **k is 3**, so it means we have to take **3 values from the back** and **put in the front** of the array values.\\n\\nSo, for that what we will do is, we will break Array into 2 parts. **Part1[P1] & Part2[P2]**\\n* `[P1] is defined as` the array part just before the last 3 values. What I mean is something like [1,2,3,4]\\n* `[P2] is defined as` the array part just after remaining values which we have to rotate [5,6,7]\\n\\n![image](https://assets.leetcode.com/users/images/bafbf0fc-198b-4fe2-b4e9-974330840daf_1643513368.0827003.png)\\n\\nSo, in order to rotate this Array **k times** what we will do is, we will reverse the **P1 first which become [4,3,2,1]** & then we **reverse P2 which becomes [7,6,5]**\\nNow finally what we have to do is we gonna **reverse the complete array** by doing that what will happen is our array become **[5,6,7,1,2,3,4]** and that\\'s what we want in our **Output**\\n\\n![image](https://assets.leetcode.com/users/images/b303db4f-a485-41ef-9b0a-1e5141c634d3_1643514374.4636352.png)\\n\\nBut, what if we have **k = 101**, then we will **not rotate it** 101 times. It simply means **till 100 times it will be [1,2,3,4,5,6,7]** & we have to **rotate only 1 time i.e. [7,1,2,3,4,5,6]**. So, now your question is how can we handle this, we simply do the **modulo of \"k\"** with length of array\\n```\\nOkay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.\\nEg - \\nInput : [1,2,3,4,5,6,7], k = -1\\nOutput : [2,3,4,5,6,7,1]\\n\\nNow how did we figure out this, if you carefully look that k = -1 is equals to k = 6.\\nJust look at the table which I have made for every possible k values\\n\\nSo, what It represent is that add the -ve value to the length of array. And you will get your answer!\\n```\\n\\n*I hope Approach is crystal clear now!* **Let\\'s do some dirty work**, `\"code it up\"`\\n\\n*code each line explained :* `Similar for C++, Java, Python` **{Only Syntax Difference}** approach same\\n* Step - 1\\n```\\n// reversing the array values\\n    public static void reverse(int nums[], int i, int j){\\n        int li = i; // left index;\\n        int ri = j; // right index\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n```\\n* Step - 2\\n```\\npublic void rotate(int[] nums, int k) {\\n        k = k % nums.length; // if we have let\\'s say 101 to rotate, then we only rotate it 1 time not 101 times\\n        if(k < 0){ // if we get -ve value, then -ve is just equals to it\\'s -ve + array.length\\n            k += nums.length;\\n        }\\n        // part 1 reverse\\n        reverse(nums, 0, nums.length - k - 1);\\n        // part 2 reverse\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        // complete reverse\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n\\t public static void reverse(int nums[], int i, int j){\\n        int li = i;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length; \\n        if(k < 0){ \\n            k += nums.length;\\n        }\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    public :\\n    void reverse(vector<int>& nums, int i, int j){\\n        int li = i; // left;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if(k < 0){ \\n            k += nums.size();\\n        }\\n        reverse(nums, 0, nums.size() - k - 1);\\n        reverse(nums, nums.size() - k, nums.size() - 1);\\n        reverse(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def reverse (self, nums, i, j) : \\n        li = i\\n        ri = j\\n        \\n        while li < ri:\\n            temp = nums[li]\\n            nums[li] = nums[ri]\\n            nums[ri] = temp\\n            \\n            li += 1\\n            ri -= 1\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        if k < 0 : \\n            k += len(nums)\\n        \\n        self.reverse(nums, 0, len(nums) - k - 1);\\n        self.reverse(nums, len(nums) - k, len(nums) - 1);\\n        self.reverse(nums, 0, len(nums) - 1);\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nWell, to be honest with you all. This is really not a hard problem! It\\'s an easy one\\n```\n```\\nOkay so, we have one thing that k will always be > 0.\\nBut, I will teach you, one bonus point as well what if k < 0 i.e. k is -ve then how can you rotate the array.\\n```\n```\\n\"K all possible rotation\"\\n\\n[7,1,2,3,4,5,6], k = 1\\n[6,7,1,2,3,4,5], k = 2\\n[5,6,7,1,2,3,4], k = 3\\n[4,5,6,7,1,2,3], k = 4\\n[3,4,5,6,7,1,2], k = 5\\n[2,3,4,5,6,7,1], k = 6\\n[1,2,3,4,5,6,7], k = 7\\n```\n```\\nOkay Bonus point what if we have k = -1, then how can we rotate the array. If k is -1 then we have to rotate the value backward not in the front.\\nEg - \\nInput : [1,2,3,4,5,6,7], k = -1\\nOutput : [2,3,4,5,6,7,1]\\n\\nNow how did we figure out this, if you carefully look that k = -1 is equals to k = 6.\\nJust look at the table which I have made for every possible k values\\n\\nSo, what It represent is that add the -ve value to the length of array. And you will get your answer!\\n```\n```\\n// reversing the array values\\n    public static void reverse(int nums[], int i, int j){\\n        int li = i; // left index;\\n        int ri = j; // right index\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n```\n```\\npublic void rotate(int[] nums, int k) {\\n        k = k % nums.length; // if we have let\\'s say 101 to rotate, then we only rotate it 1 time not 101 times\\n        if(k < 0){ // if we get -ve value, then -ve is just equals to it\\'s -ve + array.length\\n            k += nums.length;\\n        }\\n        // part 1 reverse\\n        reverse(nums, 0, nums.length - k - 1);\\n        // part 2 reverse\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        // complete reverse\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n```\n```\\nclass Solution {\\n\\t public static void reverse(int nums[], int i, int j){\\n        int li = i;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length; \\n        if(k < 0){ \\n            k += nums.length;\\n        }\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public :\\n    void reverse(vector<int>& nums, int i, int j){\\n        int li = i; // left;\\n        int ri = j;\\n        \\n        while(li < ri){\\n            int temp = nums[li];\\n            nums[li] = nums[ri];\\n            nums[ri] = temp;\\n            \\n            li++;\\n            ri--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if(k < 0){ \\n            k += nums.size();\\n        }\\n        reverse(nums, 0, nums.size() - k - 1);\\n        reverse(nums, nums.size() - k, nums.size() - 1);\\n        reverse(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reverse (self, nums, i, j) : \\n        li = i\\n        ri = j\\n        \\n        while li < ri:\\n            temp = nums[li]\\n            nums[li] = nums[ri]\\n            nums[ri] = temp\\n            \\n            li += 1\\n            ri -= 1\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        if k < 0 : \\n            k += len(nums)\\n        \\n        self.reverse(nums, 0, len(nums) - k - 1);\\n        self.reverse(nums, len(nums) - k, len(nums) - 1);\\n        self.reverse(nums, 0, len(nums) - 1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54252,
                "title": "java-o-1-space-solution-of-rotate-array",
                "content": "The basic idea is that, for example, nums = [1,2,3,4,5,6,7] and k = 3, first we reverse [1,2,3,4], it becomes[4,3,2,1]; then we reverse[5,6,7], it becomes[7,6,5], finally we reverse the array as a whole, it becomes[4,3,2,1,7,6,5] ---> [5,6,7,1,2,3,4].\\n\\nReverse is done by using two pointers, one point at the head and the other point at the tail, after switch these two, these two pointers move one position towards the middle. \\n\\n\\npublic class Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n\\n        if(nums == null || nums.length < 2){\\n            return;\\n        }\\n        \\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length - k - 1);\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        \\n    }\\n    \\n    private void reverse(int[] nums, int i, int j){\\n        int tmp = 0;       \\n        while(i < j){\\n            tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n\\n        if(nums == null || nums.length < 2){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54294,
                "title": "my-solution-by-using-python",
                "content": "    class Solution:\\n        # @param nums, a list of integer\\n        # @param k, num of steps\\n        # @return nothing, please modify the nums list in-place.\\n        def rotate(self, nums, k):\\n            n = len(nums)\\n            k = k % n\\n            nums[:] = nums[n-k:] + nums[:n-k]\\n        \\n\\nA little important thing to be cautious:  \\n\\n    nums[:] = nums[n-k:] + nums[:n-k] \\ncan't be written as:\\n\\n    nums = nums[n-k:] + nums[:n-k]\\n\\non the OJ. \\n    \\nThe previous one can truly change the value of **old** *nums*, but the following one just changes its reference to a **new** *nums* not the value of **old** *nums*.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @param nums, a list of integer\\n        # @param k, num of steps\\n        # @return nothing, please modify the nums list in-place.\\n        def rotate(self, nums, k):\\n            n = len(nums)\\n            k = k % n\\n            nums[:] = nums[n-k:] + nums[:n-k]\\n        \\n\\nA little important thing to be cautious:  \\n\\n    nums[:] = nums[n-k:] + nums[:n-k] \\ncan't be written as:\\n\\n    nums = nums[n-k:] + nums[:n-k]\\n\\non the OJ. \\n    \\nThe previous one can truly change the value of **old** *nums*, but the following one just changes its reference to a **new** *nums* not the value of **old** *nums*.",
                "codeTag": "Java"
            },
            {
                "id": 3506340,
                "title": "beats-100-3-line-solution-fully-most-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExample:-1234567 ,k=3\\n1.first reverse the numbers form index 0 to n-k;\\n->4321 567\\n2.reverse the k elements from the last \\n->4321 765\\n3.now reverse the whole nums;\\n->5671234 Done Answer is here !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // vector<int>temp;\\n        // int len=nums.size();\\n        // int j=0;\\n        // k=k%len;\\n        // for(int i=0;i<abs(len-k);i++)\\n        // {\\n        //     //1,2,3,4\\n        //     cout<<nums[i]<<\" \";\\n        //     temp.push_back(nums[i]);\\n        // }\\n        // cout<<endl;\\n        // for(int i=abs(len-k);i<len;i++)\\n        // {\\n        //     //5,6,7\\n\\n        //     cout<<nums[i]<<endl;\\n        //     nums[abs(i-abs(len-k))]=nums[i];\\n        // }\\n        // for(int i=k;i<len;i++)\\n        // {\\n        //     nums[i]=temp[j];\\n        //     j++;\\n        // }\\n        \\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n    \\n        reverse(nums.begin(),nums.end());\\n            \\n\\n        \\n        \\n\\n        \\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/be16a9b6-6d5f-433f-89e8-90f18384d6f9_1683670956.5248532.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // vector<int>temp;\\n        // int len=nums.size();\\n        // int j=0;\\n        // k=k%len;\\n        // for(int i=0;i<abs(len-k);i++)\\n        // {\\n        //     //1,2,3,4\\n        //     cout<<nums[i]<<\" \";\\n        //     temp.push_back(nums[i]);\\n        // }\\n        // cout<<endl;\\n        // for(int i=abs(len-k);i<len;i++)\\n        // {\\n        //     //5,6,7\\n\\n        //     cout<<nums[i]<<endl;\\n        //     nums[abs(i-abs(len-k))]=nums[i];\\n        // }\\n        // for(int i=k;i<len;i++)\\n        // {\\n        //     nums[i]=temp[j];\\n        //     j++;\\n        // }\\n        \\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n    \\n        reverse(nums.begin(),nums.end());\\n            \\n\\n        \\n        \\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 269948,
                "title": "4-solutions-in-python-from-easy-to-hard",
                "content": "A good start ito think a wayt out is brute force \\n\\n1. Approach #1 \\n\\n   varaible `previous` to store the number being replaced.\\n\\n   ```python\\n   class Solution1:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           for _ in range(k):\\n               previous = nums[-1] #initiate a first previous \\n               for i in range(len(nums)):\\n                   temp = nums[i] #hodl nums[i]\\n                   nums[i] = previous #overwrite the current index \\n                   previous = temp #swap the value \\n           logging.debug(f\"nums: {nums}\")\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O( *n*\\u2217*k*). All the numbers are shifted by one step(O (n)*O*(*n*)) k times(O (k)*O* ( *k* ) ).\\n   - Space complexity : O(1). No extra space is used.\\n\\n2. Approch #2 Using Extra Array\\n\\n   We use an extra array in which we place every element of the array at its correct position i.e. the number at index i*i* in the original array is placed at the index (i+k)%(length of array)(*i*+*k*). Then, we copy the new array to the original one.\\n\\n   ```python\\n   class Solution2:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           a = [0] * len(nums)\\n           for i in range(len(nums)):\\n               a[(i+k)%len(nums)] = nums[i] #recycle\\n   \\n           for i in range(len(nums)):\\n               nums[i] = a[i]\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n). One pass is used to put the numbers in the new array. And another pass to copy the new array to the original one.\\n   - Space complexity :O*(*n). Another array of the same size is used.\\n\\n\\n\\n3. Approach #3 Using Cyclic Replacements\\n\\n   ![solution 3](https://leetcode.com/media/original_images/189_Rotate_Array.png)\\n\\n   ```python\\n   class Solution3:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k = k % len(nums)\\n           count = 0\\n           start = 0\\n           while count < len(nums):\\n               current = start \\n               prev = nums[start] #store the value in the position\\n               \\n               while True:\\n                   next = (current + k) % len(nums) #\\n                   temp = nums[next] #store it temporaly \\n                   nums[next] = prev #overide the next \\n                   prev = temp #reset prev\\n                   current = next #reset current\\n                   count += 1\\n   \\n                   if start == current:\\n                       break \\n               \\n               start += 1\\n   ```\\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n). Only one pass is used.\\n   - Space complexity : O(1). Constant extra space is used.\\n\\n\\n\\n\\n\\n4. #### Approach #4 Using Reverse \\n\\n   **Algorithm**\\n\\n   This approach is based on the fact that when we rotate the array k times, k%n*k* elements from the back end of the array come to the front and the rest of the elements from the front shift backwards.\\n\\n   In this approach, we firstly reverse all the elements of the array. Then, reversing the first k elements followed by reversing the rest n-k*n*\\u2212*k*elements gives us the required result.\\n\\n   Let n=7*n*=7 and k=3*k*=3.\\n\\n   ```python\\n   Original List                   : 1 2 3 4 5 6 7\\n   After reversing all numbers     : 7 6 5 4 3 2 1\\n   After reversing first k numbers : 5 6 7 4 3 2 1\\n   After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result\\n   ```\\n\\n   ```python\\n   class Solution4:\\n       def rotate(self, nums, k) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k %= len(nums)\\n           self.reverse(nums,0,len(nums)-1)\\n           self.reverse(nums,0, k-1)\\n           self.reverse(nums,k, len(nums)-1)\\n   \\n       def reverse(self, nums, start, end) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type start: int\\n           :type end: int\\n           :rtype: None\\n           \"\"\"\\n           while start < end: #\\n               temp = nums[start]\\n               nums[start] = nums[end]\\n               nums[end] = temp \\n               start += 1\\n               end -= 1\\n   ```\\n\\n   \\n\\n   **Complexity Analysis**\\n\\n   - Time complexity : O(n) .n*n*elements are reversed a total of three times.\\n   - Space complexity : O(1). No extra space is used.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n   class Solution1:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           for _ in range(k):\\n               previous = nums[-1] #initiate a first previous \\n               for i in range(len(nums)):\\n                   temp = nums[i] #hodl nums[i]\\n                   nums[i] = previous #overwrite the current index \\n                   previous = temp #swap the value \\n           logging.debug(f\"nums: {nums}\")\\n   ```\n```python\\n   class Solution2:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           a = [0] * len(nums)\\n           for i in range(len(nums)):\\n               a[(i+k)%len(nums)] = nums[i] #recycle\\n   \\n           for i in range(len(nums)):\\n               nums[i] = a[i]\\n   ```\n```python\\n   class Solution3:\\n       def rotate(self, nums, k):\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k = k % len(nums)\\n           count = 0\\n           start = 0\\n           while count < len(nums):\\n               current = start \\n               prev = nums[start] #store the value in the position\\n               \\n               while True:\\n                   next = (current + k) % len(nums) #\\n                   temp = nums[next] #store it temporaly \\n                   nums[next] = prev #overide the next \\n                   prev = temp #reset prev\\n                   current = next #reset current\\n                   count += 1\\n   \\n                   if start == current:\\n                       break \\n               \\n               start += 1\\n   ```\n```python\\n   Original List                   : 1 2 3 4 5 6 7\\n   After reversing all numbers     : 7 6 5 4 3 2 1\\n   After reversing first k numbers : 5 6 7 4 3 2 1\\n   After revering last n-k numbers : 5 6 7 1 2 3 4 --> Result\\n   ```\n```python\\n   class Solution4:\\n       def rotate(self, nums, k) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type k: int\\n           :rtype: None Do not return anything, modify nums in-place instead.\\n           \"\"\"\\n           k %= len(nums)\\n           self.reverse(nums,0,len(nums)-1)\\n           self.reverse(nums,0, k-1)\\n           self.reverse(nums,k, len(nums)-1)\\n   \\n       def reverse(self, nums, start, end) -> None:\\n           \"\"\"\\n           :type nums: List[int]\\n           :type start: int\\n           :type end: int\\n           :rtype: None\\n           \"\"\"\\n           while start < end: #\\n               temp = nums[start]\\n               nums[start] = nums[end]\\n               nums[end] = temp \\n               start += 1\\n               end -= 1\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3351511,
                "title": "java-100-faster-soluion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2dbd188f-23fb-4f11-a067-e48f48a3a491_1680007896.3123865.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static void reverse(int nums[], int start, int end){\\n    // While start index is less than end index\\n    while(start < end){\\n        // Swap elements at start and end indices\\n        int temp = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = temp;\\n        // Increment start index and decrement end index\\n        start++;\\n        end--;\\n    }\\n}\\n\\n    public void rotate(int[] nums, int k) {\\n        // Ensure k is within array bounds\\n        k %= nums.length;\\n        // Reverse entire array\\n        reverse(nums, 0, nums.length - 1);\\n        // Reverse first k elements\\n        reverse(nums, 0, k - 1);\\n        // Reverse remaining elements\\n        reverse(nums, k, nums.length - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static void reverse(int nums[], int start, int end){\\n    // While start index is less than end index\\n    while(start < end){\\n        // Swap elements at start and end indices\\n        int temp = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = temp;\\n        // Increment start index and decrement end index\\n        start++;\\n        end--;\\n    }\\n}\\n\\n    public void rotate(int[] nums, int k) {\\n        // Ensure k is within array bounds\\n        k %= nums.length;\\n        // Reverse entire array\\n        reverse(nums, 0, nums.length - 1);\\n        // Reverse first k elements\\n        reverse(nums, 0, k - 1);\\n        // Reverse remaining elements\\n        reverse(nums, k, nums.length - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730030,
                "title": "c-brute-force-o-n-o-1-solutions-optimized-w-explanation",
                "content": "**APPROACH 1 : Brute Force**\\n\\n* If ```k>=n``` do ```k = k%n```\\n* Create a ```temp``` array of size ```k```.\\n* Store the last ```k``` elements in a temp array.\\n* Shift the rest of the elements each by 1 position to the right.\\n* Store the last ```k``` elements in the first ```k``` indices.\\n\\n**Time Complexity :** O(n)\\n\\n**Space Complexity :** O(k)\\n\\n**APPROACH 2 : Rotate k times**\\n\\n* Rotate all the elements by 1 position ```k``` times.\\n\\n**Time Complexity :** O()\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n\\tvoid rotateByOne(vector<int> &nums){\\n\\t\\tint n = nums.size(), temp = nums[n-1];\\n\\t\\tfor(int i=n-1; i>0; i--){\\n\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t\\tnums[0] = temp;\\n\\t\\t}\\n\\t}\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0; i<k; i++) rotateByOne(nums);\\n    }\\n};\\n```\\n\\n**APPROACH 3 : Reversal of array**\\n\\n* Reverse the whole array.\\n* Then reverse the first k elements.\\n* Finally reverse the remaining elements.\\n(Do a dry run, it\\'s very easy to understand)\\n\\n**Time Complexity :** O(n)\\n\\n**Space Complexity :** O(1)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```\\n\\n**Do upvote if you like my solutions & explanation :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```k>=n```\n```k = k%n```\n```temp```\n```k```\n```k```\n```k```\n```k```\n```k```\n```\\nclass Solution {\\npublic:\\n\\tvoid rotateByOne(vector<int> &nums){\\n\\t\\tint n = nums.size(), temp = nums[n-1];\\n\\t\\tfor(int i=n-1; i>0; i--){\\n\\t\\t\\tnums[i] = nums[i-1];\\n\\t\\t\\tnums[0] = temp;\\n\\t\\t}\\n\\t}\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0; i<k; i++) rotateByOne(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k%nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54249,
                "title": "3-line-using-reverse",
                "content": "    void rotate(int nums[], int n, int k) {\\n        reverse(nums,nums+n);\\n        reverse(nums,nums+k%n);\\n        reverse(nums+k%n,nums+n);\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        reverse(nums,nums+n);\\n        reverse(nums,nums+k%n);\\n        reverse(nums+k%n,nums+n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54426,
                "title": "summary-of-solutions-in-python",
                "content": "## **Classical 3-step array rotation:**\\n> \\n> 1. reverse the first n - k elements\\n> \\n> 2. reverse the rest of them\\n> \\n> 3. reverse the entire array\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            if k is None or k <= 0:\\n                return\\n            k, end = k % len(nums), len(nums) - 1\\n            self.reverse(nums, 0, end - k)\\n            self.reverse(nums, end - k + 1, end)\\n            self.reverse(nums, 0, end)\\n            \\n        def reverse(self, nums, start, end):\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start, end = start + 1, end - 1\\n\\n**O(n) in time, O(1) in space**\\n\\n\\n## **Rotate `k` times**:\\n\\nEach rotation, we move the `n - 1` to the back of the array one by one and we do rotation `k` times.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            k = k % len(nums)\\n            for i in xrange(0, k):\\n                tmp = nums[-1]\\n                for j in xrange(0, len(nums) - 1):\\n                    nums[len(nums) - 1 - j] = nums[len(nums) - 2 - j]\\n                nums[0] = tmp\\n\\n**O(n^2) in  time, O(1) in space**\\n\\n**It can't pass the OJ due to TLE.**\\n\\n## **Recursive solution** \\n\\nput the shorter part in the correct position then do the rest of them iteratively. This is not necessarily to be a recursive solution. \\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            self.helper(0, len(nums) - 1 - (k % len(nums)), len(nums) - 1, nums) # mid belongs to left part\\n    \\n        def helper(self, start, mid, end, nums):\\n            left, right = mid - start, end - mid - 1\\n            if left < 0 or right < 0:\\n                return\\n            if left > right:\\n                for j in xrange(mid + 1, end + 1):\\n                    nums[j], nums[start] = nums[start], nums[j]\\n                    start += 1\\n                self.helper(start, mid, end, nums)\\n            elif right >= left:\\n                i = mid\\n                while i >= start:\\n                    nums[i], nums[end] = nums[end], nums[i]\\n                    i, end = i - 1, end - 1\\n                if left != right:\\n                    self.helper(start, mid, end, nums)\\n\\n**O(n) in time, O(n) in space**\\n\\n## **Iterative and improved solution:** \\n\\nput the last `k` elements in correct position (ahead) and do the remaining `n - k`. Once finish swap, the `n` and k decrease.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            n, k, j = len(nums), k % len(nums), 0\\n            while n > 0 and k % n != 0:\\n                for i in xrange(0, k):\\n                    nums[j + i], nums[len(nums) - k + i] = nums[len(nums) - k + i], nums[j + i] # swap\\n                n, j = n - k, j + k\\n                k = k % n\\n\\n**O(n) in time, O(1) in space**",
                "solutionTags": [],
                "code": "## **Classical 3-step array rotation:**\\n> \\n> 1. reverse the first n - k elements\\n> \\n> 2. reverse the rest of them\\n> \\n> 3. reverse the entire array\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            if k is None or k <= 0:\\n                return\\n            k, end = k % len(nums), len(nums) - 1\\n            self.reverse(nums, 0, end - k)\\n            self.reverse(nums, end - k + 1, end)\\n            self.reverse(nums, 0, end)\\n            \\n        def reverse(self, nums, start, end):\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start, end = start + 1, end - 1\\n\\n**O(n) in time, O(1) in space**\\n\\n\\n## **Rotate `k` times**:\\n\\nEach rotation, we move the `n - 1` to the back of the array one by one and we do rotation `k` times.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            k = k % len(nums)\\n            for i in xrange(0, k):\\n                tmp = nums[-1]\\n                for j in xrange(0, len(nums) - 1):\\n                    nums[len(nums) - 1 - j] = nums[len(nums) - 2 - j]\\n                nums[0] = tmp\\n\\n**O(n^2) in  time, O(1) in space**\\n\\n**It can't pass the OJ due to TLE.**\\n\\n## **Recursive solution** \\n\\nput the shorter part in the correct position then do the rest of them iteratively. This is not necessarily to be a recursive solution. \\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            self.helper(0, len(nums) - 1 - (k % len(nums)), len(nums) - 1, nums) # mid belongs to left part\\n    \\n        def helper(self, start, mid, end, nums):\\n            left, right = mid - start, end - mid - 1\\n            if left < 0 or right < 0:\\n                return\\n            if left > right:\\n                for j in xrange(mid + 1, end + 1):\\n                    nums[j], nums[start] = nums[start], nums[j]\\n                    start += 1\\n                self.helper(start, mid, end, nums)\\n            elif right >= left:\\n                i = mid\\n                while i >= start:\\n                    nums[i], nums[end] = nums[end], nums[i]\\n                    i, end = i - 1, end - 1\\n                if left != right:\\n                    self.helper(start, mid, end, nums)\\n\\n**O(n) in time, O(n) in space**\\n\\n## **Iterative and improved solution:** \\n\\nput the last `k` elements in correct position (ahead) and do the remaining `n - k`. Once finish swap, the `n` and k decrease.\\n\\n    class Solution(object):\\n        def rotate(self, nums, k):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type k: int\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            n, k, j = len(nums), k % len(nums), 0\\n            while n > 0 and k % n != 0:\\n                for i in xrange(0, k):\\n                    nums[j + i], nums[len(nums) - k + i] = nums[len(nums) - k + i], nums[j + i] # swap\\n                n, j = n - k, j + k\\n                k = k % n\\n\\n**O(n) in time, O(1) in space**",
                "codeTag": "Java"
            },
            {
                "id": 54289,
                "title": "my-three-way-to-solve-this-problem-the-first-way-is-interesting-java",
                "content": "Method 1: ( Interesting way, O(n) time cost, O(1) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            //find GCD between nums length and step\\n            int gcd = findGcd(nums.length, step);\\n            int position, count;\\n            \\n            //gcd path to finish movie\\n            for(int i = 0; i < gcd; i++){\\n                //beginning position of each path\\n                position = i;\\n                //count is the number we need swap each path\\n                count = nums.length / gcd - 1;\\n                for(int j = 0; j < count; j++){\\n                    position = (position + step) % nums.length;\\n                    //swap index value in index i and position\\n                    nums[i] ^= nums[position];\\n                    nums[position] ^= nums[i];\\n                    nums[i] ^= nums[position];\\n                }\\n            }\\n        }\\n        \\n        public int findGcd(int a, int b){\\n            return (a == 0 || b == 0) ? a + b : findGcd(b, a % b);\\n        }\\n        \\n    }\\n\\nMethod 2:( 3 reverse thinking, O(n) time cost, O(1) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            reverse(nums,0,nums.length - 1);\\n            reverse(nums,0,step - 1);\\n            reverse(nums,step,nums.length - 1);\\n        }\\n        \\n        //reverse int array from n to m\\n        public void reverse(int[] nums, int n, int m){\\n            while(n < m){\\n                nums[n] ^= nums[m];\\n                nums[m] ^= nums[n];\\n                nums[n] ^= nums[m];\\n                n++;\\n                m--;\\n            }\\n        }\\n    }\\n\\nMethod 3:( Normal way, O(n) time cost, O(k % nums.length) space cost)\\n\\n    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }\\n            //step each time to move\\n            int step = k % nums.length;\\n            int[] tmp = new int[step];\\n            for(int i = 0; i < step; i++){\\n                tmp[i] = nums[nums.length - step + i];\\n            }\\n            for(int i = nums.length - step - 1; i >= 0; i--){\\n                nums[i + step] = nums[i];\\n            }\\n            for(int i = 0; i < step; i++){\\n                nums[i] = tmp[i];\\n            }\\n            \\n        }\\n        \\n    }\\n\\t\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if(nums.length <= 1){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2747423,
                "title": "complete-python-explanation-5-methods",
                "content": "Let\\'s start with one of the simplest ways of solving this problem \\u2013\\u2013 rotating ```nums``` by 1 step, a total of ```k``` times. From this solution, we can work towards better methods of solving the problem.\\n\\n**Method 1: Rotate 1 Step at a Time; Time: O(n\\u2022k), Space: O(1) --> TLE**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length of nums\\n\\tfor _ in range(k):\\n\\t\\tprev = nums[-1] # previous element starts as the end\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums[i], prev = prev, nums[i] # this element becomes the previous one, store this element in prev\\n```\\nIn this solution, the inner part of our outer ```for``` loop rotates ```nums``` by one spot. We perform this operation ```k``` times to rotate by a total of ```k``` steps!\\n\\nThis solution takes ```O(n\\u2022k)``` time where ```n == Ien(nums)``` since we need to look at every number in ```nums``` once to rotate by one step, and we do this ```k``` times. Unfortunately, this results in a time limit exception :( so instead of rotating one step at a time, let\\'s try to rotate ```k``` steps at a time using a second array for extra storage!\\n\\nTo come up with this solution, we need to think more about how rotation actually works. First, let\\'s think about what happens if ```nums``` has length ```5``` and we rotate ```5``` times. By the time we\\'ve made our fifth rotation, ```nums``` will be back in its original orientation! Similarly, if we rotate ```6``` times, then the first ```5``` rotations won\\'t do anything so it\\'s the same as rotating just once! Essentially, rotating ```k``` times is the same as rotating ```k % n``` times! \\n\\nSecondly, if we are rotating ```3``` times, then the last three elements in ```nums``` are going to end up going to the beginning of the array! This means that we need to be careful that we don\\'t accidentally try to insert any elements into indices beyond the end of ```nums```.\\n\\nWith this knowledge we can realize that an element at index ```i``` will need to be at index ```(i + k) % n``` after our rotation! So we can use our second array to simply set every element in ```nums``` to be their new value.\\n\\n**Method 2: Copy Array; Time: O(n), Space; O(n)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tcopy = [num for num in nums] # copy the nums array\\n\\tn = len(nums)\\n\\tfor i, num in enumerate(copy): # for every element in the copy\\n\\t\\tnums[(i + k) % n] = copy[i] # set corresponding location in nums\\n```\\n(P.S. ```for i, num in enumerate(copy)``` is the same as using ```for i in range(n)``` and then saying ```num = copy[i]```)\\n\\nSince we made a copy of our original array, the space complexity is ```O(n)```. The time this solution takes scales directly with the number of elements, so it is ```O(n)```. This is a great solution and gets accepted, but we can still improve! \\n\\nEarlier we went over what happens if we rotate ```3``` times in an array of length ```5``` \\u2013 the last ```3``` elements get rotated to the front. This means that ```nums``` will become ```[last three elements] + [first two elements]```. In python syntax, this is ```nums[-3:] + nums[-3:]``` (the negative index is the same as using ```n-3```). Therefore, we want ```nums = nums[-k:] + nums[:-k]```! However, there are two important things to note. \\n\\nFirst, we need to remember that ```k``` can be bigger than ```n```! To avoid trying to index the ```-10```th element of an array of length ```5``` (in a hypothetical case where ```n = 5``` and ```k = 10```), we can use our mod operator from before \\u2013\\u2013 we really want ```nums = nums[-k%n:] + nums[:-k%n]```. To fix this we can just add ```k %= n``` at the beginning of our answer (this is the same as ```k = k % n```).\\n\\nSecond, if we set ```nums = nums[-k:] + nums[:-k]```, then we will actually be creating a new pointer for ```nums``` in memory. Since we want to actually set ```nums``` to this result, we need to set ```nums[:] = nums[-k:] + nums[:-k]```, which will overwrite ```nums``` element by element.\\n\\n**Method 3: Pythonic; Time: O(n), Space: O(n)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length\\n\\tk %= n # avoid unnecessary rotations\\n\\tnums[:] = nums[-k:] + nums[:-k] # set nums to answer\\n```\\nThis can also be turned into a one-liner:\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tnums[:] = nums[-k%len(nums):] + nums[:-k%len(nums)]\\n```\\nThis solution also takes ```O(n)``` time and space since we still look at every element once and we also need extra space temporarily for ```nums[-k:]``` and ```nums[:-k]```. This is a very pythonic solution, but since we know the order that the elements in ```nums``` will end up, we can optimize our space storage from ```O(n)``` to ```O(k)``` by just storing the last ```k``` elements of ```nums``` and shifting the first ```n-k``` manually.\\n\\n**Method 4: Store last k elements; Time: O(n), Space: O(k)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\tnums[:k] = end # put the old end to the front\\n```\\nThe key to this solution is that we have to iterate backwards through ```nums``` with our ```for i in range(n-k-1, -1, -1)``` loop since otherwise, we may overwrite future values that we need!\\n\\nThis solution still takes ```O(n)``` time but now takes just ```O(k)``` space! We can actually optimize this depending on whether or not the end or beginning of our array is smaller:\\n\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tif k < n//2: # if the end is less than half the size of the array\\n\\t\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\t\\tnums[:k] = end # put the old end to the front\\n\\t\\telse: # the end is bigger than the beginning so store the beginning\\n\\t\\t\\tbeg = nums[:-k] # store the beginning!\\n\\t\\t\\tfor i in range(n-k, n): # go forwards through the last k elements\\n\\t\\t\\t\\tnums[(i+k)%n] = nums[i] # shift them forwards k spots (to the front of the list)\\n\\t\\t\\tnums[k:] = beg # set the end to the beginning\\n```\\nThis makes the space complexity ```O(min(k, n-k))```.\\n\\nThis is a great solution but crazily there is one way to reduce the space complexity further! To do this, we need a special insight about how to rotate the array. We want the last ```k``` elements to become the first ```k``` elements of our array, so how about we begin by reversing the whole list. After that, the first ```k``` elements will be last ```k``` elements of our original list, but they will be in reverse order. Similarly, the new end of our list will be the old beginning, only in reverse order. So how do we remedy this? Well, we can reverse the first ```k``` elements of our new array and the last ```n-k``` elements! After that, the array will be fully rotated!\\n\\n**Method 5: Reverse; Time: O(n), Space: O(1)**\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tdef reverse(start, end): # helper method to reverse from start to end\\n\\t\\twhile start < end: # while there is stuff to reverse\\n\\t\\t\\tnums[start], nums[end] = nums[end], nums[start] # swap the elements at the ends\\n\\t\\t\\tstart, end = start + 1, end - 1 # move pointers closer to each other\\n\\t\\t\\t\\n\\tn = len(nums)\\n\\tk %= n\\n\\treverse(0,n-1) # reverse full list\\n\\treverse(0,k-1) # reverse first k elements (previously the last k elements)\\n\\treverse(k,n-1) # reverse the rest of the list\\n```\\n\\nIf you are still confused about how this works, I\\'ll show what ```nums``` looks like after each step with the example problems:\\n\\n***Example 1***\\n```\\noriginal nums: [1, 2, 3, 4, 5, 6, 7]\\nnums after fully reversing: [7, 6, 5, 4, 3, 2, 1]\\nnums after reversing the first k elements: [5, 6, 7, 4, 3, 2, 1]\\nnums after reversing the remaining elements: [5, 6, 7, 1, 2, 3, 4]\\n```\\n\\n***Example 2***\\n```\\noriginal nums: [-1, -100, 3, 99]\\nnums after fully reversing: [99, 3, -100, -1]\\nnums after reversing the first k elements: [3, 99, -100, -1]\\nnums after reversing the remaining elements: [3, 99, -1, -100]\\n```\\n\\n**Thanks for Reading!**\\nPlease consider upvoting the post if it helped you! If you have any questions, comments, or concerns, please leave them below and I will get to them as soon as possible.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length of nums\\n\\tfor _ in range(k):\\n\\t\\tprev = nums[-1] # previous element starts as the end\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums[i], prev = prev, nums[i] # this element becomes the previous one, store this element in prev\\n```\n```for```\n```nums```\n```k```\n```k```\n```O(n\\u2022k)```\n```n == Ien(nums)```\n```nums```\n```k```\n```k```\n```nums```\n```5```\n```5```\n```nums```\n```6```\n```5```\n```k```\n```k % n```\n```3```\n```nums```\n```nums```\n```i```\n```(i + k) % n```\n```nums```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tcopy = [num for num in nums] # copy the nums array\\n\\tn = len(nums)\\n\\tfor i, num in enumerate(copy): # for every element in the copy\\n\\t\\tnums[(i + k) % n] = copy[i] # set corresponding location in nums\\n```\n```for i, num in enumerate(copy)```\n```for i in range(n)```\n```num = copy[i]```\n```O(n)```\n```O(n)```\n```3```\n```5```\n```3```\n```nums```\n```[last three elements] + [first two elements]```\n```nums[-3:] + nums[-3:]```\n```n-3```\n```nums = nums[-k:] + nums[:-k]```\n```k```\n```n```\n```-10```\n```5```\n```n = 5```\n```k = 10```\n```nums = nums[-k%n:] + nums[:-k%n]```\n```k %= n```\n```k = k % n```\n```nums = nums[-k:] + nums[:-k]```\n```nums```\n```nums```\n```nums[:] = nums[-k:] + nums[:-k]```\n```nums```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums) # store length\\n\\tk %= n # avoid unnecessary rotations\\n\\tnums[:] = nums[-k:] + nums[:-k] # set nums to answer\\n```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tnums[:] = nums[-k%len(nums):] + nums[:-k%len(nums)]\\n```\n```O(n)```\n```nums[-k:]```\n```nums[:-k]```\n```nums```\n```O(n)```\n```O(k)```\n```k```\n```nums```\n```n-k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\tnums[:k] = end # put the old end to the front\\n```\n```nums```\n```for i in range(n-k-1, -1, -1)```\n```O(n)```\n```O(k)```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tn = len(nums)\\n\\tk %= n\\n\\tif k != 0: # we only want to rotate the array if we need to\\n\\t\\tif k < n//2: # if the end is less than half the size of the array\\n\\t\\t\\tend = nums[-k:] # store the end of the array (which will become the front)\\n\\t\\t\\tfor i in range(n-k-1, -1, -1): # go backwards through the first n-k elements of the array\\n\\t\\t\\t\\tnums[i+k] = nums[i] # shift everything forward k spots\\n\\t\\t\\tnums[:k] = end # put the old end to the front\\n\\t\\telse: # the end is bigger than the beginning so store the beginning\\n\\t\\t\\tbeg = nums[:-k] # store the beginning!\\n\\t\\t\\tfor i in range(n-k, n): # go forwards through the last k elements\\n\\t\\t\\t\\tnums[(i+k)%n] = nums[i] # shift them forwards k spots (to the front of the list)\\n\\t\\t\\tnums[k:] = beg # set the end to the beginning\\n```\n```O(min(k, n-k))```\n```k```\n```k```\n```k```\n```k```\n```k```\n```n-k```\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tdef reverse(start, end): # helper method to reverse from start to end\\n\\t\\twhile start < end: # while there is stuff to reverse\\n\\t\\t\\tnums[start], nums[end] = nums[end], nums[start] # swap the elements at the ends\\n\\t\\t\\tstart, end = start + 1, end - 1 # move pointers closer to each other\\n\\t\\t\\t\\n\\tn = len(nums)\\n\\tk %= n\\n\\treverse(0,n-1) # reverse full list\\n\\treverse(0,k-1) # reverse first k elements (previously the last k elements)\\n\\treverse(k,n-1) # reverse the rest of the list\\n```\n```nums```\n```\\noriginal nums: [1, 2, 3, 4, 5, 6, 7]\\nnums after fully reversing: [7, 6, 5, 4, 3, 2, 1]\\nnums after reversing the first k elements: [5, 6, 7, 4, 3, 2, 1]\\nnums after reversing the remaining elements: [5, 6, 7, 1, 2, 3, 4]\\n```\n```\\noriginal nums: [-1, -100, 3, 99]\\nnums after fully reversing: [99, 3, -100, -1]\\nnums after reversing the first k elements: [3, 99, -100, -1]\\nnums after reversing the remaining elements: [3, 99, -1, -100]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 558971,
                "title": "faster-than-99-56-javascript",
                "content": "```\\nvar rotate = function(nums, k) {\\n   k %= nums.length // if k is greater than nums.length then one cycle is completed that means it will remain the same and we have to remainder shifts\\n    \\n   let reverse = function(i, j){\\n    while(i < j){\\n        let temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        i++\\n        j--\\n    }\\n   } // suppose  ----->---> \\n\\treverse(0, nums.length-1); // reverse   <--<------\\n\\t reverse(0, k-1) // reverse first part ---><----\\n   reverse(k, nums.length-1)// reverse second part --->----->\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n   k %= nums.length // if k is greater than nums.length then one cycle is completed that means it will remain the same and we have to remainder shifts\\n    \\n   let reverse = function(i, j){\\n    while(i < j){\\n        let temp = nums[i]\\n        nums[i] = nums[j]\\n        nums[j] = temp\\n        i++\\n        j--\\n    }\\n   } // suppose  ----->---> \\n\\treverse(0, nums.length-1); // reverse   <--<------\\n\\t reverse(0, k-1) // reverse first part ---><----\\n   reverse(k, nums.length-1)// reverse second part --->----->\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 54263,
                "title": "3-lines-of-c-in-one-pass-using-swap",
                "content": "Every swap will put one number into its correct position, so the running time is O(n)\\n\\nFor example,\\n\\nat first, `nums[]` is `[1,2,3,4,5,6,7]`, n is 7, k is 3\\n\\nafter first outer loop, `nums[]` is `[4,1,2,3]`, n is 4, k is 3\\n\\nafter second outer loop, `nums[]` is `[4]`, n is 1, k is 0\\n\\nloop ends.\\n\\n    void rotate(int nums[], int n, int k) {\\n        for (; k %= n; n -= k)\\n            for (int i = 0; i < k; i++)\\n                swap(*nums++, nums[n - k]);\\n    }",
                "solutionTags": [],
                "code": "Every swap will put one number into its correct position, so the running time is O(n)\\n\\nFor example,\\n\\nat first, `nums[]` is `[1,2,3,4,5,6,7]`, n is 7, k is 3\\n\\nafter first outer loop, `nums[]` is `[4,1,2,3]`, n is 4, k is 3\\n\\nafter second outer loop, `nums[]` is `[4]`, n is 1, k is 0\\n\\nloop ends.\\n\\n    void rotate(int nums[], int n, int k) {\\n        for (; k %= n; n -= k)\\n            for (int i = 0; i < k; i++)\\n                swap(*nums++, nums[n - k]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1729973,
                "title": "python3-in-place-exaplained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to reverse the given list, and then reverse elements in the range `0..k` and in the range `k..L`. For example `nums = [1,2,3,4,5,6,7]`, `k = 3`:\\n\\n1. Reverse: `nums` = [**7,6,5,4,3,2,1**] \\n2. Reverse in the range `0..k`:  `nums` = [**5,6,7**,4,3,2,1]\\n3. Reverse in the range `k..L`:  `nums` = [5,6,7,**1,2,3,4**]\\n\\nNotice that `k` can be greater than `L` (length of the `nums`) because `k` is number of rotattion steps. If `k` is equal to `L`, elements do full rotation and `nums` is not changed. So for this case we can recalculate `k` as `k%L`.\\n\\nTime: **O(n)** - for reverse and swaps\\nSpace: **O(1)** - in-place\\n\\nRuntime: 220 ms, faster than **81.00%** of Python3 online submissions for Rotate Array.\\nMemory Usage: 25.4 MB, less than **96.40%** of Python3 online submissions for Rotate Array.\\n\\n```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tL = len(nums)\\n\\tif L == k: return\\n\\n\\tk = k%L # the case when k > L\\n\\tnums.reverse()\\n\\n\\tfor i in range(k//2):\\n\\t\\tnums[i], nums[k-1-i] = nums[k-1-i], nums[i]\\n\\n\\tfor i in range(k, (L+k)//2):\\n\\t\\tnums[i], nums[L-1-i+k] = nums[L-1-i+k], nums[i]\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef rotate(self, nums: List[int], k: int) -> None:\\n\\tL = len(nums)\\n\\tif L == k: return\\n\\n\\tk = k%L # the case when k > L\\n\\tnums.reverse()\\n\\n\\tfor i in range(k//2):\\n\\t\\tnums[i], nums[k-1-i] = nums[k-1-i], nums[i]\\n\\n\\tfor i in range(k, (L+k)//2):\\n\\t\\tnums[i], nums[L-1-i+k] = nums[L-1-i+k], nums[i]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3014158,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& v, int k) {\\n        int a =k%v.size();\\n        reverse(v.begin(),v.end());\\n        reverse(v.begin(),v.begin()+a);\\n        reverse(v.begin()+a,v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& v, int k) {\\n        int a =k%v.size();\\n        reverse(v.begin(),v.end());\\n        reverse(v.begin(),v.begin()+a);\\n        reverse(v.begin()+a,v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426703,
                "title": "easy-approach-c",
                "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187339,
                "title": "easy-es6-javascript-js-solution-without-unshift-splice",
                "content": "Scroll down if you want to have an explanation.\\n\\n```\\nvar rotate = function (nums, k) {\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    nums[j] = nums.pop();\\n  }\\n\\n  // Time comlexity = O(a + b)\\n};\\n```\\n.\\n.\\n.\\n.\\n.\\n.\\nExplanation down below\\n\\n\\n```\\nvar rotate = function (nums, k) {\\n  // i.e. nums = [1, 2, 3, 4, 5, 6, 7],  k = 3\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n    // i = 6,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[6 + 3] = nums[6]\\n    // nums[9] = 7              nums = [1, 2, 3, 4, 5, 6, 7, , , 7]\\n\\n    // i = 5,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[5 + 3] = nums[5]\\n    // nums[8] = 6              nums = [1, 2, 3, 4, 5, 6, 7, , 6, 7]\\n\\n    // i = 4,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[4 + 3] = nums[4]\\n    // nums[7] = 5              nums = [1, 2, 3, 4, 5, 6, 7, 5, 6, 7]\\n\\n    // i = 3,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[3 + 3] = nums[3]\\n    // nums[6] = 4              nums = [1, 2, 3, 4, 5, 6, 4, 5, 6, 7]\\n\\n    // i = 2,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[2 + 3] = nums[2]\\n    // nums[5] = 3              nums = [1, 2, 3, 4, 5, 3, 4, 5, 6, 7]\\n\\n    // i = 1,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[1 + 3] = nums[1]\\n    // nums[4] = 2              nums = [1, 2, 3, 4, 2, 3, 4, 5, 6, 7]\\n\\n    // i = 0,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[0 + 3] = nums[0]\\n    // nums[3] = 1              nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    // nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n    nums[j] = nums.pop();\\n\\n    // j = 2\\n    // nums[j] = nums.pop()\\n    // nums[2] = 7               nums = [1, 2, 7, 1, 2, 3, 4, 5, 6]\\n\\n    // j = 1\\n    // nums[j] = nums.pop()\\n    // nums[1] = 6               nums = [1, 6, 7, 1, 2, 3, 4, 5]\\n\\n    // j = 0\\n    // nums[j] = nums.pop()\\n    // nums[0] = 5               nums = [5, 6, 7, 1, 2, 3, 4]\\n  }\\n\\n  // nums = [5, 6, 7, 1, 2, 3, 4]\\n\\n  // Time comlexity = O(a + b)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    nums[j] = nums.pop();\\n  }\\n\\n  // Time comlexity = O(a + b)\\n};\\n```\n```\\nvar rotate = function (nums, k) {\\n  // i.e. nums = [1, 2, 3, 4, 5, 6, 7],  k = 3\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    nums[i + k] = nums[i];\\n    // i = 6,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[6 + 3] = nums[6]\\n    // nums[9] = 7              nums = [1, 2, 3, 4, 5, 6, 7, , , 7]\\n\\n    // i = 5,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[5 + 3] = nums[5]\\n    // nums[8] = 6              nums = [1, 2, 3, 4, 5, 6, 7, , 6, 7]\\n\\n    // i = 4,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[4 + 3] = nums[4]\\n    // nums[7] = 5              nums = [1, 2, 3, 4, 5, 6, 7, 5, 6, 7]\\n\\n    // i = 3,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[3 + 3] = nums[3]\\n    // nums[6] = 4              nums = [1, 2, 3, 4, 5, 6, 4, 5, 6, 7]\\n\\n    // i = 2,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[2 + 3] = nums[2]\\n    // nums[5] = 3              nums = [1, 2, 3, 4, 5, 3, 4, 5, 6, 7]\\n\\n    // i = 1,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[1 + 3] = nums[1]\\n    // nums[4] = 2              nums = [1, 2, 3, 4, 2, 3, 4, 5, 6, 7]\\n\\n    // i = 0,  k = 3\\n    // nums[i + k] = nums[i]\\n    // nums[0 + 3] = nums[0]\\n    // nums[3] = 1              nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n  }\\n\\n  for (let j = k - 1; j >= 0; j--) {\\n    // nums = [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]\\n    nums[j] = nums.pop();\\n\\n    // j = 2\\n    // nums[j] = nums.pop()\\n    // nums[2] = 7               nums = [1, 2, 7, 1, 2, 3, 4, 5, 6]\\n\\n    // j = 1\\n    // nums[j] = nums.pop()\\n    // nums[1] = 6               nums = [1, 6, 7, 1, 2, 3, 4, 5]\\n\\n    // j = 0\\n    // nums[j] = nums.pop()\\n    // nums[0] = 5               nums = [5, 6, 7, 1, 2, 3, 4]\\n  }\\n\\n  // nums = [5, 6, 7, 1, 2, 3, 4]\\n\\n  // Time comlexity = O(a + b)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419527,
                "title": "python-two-pointers-solution",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        def twopt(arr, i, j):\\n            while (i < j):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                i += 1\\n                j -= 1\\n            return arr\\n        \\n        if k > len(nums):\\n            k %= len(nums)\\n            \\n        if (k > 0):\\n            twopt(nums, 0, len(nums) - 1)  # rotate entire array\\n            twopt(nums, 0, k - 1)          # rotate array upto k elements\\n            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        def twopt(arr, i, j):\\n            while (i < j):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                i += 1\\n                j -= 1\\n            return arr\\n        \\n        if k > len(nums):\\n            k %= len(nums)\\n            \\n        if (k > 0):\\n            twopt(nums, 0, len(nums) - 1)  # rotate entire array\\n            twopt(nums, 0, k - 1)          # rotate array upto k elements\\n            twopt(nums, k, len(nums) - 1)  # rotate array from k to end of array",
                "codeTag": "Java"
            },
            {
                "id": 54282,
                "title": "my-interpretation-proof-of-the-cyclic-replacements-method-in-editorial-solution",
                "content": "**Caveat at 2018-06-01 16:23:20**: it was recently pointed out that my orriginal formulation is appealing yet not really sufficient for the proof of the method. I revised the post so that I provide a revised version of the proof. Yet, I want to retain the original version, which is not strictly correct. The three sections below corresponds to:\\n* The introduction\\n* The first attempt of proof which is not rigidly correct.\\n* The second attemp of proof which is more comprehensive.\\n---\\n## Introduction\\nI find the **Cyclic Replacements** method in the editorial solution quite clever and spent some time learning it. On the other hand, I am not quite satisfied with the explanation and proof provided there. Thus I am elaborating on my way of relating to this algorithm here.\\n\\nFirst, I am putting the code directly copied from the editorial solution here for reference:\\n```java\\npublic class Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        int count = 0;\\n        for (int start = 0; count < nums.length; start++) {\\n            int current = start;\\n            int prev = nums[start];\\n            do {\\n                int next = (current + k) % nums.length;\\n                int temp = nums[next];\\n                nums[next] = prev;\\n                prev = temp;\\n                current = next;\\n                count++;\\n            } while (start != current);\\n        }\\n    }\\n}\\n```\\nThe main idea is to put each entry(denoted by its index) to its correct position after `k` shifts. \\nFirst consider how you would do this in a naive way. (assuming `k = k % n` is already done).\\n```java\\nfor (int i = 0; i < nums.length; i++) {\\n    put nums[i] to position[(i + k) % n] //cyclic shift\\n}\\n```\\nBut this naive way has a problem, when you reach `i + k`, this entry is already gone: overriden by the iteration of `i`.\\nTo avoid this problem, we could buffer `nums[i + k]` before we shift `nums[i]`, but such a modification, albeit feasible for the problem, would fail the O(1) space requirement: you need O(n - k) space to buffer the entries.\\n\\nThis **Cyclic Replacements** solution, on the other hand, overcomes this problem: only one buffer variable `prev` is shared for all shifts of all `n` elements(although the code declares new `current, prev, etc.` in each iteration, JVM optimization can handle that, or you can always just make these variables global to the loop block anyway).\\n## Proof Attempt 1: intuitive but not really complete\\n**Lemma1**: This algorithm visits each entry/index of `nums` exactly once. During the visit, the algorithm shifts the entry to the correct position. \\n**Proof**: \\n### Case 1: `n % k != 0`\\n**Caveat**: the proof for this case is incorrect, or at least incomplete. If you are not curious how it is incorrect, you can skip this part. The key error I made is I only proved that **no duplicate index is visited during one inner-loop**, but I did not prove **only one inner-loop will be executed**.\\n\\nif `n % k != 0`, the outer loop will only execute one iteration(`start == 0`) before the algorithm finisheds.\\nIf `n % k != 0`, the inner do-while loop will only terminate when `count == n`. Consider what this inner loop does: for example, in the case of `[1,2,3,4,5,6,7]` and `k = 2`, it essentially does something like moving values (not indexes) in this way: `1 -> 3, 3 -> 5, 5 -> 7, 7 -> 2, 2 -> 4, 4 -> 6, 6 -> 1`, and then`start == current` and `count == n == 7`. We will then have to try to get to the second iteration of the outer loop, which fails due to `count == n`. Thus the outer loop only executes one iteration.\\nNow let\\'s abstract: when `n % k != 0`, we start from `[0]` and in this one iteration, we can shift all `n` elements (to its perspectively correct position). This is because each `current` in the do-while loop will all be distinct indices (other than the last one that reaches `start` and ends the loop). \\n\\n**Lemma2**: No duplicate indexes will be visited (other than `start`) in each inner-loop. \\n**Proof**: This is proven by contradiction. Now, for convenience, let\\'s consider the chain of *index* movements rather than the chain of *value* movements. For the instance of `n=7, k=3`, we have:\\n```\\n0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0\\n```\\nThis is a chain of length 7 (in terms of number of distinct indexes in the chain).\\nWe start from `start`, then move `current` from there, till `current` reaches `start` again. What we want to prove is, during this process, `current` never duplicates itself before it reach the final `start`. Suppose for the sake of contradiction that it did, then we have a chain like:\\n```\\nstart -> ... -> a -> ... -> a -> ... -> start\\nA               B           C           D\\n```\\nWhere the index `a` is picked twice by the pointer `current`, also `a \\u2260 start` (otherwise the inner-loop would have terminated at the first `a`). No `a` or `start` is included in any of the three `...` segment WLOG.\\nA trivial way to prove this is that, by the above assumptions, the BC segment has no `start`, which means, you start from `a`, you will reach `a` before reaching a `start`. But looking at the CD segment, you will have another conclusion: starting from `a`, you will reach `start` before reaching `a`, where `a \\u2260 start`. This is a contradiction.\\n**End of proof for Lemma2**\\nThus concludes my attempt for this case. Note that this case\\'s proof is incomplete in that I proved that no duplicate indexes shall be reached in one inner-loop. But I did not prove that *only* one inner-loop will execute in this case: in fact, that is a false claim. As pointed out by @ibici.\\nI could add on more augments to this proof but @ibici \\'s advice made me rethink about my classification of the two cases here and I eventually see how it is not a good choice. In **attempt 2**, I will try to provide the proof in a better way.\\n\\n### Case 2: `n % k == 0`\\nFor each `start` value of the outer loop, it is obvious to see that the inner loop does `n / k` iterations, visiting one distinct indice in each iteration.\\nThat is, each `start` visits `n / k` distinct indices.\\nThen we increment `start`. How many values of `start` can we have (or what is the number iterations of the outer loop)? It has to be `k`, because in each outer loop, `count` get incremented `n / k` no matter what (even if there are duplicates across different outer loop iterations/`start` values, which we shall debunk later). So the domain of `start` is `0..k-1`. **marker here**\\n\\nWe are now sure that the entire algorithm will visit `n / k * k = n` indices, but are they guaranteed to be distinct?\\nYes, and this is proven by contradiction. Suppose there exists two indices `idx1` and `idx2`, each corresponding to `start == s1` and `start == s2` in the outer loop. Then we have:\\n```\\nidx1 = idx2\\n(s1 + a * k) % n = (s2 + b * k) % n\\n```\\nfor some `a` and `b`. We also know that `s1 != s2` (otherwise there is nothing to prove because **lemma 2** will guarantee no duplicate within a single inner-loop). \\nWe can deduce that\\n```\\n(s1 - s2) % n = (b - a) * k % n\\ns1 - s2 = (b - a) * k + t * n               //for some t\\n|s1 - s2| \\u2265 k\\n```\\nBecause \\n* if `t != 0`, then `|s1 - s2| \\u2265 n > k`; \\n* if `t == 0`, then `s1 - s2 = (b - a) * k`, and we know `s1 - s2 \\u2260 0`, so `b \\u2260 a`, thus we also have `|s1 - s2| \\u2265 k`.\\n\\nThis is a contradiction with the previous conclusion of `start`\\'s domain being `0..k-1`.\\n\\nThus the `n` indices visited in the algorithm will also be distinct.\\n**End of Proof for Lemma1**\\n\\nI think this **lemma 1** is enough for understanding the correctness of this algorithm. There is also a [nice solution](https://discuss.leetcode.com/topic/11349/my-three-way-to-solve-this-problem-the-first-way-is-interesting-java) here using a similar idea. I would learn that one as well if I were you.\\n\\nHere is a trace to help your understanding:\\n<img src=\"http://i66.tinypic.com/vhb37m.png\" width=\"350\">\\n\\n## Proof Attempt 2: complete and general\\nLet\\'s just see what\\'s happening with a concrete example where `n,k = 7,3`. Note that from now on all chains/movements are described in terms of indexes rather than values.\\n<img src=\"https://www.dropbox.com/s/qe5z20o4xn0d1x2/Screenshot%202018-06-01%2018.23.05.png?raw=1\" width=\"600\">\\n\\nAs the length of the chain grows, think carefully when would we actually stop? Yes, we would stop when we reached a length `L` such that `L` is a multiple of both `n` and `k`. To be more accurate, we stop when `L` is the LCM of `n` and `k`. \\nIf the chain started from somewhere like `1` rather than `0`, the end result is actually similar, `L` will always be an LCM and thus a multiple of `n`.\\n\\nIn the example above where `n,k=7,3`, we have\\n```\\nL = (7) * 3 = (3) * 7\\n```\\nThe parens are used to mark the `n` and `k` variables we care about.\\n\\nFrom the **lemma2** proved in **attempt 1**, we already know that within one chain, which corresponds to one inner-loop (in that the chain terminates when the first duplciate is reached, which is `start`), there is no other duplicate index than `start`. But how long can this chain be? Of course, it can\\'t exceed `n`: you only have `n` distinct indexes. In the example above, the first chain (corresponds to `start=0`) has length `chain_len=n=7`, which triggers `count=n` to terminate the outer-loop immediately.\\nAnother example: `n,k=10,4`:\\n```\\n0 -> 4 -> 8 -> 2 -> 6 -> 0\\n```\\nThis chain is only of length 5, and we have `n=10`, so in the end we need two separate chains, corresponding to two inner-loop executions, to traverse all `n` indexes. We have:\\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\\nNote how the GCD is also marked with parens.\\n\\nNow, compare the two cases, you should see how LCM and GCD plays a part in this algorithm. We first find the GCD of `n` and `k`. Then we can calculate `L`, which is the LCM, then we can divide it by `k`, then we have the length of this chain.\\nAt this moment, given the sole input of `n` and `k`, we can tell:\\n* how many disjoint chains we have?\\n    * why are they disjoint, as in why would there be no duplicates across chains? See the proof for **case 2** in **attempt 1**.\\n* how long each of the chain would be?\\n\\nThese information are not explicitly utilied in the code, but is helpful for understanding the correctness of the algorithm overall. The beauty of this cyclic replacement code as compared to [this solution](https://discuss.leetcode.com/topic/11349/my-three-way-to-solve-this-problem-the-first-way-is-interesting-java) where GCD calculations are done explicitly is that everything just, happens, and it\\'s correct.\\n\\nNow, look back at the code, you should see that the code is actually doing:\\n```\\nfor each CHAIN:\\n    for each INDEX in this CHAIN:\\n        move elements\\n```\\n**Lemma 3**: each index will be traversed exactly once during the entire outer-loop.\\n**Proof**:\\nFirst, each index will belong to exactly one of the disjoint chains. This derives naturally from how we proved the chains to be disjoint in the first place.\\nSecondly, from **lemma 1**, we know that each index will be touched no more than once within each inner-loop (chain).\\n\\nNow, what conclusion do we have by now: each index will be touched *no more than once* in the entire outer-loop.\\nThis is not enough, we want *exactly* touched once.\\n\\nThe outer loop will only terminate when `count=n` which means we visited all `n` indexes, which are guaranteed to be distinct from above discussion. Does this statement suffice? \\nWell, in the case of `n \\u2265 10`, what if we had three inner-loops each contributing 4, 4, 4 to `count`? In this case, `chain_len=4` and in the end we will have `count=12>n` to terminate the outer-loop.\\nThis case is not possible because the length of each chain is deterministically calculated as shown above: `chain_len = L / k`:\\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\\nThe `chain_len` is actually `n / GCD`, somebody else help me prove this please.\\nAssume this is right, then it is clear that `chain_len` can divide into `n`, and the case of `n,chain_len=10,4` is impossible. Ruling out that possibility, the outer-loop\\'s termination iff *exactly `n` distinct indexes visited* is enough to justify the lemma and the algorithm: `n` is a multiple of `chain_len`, we will have exactly `n=count` in the end. All distinct, so each index touched exactly once.\\n**End of proof for lemma3**.\\nThe termination of the algorithm also trivially follows from **lemma 3**.",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        int count = 0;\\n        for (int start = 0; count < nums.length; start++) {\\n            int current = start;\\n            int prev = nums[start];\\n            do {\\n                int next = (current + k) % nums.length;\\n                int temp = nums[next];\\n                nums[next] = prev;\\n                prev = temp;\\n                current = next;\\n                count++;\\n            } while (start != current);\\n        }\\n    }\\n}\\n```\n```java\\nfor (int i = 0; i < nums.length; i++) {\\n    put nums[i] to position[(i + k) % n] //cyclic shift\\n}\\n```\n```\\n0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0\\n```\n```\\nstart -> ... -> a -> ... -> a -> ... -> start\\nA               B           C           D\\n```\n```\\nidx1 = idx2\\n(s1 + a * k) % n = (s2 + b * k) % n\\n```\n```\\n(s1 - s2) % n = (b - a) * k % n\\ns1 - s2 = (b - a) * k + t * n               //for some t\\n|s1 - s2| \\u2265 k\\n```\n```\\nL = (7) * 3 = (3) * 7\\n```\n```\\n0 -> 4 -> 8 -> 2 -> 6 -> 0\\n```\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```\n```\\nfor each CHAIN:\\n    for each INDEX in this CHAIN:\\n        move elements\\n```\n```\\nL   = (10) * 2 = ((2) * 5) * 2\\n    = (4) * 5  = ((2) * 2) * 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730564,
                "title": "python-1-line-detailed-explanation-clean-and-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n\\n\\n\\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        nums[:] = nums[-(k % len(nums)):] + nums[:-(k % len(nums))]\\n```\\n![image](https://assets.leetcode.com/users/images/4cc8eab5-1c11-4042-a60b-3d824cae2113_1643522511.6529794.png)\\n\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        nums[:] = nums[-(k % len(nums)):] + nums[:-(k % len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080798,
                "title": "c-o-n-time-o-1-space-0-ms-faster-than-100-00-4-lines-amazing-cool-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + k);\\n        reverse(nums.begin() + k, nums.end());\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + k);\\n        reverse(nums.begin() + k, nums.end());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 54458,
                "title": "java-o-n-in-place-solution",
                "content": "    \\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length-1);  // reverse the whole array\\n        reverse(nums, 0, k-1);  // reverse the first part\\n        reverse(nums, k, nums.length-1);  // reverse the second part\\n    }\\n    \\n    public void reverse(int[] nums, int l, int r) {\\n        while (l < r) {\\n            int tmp = nums[l];\\n            nums[l++] = nums[r];\\n            nums[r--] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, 0, nums.length-1);  // reverse the whole array\\n        reverse(nums, 0, k-1);  // reverse the first part\\n        reverse(nums, k, nums.length-1);  // reverse the second part\\n    }\\n    \\n    public void reverse(int[] nums, int l, int r) {\\n        while (l < r) {\\n            int tmp = nums[l];\\n            nums[l++] = nums[r];\\n            nums[r--] = tmp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4006719,
                "title": "simple-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        int n = nums.length;\\n        reverseNum(nums,0,n-1);\\n        reverseNum(nums,0,k-1);\\n        reverseNum(nums,k,n-1);\\n    }\\n    public void reverseNum(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/b5d72c1f-750f-4f09-a85a-b14f1ac49274_1693936505.706019.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        int n = nums.length;\\n        reverseNum(nums,0,n-1);\\n        reverseNum(nums,0,k-1);\\n        reverseNum(nums,k,n-1);\\n    }\\n    public void reverseNum(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895412,
                "title": "python-o-n-inplace-solution-explained",
                "content": "Very nice and interesting problem if we are asked to do it in place in linear time. \\nImagine, that we have number `[1,2,3,4,5,6,7,8]` and we have `k = 3`, then what is expected from us is `[6,7,8,1,2,3,4,5]`. Let us note, that a lot of structure in our list kept the same. Let us reverse list and try to find some patterns:\\n`[6,7,8,1,2,3,4,5]`\\n`[8,7,6,5,4,3,2,1]`\\nYou see it? What we need to do know is reverse first `3` elements and to reverst last `5` elements and this is all! It seems very easy, but in fact if you never used similar trick, it is very difficult to think, why we need to inverse arrays in the first place.\\n\\n**Complexity**: time complexity is `O(n)`, because in whole we change elements `2n` times. Space complexity is `O(1)`, because we do it in place.\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def inverse(i, j):\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i, j = i + 1, j - 1\\n        \\n        n = len(nums)\\n        k = k % n\\n        inverse(0, n-1)\\n        inverse(0, k-1)\\n        inverse(k, n-1)\\n        return nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def inverse(i, j):\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i, j = i + 1, j - 1\\n        \\n        n = len(nums)\\n        k = k % n\\n        inverse(0, n-1)\\n        inverse(0, k-1)\\n        inverse(k, n-1)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259418,
                "title": "clear-cyclic-replacement-java-solution-with-proof-o-n-in-time-o-1-in-space",
                "content": "# Clear cyclic replacement solution with proof\\n## Intuition\\nAssume `k = k % n`.\\n\\nImagine we have an array `A = [0, 1, 2, 3, 4, 5, 6]` (n = 7) and need to shift it right by `k = 3` by HAND.\\n\\nWhat I would do is start from index 0, **hold** `A[0]=0` in hand, go to next index `(0 + k) % n = (0 + 3) % 7 = 3`, and swap `A[3]` with what I hold in hand, repeat this step until all elements are moved. The indexes of elements traversed form a closed chain `0 -> 3 -> 6 -> 2 -> 5 -> 1 -> 4 -> 0`, which has 7 elements, equal to array length.\\n\\nHowever, if `n` and `k` are not mutually prime, we may return to start position before moving all elements, forming a closed chain with elements fewer than `n`, e.g. `n = 6, k = 4 => 0 -> 4 -> 2 -> 0`, this chain only has `L1 = 3` elements. To move all elements, we need to start from index 1 and traverse another chain `1 -> 5 -> 3 -> 1`, which contains `L2 = 3` different elements. In total we moved `L1 + L2 = 3 + 3 = 6 == n` elements, and each element moved only once. \\n\\nThe general procedures are:\\n1. start from index `start = 0` (actually can be any other index)\\n2. cyclically shift element at index `(start + m * k)` right by `k` until reaching start again, forming a closed chain\\n3. shift `start` by 1, repeat step 1 and 2 until all elements moved.\\n\\n## Solution\\n```\\nclass Solution {\\n    // Cyclic replacement\\n    public void rotate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return;\\n        }\\n        \\n        int n = nums.length;\\n        int step = k % n;\\n        int count = 0; // count of elements moved to target position\\n        for (int start = 0; start < n; start++) {\\n            // Cyclically move each element until returning to start position and forms \\n            // a closed chain\\n            int hold = nums[start];\\n            int p = start;\\n            do {\\n                p = (p + step) % n;\\n                // swap hold and nums[p]\\n                int tmp = hold;\\n                hold = nums[p];\\n                nums[p] = tmp;\\n                count++;\\n            } while (p != start);\\n            \\n            if (count == n) {\\n                break;\\n            }\\n        }   \\n    }\\n}\\n```\\n\\n## Proof\\n### Lemme 1: Each closed chain has same length `L = n / gcd(n, k)`\\n**Proof**:\\n`lcm`: least common multiple\\n`gcd`: greatest common divisor\\n\\nAccording to the chain definition, a chain with index `start -> (start + k) % n -> (start + 2k) % n -> ... -> (start + Lk) % n` closes when chain ends at start index, i.e. `(start + Lk) % n == start`, i.e. when `Lk == tn`, where `t` is a positive integer as small as possible. In other words:\\n\\n`Lk == lcm(n, k)` => `L = lcm(n, k) / k`\\n\\nAccording to the [relation between lcm and gcd: `gcd(a,b) * lcm(a, b) = a * b`](https://math.stackexchange.com/questions/470807/prove-that-gcdm-n-times-mboxlcmm-n-m-times-n), we have:\\n\\n`L = lcm(n, k) / k = (n * k / gcd(n, k)) / k = n / gcd(n, k)`\\n\\nFor example:\\n* `n = 7, k = 3` => `L = 7 / gcd(7, 3) = 7 / 1 = 7`\\n* `n = 6, k = 4` => `L = 6 / gcd(6, 4) = 6 / 2 = 3`\\n\\nLemme 1 indicates each inner loop ends after `L = n / gcd(n, k)` steps.\\n\\n### Lemme 2: For any index `0 <= i < j < gcd(n, k)`, chains starting from `i` and `j` are mutually exclusive.\\n**Intuitive Proof**:\\nThanks to @kafa321:\\nIf two chains intercept, after intersection point, since both chains advance by `k` every step, esentially they are the same chain.\\n\\n**Strict mathmatical proof by contradiction**\\nAssume two chains does intercept at index `p` after `x` steps from `i` and `y` steps from `j`, i.e.\\n`p = (i + x * k) % n == (j + y * k) % n`\\n=> `(j - i + (y - x) * k) % n == 0`\\n=> `(j - i) - (x - y) * k = tn`\\n=> `j - i = (x - y) * k + tn`\\n=> `j - i = (x - y) * gcd(n, k) * (k / gcd(n, k)) + t * gcd(n, k) * (n / gcd(n, k))`\\n=> `j - i = gcd(n, k) * ((x - y) * (k / gcd(n, k)) + t * (n / gcd(n, k)))`\\n=> `j - i = M * gcd(n, k), M is an integer`\\n\\nHowever, `0 < j - i < gcd(n, k)`, so there exists no valid `M`, assumption is invalid.\\n\\n### Conclusion\\nBased on Lemma 1 and 2, we have proven that the cyclic replacement algorithem has following properties:\\n* Each inner loop moves `L = n / gcd(n, k)` unique indexes (according to chain definition, no duplicate indexes other than start position is allowed in a closed chain).\\n* Outer loop iterates start position from `0` to `gcd(n, k) - 1`, execute inner loop `gcd(n, k)` times\\n* All indexes moved in those `gcd(n, k)` inner loops are mutually exclusive, in total `n / gcd(n,k) * gcd(n, k) = n` unique indexes have been moved. \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Cyclic replacement\\n    public void rotate(int[] nums, int k) {\\n        if (nums == null || nums.length <= 1 || k <= 0) {\\n            return;\\n        }\\n        \\n        int n = nums.length;\\n        int step = k % n;\\n        int count = 0; // count of elements moved to target position\\n        for (int start = 0; start < n; start++) {\\n            // Cyclically move each element until returning to start position and forms \\n            // a closed chain\\n            int hold = nums[start];\\n            int p = start;\\n            do {\\n                p = (p + step) % n;\\n                // swap hold and nums[p]\\n                int tmp = hold;\\n                hold = nums[p];\\n                nums[p] = tmp;\\n                count++;\\n            } while (p != start);\\n            \\n            if (count == n) {\\n                break;\\n            }\\n        }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54702,
                "title": "java-solution-in-one-pass-o-1-space-o-n-time",
                "content": "I got the idea from this C++ solution: [3 lines of C++ in one pass using swap][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/26501/3-lines-of-c-in-one-pass-using-swap\\n\\n\\nBut since Java doesn't have all those nice trick of swap() and pointer operations, I modified it to store the processed section at the end, and then handle the rest at the beginning of the array.\\n\\nThe idea is: for a given K, I can put (n - k) elements to their final locations at the end of the array in a single pass; after that, the problem is reduced to a sub-problem of processing the remaining elements.\\n\\nFor example, [1,2,3,4,5,6,7] k = 3, in the first iteration in the while loop, put n-k=4 elements to the final places at the end. Will have to start from the last element, so that the other elements will be bubbled down correctly. It will look like this after the first iteration: [7, 5, 6, 1, 2, 3, 4]\\n\\nThe 2nd iteration will handle the remaining 3 elements: [7, 5, 6]; to determine the new k, we first observe that the # of out-of-order elements being put to the beginning of the array are (range % k), and in this example, only one element (7) is out of order. then to move the out-of-order elements back in order, we just need to rotate the remaining 3 elements to the right by k' = n - (range % k) = 2.\\n\\ntherefore, after 2nd iteration in while loop, we will get [6, 5, 7], then n <- 2, k <- 1;\\n\\nthe 3rd iteration starts with sub array [6,5], k =1, and we will get [5,6] after it,  and then n <- 1.\\n\\n\\n        if (nums.length == 0) return;\\n        int n = nums.length;\\n        while ((k %= n) > 0 && n > 1) {\\n            int range = n - k;\\n            for (int i = 1; i <= range; i++) {\\n                int val = nums[n - i];\\n                nums[n - i] = nums[n - i - k];\\n                nums[n - i - k] = val;\\n            }\\n            n = k;\\n            k = n - (range % k);\\n        }\\n\\nHope this helps.",
                "solutionTags": [
                    "Java"
                ],
                "code": "I got the idea from this C++ solution: [3 lines of C++ in one pass using swap][1]\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/26501/3-lines-of-c-in-one-pass-using-swap\\n\\n\\nBut since Java doesn't have all those nice trick of swap() and pointer operations, I modified it to store the processed section at the end, and then handle the rest at the beginning of the array.\\n\\nThe idea is: for a given K, I can put (n - k) elements to their final locations at the end of the array in a single pass; after that, the problem is reduced to a sub-problem of processing the remaining elements.\\n\\nFor example, [1,2,3,4,5,6,7] k = 3, in the first iteration in the while loop, put n-k=4 elements to the final places at the end. Will have to start from the last element, so that the other elements will be bubbled down correctly. It will look like this after the first iteration: [7, 5, 6, 1, 2, 3, 4]\\n\\nThe 2nd iteration will handle the remaining 3 elements: [7, 5, 6]; to determine the new k, we first observe that the # of out-of-order elements being put to the beginning of the array are (range % k), and in this example, only one element (7) is out of order. then to move the out-of-order elements back in order, we just need to rotate the remaining 3 elements to the right by k' = n - (range % k) = 2.\\n\\ntherefore, after 2nd iteration in while loop, we will get [6, 5, 7], then n <- 2, k <- 1;\\n\\nthe 3rd iteration starts with sub array [6,5], k =1, and we will get [5,6] after it,  and then n <- 1.\\n\\n\\n        if (nums.length == 0) return;\\n        int n = nums.length;\\n        while ((k %= n) > 0 && n > 1) {\\n            int range = n - k;\\n            for (int i = 1; i <= range; i++) {\\n                int val = nums[n - i];\\n                nums[n - i] = nums[n - i - k];\\n                nums[n - i - k] = val;\\n            }\\n            n = k;\\n            k = n - (range % k);\\n        }\\n\\nHope this helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 723103,
                "title": "c-easy-to-understand-multiple-approaches",
                "content": "***Runtime: 16 ms, faster than 21.15% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 54.57% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        vector<int> result(nums.end()-k,nums.end());\\n        result.insert(result.end(),nums.begin(),nums.end()-k);\\n        nums = result;\\n    }\\n};\\n```\\n***Time Limit Exceeded***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        while(k--){\\n            int temp = nums[nums.size()-1];\\n            for(int i = nums.size()-2; i>= 0 ;i--){\\n                nums[i+1] = nums[i];\\n            }\\n            nums[0] = temp;\\n        }   \\n    }\\n};\\n```\\n***Runtime: 28 ms, faster than 11.54% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 50.27% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int orig_size = nums.size();\\n        k %= orig_size;\\n        nums.insert(nums.end(),nums.end()-k,nums.end());\\n        int i=orig_size - k - 1, j = orig_size - 1;\\n        while(j >= 0){\\n            nums[j--] = nums[i--];\\n            if(i == -1){\\n                i = nums.size()-1;\\n            }\\n        }\\n        nums.resize(orig_size, 0);\\n    }\\n};\\n```\\n***Runtime: 8 ms, faster than 83.90% of C++ online submissions for Rotate Array.\\nMemory Usage: 10.1 MB, less than 21.86% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int sz = nums.size();\\n        vector<int> result(sz,0);\\n        for(int i=0;i<sz;i++){\\n            result[(i + k)%sz] = nums[i];\\n        }\\n        nums = result;\\n    }\\n};\\n```\\n***Runtime: 12 ms, faster than 37.86% of C++ online submissions for Rotate Array.\\nMemory Usage: 10 MB, less than 47.04% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\\n***Runtime: 8 ms, faster than 84.24% of C++ online submissions for Rotate Array.\\nMemory Usage: 10.1 MB, less than 32.86% of C++ online submissions for Rotate Array.***\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        for(int i=0;i<gcd(n,k);i++){\\n            int prev = i, next = (prev+k)%n;\\n            int temp = nums[i];\\n            while(next != i){\\n                int temp2 = nums[next];\\n                nums[next] = temp;\\n                temp = temp2;\\n                prev = next;\\n                next = (prev+k)%n;\\n            }\\n            nums[next] = temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        vector<int> result(nums.end()-k,nums.end());\\n        result.insert(result.end(),nums.begin(),nums.end()-k);\\n        nums = result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        while(k--){\\n            int temp = nums[nums.size()-1];\\n            for(int i = nums.size()-2; i>= 0 ;i--){\\n                nums[i+1] = nums[i];\\n            }\\n            nums[0] = temp;\\n        }   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int orig_size = nums.size();\\n        k %= orig_size;\\n        nums.insert(nums.end(),nums.end()-k,nums.end());\\n        int i=orig_size - k - 1, j = orig_size - 1;\\n        while(j >= 0){\\n            nums[j--] = nums[i--];\\n            if(i == -1){\\n                i = nums.size()-1;\\n            }\\n        }\\n        nums.resize(orig_size, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int sz = nums.size();\\n        vector<int> result(sz,0);\\n        for(int i=0;i<sz;i++){\\n            result[(i + k)%sz] = nums[i];\\n        }\\n        nums = result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %= nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        for(int i=0;i<gcd(n,k);i++){\\n            int prev = i, next = (prev+k)%n;\\n            int temp = nums[i];\\n            while(next != i){\\n                int temp2 = nums[next];\\n                nums[next] = temp;\\n                temp = temp2;\\n                prev = next;\\n                next = (prev+k)%n;\\n            }\\n            nums[next] = temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194483,
                "title": "go-solution-time-o-n-space-o-1",
                "content": "```\\nfunc rotate(nums []int, k int) {\\n    n := len(nums)\\n    k %= n\\n    reverse(nums, 0, n - 1)\\n    reverse(nums, 0, k - 1)\\n    reverse(nums, k, n - 1)\\n}\\n\\nfunc reverse(nums []int, start int, end int) {\\n    for start < end {\\n        nums[start], nums[end] = nums[end], nums[start]\\n        start++\\n        end--\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rotate(nums []int, k int) {\\n    n := len(nums)\\n    k %= n\\n    reverse(nums, 0, n - 1)\\n    reverse(nums, 0, k - 1)\\n    reverse(nums, k, n - 1)\\n}\\n\\nfunc reverse(nums []int, start int, end int) {\\n    for start < end {\\n        nums[start], nums[end] = nums[end], nums[start]\\n        start++\\n        end--\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54438,
                "title": "my-c-solution-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            int nowIndex = 0, nextIndex;\\n    \\t\\tint tmp1, tmp2 = nums[0];\\n    \\t\\tfor(int j=0,i=0; j<n; j++){\\n    \\t\\t\\ttmp1 = tmp2;\\n    \\t\\t\\tnowIndex = (k + nowIndex) % (n);\\n    \\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\tnums[nowIndex] = tmp1;\\n    \\t\\t\\tif(nowIndex == i) {\\n    \\t\\t\\t\\tnowIndex = ++i;\\n    \\t\\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\t}\\n    \\t\\t}\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            int nowIndex = 0, nextIndex;\\n    \\t\\tint tmp1, tmp2 = nums[0];\\n    \\t\\tfor(int j=0,i=0; j<n; j++){\\n    \\t\\t\\ttmp1 = tmp2;\\n    \\t\\t\\tnowIndex = (k + nowIndex) % (n);\\n    \\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\tnums[nowIndex] = tmp1;\\n    \\t\\t\\tif(nowIndex == i) {\\n    \\t\\t\\t\\tnowIndex = ++i;\\n    \\t\\t\\t\\ttmp2 = nums[nowIndex];\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3413782,
                "title": "js-ts-easy-explained-solution-two-pointers-o-n-o-1",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n Do not return anything, modify nums in-place instead.\\n */\\nfunction rotate(nums: number[], k: number): void {\\n  k = k % nums.length;\\n  let l = 0;\\n  let r = nums.length - 1;\\n  // reverse full given array\\n  // from [1,2,3,4,5,6,7] to [7,6,5,4,3,2,1]\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from 0 to k - 1;\\n  // from [7,6,5,4,3,2,1] to [5,6,7,4,3,2,1]\\n  l = 0;\\n  r = k - 1;\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from k to the end;\\n  // from [5,6,7,4,3,2,1] to [5,6,7,1,2,3,4]\\n  l = k;\\n  r = nums.length - 1;\\n  nums = reverseArr(nums, l, r);\\n};\\n\\nfunction reverseArr(nums: number[], l: number, r: number): number[] {\\n    while(l < r) {\\n    let temp = nums[l];\\n    nums[l] = nums[r];\\n    nums[r] = temp;\\n    l++;\\n    r--;\\n  }\\n\\n  return nums;\\n}\\n\\n```\\nPlease do not forget to upvote the solution in case it is helpfull for you \\uD83D\\uDD25",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n Do not return anything, modify nums in-place instead.\\n */\\nfunction rotate(nums: number[], k: number): void {\\n  k = k % nums.length;\\n  let l = 0;\\n  let r = nums.length - 1;\\n  // reverse full given array\\n  // from [1,2,3,4,5,6,7] to [7,6,5,4,3,2,1]\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from 0 to k - 1;\\n  // from [7,6,5,4,3,2,1] to [5,6,7,4,3,2,1]\\n  l = 0;\\n  r = k - 1;\\n  nums = reverseArr(nums, l, r);\\n\\n  // reverse part from k to the end;\\n  // from [5,6,7,4,3,2,1] to [5,6,7,1,2,3,4]\\n  l = k;\\n  r = nums.length - 1;\\n  nums = reverseArr(nums, l, r);\\n};\\n\\nfunction reverseArr(nums: number[], l: number, r: number): number[] {\\n    while(l < r) {\\n    let temp = nums[l];\\n    nums[l] = nums[r];\\n    nums[r] = temp;\\n    l++;\\n    r--;\\n  }\\n\\n  return nums;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3009665,
                "title": "java-detailed-explanation-very-easy-sol-with-step-by-step-guide-and-intuition",
                "content": "<p> <img align=\"right\" alt=\"Coding\" width=\"100\" src=\"https://assets.leetcode.com/users/images/14aea68c-f5c2-41d3-b2d2-3c8556d0d9bc_1673600276.9231472.gif\"/> </p\\n\\n![Screenshot_20230106_091731.png](https://assets.leetcode.com/users/images/19c36e8a-0203-4d3d-8ed7-694b54b5b5b7_1673020110.2665236.png)\\n\\nBefore i Start see how a bracket () can take your 2 hour.....\\uD83E\\uDEE3\\uD83D\\uDE4C\\n\\nBTW the song is of abdul hannan.....if you are curious...\\n\\n    Now let\\'s begin....\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is a famous idiom in hindi which describe this problem very acurately.....  \" UlTE KA ULTA = SIDHA \" for the non-hindi folks it goes somewhat like -> reverse of reverse is straight .\\n\\nsee we need to reverse the array but only k times and for that we can do one thing in bruteforce appraoch -\\n     we store the left part of the k i.e from k+1 to arr.length-1 in an array and from 0 to k in  other array and then just append those two array\\n  \\n    obviously the interviewer will not be \\uD83D\\uDE00 with it and will ask you\\n    to opimize it ... then you will show your skills \\uD83E\\uDEE1\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso for optimized approach we will perform 3 step ->\\n1. In first step - you will reverse the array from  0 to len-k\\n2. In second step - you will reverse the array from len-k+1 to len\\n3. And at last you will reverse the whole array.\\n   \\n# Boom you got the answer \\uD83C\\uDF93\\n\\n     well wait! there is a \\uD83E\\uDEB2 very dangerous \\n\\nwhat if we get k > then len then we will get abnormility here we will use our main weapon  -> % ( yup looks tiny but very usefull \\uD83E\\uDD26\\u200D\\u2642\\uFE0F )\\n\\nsee when we rotate len time a array we get the array back again and thus [ k%len ] give us the exact time we have to rotate after a full rotation and for k less then len we will get k back again .\\n\\n     fun fact -> the hindi idiom is self made ...just like you coder \\uD83D\\uDC96\\n\\nHope you under stood it.  For any correction pls let me know...\\n\\n    PLEASE UP-VOTE IF IT HELPED YOU \\uD83D\\uDE4C  \\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Additionals\\n-  connect with me - https://linktr.ee/_soumya\\n# Code\\n```\\nclass Solution {\\n     public int[] rotate(int[] arr, int k) {\\n        int len = arr.length-1;\\n        k=k%(len+1);\\n        arr = rev(arr,0,len-k);\\n        arr=rev(arr,len-k+1,len);\\n        arr=rev(arr,0,len);\\n        return arr;\\n    }\\n\\n   public int[] rev(int[] arr,int low,int hi)\\n    {\\n        while(low<hi)\\n        {\\n           int temp=arr[low];\\n           arr[low]=arr[hi];\\n           arr[hi]=temp;\\n           hi--;\\n           low++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n     public int[] rotate(int[] arr, int k) {\\n        int len = arr.length-1;\\n        k=k%(len+1);\\n        arr = rev(arr,0,len-k);\\n        arr=rev(arr,len-k+1,len);\\n        arr=rev(arr,0,len);\\n        return arr;\\n    }\\n\\n   public int[] rev(int[] arr,int low,int hi)\\n    {\\n        while(low<hi)\\n        {\\n           int temp=arr[low];\\n           arr[low]=arr[hi];\\n           arr[hi]=temp;\\n           hi--;\\n           low++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54437,
                "title": "my-perfect-java-code-o-1-1ms-use-reverse",
                "content": "    public class Solution {\\n        public void reverse(int[] nums, int l, int r) {\\n    \\t\\twhile (l < r) {\\n    \\t\\t\\tint temp = nums[l];\\n    \\t\\t\\tnums[l++] = nums[--r];\\n    \\t\\t\\tnums[r] = temp;\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tpublic void rotate(int[] nums, int k) {\\n    \\t\\tint n = nums.length;\\n    \\t\\tk = (n == 0 ? 0 : k % n);\\n    \\t\\treverse(nums, 0    , n - k);\\n    \\t\\treverse(nums, n - k, n    );\\n    \\t\\treverse(nums, 0    , n    );\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void reverse(int[] nums, int l, int r) {\\n    \\t\\twhile (l < r) {\\n    \\t\\t\\tint temp = nums[l];\\n    \\t\\t\\tnums[l++] = nums[--r];\\n    \\t\\t\\tnums[r] = temp;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 895980,
                "title": "2-liner-python-solution-beats-99-8-time",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        k=k%len(nums)\\n        nums[:]=nums[-k:]+nums[:-k]\\n```\\nHowever, its considered O(n) space since nums[:] is equivalent to creating a new array",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        k=k%len(nums)\\n        nums[:]=nums[-k:]+nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487529,
                "title": "py3-js-5-different-simple-solutions",
                "content": "## Brute Force\\n- Repeat `pop` and `insert at front` k times.\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\\n\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    while(k--) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\\n## `prepend` of Deque\\n- add element in front of deque takes constant time.  \\n- Time complexity: **O(K)**\\n- Space complexity: **O(N)**\\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        d = deque(nums)\\n        for _ in range(k):\\n            d.appendleft(d.pop())\\n        nums[:] = list(d)\\n```\\n\\n## Stack\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    const stack = [];\\n    k %= nums.length;\\n    while(k--) {\\n        stack.push(nums.pop());\\n    }\\n    nums.unshift(...stack.reverse());\\n};\\n```\\n\\n## Reduce `k`: Using Cyclic Replacements\\n_1. Remove redundant loop:_\\n  If `k` is bigger than length of `nums`. Bruteforce algorithm gonna looping `nums` over and over.\\n  To prevent the redunant work only move remainder of ` k / length of nums` steps.\\n- Time complexity: **O(NK)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\\n_2. Insert(0,x) takes O(N), swap elements takes O(1):_\\n  Python list is a dynamic array. inserting an element in front of array takes O(N).\\n   swaping element in array takes O(1). \\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        count, start = 0, 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while 1:\\n                current = (current + k) % len(nums)\\n                temp, nums[current] = nums[current], prev\\n                prev = temp\\n                count += 1\\n                if start == current:\\n                    break\\n            start += 1\\n```\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar rotate = (nums, k) => {\\n    let [start, count] = [0, 0];\\n    while (count < nums.length) {\\n        let [current, prev] = [start, nums[start]];\\n        do {\\n            current = (current + k) % nums.length;\\n            [nums[current], prev] = [prev, nums[current]];\\n            count++;\\n        } while (current !== start)\\n        start++\\n    }\\n};\\n```\\n\\n##  Reduce `k` & Use Slicing\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n- Python slice create new array\\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        if k == 0: return\\n        nums[:-k], nums[-k:] = nums[-k:], nums[:-k]\\n```\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n- JavaScript splice create new array\\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    nums.unshift(...nums.splice(nums.length - k%nums.length));\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    while(k--) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        d = deque(nums)\\n        for _ in range(k):\\n            d.appendleft(d.pop())\\n        nums[:] = list(d)\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    const stack = [];\\n    k %= nums.length;\\n    while(k--) {\\n        stack.push(nums.pop());\\n    }\\n    nums.unshift(...stack.reverse());\\n};\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        while k:\\n            nums.insert(0, nums.pop())\\n            k -= 1\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        count, start = 0, 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while 1:\\n                current = (current + k) % len(nums)\\n                temp, nums[current] = nums[current], prev\\n                prev = temp\\n                count += 1\\n                if start == current:\\n                    break\\n            start += 1\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar rotate = (nums, k) => {\\n    let [start, count] = [0, 0];\\n    while (count < nums.length) {\\n        let [current, prev] = [start, nums[start]];\\n        do {\\n            current = (current + k) % nums.length;\\n            [nums[current], prev] = [prev, nums[current]];\\n            count++;\\n        } while (current !== start)\\n        start++\\n    }\\n};\\n```\n```Python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        if k == 0: return\\n        nums[:-k], nums[-k:] = nums[-k:], nums[:-k]\\n```\n```JavaScript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void}\\n */\\nconst rotate = (nums, k) => {\\n    nums.unshift(...nums.splice(nums.length - k%nums.length));\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202250,
                "title": "4-python-solutions",
                "content": "Delete k elements from the end and insert them at the begining\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        for i in range(k % len(nums)):\\n            nums.insert(0, nums.pop())\\n```\\n\\nIteratively move each element to it\\'s correct position\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        n = len(nums)\\n        i = 0\\n        count = 0\\n        while count < n:\\n            pos = (i + k) % len(nums)\\n            curr = nums[pos]\\n            nums[pos] = nums[i]\\n            count += 1\\n            j = pos\\n            while j != i and count < n:\\n                pos = (j + k) % len(nums)\\n                nums[pos], curr = curr, nums[pos]\\n                j = pos\\n                count += 1\\n            i += 1\\n```\\n\\nUse an additional array to copy the elements into rotated positions and copy them back to original array\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        dupnums = [0] * len(nums)\\n        for i in range(len(nums)):\\n            dupnums[(i + k) % len(nums)] = nums[i]\\n\\n        nums[:] = dupnums # copy dupnums to nums\\n```\\n\\nSame as the first one. But, by taking advantage of python\\'s list indexing.\\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        for i in range(k % len(nums)):\\n            nums.insert(0, nums.pop())\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        n = len(nums)\\n        i = 0\\n        count = 0\\n        while count < n:\\n            pos = (i + k) % len(nums)\\n            curr = nums[pos]\\n            nums[pos] = nums[i]\\n            count += 1\\n            j = pos\\n            while j != i and count < n:\\n                pos = (j + k) % len(nums)\\n                nums[pos], curr = curr, nums[pos]\\n                j = pos\\n                count += 1\\n            i += 1\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        dupnums = [0] * len(nums)\\n        for i in range(len(nums)):\\n            dupnums[(i + k) % len(nums)] = nums[i]\\n\\n        nums[:] = dupnums # copy dupnums to nums\\n```\n```python\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54419,
                "title": "a-7-line-time-o-n-in-place-solution-no-reversing",
                "content": "The concise 7-line version.\\n\\n    Sample [1,2,3,4,5,6,7,8,9] 3    \\n    The replacing process is as follow:\\n    1) 1->4->7->1\\n    2) 2->5->8->2\\n    3) 3->6->9->3\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count++ < nums.Length){\\n            int tmp = nums[i = (i + k) % nums.Length];\\n            nums[i] = curNum;\\n            curNum = i == start ? nums[i = ++start] : tmp;\\n        }\\n    }\\n\\n\\nBelow is the elaborated version easier to understand\\n\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count < nums.Length){\\n            i = (i + k) % nums.Length;\\n            int tmp = nums[i];\\n            nums[i] = curNum;\\n            if(i == start){\\n                start++;\\n                i = start;\\n                curNum = nums[i];\\n            }\\n            else curNum = tmp;\\n            count++;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The concise 7-line version.\\n\\n    Sample [1,2,3,4,5,6,7,8,9] 3    \\n    The replacing process is as follow:\\n    1) 1->4->7->1\\n    2) 2->5->8->2\\n    3) 3->6->9->3\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count++ < nums.Length){\\n            int tmp = nums[i = (i + k) % nums.Length];\\n            nums[i] = curNum;\\n            curNum = i == start ? nums[i = ++start] : tmp;\\n        }\\n    }\\n\\n\\nBelow is the elaborated version easier to understand\\n\\n    public void Rotate(int[] nums, int k) {\\n        if(nums.Length == 0 || k % nums.Length == 0) return;\\n        int start = 0, i = start, curNum = nums[i], count = 0;\\n        while(count < nums.Length){\\n            i = (i + k) % nums.Length;\\n            int tmp = nums[i];\\n            nums[i] = curNum;\\n            if(i == start){\\n                start++;\\n                i = start;\\n                curNum = nums[i];\\n            }\\n            else curNum = tmp;\\n            count++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54606,
                "title": "c-3-lines-easy-to-understand",
                "content": "    /*****\\n    ****author: cxq\\n    ****weibo: http://weibo.com/chenxq1992\\n    ****/\\n    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k = k % n;\\n            reverse(nums, nums + n);\\n            reverse(nums, nums + k);\\n            reverse(nums + k, nums + n);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k = k % n;\\n            reverse(nums, nums + n);\\n            reverse(nums, nums + k);\\n            reverse(nums + k, nums + n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3218810,
                "title": "189-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The first step is to calculate the number of steps we actually need to take. Since rotating the array by its length has no effect, we can use the modulo operator to reduce the number of steps to be less than the length of the array.\\n2. The second step is to reverse the entire array. This has the effect of moving the last k elements to the beginning of the array.\\n3. The third step is to reverse the first k elements. This moves them to the end of the array, while leaving the remaining elements in place.\\n4. The fourth and final step is to reverse the remaining elements. This moves them to the beginning of the array, completing the rotation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        # Calculate the number of steps we actually need to take\\n        k = k % len(nums)\\n    \\n        # Reverse the entire array\\n        nums.reverse()\\n    \\n        # Reverse the first k elements\\n        nums[:k] = reversed(nums[:k])\\n    \\n        # Reverse the remaining elements\\n        nums[k:] = reversed(nums[k:])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        # Calculate the number of steps we actually need to take\\n        k = k % len(nums)\\n    \\n        # Reverse the entire array\\n        nums.reverse()\\n    \\n        # Reverse the first k elements\\n        nums[:k] = reversed(nums[:k])\\n    \\n        # Reverse the remaining elements\\n        nums[k:] = reversed(nums[k:])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832647,
                "title": "two-js-solutions",
                "content": "```\\nvar rotate = function(nums, k) {\\n    for (let i = 0; i < k; i++) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\\n\\n```\\nvar rotate = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return;\\n    }\\n    k = k % nums.length;\\n    if (k === 0) {\\n        return;\\n    }\\n    nums.reverse();\\n    reverse(nums, 0, k-1);\\n    reverse(nums, k, nums.length - 1);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nconst reverse = (arr, start, end) => {\\n    while (start < end) {\\n        let temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++, end--;\\n    }\\n}\\n\\n/*\\nSolution:\\n1. Reverse the entire array.\\n2. Reverse the first k elements.\\n3. Reverse the rest.\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    for (let i = 0; i < k; i++) {\\n        nums.unshift(nums.pop());\\n    }\\n};\\n```\n```\\nvar rotate = function(nums, k) {\\n    if (nums === null || nums.length === 0) {\\n        return;\\n    }\\n    k = k % nums.length;\\n    if (k === 0) {\\n        return;\\n    }\\n    nums.reverse();\\n    reverse(nums, 0, k-1);\\n    reverse(nums, k, nums.length - 1);\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nconst reverse = (arr, start, end) => {\\n    while (start < end) {\\n        let temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++, end--;\\n    }\\n}\\n\\n/*\\nSolution:\\n1. Reverse the entire array.\\n2. Reverse the first k elements.\\n3. Reverse the rest.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125740,
                "title": "easy-solution-with-explanation-without-using-extra-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is here to use circular rotation i.e, here in \\n##### Example 1:\\nInput: nums = [1,2], k = 3\\n Output: [2,1]\\n\\nif the value of k is greater than the size of the array, then our array can go out of bounds, to solve that and rotate the array under given condition we are using circular rotation. i.e, **k= k% nums.length**\\n\\nHere in E:g the k=3, now if k%n = 3%2 ==> 1, so the value of rotation becomes 1.\\n\\n### To Arrange the elements in place\\n\\n1) First we have to reverse the whole array using two pointers technique.\\n2) Now after the array is reversed, now we have to reverse the elements before the occurence of k, i.e, **(0,k-1)**\\n\\n**Note:** [Here we have  here we subtracted 1 from k **(0,k-1)**, because we are using 0-indexed array].\\n\\n3) Now we have to reverse the elements after the occurence of k(rotation), i.e, \\n**(k,nums.length-1)**\\n\\nNow, the array is arranged without using extra space\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        rotate(nums,0,nums.length-1);\\n        rotate(nums,0,k-1);\\n        rotate(nums,k,nums.length-1);\\n    }\\n    private void rotate(int[] nums, int low, int high){\\n        while(low<high){\\n            int temp = nums[low];\\n            nums[low] = nums[high];\\n            nums[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```\\n## Upvote me if you like the approach and explanation. This helps me to bring you more solutions like that............",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        rotate(nums,0,nums.length-1);\\n        rotate(nums,0,k-1);\\n        rotate(nums,k,nums.length-1);\\n    }\\n    private void rotate(int[] nums, int low, int high){\\n        while(low<high){\\n            int temp = nums[low];\\n            nums[low] = nums[high];\\n            nums[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258789,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        n = len(nums)\\n        k %= n\\n        ans = [0] * n\\n        \\n        for i in range(n):\\n            ans[(i+k)%n] = nums[i]\\n            \\n        for i in range(n):\\n            nums[i] = ans[i]\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse array**\\n- Example Input: [1, 2, 3, 4, 5, 6], k = 2\\n- Expect Output: [5, 6, 1, 2, 3, 4]\\n- The idea is that we do 3 reverse\\n- Reverse the whole array, it becomes: [6, 5, 4, 3, 2, 1]\\n- Reverse first `k` elements, it becomes: [5, 6, 4, 3, 2, 1]\\n- Reverse the last `n-k` elements, it becomes: [5, 6, 1, 2, 3, 4]\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def reverse(arr, left, right):\\n            while left < right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n                \\n        n = len(nums)\\n        k %= n\\n        reverse(nums, 0, n - 1)\\n        reverse(nums, 0, k-1)\\n        reverse(nums, k, n-1)\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        n = len(nums)\\n        k %= n\\n        ans = [0] * n\\n        \\n        for i in range(n):\\n            ans[(i+k)%n] = nums[i]\\n            \\n        for i in range(n):\\n            nums[i] = ans[i]\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        def reverse(arr, left, right):\\n            while left < right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n                \\n        n = len(nums)\\n        k %= n\\n        reverse(nums, 0, n - 1)\\n        reverse(nums, 0, k-1)\\n        reverse(nums, k, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668133,
                "title": "simplest-way-using-insert-and-pop",
                "content": "# Intuition\\nTo rotate the array nums to the right by k steps, we can follow these steps:\\n\\n1. If k is greater than the length of nums, reduce k by taking its modulo with the length of nums. This ensures that k falls within the range of valid rotations.\\n2. Perform the rotation in-place by repeatedly popping the last element of the array and inserting it at the beginning for k times.\\n# Approach\\n\\n1.\\tCheck if k is greater than the length of nums. If so, reduce k by taking its modulo with the length of nums.\\n2.\\tPerform the rotation by iterating k times using a for loop:\\n\\u2022\\tRemove the last element of nums using pop() and store it in a variable a.\\n\\u2022\\tInsert the value a at the beginning of nums using insert().\\n\\n# Complexity\\n- Time complexity: O(n^2)\\nThe time complexity is proportional to the value of k since we need to rotate the array k times.\\n\\n- Space complexity: O(1)\\nThe space complexity is constant as we are modifying the input array in-place and not using any additional data structures.\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        for i in range(k):\\n            a=nums.pop()\\n            nums.insert(0,a)\\n```\\n\\n##### reach me to discuss any problems - https://www.linkedin.com/in/naveen-kumar-g-500469210/\\n![image.png](https://assets.leetcode.com/users/images/8d8328c3-f05f-4acb-9e6d-87c7a1abd695_1687413526.140085.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        for i in range(k):\\n            a=nums.pop()\\n            nums.insert(0,a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168393,
                "title": "one-liner-in-python3",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545232,
                "title": "c-java-python-javascript-2-approaches-brute-and-optimized-space-complexity-o-1",
                "content": "# 1. Brute Force: Time complexity: O(n), Space complexity: O(k)\\n### Intuition\\nThe intuition behind the approach is to divide the rotation process into two steps: first, storing the last k elements in a temporary array, and then rearranging the remaining elements in nums to their new positions. By using this two-step process, the function achieves the desired rotation effect.\\n\\n### Approach\\n1. Initialize the variable `n` with the size of the `nums` vector.\\n\\n2. The value of `k` is updated to be the remainder when divided by `n`. This step ensures that `k` is within the valid range of indices.\\n\\n3. If `k` is greater than `n`, the function returns early without performing any rotations. This is because rotating by `k` positions would result in the same configuration as rotating by `k % n` positions.\\n\\n4. Next, the function checks for some special cases where rotation is not necessary: when `n` or `k` is 0, or when `n` is equal to `k`. In such cases, the function returns early without any further computations.\\n\\n5. If none of the early return conditions are met, an array `temp` of size `k` is created to store the last `k` elements of `nums` temporarily.\\n\\n6. A loop runs `k` times, copying the last `k` elements of `nums` to the `temp` array in reverse order.\\n\\n7. Another loop runs from `n-1` to 0. For each iteration, if the index `i` is less than `k`, the corresponding element in `nums` is updated with the element from `temp` at the reversed index `k-i-1`. This step places the rotated elements at the beginning of `nums`.\\n\\n8. If the index `i` is greater than or equal to `k`, the corresponding element in `nums` is updated with the element at index `i-k`, effectively shifting the remaining elements to their new positions.\\n\\n9. After the loops complete, the function has successfully rotated the elements in `nums` by `k` positions.\\n\\n### Complexity\\n- Time complexity: O(n), where n is the size of the input vector `nums`. This is because the code performs two loops, one with `k` iterations and the other with `n` iterations, where `k` and `n` are at most equal to the size of `nums`. All other operations are constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k), as it uses an auxiliary array `temp` of size `k` to temporarily store the elements to be rotated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t   k = k % n;\\n\\t   cout<<k<<endl;\\n\\t   if (k > n){\\n        return;\\n\\t   }\\n        if(n==0 || k==0 || n==k){\\n\\t       return;\\n\\t   }\\n\\t   int temp[k];\\n\\t   for(int i=0;i<k;i++){\\n\\t       temp[i]=nums[n-i-1];\\n\\t   }\\n\\t   for(int i=n-1;i>=0;i--){\\n\\t\\t\\t if(i<k){\\n\\t\\t\\t\\t nums[i]=temp[k-i-1];\\n\\t\\t\\t }\\n\\t\\t\\t else{\\n\\t\\t\\t\\t nums[i]=nums[i-k];\\n\\t\\t\\t }\\n\\t   }\\n    }\\n};\\n```\\n\\n---\\n\\n\\n# 2. Optimized Approach : Time complexity: O(n), Space complexity: O(1)\\n\\n# Intuition:\\nThe problem requires rotating the elements of a vector to the right by a given number of positions. To optimize the code to achieve O(1) space complexity, we can perform the rotation in-place without using any additional arrays.\\n\\n# Approach:\\n1. First, we initialize the variables `n` and `k`, where `n` is the size of the input vector `nums`, and `k` is the number of positions to rotate.\\n2. We update `k` to be the remainder when divided by `n` to ensure it is within the valid range of indices.\\n3. We handle some special cases: if `k` is 0, `n` is 0, or `n` is equal to `k`, we return early as no rotation is needed.\\n4. We initialize the variables `count`, `start`, `current`, and `prev`. The `count` keeps track of the number of elements moved, `start` represents the starting index for each rotation cycle, `current` is the current index being processed, and `prev` stores the value that will be moved to the next position.\\n5. We enter a loop that continues until all elements have been moved to their correct positions. Inside the loop:\\n   - We calculate the new index `current` by adding `k` to the current index and taking the modulus of `n` to handle wraparound.\\n   - We swap the value at the current index `current` with the value in `prev`.\\n   - We update `prev` to the value that was previously at the current index.\\n   - We increment the `count`.\\n   - If the `current` index becomes equal to the `start` index, it means that we have completed a rotation cycle. We increment `start`, update `current` and `prev` to the new values, and continue the rotation process until all elements have been moved.\\n6. Once the loop completes, the vector `nums` will contain the rotated elements.\\n\\n# Complexity:\\n- The time complexity of the optimized code is O(n), where n is the size of the input vector `nums`. This is because the code needs to visit each element in the vector to perform the rotations.\\n\\n- The space complexity of the optimized code is O(1) since it does not require any additional space proportional to the input size. It only uses a few extra variables to keep track of indices and temporarily store values during swapping.\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        n = len(nums)\\n        k = k % n\\n        if k == 0 or n == 0 or n == k:\\n            return\\n        \\n        count = 0\\n        start = 0\\n        current = start\\n        prev = nums[start]\\n        \\n        while count < n:\\n            current = (current + k) % n\\n            nums[current], prev = prev, nums[current]\\n            count += 1\\n            \\n            if current == start:\\n                start += 1\\n                current = start\\n                prev = nums[start]\\n\\n```\\n# JavaScript\\n```\\nvar rotate = function(nums, k) {\\n    var n = nums.length;\\n    k = k % n;\\n    if (k === 0 || n === 0 || n === k) {\\n        return;\\n    }\\n    \\n    var count = 0;\\n    var start = 0;\\n    var current = start;\\n    var prev = nums[start];\\n    \\n    while (count < n) {\\n        current = (current + k) % n;\\n        var temp = nums[current];\\n        nums[current] = prev;\\n        prev = temp;\\n        count++;\\n        \\n        if (current === start) {\\n            start++;\\n            current = start;\\n            prev = nums[start];\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t   k = k % n;\\n\\t   cout<<k<<endl;\\n\\t   if (k > n){\\n        return;\\n\\t   }\\n        if(n==0 || k==0 || n==k){\\n\\t       return;\\n\\t   }\\n\\t   int temp[k];\\n\\t   for(int i=0;i<k;i++){\\n\\t       temp[i]=nums[n-i-1];\\n\\t   }\\n\\t   for(int i=n-1;i>=0;i--){\\n\\t\\t\\t if(i<k){\\n\\t\\t\\t\\t nums[i]=temp[k-i-1];\\n\\t\\t\\t }\\n\\t\\t\\t else{\\n\\t\\t\\t\\t nums[i]=nums[i-k];\\n\\t\\t\\t }\\n\\t   }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k = k % n;\\n        if (k == 0 || n == 0 || n == k) {\\n            return;\\n        }\\n        \\n        int count = 0;\\n        int start = 0;\\n        int current = start;\\n        int prev = nums[start];\\n        \\n        while (count < n) {\\n            current = (current + k) % n;\\n            int temp = nums[current];\\n            nums[current] = prev;\\n            prev = temp;\\n            count++;\\n            \\n            if (current == start) {\\n                start++;\\n                current = start;\\n                prev = nums[start];\\n            }\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        n = len(nums)\\n        k = k % n\\n        if k == 0 or n == 0 or n == k:\\n            return\\n        \\n        count = 0\\n        start = 0\\n        current = start\\n        prev = nums[start]\\n        \\n        while count < n:\\n            current = (current + k) % n\\n            nums[current], prev = prev, nums[current]\\n            count += 1\\n            \\n            if current == start:\\n                start += 1\\n                current = start\\n                prev = nums[start]\\n\\n```\n```\\nvar rotate = function(nums, k) {\\n    var n = nums.length;\\n    k = k % n;\\n    if (k === 0 || n === 0 || n === k) {\\n        return;\\n    }\\n    \\n    var count = 0;\\n    var start = 0;\\n    var current = start;\\n    var prev = nums[start];\\n    \\n    while (count < n) {\\n        current = (current + k) % n;\\n        var temp = nums[current];\\n        nums[current] = prev;\\n        prev = temp;\\n        count++;\\n        \\n        if (current === start) {\\n            start++;\\n            current = start;\\n            prev = nums[start];\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2396053,
                "title": "c-3-methods-fast-explained",
                "content": "**This took a lot of effort to document. Please upvote if helpful**\\n\\n**Method-1**\\nMost elementary method is by creating a  copy of given array and exploiting defn of rotation: *nums[(i+k)%n] = old_nums[i]*.\\nTC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> cpy(nums.cbegin(), nums.cend());\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[(i+k)%n] = cpy[i];\\n        }\\n    }\\n};\\n```\\n\\n**Method-2**\\nHere, we reduce the space complexity from O(n) to O(1). Note that the rotated array consists of two parts of the main array- one from [k..n-1], and otehr from [0..k-1]. Note that the part from [0..k-1] follows [k..n-1]. So, we reverse the main array, and re-reverse it in two parts- [0..k-1] and [k..n-1].\\nTC: O(n)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        \\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        \\n        return;\\n    }\\n};\\n```\\n\\n**Method-3**\\nThis is fairly mathematically involved, and some interest in number theory is expected. Although it too used O(n) space, but instead of storing *n integers*, we store *n booleans*; also this is mainly for mathematic interests. For *n*, and *k*, we have two cases-\\nCase i: *gcd(n,k) = 1*\\nS = {(i+k)%n | i=0 or i \\\\in S} = {i | 0<=i and i<n}\\nCase ii: *gcd(n,k) = d != 1*\\nSt = {(i+k)%n | i=t or i \\\\in S}; union of whom for t=0 to t=d-1, will equal {i | 0<=i and i<n}.\\nTC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        vector<bool> visited(n, false);\\n\\n        int curr_idx = 0, curr_val = nums[0], next_idx = k;\\n        for (int i = 0; i < n;i++) {\\n            if (!visited[i]) {\\n                curr_idx = i;\\n                next_idx = (i + k) % n;\\n                curr_val = nums[i];\\n                while (!visited[next_idx]) {\\n                    visited[next_idx] = true;\\n                    swap(curr_val, nums[next_idx]);\\n                    curr_idx = next_idx;\\n                    next_idx = (curr_idx + k) % n;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Please upvote, if helpful; as this took a lot of effort**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> cpy(nums.cbegin(), nums.cend());\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[(i+k)%n] = cpy[i];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        \\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n        \\n        return;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k %= n;\\n        vector<bool> visited(n, false);\\n\\n        int curr_idx = 0, curr_val = nums[0], next_idx = k;\\n        for (int i = 0; i < n;i++) {\\n            if (!visited[i]) {\\n                curr_idx = i;\\n                next_idx = (i + k) % n;\\n                curr_val = nums[i];\\n                while (!visited[next_idx]) {\\n                    visited[next_idx] = true;\\n                    swap(curr_val, nums[next_idx]);\\n                    curr_idx = next_idx;\\n                    next_idx = (curr_idx + k) % n;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591978,
                "title": "python-solution-super-simple-easy-to-understand-common-mistakes-explained",
                "content": "**1. Solution**\\n\\n```\\n    def rotate(self, nums, k):\\n        k = k % len(nums)                 #take care of the case where k >= len(nums)  \\n        nums[:] = nums[-k:] + nums[:-k] \\n```\\n\\n\\n\\n**2. Remarks**\\n\\n* We use  `k % len(nums)` to take care of the case where the input `k` is larger than the length of `nums` list.\\n* There\\'s no return value since we modified the list in-place using  `nums[:] = ...` .\\n\\n\\n**3. Common confusion** \\n* ***Why ` return nums[-k:] + nums[:-k] ` doesn\\'t work?***\\n\\n     Well, it should work when you run it locally (not on Leetcode). Because there\\'s an extra constraint added in the follow-up questions which requires in-place list modification. And this is clearly not an in-place modification, so it won\\'t pass the Leetcode tests.\\n\\t \\n\\t \\n****Please upvote if you find it useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def rotate(self, nums, k):\\n        k = k % len(nums)                 #take care of the case where k >= len(nums)  \\n        nums[:] = nums[-k:] + nums[:-k] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2836561,
                "title": "o-1-java-simple-solution-0ms-100-faster",
                "content": "1. for eg: arr = [1,2,3,4,5] k=2, Now reverse the array. It becomes [5,4,3,2,1]\\n2. Now split into two parts based on k value. like [5,4,] and [3,2,1]\\n3. Now reverse the both parts.\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        // step1: reverse the array\\n        // step2: split the array into two.\\n        // step3: reverse both the two parts.\\n        \\n        //taking k modulo for edge cases\\n        k = k%nums.length;\\n        swap(nums, 0, nums.length-1);\\n        swap(nums, 0, k-1);\\n        swap(nums, k, nums.length-1);\\n    }\\n    public void swap(int[] arr, int start, int end){\\n        while(start<end){\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        // step1: reverse the array\\n        // step2: split the array into two.\\n        // step3: reverse both the two parts.\\n        \\n        //taking k modulo for edge cases\\n        k = k%nums.length;\\n        swap(nums, 0, nums.length-1);\\n        swap(nums, 0, k-1);\\n        swap(nums, k, nums.length-1);\\n    }\\n    public void swap(int[] arr, int start, int end){\\n        while(start<end){\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390391,
                "title": "4-methods-in-python-index-assign-list-slicing-reversed",
                "content": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Method 1 : list slicing\\n        k = k % len(nums)\\n        if len(nums) > 1 and k > 0:\\n            nums[:] = nums[-k:] + nums[:-k]\\n        \\n        # Method 2 : list replacing\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:k], nums[k:] = nums[-k:], nums[:-k]\\n            \\n        # Method 3 : index assigning\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for index in range(len(nums)-1, k-1, -1):\\n            nums[index] = nums[index-k]\\n        for index, value in enumerate(tmp):\\n            nums[index] = value\\n\\n        # Method 4 : reversed method\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:] = reversed(nums)\\n            nums[:k], nums[k:] = reversed(nums[:k]), reversed(nums[k:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        # Method 1 : list slicing\\n        k = k % len(nums)\\n        if len(nums) > 1 and k > 0:\\n            nums[:] = nums[-k:] + nums[:-k]\\n        \\n        # Method 2 : list replacing\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:k], nums[k:] = nums[-k:], nums[:-k]\\n            \\n        # Method 3 : index assigning\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for index in range(len(nums)-1, k-1, -1):\\n            nums[index] = nums[index-k]\\n        for index, value in enumerate(tmp):\\n            nums[index] = value\\n\\n        # Method 4 : reversed method\\n        k = k % len(nums)\\n        if len(nums) > 1 and  k > 0:\\n            nums[:] = reversed(nums)\\n            nums[:k], nums[k:] = reversed(nums[:k]), reversed(nums[k:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54331,
                "title": "three-simple-solutions-using-c",
                "content": "    void rotate(int nums[], int n, int k) {\\n        while(k>0) {\\n        int tmp = nums[n-1];\\n            for(int i=n-1; i>0; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[0] = tmp;\\n            k--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        int tmp = nums[n-1];\\n        for(int i=n-1; i>0; i--) {\\n            nums[i] = nums[i-1];\\n        }\\n        nums[0] = tmp;\\n        rotate(nums, n, k-1);\\n    }\\n    \\n    void strReverse(int nums[], int bgn, int end) {\\n        int lst = end-1;\\n        while(bgn<lst) {\\n            int tmp = nums[bgn];\\n            nums[bgn] = nums[lst];\\n            nums[lst] = tmp;\\n            bgn++;\\n            lst--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        k = k%n;\\n        strReverse(nums, 0, n-k);\\n        strReverse(nums, n-k, n);\\n        strReverse(nums, 0, n);\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        while(k>0) {\\n        int tmp = nums[n-1];\\n            for(int i=n-1; i>0; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[0] = tmp;\\n            k--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        int tmp = nums[n-1];\\n        for(int i=n-1; i>0; i--) {\\n            nums[i] = nums[i-1];\\n        }\\n        nums[0] = tmp;\\n        rotate(nums, n, k-1);\\n    }\\n    \\n    void strReverse(int nums[], int bgn, int end) {\\n        int lst = end-1;\\n        while(bgn<lst) {\\n            int tmp = nums[bgn];\\n            nums[bgn] = nums[lst];\\n            nums[lst] = tmp;\\n            bgn++;\\n            lst--;\\n        }\\n    }\\n    \\n    void rotate(int nums[], int n, int k) {\\n        if (k<=0) {\\n            return;\\n        }\\n        k = k%n;\\n        strReverse(nums, 0, n-k);\\n        strReverse(nums, n-k, n);\\n        strReverse(nums, 0, n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4045516,
                "title": "most-optimized-solution-c-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<div class=\"Note:\">\\n  <p><strong># Note:</strong> k might be greater than or equal to nums.size(). Therefore set k equal to k % nums.size() .</p>\\n</div>\\n\\n<pre>\\nk = k % nums.size();\\n</pre>\\n\\n\\n##### Example:- 1 2 3 4 5 6 7; k = 4; n = 7\\n1. Reverse the k elements from the last:\\n<pre>reverse(nums.end() - k, nums.end());      // 1 2 3 7 6 5 4</pre>\\n2. Then reverse the elements form index 0 to n-k-1:\\n<pre>reverse(nums.begin(), nums.end() - k);    // 3 2 1 7 6 5 4</pre>\\n3. Now reverse the whole nums;\\n<pre>reverse(nums.begin(), nums.end());        // 4 5 6 7 1 2 3</pre> \\n\\n\\n<!-- <div class=\"Note:\">\\n  <p><strong># Note:</strong> k might be greater than or equal to nums.size(). Therefore set k equal to k % nums.size() .</p>\\n</div> -->\\n# Complexity\\n\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // int nums_size = nums.size();\\n        k = k % nums.size();\\n        if(k!=0)\\n        {\\n            reverse(nums.end() - k, nums.end());\\n            reverse(nums.begin(), nums.end() - k);\\n            reverse(nums.begin(), nums.end());\\n        }\\n    }\\n};\\n```\\n\\n### Please upvote!!!\\n\\n<!-- <p><img src=\"https://assets.leetcode.com/users/images/be16a9b6-6d5f-433f-89e8-90f18384d6f9_1683670956.5248532.jpeg\" alt=\"7abc56.jpg\"></p> -->",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        // int nums_size = nums.size();\\n        k = k % nums.size();\\n        if(k!=0)\\n        {\\n            reverse(nums.end() - k, nums.end());\\n            reverse(nums.begin(), nums.end() - k);\\n            reverse(nums.begin(), nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244055,
                "title": "rotation-array-clockwise-rotation-rotation-game-time-complexity-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this question you just need to know: \\n**How to reverse the array?**\\nEg:\\nA0  A1  A2  A3  A4  A5  A6  A7  A8  A9  A10 A11\\n\\nfor K = 5\\nthe last 5 elements comes at the front (**observation 1**)\\n\\nAfter rotation of K times, exactly from back will come to front.\\n\\n\\nA7  A8  A9  A10 A11   A0  A1  A2  A3  A4  A5  A6\\n\\\\-------------------\\\\ \\\\--------------------------\\\\\\n______  k __________   ___________N-K _____________\\n\\nrotation(arr, k){\\n// 1. reverse the complete array\\n reverse(0, n-1);\\n// 2. reverse the first k elements\\n reverse(0, k-1);\\n// 3. reverse the remaining elements\\n reverse(k, n-1);\\n}\\n\\n\\n**Extension of Problem:**\\n**What if K > N??**\\nfor this you just have to have 1 condition:\\nif(k > n){\\nk = K %  n; // do rotations for k > n, you will figure why i did this.\\n}\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution contains three steps:-\\n1. Reverse the complete array.\\n2. Reverse first K elements.\\n3. Reverse remaining elements.\\n\\n# Complexity\\n- Time complexity: N/2 + K/2 + (n-k)/2 => N/2 +  K/2 + N/2 - K/2 => O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public void reverse(int []arr, int low, int high){\\n        while(low < high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n\\n            low++;\\n            high--;\\n        }\\n    }\\n    \\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        if(k > n){\\n            k = k%n;\\n        }\\n        //1. reversing the whole array\\n        reverse(nums, start, end);\\n \\n\\n        //2. reversing the k part\\n        reverse(nums, start, k-1);\\n\\n        //3. reverse the remaining part\\n        reverse(nums, k, end);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void reverse(int []arr, int low, int high){\\n        while(low < high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n\\n            low++;\\n            high--;\\n        }\\n    }\\n    \\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        if(k > n){\\n            k = k%n;\\n        }\\n        //1. reversing the whole array\\n        reverse(nums, start, end);\\n \\n\\n        //2. reversing the k part\\n        reverse(nums, start, k-1);\\n\\n        //3. reverse the remaining part\\n        reverse(nums, k, end);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664082,
                "title": "o-1-space-solution-with-explaination-and-code-with-comments-in-c",
                "content": "So the idea here is first we will reverse the entire array for example if the array was :[1,2,3,4,5,6,7] k=3\\nnow after we reverse it entirely we it will become :[7,6,5,4,3,2,1]\\nnow what we can do is reverse the subarray containing first k elements so now it will become :\\n[5,6,7,4,3,2,1]\\nnow u can notice that the elements which should have been in front after k rotations aree now in their right place and now finally to get our answer simply we reverse the rest of the elements then we will get :\\n[5,6,7,1,2,3,4]  this is our answer \\n\\nthis would be the code for this approach i hope guys will like it also it requires kinda 3 loops if any one has a solution to solve it in single iteration please do suggest Thankyou for viewing this below  I will be sharing the code for this with comments also please share any suggestions if you guys have any\\n\\n```\\nclass Solution {\\npublic:\\n    void rev(vector <int> &nums,int k){\\n        int s=0,e=k-1;\\n        while(s<=e){\\n            swap(nums[e],nums[s]);\\n            s++;e--;\\n        }\\n    }\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k=k%nums.size();//Calculating the appropriate size of k so as to prevent any index out of bounds\\n        \\n        reverse(nums.begin(),nums.end());// reversing the entire array\\n        \\n        rev(nums,k);// reversing first k elements of the array\\n        \\n        reverse(nums.begin()+k,nums.end());//reversing reset of the (nums.size()-k) elements of the array\\n    }\\n};\\n```\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\nThankyou !",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rev(vector <int> &nums,int k){\\n        int s=0,e=k-1;\\n        while(s<=e){\\n            swap(nums[e],nums[s]);\\n            s++;e--;\\n        }\\n    }\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k=k%nums.size();//Calculating the appropriate size of k so as to prevent any index out of bounds\\n        \\n        reverse(nums.begin(),nums.end());// reversing the entire array\\n        \\n        rev(nums,k);// reversing first k elements of the array\\n        \\n        reverse(nums.begin()+k,nums.end());//reversing reset of the (nums.size()-k) elements of the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54538,
                "title": "o-n-time-and-o-1-space-solution",
                "content": "The idea is to rotate using reversal.\\n1. divide the array into two parts.\\n2. reverse first part\\n3. reverse second part\\n4. reverse whole array\\n\\n    /**\\n     * rotate right an array\\n     * nums      : pointer to array to be rotated\\n     * numsSize  : length of array\\n     * k         : distance of rotation\\n     */ \\n    void rotate(int* nums, int numsSize, int k) {\\n        k = k % numsSize;\\n        if (k == 0) return;\\n        if (numsSize <= 1) return;\\n        \\n        //divide the array into 2 part\\n        int lengthFirstPart = numsSize - k;\\n        //reverse first part\\n        reverse(nums, lengthFirstPart);\\n        //reverse second part\\n        reverse(&nums[lengthFirstPart], numsSize - lengthFirstPart);\\n        //reverse everything\\n        reverse(nums, numsSize);\\n    }\\n    \\n    /**\\n     * reverse array\\n     * nums      : pointer to array to be reversed\\n     * numsSize  : length of array\\n     */ \\n    void reverse(int* nums, int numsSize){\\n        int mid = numsSize / 2;\\n        int temp;\\n        for(int i = 0; i < mid; i++){\\n            temp = nums[i];\\n            nums[i] = nums[numsSize - 1 - i];\\n            nums[numsSize - 1 - i] = temp;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is to rotate using reversal.\\n1. divide the array into two parts.\\n2. reverse first part\\n3. reverse second part\\n4. reverse whole array\\n\\n    /**\\n     * rotate right an array\\n     * nums      : pointer to array to be rotated\\n     * numsSize  : length of array\\n     * k         : distance of rotation\\n     */ \\n    void rotate(int* nums, int numsSize, int k) {\\n        k = k % numsSize;\\n        if (k == 0) return;\\n        if (numsSize <= 1) return;\\n        \\n        //divide the array into 2 part\\n        int lengthFirstPart = numsSize - k;\\n        //reverse first part\\n        reverse(nums, lengthFirstPart);\\n        //reverse second part\\n        reverse(&nums[lengthFirstPart], numsSize - lengthFirstPart);\\n        //reverse everything\\n        reverse(nums, numsSize);\\n    }\\n    \\n    /**\\n     * reverse array\\n     * nums      : pointer to array to be reversed\\n     * numsSize  : length of array\\n     */ \\n    void reverse(int* nums, int numsSize){\\n        int mid = numsSize / 2;\\n        int temp;\\n        for(int i = 0; i < mid; i++){\\n            temp = nums[i];\\n            nums[i] = nums[numsSize - 1 - i];\\n            nums[numsSize - 1 - i] = temp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54427,
                "title": "my-simple-python-code",
                "content": "    class Solution:\\n        def rotate(self, nums, k):\\n            while k > 0:\\n                nums.insert(0, nums.pop())\\n                k -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def rotate(self, nums, k):\\n            while k > 0:\\n                nums.insert(0, nums.pop())\\n                k -= 1",
                "codeTag": "Java"
            },
            {
                "id": 1459896,
                "title": "java-o-n-time-o-1-space-with-examples",
                "content": "**Example:**\\n\\n```\\ninput = {1, 2, 3, 4, 5, 6, 7}\\nk = 3\\n\\n// Expected output\\noutput = {5, 6, 7, 1, 2, 3, 4}\\n\\n// Step 1: Reverse the entire array\\n{7, 6, 5, 4, 3, 2, 1}\\n// Step 2: Reverse 0 to k-1 elements\\n{5, 6, 7, 4, 3, 2, 1}\\n \\\\____/\\n// Step 3: Reverse from k to n-1 elements\\n{5, 6, 7, 1, 2, 3, 4}\\n           \\\\______/\\n```\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        if (k == 0) return; // Rotated array will be same as original array\\n        reverse(0, nums.length-1, nums);\\n        reverse(0, k-1, nums);\\n        reverse(k, nums.length-1, nums);\\n    }\\n    \\n    private void reverse(int start, int end, int[] nums){        \\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start++] = nums[end];\\n            nums[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ninput = {1, 2, 3, 4, 5, 6, 7}\\nk = 3\\n\\n// Expected output\\noutput = {5, 6, 7, 1, 2, 3, 4}\\n\\n// Step 1: Reverse the entire array\\n{7, 6, 5, 4, 3, 2, 1}\\n// Step 2: Reverse 0 to k-1 elements\\n{5, 6, 7, 4, 3, 2, 1}\\n \\\\____/\\n// Step 3: Reverse from k to n-1 elements\\n{5, 6, 7, 1, 2, 3, 4}\\n           \\\\______/\\n```\n```java\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        if (k == 0) return; // Rotated array will be same as original array\\n        reverse(0, nums.length-1, nums);\\n        reverse(0, k-1, nums);\\n        reverse(k, nums.length-1, nums);\\n    }\\n    \\n    private void reverse(int start, int end, int[] nums){        \\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start++] = nums[end];\\n            nums[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54353,
                "title": "straight-forward-python-code-use-slice",
                "content": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n        k %= len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n        k %= len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]",
                "codeTag": "Java"
            },
            {
                "id": 1729862,
                "title": "c-java-simple-and-clean-very-efficient-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    void reverse_range(vector<int>& nums, int i, int j) {\\n        while (i < j)\\n            swap(nums[i++], nums[j--]);\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if (nums.size() <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.size()-1);\\n        reverse_range(nums, k, nums.size()-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n};\\n```\\n****\\n**Java:**\\n```\\nclass Solution {\\n    void reverse_range(int[] nums, int i, int j) {\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        if (nums.length <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.length-1);\\n        reverse_range(nums, k, nums.length-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse_range(vector<int>& nums, int i, int j) {\\n        while (i < j)\\n            swap(nums[i++], nums[j--]);\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        if (nums.size() <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.size()-1);\\n        reverse_range(nums, k, nums.size()-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void reverse_range(int[] nums, int i, int j) {\\n        while (i < j) {\\n            int temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        if (nums.length <= 1) return;\\n        \\n        reverse_range(nums, 0, nums.length-1);\\n        reverse_range(nums, k, nums.length-1);\\n        reverse_range(nums, 0, k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631131,
                "title": "javascript-simple-solution-3-lines",
                "content": "```\\nvar rotate = function (nums, k) {\\n  k %= nums.length;\\n  nums.unshift(...nums.splice(nums.length - k));\\n  return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n  k %= nums.length;\\n  nums.unshift(...nums.splice(nums.length - k));\\n  return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 895335,
                "title": "c-o-1-space-simple-and-easy-to-understand-o-n-time",
                "content": "Please ask in comments if you face any problem in undestanding.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums.end()-k,nums.end()); //reverse nums[n-k] to nums[n-1]\\n        reverse(nums.begin(),nums.end()-k); //reverse nums[0] to nums[n-k-1]\\n        reverse(nums.begin(),nums.end());  //reverse complete array\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums.end()-k,nums.end()); //reverse nums[n-k] to nums[n-1]\\n        reverse(nums.begin(),nums.end()-k); //reverse nums[0] to nums[n-k-1]\\n        reverse(nums.begin(),nums.end());  //reverse complete array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54650,
                "title": "simple-c-solution-with-detail-explain-and-o-1-extra-space",
                "content": "     /**\\n     * this solution is so-called three times rotate method\\n     * because (X^TY^T)^T = YX, so we can perform rotate operation three times to get the result\\n     * obviously, the algorithm consumes O(1) space and O(n) time\\n     **/\\n    class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k %= n; // if k > n then the final result is the same as k%n\\n            reverseArray(nums, n-k, n-1);\\n            reverseArray(nums, 0, n-k-1);\\n            reverseArray(nums, 0, n-1);\\n            \\n        }\\n        /**\\n         * rotate the array nums from start to end\\n        **/\\n        void reverseArray(int nums[],int start, int end){\\n            while(start < end){\\n                int temp = nums[start];\\n                nums[start++] = nums[end];\\n                nums[end--] = temp;\\n                // or you can simply code as \"std::swap(nums[start++], nums[end--])\" to replace above three lines\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void rotate(int nums[], int n, int k) {\\n            k %= n; // if k > n then the final result is the same as k%n\\n            reverseArray(nums, n-k, n-1);\\n            reverseArray(nums, 0, n-k-1);\\n            reverseArray(nums, 0, n-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54520,
                "title": "java-solution-with-o-1-space",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return;\\n            }\\n            k = k % nums.length;\\n            reverse(nums, 0, nums.length-k-1);\\n            reverse(nums, nums.length-k, nums.length-1);\\n            reverse(nums, 0, nums.length-1);\\n        }\\n        private void reverse(int[] num, int left, int right) {\\n            while (left < right) {\\n                int t = num[left];\\n                num[left] = num[right];\\n                num[right] = t;\\n                left++;\\n                right--;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            if (nums == null || nums.length == 0) {\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3754681,
                "title": "c-o-n-swapping",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int> &a, int i, int j){\\n        while(i<j){\\n            swap(a[i],a[j]);\\n            i++, j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int> &a, int k) {\\n        int n=a.size();   \\n        \\n        k%=n;\\n        if(k<0) k += n;\\n        \\n        reverse(a,0,n-1);\\n        reverse(a,0,k-1);\\n        reverse(a,k,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void reverse(vector<int> &a, int i, int j){\\n        while(i<j){\\n            swap(a[i],a[j]);\\n            i++, j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int> &a, int k) {\\n        int n=a.size();   \\n        \\n        k%=n;\\n        if(k<0) k += n;\\n        \\n        reverse(a,0,n-1);\\n        reverse(a,0,k-1);\\n        reverse(a,k,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728190,
                "title": "brute-optimized-logic-explained-time-complexity-o-n",
                "content": "# Intuition\\nSuppose the question was to rotate right by one place,\\neg: [1,2,3,4,5]  k=1\\n    then we would have:\\n   1. stored the last element in some temporary variable .\\n   2. shifted all the elements to the right-->nums[i]=nums[i-1].\\n   3. finally,put the temporary variable in the first index -->nums[0]=temp.\\n\\nwe will the same logic to solve this problem\\n\\n# Approach\\n- observe carefully and try to compare the problem with the above one\\n- store the last \\'k\\' elements in some temporary array\\n- now start shifting the \\'n-k\\' elements to the end\\n- finally place the temporary array to the beginning \\'k\\' positions.\\n- it might be confusing at first but trying doing it in pen and paper \\n\\n           \\n\\n\\n# Complexity\\n- Time complexity:\\n  This solution takes linear time complexity ->O(n)\\n\\n- Space complexity:\\n  We are using an extra temp array , hence \\n  space complexity ->O(n) , where n is the size of the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         k=k%n;\\n\\n        vector<int>temp(k);\\n   \\n        int i=0;\\n        for(int j=n-k;j<n;j++){  \\n            temp[i]=nums[j];  \\n            i++;\\n        }\\n\\n        i=n-1;  \\n        for(int j=n-k-1;j>=0;j--){\\n            nums[i]=nums[j];\\n            i--; \\n        }\\n        \\n       for(int j=0;j<=i;j++){    \\n           nums[j]=temp[j];      \\n                                  \\n        }\\n\\n    }\\n};\\n\\n<!-- DRY RUN\\n\\neg: [1,2,3,4,5,6,7]  ; k=3\\nj=4 (n-k) \\n\\ntemp=[5,6,7]\\n\\ni=6;\\n\\n[1,2,3,4,5,6,7]  \\n\\nnums[6]=nums[3]---->[1,2,3,4,5,6,4]\\nnums[5]=nums[2]---->[1,2,3,4,5,3,4]\\nnums[4]=nums[1]---->[1,2,3,4,2,3,4]\\nnums[3]=nums[0]---->[1,2,3,1,2,3,4]\\n\\n\\ni=2;   \\n\\nnums[0]=temp[0]---->[5,2,3,1,2,3,4]  \\nnums[1]=temp[1]---->[5,6,3,1,2,3,4] \\nnums[2]=temp[2]---->[5,6,7,1,2,3,4] \\n\\n\\n```\\n\\n# Without using extra space \\n- It is purely based on observation and if asked in any interview first tell the above solution. \\n- Reverse the complete array\\n- Then , reverse the first k elements.\\n- Finally , reverse the last n-k elements\\n- eg:  [1,2,3,4,5,6,7] k=3\\nI.   [7,6,5,4,3,2,1]\\nII.  [5,6,7,4,3,2,1]\\nIII. [5,6,7,1,2,3,4]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int l=nums.size();\\n        k%=l;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());      \\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n         int n=nums.size();\\n         k=k%n;\\n\\n        vector<int>temp(k);\\n   \\n        int i=0;\\n        for(int j=n-k;j<n;j++){  \\n            temp[i]=nums[j];  \\n            i++;\\n        }\\n\\n        i=n-1;  \\n        for(int j=n-k-1;j>=0;j--){\\n            nums[i]=nums[j];\\n            i--; \\n        }\\n        \\n       for(int j=0;j<=i;j++){    \\n           nums[j]=temp[j];      \\n                                  \\n        }\\n\\n    }\\n};\\n\\n<!-- DRY RUN\\n\\neg: [1,2,3,4,5,6,7]  ; k=3\\nj=4 (n-k) \\n\\ntemp=[5,6,7]\\n\\ni=6;\\n\\n[1,2,3,4,5,6,7]  \\n\\nnums[6]=nums[3]---->[1,2,3,4,5,6,4]\\nnums[5]=nums[2]---->[1,2,3,4,5,3,4]\\nnums[4]=nums[1]---->[1,2,3,4,2,3,4]\\nnums[3]=nums[0]---->[1,2,3,1,2,3,4]\\n\\n\\ni=2;   \\n\\nnums[0]=temp[0]---->[5,2,3,1,2,3,4]  \\nnums[1]=temp[1]---->[5,6,3,1,2,3,4] \\nnums[2]=temp[2]---->[5,6,7,1,2,3,4] \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452201,
                "title": "95-solution-with-easiest-explanation",
                "content": "the first solution which usually come to our mind is remove the last item, then add it at first. like this: \\n\\n```\\nvar rotate = function(nums, k) {\\n\\tfor(let i = 0; i<k; i++){\\n\\t\\t nums.unshift(nums.pop());\\n\\t}\\n   \\n};\\n```\\nBut, it has some time issue.\\n\\nThe alternative solution is using remainder. if k is less then the length of nums array, then it will remove k elements from the end, and add those at first. but, if k is greater than the length of nums array, then only the remainder of k % nums.length will be removed from the last and those will be added at the first. As a example ; if k is 2 and nums.length is 3, then 2 element will be removed from the end and those will be add at the first. this will be same as if we rotate 2 times. \\n\\nbut, if length is 2 but k is 3, and if we then rotate the array 3 times in pen and paper, we will see that after final rotation the scene will be like - only 1 element removed from the end and added at first. here 1 is the remainder of k % nums.length. This will be the case everytime whenever k is greater than nums.length. So the final solution will be- \\n\\n\\n\\n```\\nvar rotate = function(nums, k) {\\n    return nums.unshift(...nums.splice(-k % nums.length));\\n};\\n```\\n\\nhere, by using splice we remove the element from the last, splice gives us an array output. thats why we using spread operator while we wanna unshift all element which we spliced from the end.",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n\\tfor(let i = 0; i<k; i++){\\n\\t\\t nums.unshift(nums.pop());\\n\\t}\\n   \\n};\\n```\n```\\nvar rotate = function(nums, k) {\\n    return nums.unshift(...nums.splice(-k % nums.length));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906033,
                "title": "using-simple-swapping-with-explanation-0ms-100-faster",
                "content": "Click UP ARROW if you like the solution.\\nCheck profile if you wanna connect on Twitter\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        fum(nums, 0, nums.length-1);     //rotating array in [7,6,5,4,3,2,1].\\n        fum(nums, 0, k-1);                   //rotating array in [5,6,7,4,3,2,1].\\n        fum(nums,k,nums.length-1);     //rotating array in [5,6,7,1,2,3,4].\\n    }\\n    private void fum(int[] nums, int left , int right){\\n        while(left< right){                              // while loop for checking the indexes.\\n            int temp = nums[left];                          \\n            nums[left] = nums[right];             // simple swapping between array elements.\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        fum(nums, 0, nums.length-1);     //rotating array in [7,6,5,4,3,2,1].\\n        fum(nums, 0, k-1);                   //rotating array in [5,6,7,4,3,2,1].\\n        fum(nums,k,nums.length-1);     //rotating array in [5,6,7,1,2,3,4].\\n    }\\n    private void fum(int[] nums, int left , int right){\\n        while(left< right){                              // while loop for checking the indexes.\\n            int temp = nums[left];                          \\n            nums[left] = nums[right];             // simple swapping between array elements.\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557491,
                "title": "c-solutions",
                "content": "**Approach 1: Reverse (preferred)**\\n**Intuition**\\nMove the last ```k``` numbers to the front, and first ```n-k``` numbers to the end. But relative order of the two parts won\\'t change.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ca3ec7f3-6bfe-4c05-bf9a-aeeab79049ae_1631468229.9639452.png)\\n\\n**Complexity**\\n- time: O(n). Each number will be moved twice, O(2n) = O(n).\\n- space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        if(nums == null || nums.Length < 2)\\n            return;\\n        \\n        k %= nums.Length;        \\n        Reverse(nums, 0, nums.Length - 1);\\n        Reverse(nums, 0, k - 1);\\n        Reverse(nums, k, nums.Length - 1); \\n    }\\n    \\n    public void Reverse(int[] nums, int left, int right)\\n    {\\n        while(left < right)\\n        {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n</br></br></br>\\n**Approach 2: Extra Space**\\n**Intuition**\\nUse additional space to move ```nums[i]``` to ```arr[(i+k)%n]```\\n\\n**Complexity**\\n* Time: O(n)\\n* Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0 || k == 0)\\n            return;\\n        \\n        int n = nums.Length;\\n        int[] tmp = new int[n];\\n        for(int i = 0; i < n; i++)\\n            tmp[(i + k) % n] = nums[i];\\n        \\n         for(int i = 0; i < n; i++)\\n             nums[i] = tmp[i];\\n        \\n        // nums = (int[])tmp.Clone(); fail\\n        // Array.Copy(tmp, 0, nums, 0, n); success\\n        // Array.Copy(tmp, nums, n);       success\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```k```\n```n-k```\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        if(nums == null || nums.Length < 2)\\n            return;\\n        \\n        k %= nums.Length;        \\n        Reverse(nums, 0, nums.Length - 1);\\n        Reverse(nums, 0, k - 1);\\n        Reverse(nums, k, nums.Length - 1); \\n    }\\n    \\n    public void Reverse(int[] nums, int left, int right)\\n    {\\n        while(left < right)\\n        {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```nums[i]```\n```arr[(i+k)%n]```\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {\\n        \\n        if(nums == null || nums.Length == 0 || k == 0)\\n            return;\\n        \\n        int n = nums.Length;\\n        int[] tmp = new int[n];\\n        for(int i = 0; i < n; i++)\\n            tmp[(i + k) % n] = nums[i];\\n        \\n         for(int i = 0; i < n; i++)\\n             nums[i] = tmp[i];\\n        \\n        // nums = (int[])tmp.Clone(); fail\\n        // Array.Copy(tmp, 0, nums, 0, n); success\\n        // Array.Copy(tmp, nums, n);       success\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54659,
                "title": "one-concise-solution-with-constant-space-o-n-time-java",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n            int n = nums.length;\\n            k %= n;\\n            reverse(nums, 0, n);\\n            reverse(nums, 0, k);\\n            reverse(nums, k, n);\\n        }\\n        \\n        private void reverse(int[] nums, int s, int e) {\\n            while (s < --e) {\\n                int temp = nums[s];\\n                nums[s] = nums[e];\\n                nums[e] = temp;\\n                ++s;\\n            }\\n        }\\n    }\\n\\nAny suggestions? Thanks.",
                "solutionTags": [],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n            int n = nums.length;\\n            k %= n;\\n            reverse(nums, 0, n);\\n            reverse(nums, 0, k);\\n            reverse(nums, k, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3184255,
                "title": "the-use-of-simple-swapping-with-an-explanation-0ms-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide the array into two parts, one ranging from 0 to n-k-1 and the other ranging from n-k to n-1. Afterward, reverse the first and second parts of the array and finally reverse the entire array to obtain the result\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        flip(nums,0,n-k-1);\\n        flip(nums,n-k,n-1);\\n        flip(nums,0,n-1);\\n        \\n    }\\n    public void flip(int[] arr,int s,int e)\\n    {\\n        while(s<e)\\n        {\\n            int temp=arr[s];\\n            arr[s]=arr[e];\\n            arr[e]=temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        flip(nums,0,n-k-1);\\n        flip(nums,n-k,n-1);\\n        flip(nums,0,n-1);\\n        \\n    }\\n    public void flip(int[] arr,int s,int e)\\n    {\\n        while(s<e)\\n        {\\n            int temp=arr[s];\\n            arr[s]=arr[e];\\n            arr[e]=temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064276,
                "title": "c-o-n-easy-solution-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n ## Swaping number in array basically. please voteup \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\t \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. some people might be thinking why i am using k=k%n when k>n because there are only two possibility first is when k is divisible by \\'n\\' than no need to change-.. if it\\'s not divisible than k%n time we have to run the loop.\\n2. first you make a vector to copy the given array because if we changing  in array will affect the value of given array.That why we have to make a copy of given array.\\n3. second start changing in array nums[i]value to last \"num[n-k+i]--> which is 5 when i=0,6 -->i=1,...\".run it only  k time.for shifting of array last to first\\n4. Third loop will change remain position of array nuumber.basically for shifting of array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int>v;// making vector for copy the array in vector.\\n        int n=nums.size();\\n        if(k>nums.size()){\\n           k=k%n;// check k>n and than check it is divisible by n or not.\\n       }\\n        for(int i=0;i<n;i++){\\n           v.push_back(nums[i]);// puting nums value to vector..\\n        }\\n       for(int i=0;i<k;i++){\\n           nums[i]=v[n-k+i];// puting value of vector into nums..i explained it above..\\n        }\\n        for(int i=0;i<n-k;i++){ \\n            nums[k+i]=v[i];// here we will changing  all value (n-k time)of nums array after runing k time. for shifting of array.\\n        }\\n      return ;\\n    }\\n};// ;)plzz like bro..................................>>>>>>>>>>>>>>\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int>v;// making vector for copy the array in vector.\\n        int n=nums.size();\\n        if(k>nums.size()){\\n           k=k%n;// check k>n and than check it is divisible by n or not.\\n       }\\n        for(int i=0;i<n;i++){\\n           v.push_back(nums[i]);// puting nums value to vector..\\n        }\\n       for(int i=0;i<k;i++){\\n           nums[i]=v[n-k+i];// puting value of vector into nums..i explained it above..\\n        }\\n        for(int i=0;i<n-k;i++){ \\n            nums[k+i]=v[i];// here we will changing  all value (n-k time)of nums array after runing k time. for shifting of array.\\n        }\\n      return ;\\n    }\\n};// ;)plzz like bro..................................>>>>>>>>>>>>>>\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937407,
                "title": "typescript-one-line-solution",
                "content": "```typescript\\nfunction rotate(nums: number[], k: number): void {\\n  nums.unshift(...nums.splice(-(k % nums.length)));\\n};\\n```\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction rotate(nums: number[], k: number): void {\\n  nums.unshift(...nums.splice(-(k % nums.length)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729976,
                "title": "c-o-n-gcd",
                "content": "# 1. Observation of how gcd(n,k) cases related to array rotation.\\nFrom the following observation ,  we know that rorate can seperate into gcd(n,k) cases.\\nJust let me say that we can process in different rows. \\n```\\n    //[0,1,2,3,4,5,6] steps 3\\u3000gcd(7,3) = 1\\n    //0,3,6,2,5,1,4,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 4  gcd(8,4)=4\\n    //0,4,\\n    //1,5,\\n    //2,6,\\n    //3,7,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 2  gcd(8,2) = 2\\n    //0,2,4,6,\\n    //1,3,5,7,\\n    \\n    //[0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,\\n    //1,4,7,10,\\n    //2,5,8,11,\\n```\\n\\nFor each row, we can process its rorated move. \\nFor example\\n```\\n    [0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,  -> 9,0,3,6  \\\\\\n    //1,4,7,10  ->10,1 4,7   -=> [9,10,11,0,1,2,3,4,5,6,7,8]\\t\\n    //2,5,8,11 -> 11,2,5,8  / \\n```\\n\\n# 2. rotate array by two temp variable.\\nAnother tool is the way to make rorate move. \\nMy idea of rorated move is by using two temp values. \\nFor example of rorated move from  A={2,5,8,11} to A={11,2,5,8}. \\nI the following explantation, I use notation A\\'[0] to mean original A[0]. \\nSo whatever A have been changed, It\\'s still that A\\'[0] =2, A\\'[1]=5. A\\'[2]=8. A\\'[3]=11\\nThe following is showing how two temp variable can make help rorated move. \\n```  \\nprev_temp=NA\\ntemp=2\\nA is {2,5, 8,11}\\n```\\n```\\nprev_temp=2 //(A\\'[0])\\ntemp=5  //(A\\'[1])\\nA[1] = 2 ->  A is {2,2,8,11}\\n```\\n```\\nprev_temp=5 //(A\\'[1])\\ntemp=8  //(A\\'[2])      \\nA[2] = 5 ->  A is {2,2,5,11}\\n```\\n```\\nprev_temp=8 //(A\\'[2])      \\ntemp=11 //(A\\'[3])      \\nA[3] = 8 ->  A is {2,2,5,8}\\n```\\n```\\nprev_temp=11 //(A\\'[3])      \\ntemp=2 //(A\\'[0])      \\nA[0] = 11 ->  A is {11,2,5,8}\\n```\\n\\n\\n# 3. outcome of solution\\nFrom the observation to seperate row and the idea of rorated move by two temp variable, \\nwe can implment the following solution.\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n\\t\\t\\t//seperate into gcd(n,k) rows cases\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n\\t\\t\\t\\t//Make a rorated move for each row by two temp\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    //[0,1,2,3,4,5,6] steps 3\\u3000gcd(7,3) = 1\\n    //0,3,6,2,5,1,4,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 4  gcd(8,4)=4\\n    //0,4,\\n    //1,5,\\n    //2,6,\\n    //3,7,\\n    \\n    //[0,1,2,3,4,5,6,7] steps 2  gcd(8,2) = 2\\n    //0,2,4,6,\\n    //1,3,5,7,\\n    \\n    //[0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,\\n    //1,4,7,10,\\n    //2,5,8,11,\\n```\n```\\n    [0,1,2,3,4,5,6,7,8,9,10,11] step 3   gcd(12,3) = 3\\n    //0,3,6,9,  -> 9,0,3,6  \\\\\\n    //1,4,7,10  ->10,1 4,7   -=> [9,10,11,0,1,2,3,4,5,6,7,8]\\t\\n    //2,5,8,11 -> 11,2,5,8  / \\n```\n```  \\nprev_temp=NA\\ntemp=2\\nA is {2,5, 8,11}\\n```\n```\\nprev_temp=2 //(A\\'[0])\\ntemp=5  //(A\\'[1])\\nA[1] = 2 ->  A is {2,2,8,11}\\n```\n```\\nprev_temp=5 //(A\\'[1])\\ntemp=8  //(A\\'[2])      \\nA[2] = 5 ->  A is {2,2,5,11}\\n```\n```\\nprev_temp=8 //(A\\'[2])      \\ntemp=11 //(A\\'[3])      \\nA[3] = 8 ->  A is {2,2,5,8}\\n```\n```\\nprev_temp=11 //(A\\'[3])      \\ntemp=2 //(A\\'[0])      \\nA[0] = 11 ->  A is {11,2,5,8}\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n\\t\\t\\t//seperate into gcd(n,k) rows cases\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n\\t\\t\\t\\t//Make a rorated move for each row by two temp\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54564,
                "title": "python-easy-to-understand-solutions",
                "content": "        \\n    def rotate1(self, nums, k):\\n        k %= len(nums)\\n        self.reverse(nums, 0, len(nums)-1)\\n        self.reverse(nums, 0, k-1)\\n        self.reverse(nums, k, len(nums)-1)\\n        \\n    def reverse(self, nums, l, r):\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l += 1\\n            r -= 1\\n            \\n    def rotate2(self, nums, k):\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            nums.insert(0, nums.pop())\\n     \\n    # O(n) space       \\n    def rotate(self, nums, k):\\n        deque = collections.deque(nums)\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            deque.appendleft(deque.pop())\\n        nums[:] = list(deque)",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def rotate1(self, nums, k):\\n        k %= len(nums)\\n        self.reverse(nums, 0, len(nums)-1)\\n        self.reverse(nums, 0, k-1)\\n        self.reverse(nums, k, len(nums)-1)\\n        \\n    def reverse(self, nums, l, r):\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l += 1\\n            r -= 1\\n            \\n    def rotate2(self, nums, k):\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            nums.insert(0, nums.pop())\\n     \\n    # O(n) space       \\n    def rotate(self, nums, k):\\n        deque = collections.deque(nums)\\n        k %= len(nums)\\n        for _ in xrange(k):\\n            deque.appendleft(deque.pop())\\n        nums[:] = list(deque)",
                "codeTag": "Python3"
            },
            {
                "id": 54602,
                "title": "accepted-java-solution-with-o-1-space-and-o-n-time",
                "content": "  \\n\\n    public void rotate(int[] nums, int k) {\\n         \\n        if (k >nums.length){\\n            k = k%nums.length;\\n         }\\n        int end = nums.length;\\n        \\n        nums = reverse(nums,0,end-k-1);\\n        nums = reverse(nums,end-k,end-1);\\n        nums = reverse(nums,0,end-1);\\n     }\\n        \\n        private int[] reverse(int[] nums, int start, int end){\\n           \\n           while(start<end){\\n           int temp = nums[start];\\n           nums[start] = nums[end];\\n           nums[end] = temp;\\n           start++; end--;\\n           }\\n           return nums;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "  \\n\\n    public void rotate(int[] nums, int k) {\\n         \\n        if (k >nums.length){\\n            k = k%nums.length;\\n         }\\n        int end = nums.length;\\n        \\n        nums = reverse(nums,0,end-k-1);\\n        nums = reverse(nums,end-k,end-1);\\n        nums = reverse(nums,0,end-1);\\n     }\\n        \\n        private int[] reverse(int[] nums, int start, int end){\\n           \\n           while(start<end){\\n           int temp = nums[start];\\n           nums[start] = nums[end];\\n           nums[end] = temp;\\n           start++; end--;\\n           }\\n           return nums;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3826786,
                "title": "1-line-in-c-optimized-solution-using-inbuilt-function",
                "content": "# Intuition\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k= k%nums.size();\\n    std::rotate(nums.begin(), nums.begin()+nums.size()-k, nums.end());  \\n    }\\n};\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![upvote1.gif](https://assets.leetcode.com/users/images/73a3f1a5-c0ba-4c88-9276-144642d7fc29_1690519094.3517249.gif)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k= k%nums.size();\\n    std::rotate(nums.begin(), nums.begin()+nums.size()-k, nums.end());  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758175,
                "title": "java-0ms-100-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n       k %= nums.length;\\n       reverse(nums, 0, nums.length - 1); // Reverse the entire array\\n       reverse(nums, 0, k - 1); // Reverse the first k elements\\n       reverse(nums, k, nums.length - 1); // Reverse the rest of the elements\\n    }\\n    public static void reverse(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start ++;\\n            end --;\\n        }\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n       k %= nums.length;\\n       reverse(nums, 0, nums.length - 1); // Reverse the entire array\\n       reverse(nums, 0, k - 1); // Reverse the first k elements\\n       reverse(nums, k, nums.length - 1); // Reverse the rest of the elements\\n    }\\n    public static void reverse(int[] nums, int start, int end) {\\n        while(start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start ++;\\n            end --;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186609,
                "title": "python-clean-simple-o-n-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here we are reversing array 3 times. \\n1. from the start to the n - k - 1 index \\n2. from n - k to end of the array\\n3. Reversing whole array\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, arr: List[int], k: int) -> None:\\n        n = len(arr)\\n        k = k % n                 \\n# Here reminder is taken because if we had 10 rotation but our array is of size 9 then only 1 rotation is effective to produce ans.\\n\\n        arr[n - k:] = arr[n - k:][::-1] # Reverse n - k to end of the array \\n        arr[:n - k] = arr[:n - k][::-1] # Reverse 0 to n - k  \\n        arr[:] = arr[::-1]              # Reverse whole array\\n\\n```\\nWe can do above 3 steps in 1 step using python list slicing\\n\\n```\\narr[:] = arr[n - k:] + arr[:n - k]\\n```\\n\\nCan\\'t be written as \\n\\n```\\narr = arr[n - k:] + arr[:n - k]\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, arr: List[int], k: int) -> None:\\n        n = len(arr)\\n        k = k % n                 \\n# Here reminder is taken because if we had 10 rotation but our array is of size 9 then only 1 rotation is effective to produce ans.\\n\\n        arr[n - k:] = arr[n - k:][::-1] # Reverse n - k to end of the array \\n        arr[:n - k] = arr[:n - k][::-1] # Reverse 0 to n - k  \\n        arr[:] = arr[::-1]              # Reverse whole array\\n\\n```\n```\\narr[:] = arr[n - k:] + arr[:n - k]\\n```\n```\\narr = arr[n - k:] + arr[:n - k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668087,
                "title": "c-4-different-solutions-highly-commented-and-explained",
                "content": "```\\n/*\\n* o(n)\\n* This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. \\n* Do a dry run by taking an example on copy and you will usndersand it. \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k%nums.size());\\n        reverse(nums.begin()+k%nums.size(),nums.begin()+nums.size());\\n    }\\n};\\n\\n// o(n) Same as above but without using inbuilt function.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        reverse(nums.begin(),nums.end());\\n        int i=0,j=k-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n        i=k,j=nums.size()-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n    }\\n};\\n\\n/*\\n* o(n) \\n* Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and \\n* we then pushback the reaining elements in the temp vector from index 0 to n-k-1; \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        vector<int> temp;\\n        int n = nums.size() - k;\\n        for(int i=n ; i<nums.size();i++)temp.push_back(nums[i]);\\n        for(int i=0;i<n;i++) temp.push_back(nums[i]);\\n        nums = temp;\\n\\n    }\\n};\\n\\n// o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.\\n// TLE\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k){\\n        int i, j, tmp,n = nums.size();\\n        k%=n;\\n        if (n==k) return;\\n        for(i=n-1; i>=n-k; i--) {\\n            tmp = nums[n-1];\\n            for (j=n-1;j>0;j--)nums[j] = nums[j-1];\\n            nums[0] = tmp;\\n        }   \\n    }\\n};\\n```\\n\\n***Do upvote if you like my solutions & explanation :)***\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n* o(n)\\n* This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. \\n* Do a dry run by taking an example on copy and you will usndersand it. \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k%nums.size());\\n        reverse(nums.begin()+k%nums.size(),nums.begin()+nums.size());\\n    }\\n};\\n\\n// o(n) Same as above but without using inbuilt function.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        reverse(nums.begin(),nums.end());\\n        int i=0,j=k-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n        i=k,j=nums.size()-1;\\n        while(i<j) swap(nums[i++],nums[j--]);\\n    }\\n};\\n\\n/*\\n* o(n) \\n* Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and \\n* we then pushback the reaining elements in the temp vector from index 0 to n-k-1; \\n*/\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        vector<int> temp;\\n        int n = nums.size() - k;\\n        for(int i=n ; i<nums.size();i++)temp.push_back(nums[i]);\\n        for(int i=0;i<n;i++) temp.push_back(nums[i]);\\n        nums = temp;\\n\\n    }\\n};\\n\\n// o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.\\n// TLE\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k){\\n        int i, j, tmp,n = nums.size();\\n        k%=n;\\n        if (n==k) return;\\n        for(i=n-1; i>=n-k; i--) {\\n            tmp = nums[n-1];\\n            for (j=n-1;j>0;j--)nums[j] = nums[j-1];\\n            nums[0] = tmp;\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917709,
                "title": "c-o-1-space-o-n-time",
                "content": "Step 1: reverse the whole array.\\nStep 2: reverse the elements from starting of the array till the kth element.\\nStep 3: reverse the elements from the kth element till the end of the array.\\n\\nFor example:\\nlet the array be arr = [1,2,3,4,5] and k = 2\\ntherefore the result  array should be arr = [4,5,1,2,3]\\n\\nStep 1: reverse the whole array\\narr = [5,4,3,2,1]\\nStep 2: reverse from 0 to k\\narr = [4,5,3,2,1]\\nStep 3: reverse from k to n\\narr = [4,5,1,2,3]\\n\\n```class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n\\t\\t//remove redundant k values  and shorten k\\n        k = k % nums.size();\\n        \\n\\t\\t//reverse the array from starting to end\\n        reverse(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t//reverse from starting till kth element\\n        reverse(nums.begin(), nums.begin()+k);\\n\\t\\t\\n\\t\\t//reverse from kth till last element\\n        reverse(nums.begin()+k, nums.end());\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n\\t\\t//remove redundant k values  and shorten k\\n        k = k % nums.size();\\n        \\n\\t\\t//reverse the array from starting to end\\n        reverse(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t//reverse from starting till kth element\\n        reverse(nums.begin(), nums.begin()+k);\\n\\t\\t\\n\\t\\t//reverse from kth till last element\\n        reverse(nums.begin()+k, nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817326,
                "title": "java-explained-time-o-n-space-o-1-runtime-0-ms-100-faster",
                "content": "# **Please upvote if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n  /***\\n     * To do the in place rotation i.e. with O(1) space complexity we need to follow the below steps\\n     *\\n     * Step-1 : Divide the Array into two part and the division should be from right side / end.\\n     *          like for arr = [1, 2, 3, 4, 5]  and k = 2 we need to divide the array into two part\\n     *          arr = [1, 2, 3   ##   4, 5]   (k position from right)\\n     *          i.e. Part-1 : [1, 2. 3]  part-2 : [4, 5]\\n     *\\n     *  Step-2 : Reverse the above part individually, so post reversal it should be something like below\\n     *           arr = [3, 2, 1   ##   5, 4]\\n     *\\n     *  Step-3 : Now reverse the whole array, so post reversal it should be something like below\\n     *           arr = [4, 5, 1, 2, 3]  which is the intended output\\n     */\\n    public void rotate(int[] nums, int k) {\\n\\n        /**\\n         *\\n         * For a given array of length N if we will rotate it N times the initial and final array will be same\\n         * like for arr = [1, 2, 3, 4, 5]\\n         * Rotate-1 :  [5, 1, 2, 3, 4]  -> Rotate-2 :  [4, 5, 1, 2, 3]   ...   Rotate-5 :  [1, 2, 3, 4, 5]\\n         *\\n         * So, If k is greater than length of the array, then we can say (k % nums.length) value time rotation state will\\n         * be the final state of the array.\\n         */\\n        if (k > nums.length) {\\n            k = k % nums.length;\\n        }\\n\\n        /**\\n         *   As per the problem statement below check is not required as value of k is 0 <= k <= 105\\n         *\\n         *   Constraints:\\n         *      1 <= nums.length <= 105\\n         *      -231 <= nums[i] <= 231 - 1\\n         *      0 <= k <= 105\\n         */\\n\\n\\n        /***\\n         * If value of k is negative and for all -ve value it should rotate left wise\\n         * Like arr = [1, 2, 3, 4, 5]  and k = -1 the final array should be arr : [2, 3, 4, 5, 1]\\n         *\\n         * Now to handle this kind of -ve cases, lets analyze the rotation\\n         *          arr = [1, 2, 3, 4, 5]\\n         *\\n         *  Rotation  -2 :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  -1 :  [2, 3, 4, 5, 1]      ****\\n         *  Rotation  0  :  [1, 2, 3, 4, 5]\\n         *  Rotation  1  :  [5, 1, 2, 3, 4]\\n         *  Rotation  2  :  [4, 5, 1, 2, 3]\\n         *  Rotation  3  :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  4  :  [2, 3, 4, 5, 1]     ****\\n         *  Rotation  5  :  [1, 2, 3, 4, 5]\\n         *\\n         *  Now if we will see Rotation for -1 and 4 is same or -2 and 3 is also same.\\n         *  So, we can say -k rotation is equivalent to -k + array length position\\n         */\\n//        if (k < 0) {\\n//            k = k + nums.length;\\n//        }\\n\\n\\n        // Step-1 : Divide the Array into two part\\n        int numsLength = nums.length - 1;\\n        int dividePosition = numsLength - k;\\n\\n        //Step-2 : Reverse the above part individually\\n        reverse(0, dividePosition, nums);\\n        reverse(dividePosition + 1, numsLength, nums);\\n\\n        //Step-3 : Now reverse the whole array\\n        reverse(0, numsLength, nums);\\n    }\\n\\n    private void reverse(int start, int end, int[] nums) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n  /***\\n     * To do the in place rotation i.e. with O(1) space complexity we need to follow the below steps\\n     *\\n     * Step-1 : Divide the Array into two part and the division should be from right side / end.\\n     *          like for arr = [1, 2, 3, 4, 5]  and k = 2 we need to divide the array into two part\\n     *          arr = [1, 2, 3   ##   4, 5]   (k position from right)\\n     *          i.e. Part-1 : [1, 2. 3]  part-2 : [4, 5]\\n     *\\n     *  Step-2 : Reverse the above part individually, so post reversal it should be something like below\\n     *           arr = [3, 2, 1   ##   5, 4]\\n     *\\n     *  Step-3 : Now reverse the whole array, so post reversal it should be something like below\\n     *           arr = [4, 5, 1, 2, 3]  which is the intended output\\n     */\\n    public void rotate(int[] nums, int k) {\\n\\n        /**\\n         *\\n         * For a given array of length N if we will rotate it N times the initial and final array will be same\\n         * like for arr = [1, 2, 3, 4, 5]\\n         * Rotate-1 :  [5, 1, 2, 3, 4]  -> Rotate-2 :  [4, 5, 1, 2, 3]   ...   Rotate-5 :  [1, 2, 3, 4, 5]\\n         *\\n         * So, If k is greater than length of the array, then we can say (k % nums.length) value time rotation state will\\n         * be the final state of the array.\\n         */\\n        if (k > nums.length) {\\n            k = k % nums.length;\\n        }\\n\\n        /**\\n         *   As per the problem statement below check is not required as value of k is 0 <= k <= 105\\n         *\\n         *   Constraints:\\n         *      1 <= nums.length <= 105\\n         *      -231 <= nums[i] <= 231 - 1\\n         *      0 <= k <= 105\\n         */\\n\\n\\n        /***\\n         * If value of k is negative and for all -ve value it should rotate left wise\\n         * Like arr = [1, 2, 3, 4, 5]  and k = -1 the final array should be arr : [2, 3, 4, 5, 1]\\n         *\\n         * Now to handle this kind of -ve cases, lets analyze the rotation\\n         *          arr = [1, 2, 3, 4, 5]\\n         *\\n         *  Rotation  -2 :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  -1 :  [2, 3, 4, 5, 1]      ****\\n         *  Rotation  0  :  [1, 2, 3, 4, 5]\\n         *  Rotation  1  :  [5, 1, 2, 3, 4]\\n         *  Rotation  2  :  [4, 5, 1, 2, 3]\\n         *  Rotation  3  :  [3, 4, 5, 1, 2]   ###\\n         *  Rotation  4  :  [2, 3, 4, 5, 1]     ****\\n         *  Rotation  5  :  [1, 2, 3, 4, 5]\\n         *\\n         *  Now if we will see Rotation for -1 and 4 is same or -2 and 3 is also same.\\n         *  So, we can say -k rotation is equivalent to -k + array length position\\n         */\\n//        if (k < 0) {\\n//            k = k + nums.length;\\n//        }\\n\\n\\n        // Step-1 : Divide the Array into two part\\n        int numsLength = nums.length - 1;\\n        int dividePosition = numsLength - k;\\n\\n        //Step-2 : Reverse the above part individually\\n        reverse(0, dividePosition, nums);\\n        reverse(dividePosition + 1, numsLength, nums);\\n\\n        //Step-3 : Now reverse the whole array\\n        reverse(0, numsLength, nums);\\n    }\\n\\n    private void reverse(int start, int end, int[] nums) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683382,
                "title": "c-o-1-space-and-o-n-time-3-step-solution",
                "content": "Let n = size of array\\n\\n3 step solution:\\n- Reverse 1st half of array i.e 0 to n-k-1\\n- Reverse 2nd half of array i.e n-k to n-1\\n- Then reverse full array i.e 0 to n-k\\n\\nAfter 3rd step we\\'ll get our rotated array\\n\\n![image](https://assets.leetcode.com/users/images/36bc86e5-10a3-411c-afd5-495cc80caebb_1641922898.1235006.png)\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k - (k/nums.size())*nums.size();\\n        reverse(nums, 0,nums.size()-k-1);\\n        reverse(nums, nums.size()-k ,nums.size()-1);\\n        reverse(nums,0,nums.size()-1);\\n    }\\n    void reverse(vector<int>& nums, int low, int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k - (k/nums.size())*nums.size();\\n        reverse(nums, 0,nums.size()-k-1);\\n        reverse(nums, nums.size()-k ,nums.size()-1);\\n        reverse(nums,0,nums.size()-1);\\n    }\\n    void reverse(vector<int>& nums, int low, int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468248,
                "title": "python-simple-but-optimal-solution-o-n-time-and-o-1-space",
                "content": "The idea is to first reverse the whole array, then reverse the first `k` elements and then reverse the last `n-k` elements. You end up with the rotated array. As reversing an array in-place is easily possible in linear time and constant space, the overall solution also just uses O(n) time and O(1) space. Here is the code:\\n\\n```\\ndef reverse_inplace(nums, lo, hi):\\n    while lo < hi:\\n        nums[lo], nums[hi] = nums[hi], nums[lo]\\n        lo += 1\\n        hi -= 1\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        reverse_inplace(nums, 0, len(nums) - 1)\\n        reverse_inplace(nums, 0, k - 1)\\n        reverse_inplace(nums, k, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverse_inplace(nums, lo, hi):\\n    while lo < hi:\\n        nums[lo], nums[hi] = nums[hi], nums[lo]\\n        lo += 1\\n        hi -= 1\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        reverse_inplace(nums, 0, len(nums) - 1)\\n        reverse_inplace(nums, 0, k - 1)\\n        reverse_inplace(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377847,
                "title": "python-multiple-solutions",
                "content": "# List slicing\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```\\n\\n# Temp list of size k\\n\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for idx in reversed(range(k, len(nums))):\\n            nums[idx] = nums[idx-k]\\n            \\n        for idx, num in enumerate(tmp):\\n            nums[idx] = num\\n```\\n\\n# Cyclic Replacement\\n\\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        count = 0\\n        start = 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while True:\\n                next = (current + k) % len(nums)\\n                temp = nums[next]\\n                nums[next] = prev\\n                prev = temp\\n                current = next\\n                count += 1\\n                if current == start:\\n                    break\\n            start += 1\\n```\\n\\n# List reversal\\n\\n```python\\nclass Solution:\\n    \\n    def reverse(self, nums, start, end):\\n        while (start < end):\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        self.reverse(nums, 0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        tmp = nums[-k:]\\n        for idx in reversed(range(k, len(nums))):\\n            nums[idx] = nums[idx-k]\\n            \\n        for idx, num in enumerate(tmp):\\n            nums[idx] = num\\n```\n```python\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        count = 0\\n        start = 0\\n        while count < len(nums):\\n            current = start\\n            prev = nums[start]\\n            while True:\\n                next = (current + k) % len(nums)\\n                temp = nums[next]\\n                nums[next] = prev\\n                prev = temp\\n                current = next\\n                count += 1\\n                if current == start:\\n                    break\\n            start += 1\\n```\n```python\\nclass Solution:\\n    \\n    def reverse(self, nums, start, end):\\n        while (start < end):\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        self.reverse(nums, 0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253052,
                "title": "c-solution",
                "content": "Runtime: 256 ms, faster than 93.03% of C# online submissions for Rotate Array.\\nMemory Usage: 30.6 MB, less than 10.00% of C# online submissions for Rotate Array.\\n\\n```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {       \\n        // Solution 1 -- Time: O(n), Space: O(n)\\n        int[] output = new int[nums.Length];\\n        int length = nums.Length;\\n        for(int i=0; i<nums.Length; i++) {\\n            output[(i+k) % length] = nums[i];\\n        }\\n        for(int i=0; i<nums.Length; i++) {\\n            nums[i] = output[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public void Rotate(int[] nums, int k) {       \\n        // Solution 1 -- Time: O(n), Space: O(n)\\n        int[] output = new int[nums.Length];\\n        int length = nums.Length;\\n        for(int i=0; i<nums.Length; i++) {\\n            output[(i+k) % length] = nums[i];\\n        }\\n        for(int i=0; i<nums.Length; i++) {\\n            nums[i] = output[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 54529,
                "title": "5-lines-c-using-reverse",
                "content": "        \\n    \\n       void rotate(vector<int>& nums, int k) {\\n            k%=nums.size();\\n            if(k==0 || nums.size()==0) return;\\n            reverse(nums.begin(), nums.end());\\n            reverse(nums.begin(), nums.begin()+k);\\n            reverse(nums.begin()+k, nums.end());\\n        }",
                "solutionTags": [],
                "code": "        \\n    \\n       void rotate(vector<int>& nums, int k) {\\n            k%=nums.size();\\n            if(k==0 || nums.size()==0) return;\\n            reverse(nums.begin(), nums.end());\\n            reverse(nums.begin(), nums.begin()+k);\\n            reverse(nums.begin()+k, nums.end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529657,
                "title": "a-different-way-of-thinking-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf an array consisting of `n` elements if to right-rotated by `k` positions, we can reverse the array from the beginning till the `(n-k)`th index, then again from the `(n-k)`th index to the end and finally, from the beginning to the end. This will yield the same result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssign to `k` the mod of itself with the size of the array.\\n\\nThis is done to ensure the number of operations is minimum as right-rotating an array of size 5 eight times will yield the same result as right-rotating it 8%5 = three times.\\n\\nFirst, reverse the array from the beginning till the `(n-k)`th index. Now, reverse it from the `(n-k)`th index to the end. Finally, reverse the array from the beginning to the end.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        k%=n;\\n        reverse(nums.begin(), nums.begin()+(n-k));\\n        reverse(nums.begin()+(n-k), nums.end());\\n        reverse(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        k%=n;\\n        reverse(nums.begin(), nums.begin()+(n-k));\\n        reverse(nums.begin()+(n-k), nums.end());\\n        reverse(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360421,
                "title": "three-possible-java-solution-to-rotate-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- ## ***- Time complexity:***\\n\\n---\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// public class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int[] a = new int[nums.length];\\n//         for (int i = 0; i < nums.length; i++) {\\n//             a[(i + k) % nums.length] = nums[i];\\n//         }\\n//         for (int i = 0; i < nums.length; i++) {\\n//             nums[i] = a[i];\\n//         }\\n//     }\\n// }\\n// class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int offset = k % nums.length;\\n//         reverse(nums, 0, nums.length - 1);\\n//         reverse(nums, 0, offset - 1);\\n//         reverse(nums, offset, nums.length - 1);\\n//     }\\n\\n//     public void reverse(int[] nums, int start, int end) {\\n//         while (start < end) {\\n//             int temp = nums[start];\\n//             nums[start] = nums[end];\\n//             nums[end] = temp;\\n//             start++;\\n//             end--;\\n//         }\\n//     }\\n// }$$$$O(n)$$$$\\nclass Solution{\\n    public void rotate(int[] nums,int k)\\n    {\\n        k=k%nums.length;\\n    reverse(nums,0,nums.length-1);\\n    reverse(nums,0,(k-1));\\n    reverse(nums,k,nums.length-1);\\n\\n\\n\\n    }\\n    public void reverse(int[] nums,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            start++;\\n            end--;\\n                    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// public class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int[] a = new int[nums.length];\\n//         for (int i = 0; i < nums.length; i++) {\\n//             a[(i + k) % nums.length] = nums[i];\\n//         }\\n//         for (int i = 0; i < nums.length; i++) {\\n//             nums[i] = a[i];\\n//         }\\n//     }\\n// }\\n// class Solution {\\n//     public void rotate(int[] nums, int k) {\\n//         if (nums == null || nums.length == 0) {\\n//             return;\\n//         }\\n\\n//         int offset = k % nums.length;\\n//         reverse(nums, 0, nums.length - 1);\\n//         reverse(nums, 0, offset - 1);\\n//         reverse(nums, offset, nums.length - 1);\\n//     }\\n\\n//     public void reverse(int[] nums, int start, int end) {\\n//         while (start < end) {\\n//             int temp = nums[start];\\n//             nums[start] = nums[end];\\n//             nums[end] = temp;\\n//             start++;\\n//             end--;\\n//         }\\n//     }\\n// }$$$$O(n)$$$$\\nclass Solution{\\n    public void rotate(int[] nums,int k)\\n    {\\n        k=k%nums.length;\\n    reverse(nums,0,nums.length-1);\\n    reverse(nums,0,(k-1));\\n    reverse(nums,k,nums.length-1);\\n\\n\\n\\n    }\\n    public void reverse(int[] nums,int start,int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            start++;\\n            end--;\\n                    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925114,
                "title": "3-solutions-easy-medium-hard-explained",
                "content": "There are 3 methods to solve this question:\\n1) Brute-Force Method : \\ni. Purely Brute-force, no optimization\\nii. a little optimized (but still brute-force)\\n( In either of the cases above Time Limit will exceed )\\n\\nIn the i. part we will simply rotate for k times (which is given). It is the most basic approach which will come to everyone\\'s mind at first thought. \\n\\nCode for the Above :-\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n\\n        for(int i = 1; i <= k; i++){\\n            //code for simple rotation\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n    //Note: Time Limit will Exceed\\n    }\\n};\\n```\\nNow Let\\'s think, do we really need to rotate K times? If we check carefully after rotating for a total of n times (where n is equal to length of the array) we will reach at the initial state of our array. **How?** Let\\'s take a look at the below example:\\n```\\nfor eg, array is = [1, 2, 3]\\n Let\\'s say we have to rotate the above array for 3 times\\n which is equal to the length of the array (say length is n).\\n Let\\'s rotate,\\n    First Rotation: [3, 1, 2]\\n    Second Rotation: [2, 3, 1]\\n    Third Rotation: [1, 2, 3]\\n \\n Isn\\'t the array we got after n rotations equal to our initial \\n array? So actually we did waste 3 iteration for the same task\\n which could have been done in 0 iteration, right?\\n```\\nWhich leads us to our Brute-Force ii. method:\\n```\\nHere we will only rotate for k % size of array times.\\nwhere k is the number of times given to rotate.\\n\\nLet\\'s Rotate the same array of our previous example: [1, 2, 3],\\nfor a total of 7 times, i.e, k = 7.\\n\\nFirst, Let\\'s do the same with the help of Brute-Force i. method:\\n[using r as abbreviation for rotation]\\n1st r: [3, 1, 2]\\n2nd r: [2, 3, 1]\\n3rd r: [1, 2, 3] -> see how we returned to initial state\\n4th r: [3, 1, 2]\\n5th r: [2, 3, 1]\\n6th r: [1, 2, 3] -> notice we once again reached initial state\\n7th r: [3, 1, 2]\\n\\nLet\\'s try rotating with our Brute-Force ii. method:\\ntimesToRotate = k % size => 7 % 3 = 1\\nRotating timesToRotate times now, i.e, 1 time:\\noriginal array: [1, 2, 3]\\nafter 1st r: [3, 1, 2]\\n\\nDidn\\'t we get the same array we got by using our first approach?\\nAlso we didn\\'t have to waste so many iterations with the help of a\\nsimple mod operation.\\n```\\nLet\\'s see the Code for the Above Approach:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        for(int i = 1; i <= timesToRotate; i++){\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n        //Note: Time Limit will still exceed\\n    }\\n};\\n```\\nOkay, very Well, we now know our first approach, but come to think of it, why is the time limit still exceeding? it\\'s because we are shifting the elements in the array one-by-one for a total of k times or k % size times with the help of our 1st Approach, which ultimately is a time consuming task even if we optimized it.\\nCan we do the same task in O(n) time, i.e, in a single traversal? to do so we have to understand our 2nd Approach:\\n2) We now know that we only need to rotate for t times now, lets say t = k % size by our first approach. Now what if we create a second array and directly store the corresponding elements of our main array at the proper location they should be after rotation and then copy it back to our main array. Note: The Time complexity will surely be reduced but we will have to use extra space for another array in this case.\\n\\nLet\\'s understand the above in a little more depth:\\n```\\nLet\\'s Say we have the same array: [1, 2, 3]\\nWe also create a temporary array: [0, 0, 0] <- 0 denoting no values\\n(which has the same size as the main array but is currently NULL)\\n\\nLet\\'s say k = 7,\\ntherefore t = k % size => 7 % 3 = 1\\n\\nNow, what if we store each element of first array at \\n(current index + t) % (size of array) index in our secondary \\narray.\\n\\nFor example:\\nin our main array: 1 is at index -> 0\\n                   2 is at index -> 1\\n                   3 is at index -> 2\\n\\nSo in our secondary array we should store 1 at:\\n    (index of 1 in main array + t) % size => (0 + 1) % 3 = 1\\nSo our secondary array becomes: [0, 1, 0]\\n\\nDoing the same element 2 of main array:\\n    (2s index in main array + t) % size => (1 + 1) % 3 = 2\\nSecondary array becomes: [0, 1, 2]\\n\\nDoing the same with element 3 of main array:\\n    (3s index in main array + t) % size => (2 + 1) % 3 = 0\\nSecondary array becomes: [3, 1, 2]\\nNow simply copy it to our main array.\\n\\nWhy did we have to mod the position to provide in array2 \\nby the size? it could have been done without it? Well, \\nwe did it to save ourselves from handling the edge cases when\\nindex becomes greater than size - 1 of array, which if is not\\nhandled will give us ArrayOutOfBounds kind of error.\\n\\nHere we only traversed the main array once hence Time Complexity \\nwill be = O(n),\\nand O(n) time will also be taken for copying, making the\\nTotal Complexity = O(n) + O(n) = O(n) (in general)\\n```\\nLet\\'s see the Implementation of the above code,\\n (This time it won\\'t exceed the time limit):\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            temp[(i + timesToRotate) % nums.size()] = nums[i];\\n        \\n        //copying the array\\n        for(int i = 0; i < nums.size(); i++)\\n            nums[i] = temp[i];\\n    }\\n};\\n```\\nNow, we have done the task in O(n) time, so why do we need more approaches? The reason being we took extra space in our last approach, Can we do the same task in O(n) time without using extra space? the answer is Yes we can, which brings us our 3rd Approach:\\n\\n3) Now this approach TBH is tricky and you won\\'t understand it unless you dry run it, and for your curiousity neither was I able to understand it without implementing.\\nIn this approach we will :\\n    First: Reverse the whole array.\\n    Second: Reverse from starting till t - 1 index (where t = k % length/size of array).\\n    Third: Reverse from index t till the last index of the array.\\n\\nDidn\\'t understand any of the above? Worry not, let\\'s understand in a little depth:\\n```\\nLet\\'s take our favourite array: [1, 2, 3]\\nand our favourite k, which is: 7 times\\nour t becomes: k % size of array => 7 % 3 = 1\\n\\nStep 1: Reverse the whole array:\\n    [3, 2, 1]\\nStep 2: Reverse from start (which is 0th index) till t-1 index:\\n    t = 1\\n    t - 1 = 0\\n    Reverse from 0 to 0th index, which is basically doing nothing\\n    [3, 2, 1]\\nStep 3: Reverse from index t to end of array:\\n    t = 1\\n    last index = size - 1 => 3 - 1 = 2\\n    reversing from index 1 to 2:\\n    [3, 1, 2] <- Isn\\'t this the very array we were asked to fetch?\\n\\nSo here we solved the question without using any extra space like\\nour 2nd approach.\\n```\\nNow, I have written the code in cpp which has a function which takes the parameter of both the start point of the reverse and the end point of the reverse (where the end point is not included). If you use some other language you might have to create a function to reverse which accepts both starting and ending points seperately (which is pretty easy to do) or pass your parameters of indexes a little differently than me. However, the logic remains the same as above.\\n\\nMy Cpp code for the same:\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + timesToRotate);\\n        reverse(nums.begin() + timesToRotate, nums.end());\\n\\n    }\\n};\\n```\\n> **If you read till here and found it helpful then don\\'t forget to UP VOTE**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n\\n        for(int i = 1; i <= k; i++){\\n            //code for simple rotation\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n    //Note: Time Limit will Exceed\\n    }\\n};\\n```\n```\\nfor eg, array is = [1, 2, 3]\\n Let\\'s say we have to rotate the above array for 3 times\\n which is equal to the length of the array (say length is n).\\n Let\\'s rotate,\\n    First Rotation: [3, 1, 2]\\n    Second Rotation: [2, 3, 1]\\n    Third Rotation: [1, 2, 3]\\n \\n Isn\\'t the array we got after n rotations equal to our initial \\n array? So actually we did waste 3 iteration for the same task\\n which could have been done in 0 iteration, right?\\n```\n```\\nHere we will only rotate for k % size of array times.\\nwhere k is the number of times given to rotate.\\n\\nLet\\'s Rotate the same array of our previous example: [1, 2, 3],\\nfor a total of 7 times, i.e, k = 7.\\n\\nFirst, Let\\'s do the same with the help of Brute-Force i. method:\\n[using r as abbreviation for rotation]\\n1st r: [3, 1, 2]\\n2nd r: [2, 3, 1]\\n3rd r: [1, 2, 3] -> see how we returned to initial state\\n4th r: [3, 1, 2]\\n5th r: [2, 3, 1]\\n6th r: [1, 2, 3] -> notice we once again reached initial state\\n7th r: [3, 1, 2]\\n\\nLet\\'s try rotating with our Brute-Force ii. method:\\ntimesToRotate = k % size => 7 % 3 = 1\\nRotating timesToRotate times now, i.e, 1 time:\\noriginal array: [1, 2, 3]\\nafter 1st r: [3, 1, 2]\\n\\nDidn\\'t we get the same array we got by using our first approach?\\nAlso we didn\\'t have to waste so many iterations with the help of a\\nsimple mod operation.\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        for(int i = 1; i <= timesToRotate; i++){\\n            int temp = nums[0];\\n            for(int idx = 1; idx < nums.size(); idx++){\\n                int temp1 = nums[idx];\\n                nums[idx] = temp;\\n                temp = temp1;\\n            }\\n            nums[0] = temp;\\n        }\\n        //Note: Time Limit will still exceed\\n    }\\n};\\n```\n```\\nLet\\'s Say we have the same array: [1, 2, 3]\\nWe also create a temporary array: [0, 0, 0] <- 0 denoting no values\\n(which has the same size as the main array but is currently NULL)\\n\\nLet\\'s say k = 7,\\ntherefore t = k % size => 7 % 3 = 1\\n\\nNow, what if we store each element of first array at \\n(current index + t) % (size of array) index in our secondary \\narray.\\n\\nFor example:\\nin our main array: 1 is at index -> 0\\n                   2 is at index -> 1\\n                   3 is at index -> 2\\n\\nSo in our secondary array we should store 1 at:\\n    (index of 1 in main array + t) % size => (0 + 1) % 3 = 1\\nSo our secondary array becomes: [0, 1, 0]\\n\\nDoing the same element 2 of main array:\\n    (2s index in main array + t) % size => (1 + 1) % 3 = 2\\nSecondary array becomes: [0, 1, 2]\\n\\nDoing the same with element 3 of main array:\\n    (3s index in main array + t) % size => (2 + 1) % 3 = 0\\nSecondary array becomes: [3, 1, 2]\\nNow simply copy it to our main array.\\n\\nWhy did we have to mod the position to provide in array2 \\nby the size? it could have been done without it? Well, \\nwe did it to save ourselves from handling the edge cases when\\nindex becomes greater than size - 1 of array, which if is not\\nhandled will give us ArrayOutOfBounds kind of error.\\n\\nHere we only traversed the main array once hence Time Complexity \\nwill be = O(n),\\nand O(n) time will also be taken for copying, making the\\nTotal Complexity = O(n) + O(n) = O(n) (in general)\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n            temp[(i + timesToRotate) % nums.size()] = nums[i];\\n        \\n        //copying the array\\n        for(int i = 0; i < nums.size(); i++)\\n            nums[i] = temp[i];\\n    }\\n};\\n```\n```\\nLet\\'s take our favourite array: [1, 2, 3]\\nand our favourite k, which is: 7 times\\nour t becomes: k % size of array => 7 % 3 = 1\\n\\nStep 1: Reverse the whole array:\\n    [3, 2, 1]\\nStep 2: Reverse from start (which is 0th index) till t-1 index:\\n    t = 1\\n    t - 1 = 0\\n    Reverse from 0 to 0th index, which is basically doing nothing\\n    [3, 2, 1]\\nStep 3: Reverse from index t to end of array:\\n    t = 1\\n    last index = size - 1 => 3 - 1 = 2\\n    reversing from index 1 to 2:\\n    [3, 1, 2] <- Isn\\'t this the very array we were asked to fetch?\\n\\nSo here we solved the question without using any extra space like\\nour 2nd approach.\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int timesToRotate = k % nums.size();\\n\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin() + timesToRotate);\\n        reverse(nums.begin() + timesToRotate, nums.end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673140,
                "title": "python3-easy-3-lines-99-8-faster",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k%len(nums)\\n        n= len(nums)-k\\n        nums[:] = nums[n:]+nums[:n]\\n            \\n```\\npls upvote if you like the solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        k = k%len(nums)\\n        n= len(nums)-k\\n        nums[:] = nums[n:]+nums[:n]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373418,
                "title": "fast-c-easy-logic",
                "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int> ans(n);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          //i-th index wali value (i+k)%n wale index par hogi\\n            ans[(i+k)%n]=nums[i];\\n        \\n        \\n        }\\n        nums=ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int> ans(n);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          //i-th index wali value (i+k)%n wale index par hogi\\n            ans[(i+k)%n]=nums[i];\\n        \\n        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2082183,
                "title": "o-n-time-complexity-o-1-extra-space",
                "content": "In this , you have to make the flow diagram and debug it again and again to understand this better.\\nSuppose,\\n1 2 3 4 5 6 7 is the array and the number of rotations is 3.\\nWe have taken iterations as 0.\\nAfter 1st iteration, \\n4 2 3 1 5 6 7 and we have the index of 4 as well because we are always moving 3 steps ahead which our index variable is taking care of.\\nAfter 2nd iteration,\\n7 2 3 1 5 6 4\\nAfter 3rd iteration,\\n3 2 7 1 5 6 4\\nAfter 4th iteration,\\n6 2 7 1 5 3 4 \\nAfter 5th iteration,\\n2 6 7 1 5 3 4\\nAfter 6th iteration,\\n5 6 7 1 2 3 4 which is our answer and now as iterations == array.length so loop will not further move.\\n\\nSimilarly, for -1 , 100, 3, 99\\nAfter 1st iteration,\\n3,100,-1,99\\nAfter 2nd iteration,\\n3 100 -1 99   i==1\\nAfter 3rd iteration,\\n3 99 -1 100\\nNow iterations == array.length so this will not further move. \\n\\n**Important**\\nIt is very important that you do not move more than the length of the array as it will ruin the indices that you corrected while rotating.\\n\\n```\\n public void rotate(int[] nums, int k) {\\n//        Marks the correct index of a number\\n        int index = 0;\\n//        Marks the index of the array.\\n        int i = 0;\\n//        Marks the number of iterations in the array.\\n        int iterations = 0;\\n        while(iterations < nums.length){\\n           if((index+k)% nums.length == i){\\n               i++;\\n               index = i;\\n               iterations++;\\n           }else{\\n               swap(nums,i,(index+k)%nums.length);\\n               index = (index+k)%nums.length;\\n               iterations++;\\n           }\\n        }\\n    }\\n\\n    void swap(int [] nums , int i , int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\\n\\nIf you liked the solution or found it different , do upvote :)\\nThank you",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n public void rotate(int[] nums, int k) {\\n//        Marks the correct index of a number\\n        int index = 0;\\n//        Marks the index of the array.\\n        int i = 0;\\n//        Marks the number of iterations in the array.\\n        int iterations = 0;\\n        while(iterations < nums.length){\\n           if((index+k)% nums.length == i){\\n               i++;\\n               index = i;\\n               iterations++;\\n           }else{\\n               swap(nums,i,(index+k)%nums.length);\\n               index = (index+k)%nums.length;\\n               iterations++;\\n           }\\n        }\\n    }\\n\\n    void swap(int [] nums , int i , int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873375,
                "title": "c-easy-solution-98-o-n-o-1",
                "content": "```\\nvoid reverse(int* arr, int start, int end) {\\n    for (; start < end; start++, end--) {\\n        int tmp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = tmp;\\n    }\\n}\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n    if (numsSize == 1)\\n        return;\\n    k %= numsSize;\\n\\n    reverse(nums, 0, numsSize - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, numsSize - 1);\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(int* arr, int start, int end) {\\n    for (; start < end; start++, end--) {\\n        int tmp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = tmp;\\n    }\\n}\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n    if (numsSize == 1)\\n        return;\\n    k %= numsSize;\\n\\n    reverse(nums, 0, numsSize - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, numsSize - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769426,
                "title": "javascript-solution",
                "content": "```\\nvar rotate = function (nums, k) {\\n    const len = nums.length\\n    k = (k % len)\\n    \\n    let end = nums.splice(len - k)\\n\\n    nums.splice(0,0,...end)\\n};\\n```\\n\\nRuntime: 104 ms, faster than 87.37% of JavaScript online submissions for Rotate Array.\\nMemory Usage: 50.7 MB, less than 43.86% of JavaScript online submissions for Rotate Array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function (nums, k) {\\n    const len = nums.length\\n    k = (k % len)\\n    \\n    let end = nums.splice(len - k)\\n\\n    nums.splice(0,0,...end)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314695,
                "title": "javascript-0-n-solution",
                "content": "```\\nvar rotate = function(nums, k) {\\n    let j = nums.length - k % nums.length;\\n    let arr = [...nums];\\n    for(let i=0; i<nums.length; i++) {\\n        if(j === nums.length) {\\n            j = 0;\\n        }\\n        nums[i] = arr[j];\\n        j++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    let j = nums.length - k % nums.length;\\n    let arr = [...nums];\\n    for(let i=0; i<nums.length; i++) {\\n        if(j === nums.length) {\\n            j = 0;\\n        }\\n        nums[i] = arr[j];\\n        j++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225810,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Brute Force Approach**\\n\\n**Intuition:**\\n- The simplest approach is to rotate all the elements of the array in `K` .\\n\\n**Algorithm:**\\n1. Shift all the array elements right by `1` step.\\n1. Do this `K` times.\\n\\n**Time complexity:** `O(N * K)`, All the numbers are shifted by one step right and it will take `O(N)`. For `K` times, it will take `O(N * K)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        int prev;\\n        int current;\\n\\n        for (int i = 0; i < K; i++) {\\n            prev = A[A.length - 1];\\n\\n            for (int j = 0; j < A.length; j++) {\\n                current = A[j];\\n                A[j] = prev;\\n                prev = current;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2: Using Extra Array**\\n\\n**Algorithm:**\\n1. We use an extra array in which we place every element of the array at its correct position i.e. the number at index `i` in the original array is placed at the index `(i + K) % length` of array. \\n1. Then, we copy the new array to the original one.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(N)`, Another array of the same size is used.\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        int[] B = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            int index = (i + K) % A.length;\\n            B[index] = A[i];\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = B[i];\\n        }\\n    }\\n}\\n```\\n\\n**Solution 3: Using Reverse**\\n\\n**Intuition:**\\n- Let given array `A = [1, 2, 3, 4, a, b]`, and `K = 2`. Then in the rotated array `A`, there are two sub-arrays, `[1, 2, 3, 4]` and `[a, b]` that keep their original orders.\\n- Therefore, rotation can be seen as the exchanges of the two sub-arrays of `A` and these exchanges can be performed in `O(N)` time. Also we can use an in-place array-reverse method to perform these exchanges in `O(1)` space.\\n\\n**Algorithm:**\\n1. First reverse the entire array `A` and so `[1, 2, 3, 4, a, b]` becomes `[b, a, 4, 3, 2, 1].`\\n2. Then reverse first `K` elements from index `0` to `K` and so `[b, a, 4, 3, 2, 1]` becomes `[a, b, 4, 3, 2, 1]`.\\n3. Lastly, reverse the remaining `N - K` elements from index `N` to `N - 1` and so `[a, b, 4, 3, 2, 1]` becomes `[a, b, 1, 2, 3, 4]` which yields the rotated array.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        reverse(A, 0, A.length - 1);    // [1, 2, 3, 4, a, b] --> [b, a, 4, 3, 2, 1]  Reverse entire array\\n        reverse(A, 0, K - 1);           // [b, a, 4, 3, 2, 1] --> [a, b, 4, 3, 2, 1]  Reverse first \\'K\\' elements\\n        reverse(A, K, A.length - 1);    // [a, b, 4, 3, 2, 1] --> [a, b, 1, 2, 3, 4]  Reverse remaining \\'N - K\\' elements\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            int temp = A[start];\\n            A[start++] = A[end];\\n            A[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        int prev;\\n        int current;\\n\\n        for (int i = 0; i < K; i++) {\\n            prev = A[A.length - 1];\\n\\n            for (int j = 0; j < A.length; j++) {\\n                current = A[j];\\n                A[j] = prev;\\n                prev = current;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        int[] B = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            int index = (i + K) % A.length;\\n            B[index] = A[i];\\n        }\\n\\n        for (int i = 0; i < A.length; i++) {\\n            A[i] = B[i];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void rotate(int[] A, int K) {\\n        K = K % A.length;\\n\\n        reverse(A, 0, A.length - 1);    // [1, 2, 3, 4, a, b] --> [b, a, 4, 3, 2, 1]  Reverse entire array\\n        reverse(A, 0, K - 1);           // [b, a, 4, 3, 2, 1] --> [a, b, 4, 3, 2, 1]  Reverse first \\'K\\' elements\\n        reverse(A, K, A.length - 1);    // [a, b, 4, 3, 2, 1] --> [a, b, 1, 2, 3, 4]  Reverse remaining \\'N - K\\' elements\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            int temp = A[start];\\n            A[start++] = A[end];\\n            A[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169152,
                "title": "my-detailed-explained-5-javascript-solutions-with-one-liner-that-beats-98-5-of-all-submissions",
                "content": "Here are my five different JavaScript solutions for Rotate Array problem (four are analogs to Solutions and one is JavaScript-specific, requiring ES6 syntax). The most interesting JS-specific ES6 one-line super-fast solution with detailed description is at the very end.\\n\\nFirst is the same as solution **#4 cycling replacements**. I figured out this method by myself by trying to solve this task on a piece of paper, so my solution is somewhat different from the one stated in LeetCode solution. My solution uses only a single `do while` cycle, and I handle special case where I need to update starting point via `if` statement.\\n\\n```\\nlet rotate = function(nums, k) {\\n    function getNext(start, shift = k) {\\n        return (start + shift) % nums.length;\\n    }\\n\\n    k = getNext(k, 0); // force k < nums.length\\n    if (nums.length === 1 || k === 0) return;\\n\\n    let start = 0, i = start + k, prev = start, temp = nums[start], swaps = 0;\\n    do {\\n        let buffer = nums[i];\\n        nums[i] = temp;\\n        temp = buffer;\\n        if (i === start) {\\n            start++;\\n            i = start;\\n            temp = nums[i];\\n        }\\n        prev = i;\\n        i = getNext(i);\\n        swaps++;\\n    } while (swaps < nums.length);\\n};\\n```\\n\\nMy initial solution was identical to **#2 - Using Extra Array**. I use a temp array to create a copy of the input array and insert original elements into new indexes, and then simply update original array. This solution has O(n) time complexity, O(n) space complexity:\\n\\n```\\nlet rotate = function(nums, k) {\\n    while (k >= nums.length) {\\n        k -= nums.length;\\n    }\\n    if (nums.length === 1 || k === 0) return;\\n    let temp = [];\\n    for (let left = 0, right = k; left < nums.length; left++, right++) {\\n        if (right >= nums.length) {\\n            right -= nums.length;\\n        }\\n        temp[right] = nums[left];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i] = temp[i];\\n    }\\n};\\n```\\n\\nI really loved the original idea of solution **#4 - Using Reverse**, or simply rotating array and two parts (before and after the shift). So I took the idea and made a JavaScript implementation:\\n\\n```\\nlet rotate = function(nums, k) {\\n    k = k % nums.length;\\n    if (k === 0 || nums.length === 1) return;\\n\\n    function reverse(start, finish) {\\n        for (let i = start, j = finish - 1; i < Math.floor((start + finish) / 2); i++, j--) {\\n            let temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n\\n    reverse(0, nums.length);\\n    reverse(0, k);\\n    reverse(k, nums.length);\\n};\\n```\\n\\n**One-line brute-force** approach.\\nUsing JavaScript built-in methods we can shrink brute force to one line:\\nFirst, `pop` the last element of the array, then `unshift` it (add it at the start). Repeat `k` times to reach desired result. Very easy to code in JS but not very fast, beats around 50% of submissions:\\n```\\nlet rotate = function(nums, k) {\\n    for(let i = 0; i < k % nums.length; i++) nums.unshift(nums.pop());\\n};\\n```\\n\\nAnd here\\'s my favorite JS-specific one-line solution, which just happens to be very efficient - it **beats 98.5% of all submissions (and looks awesome!)**:\\n```\\nlet rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length-k));\\n};\\n```\\nThis does exactly what is required: cuts off nums.length elements at the end and reinserts them at the start. All while using built-in JavaScript functions. As a bonus, it has same execution speed as the faster methods above. The only **downside** - it cannot be recreated in other languages unless they have `unshift` and `splice` analogs. `...` (spread) is required for quick and painless `unshift`ing.\\n\\nHow it works:\\n`splice` removes a certain number of elements starting at provided index and modifies array length. Removed elements are returned. [Array.prototype.splice() @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)\\n`unshift` adds elements at the start of the array and moves the rest of elements forward. [Array.prototype.unshift() @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)\\n`...` is called [Spread syntax @ MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax). It is used to break down arrays (or strings) into separate elements. In this case it allows us to `unshif` elements we `splice`d from the array without concatenating arrays and iterating over `nums` to update it in place.",
                "solutionTags": [],
                "code": "```\\nlet rotate = function(nums, k) {\\n    function getNext(start, shift = k) {\\n        return (start + shift) % nums.length;\\n    }\\n\\n    k = getNext(k, 0); // force k < nums.length\\n    if (nums.length === 1 || k === 0) return;\\n\\n    let start = 0, i = start + k, prev = start, temp = nums[start], swaps = 0;\\n    do {\\n        let buffer = nums[i];\\n        nums[i] = temp;\\n        temp = buffer;\\n        if (i === start) {\\n            start++;\\n            i = start;\\n            temp = nums[i];\\n        }\\n        prev = i;\\n        i = getNext(i);\\n        swaps++;\\n    } while (swaps < nums.length);\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    while (k >= nums.length) {\\n        k -= nums.length;\\n    }\\n    if (nums.length === 1 || k === 0) return;\\n    let temp = [];\\n    for (let left = 0, right = k; left < nums.length; left++, right++) {\\n        if (right >= nums.length) {\\n            right -= nums.length;\\n        }\\n        temp[right] = nums[left];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i] = temp[i];\\n    }\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    k = k % nums.length;\\n    if (k === 0 || nums.length === 1) return;\\n\\n    function reverse(start, finish) {\\n        for (let i = start, j = finish - 1; i < Math.floor((start + finish) / 2); i++, j--) {\\n            let temp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = temp;\\n        }\\n    }\\n\\n    reverse(0, nums.length);\\n    reverse(0, k);\\n    reverse(k, nums.length);\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    for(let i = 0; i < k % nums.length; i++) nums.unshift(nums.pop());\\n};\\n```\n```\\nlet rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length-k));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851537,
                "title": "beats-100-o-n-time-o-1-space-java-striver-explanation",
                "content": "# Intuition\\nTo rotate the array to the right by k steps, we can use a three-step approach. Firstly, we reverse the first n-k elements of the array. Then, we reverse the remaining k elements. Finally, we reverse the entire array. This approach allows us to achieve the rotation in-place without using any additional space.\\n\\n# Approach\\n1. Reverse the first n-k elements of the array. We can do this by swapping elements from the start and end of the subarray until we reach the middle.\\n2. Reverse the remaining k elements of the array. We can do this by swapping elements from the start and end of the subarray until we reach the middle.\\n3. Reverse the entire array. This is similar to step 1 but done on the whole array.\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of elements in the array. The three reverse operations take linear time, and since all three operations are done separately, the overall time complexity remains linear.\\n- Space complexity: O(1) since we are modifying the input array in-place and not using any additional space that depends on the size of the input.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k %= n; // In case k is larger than the length of the array, take the modulo.\\n\\n        // Reverse the first n-k elements.\\n        reverseArray(nums, 0, n - k - 1);\\n\\n        // Reverse the rest elements.\\n        reverseArray(nums, n - k, n - 1);\\n\\n        // Reverse the entire array.\\n        reverseArray(nums, 0, n - 1);\\n    }\\n    private static void reverseArray(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        k %= n; // In case k is larger than the length of the array, take the modulo.\\n\\n        // Reverse the first n-k elements.\\n        reverseArray(nums, 0, n - k - 1);\\n\\n        // Reverse the rest elements.\\n        reverseArray(nums, n - k, n - 1);\\n\\n        // Reverse the entire array.\\n        reverseArray(nums, 0, n - 1);\\n    }\\n    private static void reverseArray(int[] nums, int start, int end) {\\n        while (start < end) {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726746,
                "title": "python-reversal-algorithm-beginners-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        def reverse(nums,l,h):\\n            while l<=h:\\n                nums[l],nums[h] = nums[h],nums[l]\\n                l+=1\\n                h-=1\\n        \\n        n = len(nums)\\n        k = k%n\\n        reverse(nums,0,n-k-1)\\n        reverse(nums,n-k,n-1)\\n        reverse(nums,0,n-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        def reverse(nums,l,h):\\n            while l<=h:\\n                nums[l],nums[h] = nums[h],nums[l]\\n                l+=1\\n                h-=1\\n        \\n        n = len(nums)\\n        k = k%n\\n        reverse(nums,0,n-k-1)\\n        reverse(nums,n-k,n-1)\\n        reverse(nums,0,n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720648,
                "title": "easy-java-solution-3ms",
                "content": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623153,
                "title": "c-solution-o-n-time-complexity-o-1-space-complexity-99-faster",
                "content": "Lets take an Example:- \\nnums = [-1,-100,3,99], k = 2\\n**Algo**\\nStep 1- Reverse first size-k element\\nnums=[**-100,-1**,3,99]\\nStep 2- Reverse last k element\\nnums=[-100,-1,**99,3**]\\nStep 3- At last, reverse whole array\\nnums[**3,99,-1,-100**]\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int len=nums.size();\\n        k%=len;\\n        if(k==0)\\n            return;\\n\\t\\t// reversing first size-k element\\n        reverse(nums.begin(),nums.end()-k);\\n\\t\\t\\n\\t\\t// reversing last k element\\n        reverse(nums.end()-k,nums.end());\\n\\t\\t\\n\\t\\t//reversing the whole array\\n        reverse(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n\\nPlz upvote if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int len=nums.size();\\n        k%=len;\\n        if(k==0)\\n            return;\\n\\t\\t// reversing first size-k element\\n        reverse(nums.begin(),nums.end()-k);\\n\\t\\t\\n\\t\\t// reversing last k element\\n        reverse(nums.end()-k,nums.end());\\n\\t\\t\\n\\t\\t//reversing the whole array\\n        reverse(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884774,
                "title": "98-faster-reverse-c",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Explanation :-**\\n\\neg. [1,2,3,4,5,6,7] , k = 3\\nOutput = [5,6,7,1,2,3,4]\\n\\n\\u2714 Reverse the whole array => [7,6,5,4,3,2,1]\\n\\u2714 Reverse the parts now as => [5,6,7,1,2,3,4]\\nWe are doing k = k % n because if size of array is 7 (n = 7) and k = 21, then we need not to rotate the array as we will get the same array after rotations.\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        reverse(nums.begin() , nums.end());\\n        reverse(nums.begin() , nums.begin() + k);\\n        reverse(nums.begin() + k , nums.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        k = k % n;\\n        reverse(nums.begin() , nums.end());\\n        reverse(nums.begin() , nums.begin() + k);\\n        reverse(nums.begin() + k , nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776484,
                "title": "c-o-1-space-follow-up-reverse-approach-3-solution",
                "content": "This solution can be done in the following approaches:\\n1. Creating an array and add last k elements firast then add 1 to n-k elements in the array.\\n2. We can store last element of array in a variable and will rotate array by 1. Repeat this k times.\\n3.  Reversing the array multiple times. (Code is below)\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n=k%nums.size(); //if k is greater then size\\n        \\n        reverse(nums.begin(),nums.end()); //reverse full array\\n        \\n        reverse(nums.begin(),nums.begin()+n);   //reverse first k elements\\n        \\n        reverse(nums.begin()+n,nums.end());     // reverse remaining elements\\n        \\n    }\\n};\\n```\\nPlease **UpVote** if you liked my solution.\\nDon\\'t forget to check my other solution: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n=k%nums.size(); //if k is greater then size\\n        \\n        reverse(nums.begin(),nums.end()); //reverse full array\\n        \\n        reverse(nums.begin(),nums.begin()+n);   //reverse first k elements\\n        \\n        reverse(nums.begin()+n,nums.end());     // reverse remaining elements\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719123,
                "title": "o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums, int i, int j){\\n        while(i<j){\\n            swap(nums[i],nums[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k>n){\\n            k=k%n;\\n        }\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums, int i, int j){\\n        while(i<j){\\n            swap(nums[i],nums[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k>n){\\n            k=k%n;\\n        }\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494187,
                "title": "c-easy-2-methods-with-and-without-using-extra-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Space complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n       int i=1,l=nums.size();\\n        while(true)\\n        {\\n            if(i*l-k>0)\\n            {\\n            k=i*l-k;\\n            break;\\n            }\\n            i++;\\n        }\\n        vector<int> ans;\\n        for(int j=k;j<l;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        for(int j=0;j<k;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        nums=ans;\\n    }\\n};\\n```\\n**Space complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+k);\\n    reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n       int i=1,l=nums.size();\\n        while(true)\\n        {\\n            if(i*l-k>0)\\n            {\\n            k=i*l-k;\\n            break;\\n            }\\n            i++;\\n        }\\n        vector<int> ans;\\n        for(int j=k;j<l;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        for(int j=0;j<k;j++)\\n        {\\n            ans.push_back(nums[j]);\\n        }\\n        nums=ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+k);\\n    reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853405,
                "title": "clean-python",
                "content": "**Clean Python**\\n\\nOfficial Solution N\\xBA 4, with clean variables and a small check to prevent redundant work.\\n\\n```\\nclass Solution:\\n    def reverse(self,A,i,j):\\n        while i<j:\\n            A[i],A[j] = A[j],A[i]\\n            i += 1\\n            j -= 1\\n    def rotate(self, A, k):\\n        L  = len(A)\\n        k %= L\\n        if k:\\n            self.reverse( A , 0 , L-1 )\\n            self.reverse( A , 0 , k-1 )\\n            self.reverse( A , k , L-1 )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverse(self,A,i,j):\\n        while i<j:\\n            A[i],A[j] = A[j],A[i]\\n            i += 1\\n            j -= 1\\n    def rotate(self, A, k):\\n        L  = len(A)\\n        k %= L\\n        if k:\\n            self.reverse( A , 0 , L-1 )\\n            self.reverse( A , 0 , k-1 )\\n            self.reverse( A , k , L-1 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278393,
                "title": "swift",
                "content": "```\\n    func rotate(_ nums: inout [Int], _ k: Int) {\\n        if k < 1 || nums.count == 0{\\n            return\\n        }\\n        var k = k % nums.count\\n        nums = Array(nums[nums.count - k..<nums.count] + nums[0..<nums.count-k])\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func rotate(_ nums: inout [Int], _ k: Int) {\\n        if k < 1 || nums.count == 0{\\n            return\\n        }\\n        var k = k % nums.count\\n        nums = Array(nums[nums.count - k..<nums.count] + nums[0..<nums.count-k])\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 54563,
                "title": "my-o-n-solution-using-c",
                "content": "    void reverse( int *nums,int begin,int end ){\\n        int tmp = 0;\\n        while( begin < end ){\\n            tmp = nums[begin];\\n            nums[begin++] = nums[end];\\n            nums[end--] = tmp;\\n        }\\n    }\\n    void three_reverse( int *nums,int numsSize,int n ){\\n        reverse(nums,0,n-1);\\n        reverse(nums,n,numsSize-1);\\n        reverse(nums,0,numsSize-1);\\n    }\\n    void rotate(int* nums, int numsSize, int k) {\\n        k %= numsSize;\\n        three_reverse(nums,numsSize,numsSize-k);\\n    }",
                "solutionTags": [],
                "code": "    void reverse( int *nums,int begin,int end ){\\n        int tmp = 0;\\n        while( begin < end ){\\n            tmp = nums[begin];\\n            nums[begin++] = nums[end];\\n            nums[end--] = tmp;\\n        }\\n    }\\n    void three_reverse( int *nums,int numsSize,int n ){\\n        reverse(nums,0,n-1);\\n        reverse(nums,n,numsSize-1);\\n        reverse(nums,0,numsSize-1);\\n    }\\n    void rotate(int* nums, int numsSize, int k) {\\n        k %= numsSize;\\n        three_reverse(nums,numsSize,numsSize-k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54557,
                "title": "my-accepted-java-solution-o-n-time-and-o-1-space",
                "content": "    public class Solution {\\n        public void rotate(int[] nums, int k) {\\n           int end = nums.length;\\n            k=k%end;// to check for outofbounds when k >= nums.length\\n            rotate(nums,0,end-k-1);//reverse one half of the array\\n            rotate(nums,end-k,end-1);//reverse other half of the array\\n            rotate(nums,0,end-1);//reverse whole array  \\n        }\\n        public void swap(int[] nums,int a,int b){\\n            int temp = nums[a];\\n            nums[a] = nums[b];\\n            nums[b] = temp;\\n        }\\n        \\n        public void rotate(int[] nums,int start,int end){\\n            for(int i = start;i<=(start+end)/2;i++){\\n                swap(nums,i,(start+end)-i);\\n            }\\n        }\\n        \\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void rotate(int[] nums, int k) {\\n           int end = nums.length;\\n            k=k%end;// to check for outofbounds when k >= nums.length\\n            rotate(nums,0,end-k-1);//reverse one half of the array\\n            rotate(nums,end-k,end-1);//reverse other half of the array\\n            rotate(nums,0,end-1);//reverse whole array  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 54567,
                "title": "a-simple-c-solution-o-1-space",
                "content": "  \\n    void swap(int &x,int &y)\\n    {\\n        int tmp = x;\\n        x = y;\\n        y = tmp;\\n    }\\n    \\n    void swap_arr(vector<int>& nums, int s, int e)\\n    {\\n        int mid = (s+e)>>1;\\n        for(int i = s; i < mid; ++i)\\n        {\\n            swap(nums[i],nums[s+e-1-i]);\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n<=1)return;\\n        if(k==0)return;\\n        if(k>n)k = k%n;\\n        k = n-k;\\n        swap_arr(nums,0,k);\\n        swap_arr(nums,k,n);\\n        swap_arr(nums,0,n);\\n        \\n    }",
                "solutionTags": [],
                "code": "  \\n    void swap(int &x,int &y)\\n    {\\n        int tmp = x;\\n        x = y;\\n        y = tmp;\\n    }\\n    \\n    void swap_arr(vector<int>& nums, int s, int e)\\n    {\\n        int mid = (s+e)>>1;\\n        for(int i = s; i < mid; ++i)\\n        {\\n            swap(nums[i],nums[s+e-1-i]);\\n        }\\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(n<=1)return;\\n        if(k==0)return;\\n        if(k>n)k = k%n;\\n        k = n-k;\\n        swap_arr(nums,0,k);\\n        swap_arr(nums,k,n);\\n        swap_arr(nums,0,n);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54633,
                "title": "share-c-code-sub-array-rotate",
                "content": "    void R(int *a, int n){\\n        for(int i=0;i<n/2;i++){\\n            int temp = a[i];\\n            a[i] = a[n-i-1];\\n            a[n-i-1] = temp;\\n        }\\n    }\\n    void rotate(int nums[], int n, int k) {\\n        k = k%n;\\n        R(nums,n-k);\\n        R(nums+n-k,k);\\n        R(nums,n);\\n    }",
                "solutionTags": [],
                "code": "    void R(int *a, int n){\\n        for(int i=0;i<n/2;i++){\\n            int temp = a[i];\\n            a[i] = a[n-i-1];\\n            a[n-i-1] = temp;\\n        }\\n    }\\n    void rotate(int nums[], int n, int k) {\\n        k = k%n;\\n        R(nums,n-k);\\n        R(nums+n-k,k);\\n        R(nums,n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 54481,
                "title": "my-accepted-python-solution-in-o-1-space-and-o-n-time",
                "content": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n\\t\\tk %= len(nums)\\n\\t\\tdef transpose(nums, lo, hi):\\n\\t\\t\\tif lo >= hi:\\n\\t\\t\\t\\treturn\\n\\t\\t\\twhile lo < hi:\\n\\t\\t\\t\\tnums[lo], nums[hi - 1] = (nums[hi - 1], nums[lo])\\n\\t\\t\\t\\tlo += 1\\n\\t\\t\\t\\thi -= 1\\n\\t\\tlength = len(nums)\\n\\t\\tk %= length\\n\\t\\ttranspose(nums, 0, length - k)\\n\\t\\ttranspose(nums, length - k, length)\\n\\t\\ttranspose(nums, 0, length)\\n\\n\\nThe rationale is ***Matrix Transposition***: ((a^tr)(b^tr))^tr = ba\\n\\n\\n***ab*** is the source list, ***ba*** is the target. So we just transpose ***a***, then transpose ***b***, finally transpose ***(a^tr)(b^tr)***, as a result, we get the result ***ba***.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param nums, a list of integer\\n    # @param k, num of steps\\n    # @return nothing, please modify the nums list in-place.\\n    def rotate(self, nums, k):\\n\\t\\tk %= len(nums)\\n\\t\\tdef transpose(nums, lo, hi):\\n\\t\\t\\tif lo >= hi:\\n\\t\\t\\t\\treturn\\n\\t\\t\\twhile lo < hi:\\n\\t\\t\\t\\tnums[lo], nums[hi - 1] = (nums[hi - 1], nums[lo])\\n\\t\\t\\t\\tlo += 1\\n\\t\\t\\t\\thi -= 1\\n\\t\\tlength = len(nums)\\n\\t\\tk %= length\\n\\t\\ttranspose(nums, 0, length - k)\\n\\t\\ttranspose(nums, length - k, length)\\n\\t\\ttranspose(nums, 0, length)\\n\\n\\nThe rationale is ***Matrix Transposition***: ((a^tr)(b^tr))^tr = ba\\n\\n\\n***ab*** is the source list, ***ba*** is the target. So we just transpose ***a***, then transpose ***b***, finally transpose ***(a^tr)(b^tr)***, as a result, we get the result ***ba***.",
                "codeTag": "Java"
            },
            {
                "id": 3196739,
                "title": "tc-o-n-sc-o-1-efficient-rotation-of-an-array-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo rotate an array by k steps, we can $$reverse$$ the $$entire$$ array first, then $$reverse$$ the $$first$$ $$k$$ elements, and finally reverse the remaining i.e $$(k-1)$$ to $$len(array)$$ elements to obtain the required $$rotated$$ array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Make $$k$$ = $$k$$ % $$len(nums)$$ because whatever $$k$$ value is that is greater than length of the array we only need to rotate $$k$$ % $$len(array)$$ and also to avoid list index out range errors.\\n2. For example let\\'s say array = [1,2,3] and $$k$$ = $$4$$ after rotating $$4$$ times resulting array = [2,3,1] which is same as $$k$$%$$3$$ $$(len(array))$$ i.e $$1$$ rotation.\\n2. Define a helper function called $$reverse$$ which takes a $$left$$ index, $$right$$ index, and $$array$$ as arguments. The function reverses the array $$in$$ $$place$$ for the $$specified$$ range.\\n3. Reverse the $$entire$$ array by calling $$reverse$$ function with $$left$$ index as $$0$$ and $$right$$ index as $$len(nums)-1$$.\\n4. Reverse the $$first$$ $$k$$ elements of the array by calling $$reverse$$ function with $$left$$ index as $$0$$ and $$right$$ index as $$k-1$$.\\n5. Reverse the remaining elements of the $$array$$ by calling $$reverse$$ function with $$left$$ index as $$k$$ and $$right$$ index as $$len(nums)-1$$.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nThe time complexity of the algorithm is O(n) because we are \\nreversing the array three times which takes linear time.\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nThe space complexity of the algorithm is O(1) because we are not\\nusing any extra space except for some variables.\\n```\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)   #calculate k such that it is less than length of the array\\n        def reverse(left,right,nums):\\n            while left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left, right = left+1, right-1\\n        reverse(0, len(nums)-1, nums)   #reverse the entire array\\n        reverse(0, k-1, nums)   #reverse the first k elements\\n        reverse(k, len(nums)-1, nums)   #reverse the remaining elements\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nThe time complexity of the algorithm is O(n) because we are \\nreversing the array three times which takes linear time.\\n```\n```\\nThe space complexity of the algorithm is O(1) because we are not\\nusing any extra space except for some variables.\\n```\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)   #calculate k such that it is less than length of the array\\n        def reverse(left,right,nums):\\n            while left <= right:\\n                nums[left], nums[right] = nums[right], nums[left]\\n                left, right = left+1, right-1\\n        reverse(0, len(nums)-1, nums)   #reverse the entire array\\n        reverse(0, k-1, nums)   #reverse the first k elements\\n        reverse(k, len(nums)-1, nums)   #reverse the remaining elements\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172485,
                "title": "3-approaches-easy-solution-c-4-lines-of-code",
                "content": "# Multiple Methods\\n\\n### TTime Complexity O(N), Space O(N)\\n\\n# Code\\n```\\n void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(k>=n){\\n            k = k%n;\\n        }\\n        \\n        \\n        vector<int> newarr(n,0);\\n     int c = 0;\\n       for(int i=n-k;i<n;i++){\\n           newarr[c++] = nums[i];\\n       }\\n        \\n        for(int i=0;i<n-k;i++){\\n            newarr[c++] = nums[i];\\n        }\\n    \\n        for(int i =0 ;i<n;i++){\\n            nums[i] = newarr[i];\\n        }\\n     return;\\n```\\n\\n### Time Complexity O(N), Space O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rev(vector<int>& arr, int start, int end){\\n        while(start<=end){\\n            swap(arr[start++],arr[end--]);\\n        }\\n    }\\n    void rotate(vector<int>& arr, int k) {\\n        int n = size(arr);\\n        k = k%n;\\n        rev(arr,n-k,n-1);\\n        rev(arr,0,n-k-1);\\n        rev(arr,0,n-1);\\n        return;\\n\\t} \\n};\\n```\\n### Using In-built Reverse Function\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %=nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```\\n#### Please UPVOTE if you liked the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        if(k>=n){\\n            k = k%n;\\n        }\\n        \\n        \\n        vector<int> newarr(n,0);\\n     int c = 0;\\n       for(int i=n-k;i<n;i++){\\n           newarr[c++] = nums[i];\\n       }\\n        \\n        for(int i=0;i<n-k;i++){\\n            newarr[c++] = nums[i];\\n        }\\n    \\n        for(int i =0 ;i<n;i++){\\n            nums[i] = newarr[i];\\n        }\\n     return;\\n```\n```\\nclass Solution {\\npublic:\\n    void rev(vector<int>& arr, int start, int end){\\n        while(start<=end){\\n            swap(arr[start++],arr[end--]);\\n        }\\n    }\\n    void rotate(vector<int>& arr, int k) {\\n        int n = size(arr);\\n        k = k%n;\\n        rev(arr,n-k,n-1);\\n        rev(arr,0,n-k-1);\\n        rev(arr,0,n-1);\\n        return;\\n\\t} \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k %=nums.size();\\n        reverse(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.begin()+k);\\n        reverse(nums.begin()+k, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984833,
                "title": "python-solution-explained-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first compute rotation since k could be greater than the length of the array, we can find the modulo of k to length (` k % len(nums)`) of array. this gives us the rotation without rotating it more than once.\\n\\nFinaly we can splice the two halves and `swap` them. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if k == 0:\\n            return nums\\n        \\n        # compute rotation\\n        k = k % len(nums)\\n        lenght = len(nums)\\n        \\n        #swap positions\\n        nums[lenght-k:], nums[:lenght-k] = nums[:lenght-k],nums[lenght-k:]\\n        # return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if k == 0:\\n            return nums\\n        \\n        # compute rotation\\n        k = k % len(nums)\\n        lenght = len(nums)\\n        \\n        #swap positions\\n        nums[lenght-k:], nums[:lenght-k] = nums[:lenght-k],nums[lenght-k:]\\n        # return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875064,
                "title": "easiest-faang-method-ever",
                "content": "\\n\\n# \\uD83D\\uDCA8Complexity :-\\n- Time complexity: O(n) + O(n) + O(n) = O(3n) ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# ***Please Upvote if it Helps :)***\\n\\n# \\uD83D\\uDCA8Code :-\\n# **\\u26A1Method 1 => TC: O(n) SC:O(1)**\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\\n# **\\u26A1Method-2 => TC: O(n) SC:O(k)**\\nThis method throws TLE error for 1 case !\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int count=0;\\n        k=k%nums.size();\\n        for(int i=nums.size()-1;count<k;){\\n            nums.emplace(nums.begin(),nums[i]);\\n            nums.pop_back();\\n            count++;\\n        }\\n    }\\n};\\n```\\n# ***Please Upvote if it Helps :)***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k = k % nums.size();\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int count=0;\\n        k=k%nums.size();\\n        for(int i=nums.size()-1;count<k;){\\n            nums.emplace(nums.begin(),nums[i]);\\n            nums.pop_back();\\n            count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566915,
                "title": "c-too-easy-cool-soln",
                "content": "void rotate(vector<int>& nums, int k) {\\n        \\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0;i < nums.size(); i++) {\\n            \\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }\\n\\tPlz upvote if you find it helpful !!! warna koi na, chill scene. \\n\\tpls share better approach if you have any...",
                "solutionTags": [
                    "C"
                ],
                "code": "void rotate(vector<int>& nums, int k) {\\n        \\n        vector<int> temp(nums.size());\\n        \\n        for(int i = 0;i < nums.size(); i++) {\\n            \\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }\\n\\tPlz upvote if you find it helpful !!! warna koi na, chill scene. \\n\\tpls share better approach if you have any...",
                "codeTag": "Unknown"
            },
            {
                "id": 2460257,
                "title": "o-1-space-complexity-solution",
                "content": "**Plzz Upvote if you find it helpful**\\n```\\nclass Solution {\\n    public void rotate(int[] arr, int d) {\\n    \\n         /*\\n        Reversal algorithm For ArrayRotation\\n        1. Reverse the first part\\n        2. Reverse last part\\n        3. Reverse the whole array.\\n        */\\n        int n = arr.length;\\n        d= d%n;\\n        reverse(arr,0,n-d);\\n        reverse(arr,n-d,n);\\n        reverse(arr,0,n);\\n    \\n    }   \\n  \\n     void reverse(int []arr,int start, int end){\\n        int j = end-1;\\n        for(int i= start;i<j;i++){\\n            int temp = arr[i];\\n            arr[i]= arr[j];\\n            arr[j]= temp;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] arr, int d) {\\n    \\n         /*\\n        Reversal algorithm For ArrayRotation\\n        1. Reverse the first part\\n        2. Reverse last part\\n        3. Reverse the whole array.\\n        */\\n        int n = arr.length;\\n        d= d%n;\\n        reverse(arr,0,n-d);\\n        reverse(arr,n-d,n);\\n        reverse(arr,0,n);\\n    \\n    }   \\n  \\n     void reverse(int []arr,int start, int end){\\n        int j = end-1;\\n        for(int i= start;i<j;i++){\\n            int temp = arr[i];\\n            arr[i]= arr[j];\\n            arr[j]= temp;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364200,
                "title": "fast-c-c-python-javascript-java-solution",
                "content": "Fast C++ || C || Python || Javascript || Java Solution\\nhttps://www.nileshblog.tech/2022/04/leet-code-rotate-array-c-python-javascript-java-solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2348333,
                "title": "fast-java-javascript-c-python-solution",
                "content": "Fast Java | JavaScript | C++ | Python Solution\\nhttps://www.nileshblog.tech/2022/04/leet-code-rotate-array-c-python-javascript-java-solution/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2257586,
                "title": "3-ways-to-solve-this-problem-simple-easy-understand-c-o-n-time-and-o-1-space",
                "content": "okay first we need to insure that* k* shoud not be greater than n if *k >n* then we simply take module of this k\\n \\n`k=k%n;`\\n*let solve this question *\\n\\n**first method is O(k*n) time and O(1) space**\\n![image](https://assets.leetcode.com/users/images/99b471eb-4789-46f3-b8f6-4aea3aa38def_1657349607.591481.png)\\n\\n we will create a function which rotate a array by one.\\n and we call this function by k times in our main function\\n```\\n    void rotatebyone(vector<int>&nums){\\n        int n=nums.size();\\n        int temp=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            nums[i+1]=nums[i];\\n        nums[0]=temp;\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // first we need to insure that k<n\\n        k=k%n;\\n        for(int i=0;i<k;i++){\\n            rotatebyone(nums);\\n        }\\n   }\\n```\\n**now lets talk about O(n) time and O(n) space**\\n```\\n void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;// insuring that k<n\\n        vector<int>ans(n);// create ans array/vector\\n        int j=0;\\n\\t\\t//copy elements from n-k to n in our ans vector\\n        for(int i=n-k;i<n;i++){\\n            ans[j++]=nums[i];\\n        }\\n\\t\\t// copy elements form 0 to n-k\\n        for(int i=0;i<n-k;i++){\\n            ans[j++]=nums[i];\\n        }\\n       nums=ans;\\n    }\\n```\\n**third solution is O(n) time and O(1) space**\\nthe idea is simple first we reverse 0 to n-k element \\nafter that we reverse n-k to n and in the last we reverse whole array\\nand we get our ans\\n![image](https://assets.leetcode.com/users/images/b7cd48c5-dfdb-46fd-99f2-b85d34372b22_1657351951.3675656.png)\\n\\n```\\n    void reverseArray(vector<int>&nums,int i,int j){\\n        while(i<j){\\n            swap(nums[i++],nums[j--]);\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverseArray(nums,0,n-k-1);\\n        reverseArray(nums,n-k,n-1);\\n        reverseArray(nums,0,n-1);\\n    }\\n```\\nthnaks!\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n    void rotatebyone(vector<int>&nums){\\n        int n=nums.size();\\n        int temp=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            nums[i+1]=nums[i];\\n        nums[0]=temp;\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        // first we need to insure that k<n\\n        k=k%n;\\n        for(int i=0;i<k;i++){\\n            rotatebyone(nums);\\n        }\\n   }\\n```\n```\\n void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;// insuring that k<n\\n        vector<int>ans(n);// create ans array/vector\\n        int j=0;\\n\\t\\t//copy elements from n-k to n in our ans vector\\n        for(int i=n-k;i<n;i++){\\n            ans[j++]=nums[i];\\n        }\\n\\t\\t// copy elements form 0 to n-k\\n        for(int i=0;i<n-k;i++){\\n            ans[j++]=nums[i];\\n        }\\n       nums=ans;\\n    }\\n```\n```\\n    void reverseArray(vector<int>&nums,int i,int j){\\n        while(i<j){\\n            swap(nums[i++],nums[j--]);\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverseArray(nums,0,n-k-1);\\n        reverseArray(nums,n-k,n-1);\\n        reverseArray(nums,0,n-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1730768,
                "title": "rotate-array-beginner-friendly-and-easy-to-understand",
                "content": "In this question we have been given an array and an integer .We to rotate k elements of the array.\\nIn this approach a reverse function is created in which array , starting index and ending index is passed.Then using swapping technique we are reversing the array.\\n\\n**Steps followed**\\n\\n1 ). In the main function first we are reversing the whole array.\\n2 ). Then starting from 0th index till k-1 th index we will reverse the array.\\n3 ). In the last step starting from kth index till end index we are reversing the array.\\n\\nHence we will reach out to the output.\\n\\n![image](https://assets.leetcode.com/users/images/588e3a64-320b-4311-9455-5685922ab470_1643525385.3704638.jpeg)\\n\\nHere is the code\\n\\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums,int start,int end){\\n        //creating a variable to stor one data\\n        int temp;\\n        while(start<end){   // traversing through the array\\n            \\n            //swappig first index with the last index\\n            temp = nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            \\n            //increasing starting index and decreasing ending index\\n            \\n            start++;\\n            end--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //if k is greater than size then making it in the range of size\\n        k=k%n;\\n        \\n        //if k is 0 or only one element in array no need to rotate\\n        if(k==0 || n==1)\\n        return;\\n        \\n        reverse(nums,0,n-1);    // reversing the whole array\\n        reverse(nums,0,k-1);    //reversing first half of array\\n        reverse(nums,k,n-1);    //reversing second half of array\\n        \\n    } \\n};\\n```\\n\\nThis is a beginner friendly approach and easy to understand.\\n\\nPlease upvote if understand it \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse(vector<int>& nums,int start,int end){\\n        //creating a variable to stor one data\\n        int temp;\\n        while(start<end){   // traversing through the array\\n            \\n            //swappig first index with the last index\\n            temp = nums[start];\\n            nums[start]=nums[end];\\n            nums[end]=temp;\\n            \\n            //increasing starting index and decreasing ending index\\n            \\n            start++;\\n            end--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        //if k is greater than size then making it in the range of size\\n        k=k%n;\\n        \\n        //if k is 0 or only one element in array no need to rotate\\n        if(k==0 || n==1)\\n        return;\\n        \\n        reverse(nums,0,n-1);    // reversing the whole array\\n        reverse(nums,0,k-1);    //reversing first half of array\\n        reverse(nums,k,n-1);    //reversing second half of array\\n        \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730029,
                "title": "java-0-ms-explained",
                "content": "**Method 1:**\\n>**T/S:** O(n)/O(n), where n = size(nums)\\n```\\npublic void rotateExtraSpace(int[] nums, int k) {\\n\\tvar rotated = nums.clone();\\n\\tvar n = nums.length;\\n\\tk %= n;\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[(i + k) % n] = rotated[i];\\n}\\n```\\n**Method 2:** When an array is rotated k times to the right, k items from the end move to the front of the array and n - k items move to the end\\n```\\nSource: [1, 2, 3, 4, 5, 6, 7] | Target: [5, 6, 7, 1, 2, 3, 4], rotate k = 3 times\\n\\nStep 1: Reverse [0, n). This brings the last k items to the front and n - k items from the front to the end, but they\\'re all in reverse\\n0     k           n\\n[7, 6, 5, 4, 3, 2, 1]\\n\\nStep 2: Reverse [0, k)\\n 0     k           n\\n[5, 6, 7, 4, 3, 2, 1]\\n\\nStep 3: Reverse [k, n)\\n 0     k           n\\n[5, 6, 7, 1, 2, 3, 4]\\n\\n```\\n>**T/S:** O(n)/O(1)\\n```\\npublic void rotate(int[] nums, int k) {\\n\\tvar length = nums.length;\\n\\tk %= length--;\\n\\treverse(nums, 0, length);\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, length);\\n}\\n\\nprivate void reverse(int[] nums, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tvar temp = nums[start];\\n\\t\\tnums[start++] = nums[end];\\n\\t\\tnums[end--] = temp;\\n\\t}\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void rotateExtraSpace(int[] nums, int k) {\\n\\tvar rotated = nums.clone();\\n\\tvar n = nums.length;\\n\\tk %= n;\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[(i + k) % n] = rotated[i];\\n}\\n```\n```\\nSource: [1, 2, 3, 4, 5, 6, 7] | Target: [5, 6, 7, 1, 2, 3, 4], rotate k = 3 times\\n\\nStep 1: Reverse [0, n). This brings the last k items to the front and n - k items from the front to the end, but they\\'re all in reverse\\n0     k           n\\n[7, 6, 5, 4, 3, 2, 1]\\n\\nStep 2: Reverse [0, k)\\n 0     k           n\\n[5, 6, 7, 4, 3, 2, 1]\\n\\nStep 3: Reverse [k, n)\\n 0     k           n\\n[5, 6, 7, 1, 2, 3, 4]\\n\\n```\n```\\npublic void rotate(int[] nums, int k) {\\n\\tvar length = nums.length;\\n\\tk %= length--;\\n\\treverse(nums, 0, length);\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, length);\\n}\\n\\nprivate void reverse(int[] nums, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tvar temp = nums[start];\\n\\t\\tnums[start++] = nums[end];\\n\\t\\tnums[end--] = temp;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668690,
                "title": "c-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp[(i+k)%nums.size()]=nums[i];\\n        }\\n                                           \\n          nums=temp;                               \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp[(i+k)%nums.size()]=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1467132,
                "title": "easy-c-solution-using-reversal-algorithm-o-n",
                "content": "class Solution {\\npublic:\\n    \\n    void reverse(vector<int>&nums,int low,int high)\\n    {\\n        while(low<high){\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }    \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        long long int n = nums.size();\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);    \\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void reverse(vector<int>&nums,int low,int high)\\n    {\\n        while(low<high){\\n            swap(nums[low],nums[high]);\\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1461106,
                "title": "c-easy-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        if(k==0) return;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k%=nums.size();\\n        if(k==0) return;\\n        reverse(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426336,
                "title": "java-o-n-time-o-1-space-in-depth-explanation",
                "content": "The concept of this problem is very simple, but the catch here is to try and do it in linear time and constant space. \\n\\n**Naive Solution**\\nWe can start of with the simple naive approach by actually rotating the array ```k``` times.\\n\\n```\\nclass Solutions{\\n    public void rotate(int[] nums, int k){\\n\\t    for(int i = 0; i < k; i++){\\n\\t\\t    rotation(nums);\\n\\t\\t}\\n\\t}\\n    public void rotation(int[] nums){\\n\\t    int temp = nums[nums.length - 1];\\n\\t\\tfor(int i = nums.length - 1; i > 0; i--){\\n\\t\\t    nums[i] = nums[i-1];\\n\\t    }\\n\\t\\tnums[0] = temp;\\n\\t}\\n}\\n```\\nThis solution does the trick, but is very slow with an ```O(kn)``` run time. In cases where the array is very large and ```k``` is very large, the solution takes too long, so this solution would not be accepted.\\n\\n**Slight Improvement**\\nThere is still one thing we can do to this solution to speed it up. Notice how after the array is rotated ```nums.length ``` times, it reverts to the original array. This means instead of doing ```k``` rotations, we do ```k % nums.length``` rotations. Since this bounds the number of rotations to the interval ```[0, n-1]```, this solution now has a run time of ```O(n^2)``` in the worst case. \\n\\nEven after doing this, the inputs can still be large enough to a point where ```O(n^2)``` is still too slow. So we need to do better.\\n\\n\\n**Optimal Solution**\\nFor the sake of simplicty, let ```k = k % nums.length```\\n\\nIn order to do this problem in ```O(n)``` time, we can make a few observations about how the rotated array differs from the original. Let\\'s use the example given in the problem ```[1, 2, 3, 4, 5, 6, 7]``` and ```k = 3```. After rotating, the array becomes ```[5, 6, 7, 1, 2, 3, 4]```. \\n\\nNotice how essentially, the original array is broken up into 2 blocks, a block of size ```k``` consisting of the last ```k``` elements, and a block of size ```nums.length - k``` elments. These two blocks are switched in the rotated array. So how can we swap these two blocks with constant space?\\n\\nNotice that the element in the ```nums.length - k``` index is now at the front, and the elements following the ```nums.length - k```th element also follow it at the front of the array. We can move this entire block of elements by reversing the subarray from ```[nums.length - k, nums.length - 1]```, then reverse the entire array. Using the array in the example, after these 2 reversals, it becomes :\\n\\n```[5, 6, 7, 4, 3, 2, 1]```. \\n\\nNow notice that the only thing different from this and the rotated array is that the elements from the ```k```th index to the end are reversed. So after reversing those elements, the array becomes ```[5, 6, 7, 1, 2, 3, 4]```, which is the array we were looking for. \\n\\nSince the reverse functions runs in ```O(n)``` time and is done in-place, and is called exactly 3 times, the whole algorithm runs in ```O(n)``` time with ```O(1)``` extra space. \\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){\\n        while(start <= end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```k```\n```\\nclass Solutions{\\n    public void rotate(int[] nums, int k){\\n\\t    for(int i = 0; i < k; i++){\\n\\t\\t    rotation(nums);\\n\\t\\t}\\n\\t}\\n    public void rotation(int[] nums){\\n\\t    int temp = nums[nums.length - 1];\\n\\t\\tfor(int i = nums.length - 1; i > 0; i--){\\n\\t\\t    nums[i] = nums[i-1];\\n\\t    }\\n\\t\\tnums[0] = temp;\\n\\t}\\n}\\n```\n```O(kn)```\n```k```\n```nums.length ```\n```k```\n```k % nums.length```\n```[0, n-1]```\n```O(n^2)```\n```O(n^2)```\n```k = k % nums.length```\n```O(n)```\n```[1, 2, 3, 4, 5, 6, 7]```\n```k = 3```\n```[5, 6, 7, 1, 2, 3, 4]```\n```k```\n```k```\n```nums.length - k```\n```nums.length - k```\n```nums.length - k```\n```[nums.length - k, nums.length - 1]```\n```[5, 6, 7, 4, 3, 2, 1]```\n```k```\n```[5, 6, 7, 1, 2, 3, 4]```\n```O(n)```\n```O(n)```\n```O(1)```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k %= nums.length;\\n        reverse(nums, nums.length - k, nums.length - 1);\\n        reverse(nums, 0, nums.length - 1);\\n        reverse(nums, k, nums.length - 1);\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){\\n        while(start <= end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346844,
                "title": "c-easy-4-lines-solution",
                "content": "this is my c++ solution  , hope you find it helpful , if you do  , upvote!\\n\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\nk=k%nums.size();\\nreverse(nums.begin() , nums.end());\\nreverse(nums.begin() , nums.begin()+k);\\nreverse(nums.begin()+k , nums.end());\\n }\\n};\\n```\\ndont forget to upvote if it helps you in any way , im trying to get through collage :/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\nk=k%nums.size();\\nreverse(nums.begin() , nums.end());\\nreverse(nums.begin() , nums.begin()+k);\\nreverse(nums.begin()+k , nums.end());\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770606,
                "title": "c-solution",
                "content": "```\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n\\tsize_t tmp;\\n\\tsize_t i;\\n\\tfor(i = 0; i < numsSize / 2; i++)\\n\\t{\\n\\t\\t// reverse array\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i - 1];\\n\\t\\tnums[numsSize - i - 1] = tmp;\\n\\t}\\t    \\n\\t \\n\\tk %= numsSize;\\n    \\n\\tfor(i = 0; i < k / 2; i++)\\n\\t{\\n\\t\\t// reverse first k elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[k - i - 1];\\n\\t\\tnums[k - i - 1] = tmp;\\n\\t\\t\\n\\t}\\n\\n\\n\\tfor(i = k; i < (numsSize - k) / 2 + k ; i++)\\n\\t{\\n\\t\\t// reverse last (numsSize - k) elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i + k - 1];\\n\\t\\tnums[numsSize - i + k - 1] = tmp;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid rotate(int* nums, int numsSize, int k)\\n{\\n\\tsize_t tmp;\\n\\tsize_t i;\\n\\tfor(i = 0; i < numsSize / 2; i++)\\n\\t{\\n\\t\\t// reverse array\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i - 1];\\n\\t\\tnums[numsSize - i - 1] = tmp;\\n\\t}\\t    \\n\\t \\n\\tk %= numsSize;\\n    \\n\\tfor(i = 0; i < k / 2; i++)\\n\\t{\\n\\t\\t// reverse first k elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[k - i - 1];\\n\\t\\tnums[k - i - 1] = tmp;\\n\\t\\t\\n\\t}\\n\\n\\n\\tfor(i = k; i < (numsSize - k) / 2 + k ; i++)\\n\\t{\\n\\t\\t// reverse last (numsSize - k) elements\\n\\t\\ttmp = nums[i];\\n\\t\\tnums[i] = nums[numsSize - i + k - 1];\\n\\t\\tnums[numsSize - i + k - 1] = tmp;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291388,
                "title": "javascript-o-n-space-o-1-space-special-trick",
                "content": "if you reverse the entire array to start, and then reverse the k portion at the beginning and reverse the remaining, you will achieve the k rotation.\\n\\n```\\nfunction rotate(nums, k) {\\n  if (!nums.length) return [];\\n\\n  if (k > 0) {\\n    k = k % nums.length;\\n    reverse(nums, 0, nums.length - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, nums.length - 1);\\n  }\\n\\n  return nums;\\n};\\n\\nfunction reverse(arr, start, end) {\\n  if (!arr || !arr.length || start >= end) return;\\n\\n  while (start < end) {\\n    let temp = arr[start];\\n    arr[start] = arr[end];\\n    arr[end] = temp;\\n    start++, end--;\\n  }\\n\\n  return arr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction rotate(nums, k) {\\n  if (!nums.length) return [];\\n\\n  if (k > 0) {\\n    k = k % nums.length;\\n    reverse(nums, 0, nums.length - 1);\\n    reverse(nums, 0, k - 1);\\n    reverse(nums, k, nums.length - 1);\\n  }\\n\\n  return nums;\\n};\\n\\nfunction reverse(arr, start, end) {\\n  if (!arr || !arr.length || start >= end) return;\\n\\n  while (start < end) {\\n    let temp = arr[start];\\n    arr[start] = arr[end];\\n    arr[end] = temp;\\n    start++, end--;\\n  }\\n\\n  return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146061,
                "title": "clean-python",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        while k>0:\\n            nums.insert(0,nums.pop())\\n            k-=1\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        while k>0:\\n            nums.insert(0,nums.pop())\\n            k-=1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 54490,
                "title": "java-o-1-space-o-n-time-with-detailed-explanations",
                "content": "If you have difficulty understanding the following code, check [this link][1] for detailed explanation.\\n\\n    public void rotate(int[] nums, int k) {\\n    \\tint L=nums.length, counter=0, currentLoc=0, starti=0, prevVal=nums[currentLoc];\\n    \\tk = k%L;\\n    \\twhile(counter++<L) {\\n    \\t\\tif(currentLoc>=L && currentLoc%L==starti) { // this handles the case when currentLoc moves back to where started.\\n    \\t\\t    currentLoc = ++starti; \\n    \\t\\t    prevVal=nums[currentLoc];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tint nextLoc = (currentLoc+k)%L; // get index of next location\\n    \\t\\tint nextVal = nums[nextLoc]; // get value at next location\\n    \\t\\tnums[nextLoc] = prevVal; // update value at next location\\n    \\t\\tprevVal = nextVal; // update previous value\\n\\n    \\t\\tcurrentLoc += k; // move current to next location\\n    \\t}\\n    }\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java/commit/520f505ccc3f9e5512d8ae2d6824ec9833b71b5c",
                "solutionTags": [
                    "Java"
                ],
                "code": "If you have difficulty understanding the following code, check [this link][1] for detailed explanation.\\n\\n    public void rotate(int[] nums, int k) {\\n    \\tint L=nums.length, counter=0, currentLoc=0, starti=0, prevVal=nums[currentLoc];\\n    \\tk = k%L;\\n    \\twhile(counter++<L) {\\n    \\t\\tif(currentLoc>=L && currentLoc%L==starti) { // this handles the case when currentLoc moves back to where started.\\n    \\t\\t    currentLoc = ++starti; \\n    \\t\\t    prevVal=nums[currentLoc];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tint nextLoc = (currentLoc+k)%L; // get index of next location\\n    \\t\\tint nextVal = nums[nextLoc]; // get value at next location\\n    \\t\\tnums[nextLoc] = prevVal; // update value at next location\\n    \\t\\tprevVal = nextVal; // update previous value\\n\\n    \\t\\tcurrentLoc += k; // move current to next location\\n    \\t}\\n    }\\n\\n\\n  [1]: https://github.com/F-L-A-G/Algorithms-in-Java/commit/520f505ccc3f9e5512d8ae2d6824ec9833b71b5c",
                "codeTag": "Unknown"
            },
            {
                "id": 54587,
                "title": "my-two-o-n-solutions-with-o-1-extra-memory-i-don-t-know-the-third-one-yet-any-idea",
                "content": "    void rotate(int nums[], int n, int k) {\\n        if (n == 0)\\n            return;\\n\\n        k %= n;\\n        if (k == 0)\\n            return;\\n\\n        // Method 1, \\n        // reverse(nums, 0, n-k-1);\\n        // reverse(nums, n-k, n-1);\\n        // reverse(nums, 0, n-1);\\n\\n        // Method 2. Swap int to its position directly, \\n        // and store the next one that need be swapped. \\n        // One tricky thing is to to avoid swapping the same int.\\n        int idx = 0;\\n        int distance = 0;\\n        int cur = nums[idx];\\n        for (int i = 0; i < n; ++i) {\\n            int next = (idx+k)%n;\\n            int temp = nums[next];\\n            nums[next] = cur;\\n            idx = next;\\n            cur = temp;\\n\\n            // If distance is back. Move it one step forward.\\n            distance = (distance+k)%n;\\n            if (distance == 0) {\\n                idx = (idx+1)%n;\\n                cur = nums[idx];\\n            }\\n        }\\n    }\\n\\n    void reverse(int nums[], int begin, int end) {\\n        while (begin < end) {\\n            swap (nums[begin++], nums[end--]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void rotate(int nums[], int n, int k) {\\n        if (n == 0)\\n            return;\\n\\n        k %= n;\\n        if (k == 0)\\n            return;\\n\\n        // Method 1, \\n        // reverse(nums, 0, n-k-1);\\n        // reverse(nums, n-k, n-1);\\n        // reverse(nums, 0, n-1);\\n\\n        // Method 2. Swap int to its position directly, \\n        // and store the next one that need be swapped. \\n        // One tricky thing is to to avoid swapping the same int.\\n        int idx = 0;\\n        int distance = 0;\\n        int cur = nums[idx];\\n        for (int i = 0; i < n; ++i) {\\n            int next = (idx+k)%n;\\n            int temp = nums[next];\\n            nums[next] = cur;\\n            idx = next;\\n            cur = temp;\\n\\n            // If distance is back. Move it one step forward.\\n            distance = (distance+k)%n;\\n            if (distance == 0) {\\n                idx = (idx+1)%n;\\n                cur = nums[idx];\\n            }\\n        }\\n    }\\n\\n    void reverse(int nums[], int begin, int end) {\\n        while (begin < end) {\\n            swap (nums[begin++], nums[end--]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4036034,
                "title": "accepted-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **0** *ms* | *Beats* **100%**\\n**Memory** | **56** *MB* | *Beats* **50%**\\n```\\nclass Solution {\\n    public void rev(int[] nums,int l,int r){\\n        while(l<r){\\n            // swap\\n            nums[l]=nums[l]+nums[r]-(nums[r]=nums[l]);\\n            l++;r--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k%=nums.length;\\n        rev(nums,0,nums.length-1);\\n        rev(nums,0,k-1);\\n        rev(nums,k,nums.length-1);\\n\\n    }\\n}\\n```\\n## UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void rev(int[] nums,int l,int r){\\n        while(l<r){\\n            // swap\\n            nums[l]=nums[l]+nums[r]-(nums[r]=nums[l]);\\n            l++;r--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        k%=nums.length;\\n        rev(nums,0,nums.length-1);\\n        rev(nums,0,k-1);\\n        rev(nums,k,nums.length-1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573071,
                "title": "python-beats-99-98",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first creates an empty list `temp` to hold the rotated elements. It then calculates the effective rotation steps `k` by taking the modulus of `k` with the length of `nums` to handle cases where `k` is larger than the length of `nums`.\\n\\nNext, it assigns the last `k` elements of `nums` to `temp` using slicing `nums[-k:]`. This captures the elements that will be moved to the front of the list after rotation.\\n\\nThen, it updates the `nums` list by assigning the elements from index `k` onwards (`nums[k:]`) to the elements from index 0 to `k-1` in `nums` (`nums[:-k]`). This shifts the remaining elements to the right, making space for the rotated elements.\\n\\nFinally, it assigns the elements in `temp` to the first `k` positions in `nums` (`nums[:k]`). This places the rotated elements at the front of the list.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. O(n) -->\\n\\n- Space complexity: `O(k)`\\n<!-- Add your space complexity here, e.g. O(n) -->\\n\\n# Code\\nFollowing code beats 94%\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\\n\\n# Optimization proposed by @drjasonharrison\\nWe need to compute the remainder only if `k` >= `n`, because when `k` is less than `n`, `k % n` is still equal to `k`.\\n# Code\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        if `k` >= len(nums):\\n            k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        `temp` = []\\n        if `k` >= len(nums):\\n            k = k % len(nums)\\n        `temp` = nums[-k:]\\n        nums[k:] = nums[:-k]\\n        nums[:k] = `temp`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484143,
                "title": "easy-solution-solved-in-o-1-space-beginner-friendly-approach",
                "content": "## Read intuition and approach, and try to code it own, at last see code\\n# Intuition\\nWe have to rotate right, so we rotate from last...\\n\\n# Approach\\n1. reverse last k numbers in array.\\n2. reverse araay from 0 to n-k numbers.\\n3. reverse whole array from 0 to end..\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin()+n-k, nums.end()); // reverse last k numbers\\n        reverse(nums.begin(), nums.begin()+n-k); //reverse first n-k numbers\\n        reverse(nums.begin(), nums.end()); // reverse whole array for required answer\\n    }\\n};\\n```\\nif you like solution, then plz \\uD83D\\uDE4F upvote this solution..",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin()+n-k, nums.end()); // reverse last k numbers\\n        reverse(nums.begin(), nums.begin()+n-k); //reverse first n-k numbers\\n        reverse(nums.begin(), nums.end()); // reverse whole array for required answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230089,
                "title": "one-line-very-easy-solution-python",
                "content": "\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866425,
                "title": "java-optimize-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\noptimize Soluation with time complexity O(N) & Space complexity O(1)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this question just you have to first reverse the whole array and then  you have to rotate array with index 0 to k-1 and we have to rotate array from k to arr.length\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void rotate(int[] arr, int k) {\\n\\n        k = k%arr.length;\\n        reverseArray(0 ,  arr.length-1 ,  arr);\\n\\t    reverseArray(0 ,  k-1 ,  arr);\\n\\t    reverseArray(k,  arr.length-1 ,  arr);\\n\\n        System.out.println(arr);\\n\\n\\n        \\n    }\\n\\n    public static void  reverseArray(int i , int j , int[] arr){\\n\\n\\t    while(i<j){\\n\\t            \\n\\t            \\n\\t        int temp = arr[i];\\n\\t        arr[i] = arr[j];\\n\\t        arr[j]= temp;\\n\\t            \\n\\t        i++;\\n\\t        j--;\\n\\t            \\n\\t    }\\n\\t        \\n\\t        \\n\\t        \\n\\t        \\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void rotate(int[] arr, int k) {\\n\\n        k = k%arr.length;\\n        reverseArray(0 ,  arr.length-1 ,  arr);\\n\\t    reverseArray(0 ,  k-1 ,  arr);\\n\\t    reverseArray(k,  arr.length-1 ,  arr);\\n\\n        System.out.println(arr);\\n\\n\\n        \\n    }\\n\\n    public static void  reverseArray(int i , int j , int[] arr){\\n\\n\\t    while(i<j){\\n\\t            \\n\\t            \\n\\t        int temp = arr[i];\\n\\t        arr[i] = arr[j];\\n\\t        arr[j]= temp;\\n\\t            \\n\\t        i++;\\n\\t        j--;\\n\\t            \\n\\t    }\\n\\t        \\n\\t        \\n\\t        \\n\\t        \\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271395,
                "title": "very-easy-with-intutuion-c",
                "content": "**Please Upvote if understood**\\n\\n```\\n// suppose nums: 1 2 3 4 5 6 7, k = 3\\n        int n = nums.size();\\n                \\n        k = k%n;\\n        \\n```\\n        reverse(nums.begin(),nums.end());\\n        // 7 6 5 4 3 2 1 \\n        // we need to reverse from start to k and k to end.\\n        reverse(nums.begin(),nums.begin() + k);\\n        // 5 6 7 4 3 2 1\\n        reverse(nums.begin() + k,nums.end());\\n        // 5 6 7 1 2 3 4",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// suppose nums: 1 2 3 4 5 6 7, k = 3\\n        int n = nums.size();\\n                \\n        k = k%n;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078308,
                "title": "python-two-solutions-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        #Approach 1\\n        for _ in range(k):\\n            nums.insert(0, nums.pop())\\n        \\n        #Approach 2\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        #Approach 1\\n        for _ in range(k):\\n            nums.insert(0, nums.pop())\\n        \\n        #Approach 2\\n        k = k % len(nums)\\n        nums[:] = nums[-k:] + nums[:-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830990,
                "title": "rotate-array-time-o-n-space-o-1-with-proper-explanation",
                "content": "class Solution {\\n    \\n    //This solution is solved using reversal algorithm.\\n    \\n    //function for reversing the array element in the specified range\\n    public void reverse(int arr[],int low,int high){\\n        while(low<high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n==1){\\n            return;\\n        }\\n        //if(k>n) this will handle the cases\\n        k = k%n;\\n        \\n         reverse(nums,0,(n-k)-1);\\n         reverse(nums,n-k,n-1);\\n         reverse(nums,0,n-1);\\n        \\n    }\\n}\\n\\n**********************************************************************************************************************\\nIf you did not understood the concept. You can read the concept below.\\n\\nThe main idea of the reversal algorithm is :\\nWe divide the given array into two parts. Lets say A = arr[0,.....k-1]  and B = arr[k,.....n-1].\\n\\nAlgorithm:\\n\\n1. Reverse A.\\n2. Reverse B\\n3. Reverse the whole array to get the desired result;\\n\\n\\nLets understand this with an example. For rotating the array k places towards left(anticlockwise)----->for clockwise(right rotattion) the solution is mentioned above. You can try coding for anticlockwise rotation using the concept described here.\\n\\narray = [1,2,3,4,5,6,7]   k=2\\n\\nA = [1,2] and B = [3,4,5,6,7]\\n\\nstep1: reverse A :  [2,1,3,4,5,6,7]\\nstep2.reverse B: [2,1,7,6,5,4,3]\\nstep3: reverse the whole array. \\n\\nResultant array = [3,4,5,6,7,1,2]\\n\\n\\n********************************************************************************************************\\nIf it helped you kindly please upvote. Thank You Happy coding\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    \\n    //This solution is solved using reversal algorithm.\\n    \\n    //function for reversing the array element in the specified range\\n    public void reverse(int arr[],int low,int high){\\n        while(low<high){\\n            int temp = arr[low];\\n            arr[low] = arr[high];\\n            arr[high] = temp;\\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1717742,
                "title": "c-2-approaches-easy-understanding",
                "content": "**APPROACH-1:**\\n\\n Takes extra space\\n\\n\\n\\t  \\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[(i+k)%n]=nums[i];\\n        }\\n        \\n        nums=res;  \\n    }\\n};\\n```\\n\\n**APPROACH-2:**\\n\\nEfficient approach , doesn\\'t take any extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int> &num,int low,int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(num[low],num[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```\\n\\nDo upvote this...: )",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[(i+k)%n]=nums[i];\\n        }\\n        \\n        nums=res;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverse(vector<int> &num,int low,int high)\\n    {\\n        while(low<high)\\n        {\\n            swap(num[low],num[high]);\\n            low++;\\n            high--;\\n        }\\n    }\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        reverse(nums,0,n-k-1);\\n        reverse(nums,n-k,n-1);\\n        reverse(nums,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709227,
                "title": "easy-c-solution-using-reverse-with-explaination",
                "content": "```\\n k=k%nums.size();\\n        // divide the array in two parts 0 to (length-k-1) AND length-k to length\\n\\t\\t// Eg. 1 2 3 4 5 6 7 if k=3 ans should be 5 6 7 1 2 3 4\\n        reverse(nums.begin(), nums.end()-k);// reverse the first half  4 3 2 1 , full array now- 4 3 2 1 5 6 7\\n        reverse(nums.end()-k,nums.end()); // reverse the second half 7 6 5  , full array now-  4 3 2 1 7 6 5\\n        reverse(nums.begin(), nums.end()); // reverse the whole array , full array now- 5 6 7 1 2 3 4\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n k=k%nums.size();\\n        // divide the array in two parts 0 to (length-k-1) AND length-k to length\\n\\t\\t// Eg. 1 2 3 4 5 6 7 if k=3 ans should be 5 6 7 1 2 3 4\\n        reverse(nums.begin(), nums.end()-k);// reverse the first half  4 3 2 1 , full array now- 4 3 2 1 5 6 7\\n        reverse(nums.end()-k,nums.end()); // reverse the second half 7 6 5  , full array now-  4 3 2 1 7 6 5\\n        reverse(nums.begin(), nums.end()); // reverse the whole array , full array now- 5 6 7 1 2 3 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676538,
                "title": "python-simple-reverse-solution",
                "content": "**Python :**\\n\\n```\\nclass Solution:\\n    def reverse(self, nums, start, end) -> None:\\n        while start < end: \\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        self.reverse(nums,0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverse(self, nums, start, end) -> None:\\n        while start < end: \\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n            \\n    def rotate(self, nums: List[int], k: int) -> None:\\n        k %= len(nums)\\n        self.reverse(nums,0, len(nums) - 1)\\n        self.reverse(nums, 0, k - 1)\\n        self.reverse(nums, k, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663260,
                "title": "python-solution",
                "content": "Python solution: \\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        nums.reverse()\\n        for i in range(k):\\n            nums.append(nums[i])\\n        nums[:] = nums[k:]\\n        nums.reverse()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        nums.reverse()\\n        for i in range(k):\\n            nums.append(nums[i])\\n        nums[:] = nums[k:]\\n        nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642621,
                "title": "faster-than-100-javascript-atleast-on-first-run",
                "content": "```\\nvar rotate = function(nums, k) {\\n    if(k === 0) return nums\\n    let rotations = k % nums.length\\n    let tempArr = nums.splice(nums.length - rotations, rotations)\\n    return nums.unshift(...tempArr)\\n};\\n```\\n\\nGet remainder of k % nums.length, to get rid of all full-rotations you would have to do for bigger values.\\n\\nTake out the amount of rotations you have remaining from the back of the nums array.\\nStore in temporary array with original order intact thanks to splice().\\n\\nInsert it all back into the front of the original array with the temporary array.\\n\\nNot sure if there are other test-cases I should\\'ve tested for, but pretty pumped I figured this out!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotate = function(nums, k) {\\n    if(k === 0) return nums\\n    let rotations = k % nums.length\\n    let tempArr = nums.splice(nums.length - rotations, rotations)\\n    return nums.unshift(...tempArr)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563149,
                "title": "c-o-n-solution-faster-than-99-67",
                "content": "```\\nvoid rotate(vector<int>& nums, int k) {\\n        k=nums.size()-k%nums.size();\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        reverse(nums.begin(),nums.end());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid rotate(vector<int>& nums, int k) {\\n        k=nums.size()-k%nums.size();\\n        reverse(nums.begin(),nums.begin()+k);\\n        reverse(nums.begin()+k,nums.end());\\n        reverse(nums.begin(),nums.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558449,
                "title": "java-100-faster-solution-easy-and-explained",
                "content": "# JAVA SOLUTION @DeepakKumar\\n# In Case of Any Doubt Feel Free to ASK ....\\n\\n ```\\n/*\\n        Array Rotation Using Reversal Algorithm\\n        Step 1: reverse the Array from indices 0 to length-1\\n        Step 2: reverse the Array from indices 0 to k-1\\n        Step 3: reverse the Array from indices 0 to length-1\\n\\n        Example:\\n           let  arr is --> [ 1, 2, 3, 4, 5 ]      k = 2\\n\\n           index -->     0   k-1  k  3  length-1\\n                       [ 1,  2,  3,  4,  5 ]\\n\\n            Reversing from 0 to length -1\\n                      We get     [5,4,3,2,1]\\n            Reversing from 0 to k-1\\n                      We get     [4, 5, 3, 2, 1]\\n            Reversing from k to length-1\\n                      We get     [4, 5, 1, 2, 3]   --> RESULTANT Rotated Array\\n         */\\n```\\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.length-1);\\n    }\\n\\n    static void reverse(int [] nums, int start, int end){\\n        // reversing the Array Using two pointer Method\\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n        Array Rotation Using Reversal Algorithm\\n        Step 1: reverse the Array from indices 0 to length-1\\n        Step 2: reverse the Array from indices 0 to k-1\\n        Step 3: reverse the Array from indices 0 to length-1\\n\\n        Example:\\n           let  arr is --> [ 1, 2, 3, 4, 5 ]      k = 2\\n\\n           index -->     0   k-1  k  3  length-1\\n                       [ 1,  2,  3,  4,  5 ]\\n\\n            Reversing from 0 to length -1\\n                      We get     [5,4,3,2,1]\\n            Reversing from 0 to k-1\\n                      We get     [4, 5, 3, 2, 1]\\n            Reversing from k to length-1\\n                      We get     [4, 5, 1, 2, 3]   --> RESULTANT Rotated Array\\n         */\\n```\n```\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        k = k % nums.length;\\n        reverse(nums, 0, nums.length-1);\\n        reverse(nums, 0, k-1);\\n        reverse(nums, k, nums.length-1);\\n    }\\n\\n    static void reverse(int [] nums, int start, int end){\\n        // reversing the Array Using two pointer Method\\n        while(start < end){\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529297,
                "title": "easyyyyyy-cpp-solution-with-picture-illustration",
                "content": "UPVOTE PLEASE \\uD83D\\uDE0A \\n\\n![image](https://assets.leetcode.com/users/images/64b42ea9-f49e-4978-bf98-dc799576a450_1634626183.3344586.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // a function to reverse from position lo to hi\\n    \\n    void reverse(vector<int>& n, int lo, int hi) {\\n        \\n        while(lo<=hi) {\\n            int t = n[lo];\\n            n[lo] = n[hi];\\n            n[hi] = t;\\n            lo++; hi--;\\n        }\\n        \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// what if k is greater than n? \\n        k = k%n;\\n        \\n        // reverse the whole array\\n        reverse(nums,0,n-1);\\n        \\n        // reverse the first k elements\\n        reverse(nums,0,k-1);\\n        \\n        // reverse rest of the (n-k) elenebts\\n        reverse(nums,k,n-1);\\n        \\n        \\n        // there u go!\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // a function to reverse from position lo to hi\\n    \\n    void reverse(vector<int>& n, int lo, int hi) {\\n        \\n        while(lo<=hi) {\\n            int t = n[lo];\\n            n[lo] = n[hi];\\n            n[hi] = t;\\n            lo++; hi--;\\n        }\\n        \\n    }\\n    \\n    void rotate(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n\\t\\t// what if k is greater than n? \\n        k = k%n;\\n        \\n        // reverse the whole array\\n        reverse(nums,0,n-1);\\n        \\n        // reverse the first k elements\\n        reverse(nums,0,k-1);\\n        \\n        // reverse rest of the (n-k) elenebts\\n        reverse(nums,k,n-1);\\n        \\n        \\n        // there u go!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515960,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int[] rotate(int[] nums, int k) {\\n        k = k % nums.length; //every number divisible by nums.length meaning it will go back to initial position, will only need to rotate  by the modulo\\n        reverse(nums, 0, nums.length - 1);  //reverse the whole array\\n        reverse(nums, 0, k -1); //reverse back the first k numbers to original order\\n        reverse(nums, k, nums.length  - 1); //reverse the remaining numbers  to original  order\\n        return nums;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while (start < end ){\\n            int  temp  = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] rotate(int[] nums, int k) {\\n        k = k % nums.length; //every number divisible by nums.length meaning it will go back to initial position, will only need to rotate  by the modulo\\n        reverse(nums, 0, nums.length - 1);  //reverse the whole array\\n        reverse(nums, 0, k -1); //reverse back the first k numbers to original order\\n        reverse(nums, k, nums.length  - 1); //reverse the remaining numbers  to original  order\\n        return nums;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while (start < end ){\\n            int  temp  = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1737179,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1564818,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1576312,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566763,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566543,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1569644,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567132,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565517,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567394,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565169,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1737179,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1564818,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1576312,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566763,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1566543,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1569644,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567132,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565517,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1567394,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1565169,
                "content": [
                    {
                        "username": "zerobrine",
                        "content": "who tf put case 38 in (5000+ long array) wtf"
                    },
                    {
                        "username": "Anshul29",
                        "content": "The TLE is the reason why this is put in medium and not easy (constraints say array length can be up to 10000)."
                    },
                    {
                        "username": "Yunhans",
                        "content": "I cannot agree with you more, I shall pass it an hour earlier if there is no test case 38."
                    },
                    {
                        "username": "HolyArseny",
                        "content": "lmao"
                    },
                    {
                        "username": "rushilShandilya",
                        "content": "Yeah the question could have been solved a simple 2 for loop"
                    },
                    {
                        "username": "xruzty",
                        "content": "Let the array be - 123456789 and k = 4\\n\\n\\n*Step 1* -  **12345** 6789  --->  **54321** 6789\\n\\n*Step 2* -  54321 **6789**  --->  54321 **9876**\\n\\n*Step 3* -  **543219876**    --->   **678912345**\\n\\n\\n> 678912345 !!"
                    },
                    {
                        "username": "imninad_99",
                        "content": "[@Rajeev_code](/Rajeev_code) \\nbruh put this condition....k =k% nums.size()....and it will work"
                    },
                    {
                        "username": "Saitama109",
                        "content": "[@Rajeev_code](/Rajeev_code)  if(k >= nums.size()) k = k%nums.size();\\nput that line and it should work.."
                    },
                    {
                        "username": "kdz",
                        "content": "Thank you! But for me I think this order is more understandable\\n\\nLet the array be - 123456789 and k = 4\\n\\nStep 1 reverse all - 123456789 ---> 987654321\\n\\nStep 2 split - 9876 54321 \\n\\nStep 3 reverse parts - 9876 54321 ---> 6789 12345"
                    },
                    {
                        "username": "Rajeev_code",
                        "content": "what if k is greater than the length of array?"
                    },
                    {
                        "username": "allenabraham999",
                        "content": "Adipoli\\n"
                    },
                    {
                        "username": "sourguyjunk",
                        "content": "Why does this method work?"
                    },
                    {
                        "username": "Codelance",
                        "content": "I found the video for the same approach.\\n\\nhttps://www.youtube.com/watch?v=ENcnXXiRT6E"
                    },
                    {
                        "username": "popov-andrei",
                        "content": "genius!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "kooskoos",
                        "content": "This post assumes you have already explored the reversing based solution which pretty much says:\\nFor k=2\\n**12345** -> **54321**\\n**54**321->**45**321\\n45**321**->45**123**\\n\\nSo why does this work?\\n\\nLet us understand the significance of k. k is nothing but a pivot point. \\nWhat this means is, in case of 12345 with k = 2, your pivot point lies at 123|45.\\n\\nWe want to rotate the entity along the pivot point. For simplicity let us denote either sides of pivot point as single entities as **X|Y** where X = 123 and Y = 45.\\n\\nWhen we are done rotating the aggregate entity it looks something like **Y|X**.\\nLet us now understand why this tranlates to reversing the entire array. The crucial thing we will try to understand here is why irrespective of where the pivot point lies, we alwasys have to reverse the array.\\n\\nThe answer for this is irrespective of where you keep the pivot point the reverse always fetches the same result. Let us try to understand this. When we say reverse by default we mean mirror from the mid point.\\n\\n12|34 -> 43|21\\n\\nBut what else is possible? Does it still fetch the same result when mirror point is changed? Let\\'s observe\\n\\n1|234 -> 432|1\\n\\nWow, why did this happen? We can understand this by adding additional padding on the lighter side and always positioning the mirror at the center. The same string can be returned as:\\n\\n001|234 -> 432|100\\n\\nYou can alwasys balance the sides with padding resulting in the same result. So complete reverse across any pivot points fetches the same result. That is all character end up changing sides. Think about it.\\n\\nNow that we have converted **X|Y** to **Y\\'|X\\'**, we know in the process we ended of mirroring contents of X and Y as well. \\nWhere Y\\' means Y reverse\\nand      X\\' means X reverse\\nSo in the next step we mirror them back to get the same configuration like below.\\n\\nIn reverse 1, X transformed this way 123 -> 321, we do not desire this transformation.\\nSo to fix it we use:\\nMirror(reverse)+Mirror(reverse) -> Original\\n\\nSo we reverse X and Y individually again.\\nSo X again transforms 321 -> 123\\n\\nAnd we get our answer 123|45 -> 45|123\\n\\nHope this was helpful. Happy learning :)"
                    },
                    {
                        "username": "rabeeh",
                        "content": "I wonder what does it mean to rotate a vector for K greater than the length of the word? can someone explain?"
                    },
                    {
                        "username": "younusandali",
                        "content": "[@hamdinahdi2](/hamdinahdi2)  if there is case where k==length of an array then in that case it makes no sense to rotate the array right bcoz we will end up with the same array as original one similarly if k is a multiple of length of an array again we will get the same array . Therefore we are doing here k=k%nums.size() bcoz we are only bother about the remainder.\\n"
                    },
                    {
                        "username": "balajigarray",
                        "content": "[@princesahu169](/princesahu169) why ? \\n"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "[@hamdinahdi2](/hamdinahdi2) even that gives TLE"
                    },
                    {
                        "username": "Rimanagi",
                        "content": "k % len(nums)"
                    },
                    {
                        "username": "hamdinahdi2",
                        "content": "[@Harsh__Sharma](/Harsh__Sharma)  \\ncould you explain what\\'s the point of this line ?\\nDo k=k%nums.length;\\n\\n\\n"
                    },
                    {
                        "username": "princesahu169",
                        "content": "if k is greater then size  we are going to treat as circular"
                    },
                    {
                        "username": "Harsh_____Sharma",
                        "content": "Do k=k%nums.length;"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@sadman_mehedi](/sadman_mehedi) thanks buddy"
                    },
                    {
                        "username": "sadman_mehedi",
                        "content": "You should do k%=nums.size..Because think when k==nums.size() means ultimately you will get your first array back..So it doesnot matter..Only remainders value will affect it."
                    },
                    {
                        "username": "SkarabeyDM",
                        "content": "k %= length"
                    },
                    {
                        "username": "thisisnotanton",
                        "content": "var rotate = function(nums, k) {\\n    nums = nums.concat(nums.splice(0, k+1));\\n};\\n\\nthis works on other websites."
                    },
                    {
                        "username": "spamf",
                        "content": "Apparently part of the description is the result MUST be in-place. The return value is ignored. The assertions are executed against the original `nums` value.\\n\\nAssigning `nums` inside the function won\\'t change the caller reference. And since `Array.concat()` creates a new array value the result won\\'t be visible for the caller to verify."
                    },
                    {
                        "username": "_bolu_",
                        "content": "The index wrapping should be explicitly stated problem description.\\n\\nSolve by adding this line before your computations:\\n\\nk = k % len(nums)"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "even that giving TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "No it shouldn\\'t. Thats a part of the problem that makes it tougher. It is up to you to figure it out "
                    },
                    {
                        "username": "roshankannaujiya9",
                        "content": "Got your point. will need less loops as array will reset to original if n==k, only need mod value shift. but still not working for me. Getting time limit exceed at last test case."
                    },
                    {
                        "username": "rohit_2345",
                        "content": "why this condition?"
                    },
                    {
                        "username": "RezaEivazzadeh",
                        "content": "\\tbreak_point = (len(nums) - k) % len(nums)\\n\\tnums[:] = nums[break_point:] + nums[:break_point]"
                    },
                    {
                        "username": "Ninjabdul",
                        "content": "my first thought, however it doesn\\'t feel like an true inplace solution since we are creating a copy"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/rotate-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Extra Array\n\n  \n**Approach 3:** Using Cyclic Replacements\n\n  \n**Approach 4:** Using Reverse\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "vamsi_krishna_reddy",
                        "content": "![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879510.png)\\n![image](https://assets.leetcode.com/users/vamsi_krishna_reddy/image_1561879437.png)\\n\\n\\nconsole.log is giving the rotated array... but the return is returning only nums ...why?"
                    },
                    {
                        "username": "suryathink",
                        "content": " Do not return anything, modify nums in-place instead.\\n\\nyou have to modify nums array only."
                    },
                    {
                        "username": "sanket2714",
                        "content": "reverse(nums.begin()+(nums.size()-k),nums.end());\\nreverse(nums.begin(),nums.end()-k);\\nreverse(nums.begin(),nums.end());"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    }
                ]
            },
            {
                "id": 1749563,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567774,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1568187,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567911,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1783664,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1566273,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1710887,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1688955,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1576581,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1567910,
                "content": [
                    {
                        "username": "Zenpy",
                        "content": " size = len(nums)\\n x = nums[size- k:]\\n nums = x + nums[: size - k]\\n\\nthis code working on the vscode, pycharm perfectly, but not on leetcode.  even if: input nums = [1, 2, 3, 4, 5, 6] , and in side the coding part, i state , nums = [0 , 0 ,0 ]  and run the code, leetcode says, your output is [ 1, 2, 3, 4, 5, 6] but it should be bla bla....  even intentionally I am making it working, but now showing the exact wrong.  and when its runnig perfectly on other editor, don\\'t run on leedcode."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "lmao facing the exact same prob\\n"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "Beaconsyh08",
                        "content": "\\tk = k % len(nums)\\n\\tif k > 0:\\n\\t\\tnums[:k], nums[k:] = nums[-k:], nums[:-k]\\n\\nJust slice the list.\\nUsing module to avoid modification when k is larger than the length of list."
                    },
                    {
                        "username": "kathandra",
                        "content": "    var rotate = function(nums, k) {\\n      nums = nums.slice(k, nums.length).concat(nums.slice(0, k));\\n    };\\n\\nInput: [1,2], 1\\nOutput:[1,2]\\nExpected:[2,1]\\n\\nBut real output is [2, 1]!  Whats wrong?"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "I am very happy because I was able to do my first task at medium level. Good luck, bro, u are super star)."
                    },
                    {
                        "username": "alamicrodev",
                        "content": "Congrattttts!!! wohooooo"
                    },
                    {
                        "username": "summerson",
                        "content": "here is a case:\\n[1, 2]\\n3\\nand result as [2,1]\\nbut K is bigger than nums.length, and I think the result should be [1,2], as discribe in problem.\\n[1,2,3,4,5,6,7] K =3.\\nthen we put 1234 to right side, and 567 to left, the operation which means that we put numbers 1 to k to right , and put  after length -k  to right.\\n\\nso when K is bigger than nums.length, we should put all the array numbers to right. and new array should be the same to the origin one. \\n\\nso why that case rotated?"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "I know this comment is 4 years old, but I\\'ll throw my thoughts out there anyway.  When k is bigger than the length of the array, I took that to mean that you just keep cycling around over and over until you\\'ve been able to shift the appropriate number of times.  So, in the case of [1, 2], if you were to shift right 1 place, your array would be [2, 1].  If you were to shift right 2 places, then you would be back to [1, 2] again.  Since the 1 can \"loop around\" to the front of the array once, I see no reason why it couldn\\'t do it multiple times.  In fact, I believe there was another test case where the array was [1, 2] and the k value was 5, so it would loop around multiple times.\\n\\nI was getting hung up on these 2-value arrays, so in the end I just added an extra IF statement that checked if the nums.length was 2.  If it is, then it checks if k is odd or even.  If k is even (k % 2 == 0), then it just returns since you\\'ll end up with the original array with any k value that is even.  If k is odd, then it flips the array values around and returns.  (I wrote my solution in Java.)"
                    },
                    {
                        "username": "sha443",
                        "content": "When I run my code locally, it shows the correct answer. But shows different answer on leetcode. Why?\\n\\nInput:\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\n\\nLocal PC output: [5,6,7,1,2,3,4]\\nLeetcode Output: [1,2,3,4,5,6,7]\\n\\nSorry to paste the code here.\\n\\n    def rotate(self, nums, k):\\n\\n        l = len(nums)\\n        copy = []\\n        if k > l: k -= l\\n\\n        copy[0:l-k] = nums[k:]\\n        copy[l-k:] = nums[0:k]\\n\\n        return copy"
                    },
                    {
                        "username": "krasivan93",
                        "content": "Because you are returning a new array, but you have to modify the original one"
                    },
                    {
                        "username": "bizco8",
                        "content": "same"
                    },
                    {
                        "username": "Heet_Ankola",
                        "content": "`int n=0;`\\n`        for(int i=0;i<k;i++){`\\n`            n=nums[nums.length-1];`\\n`            for(int j=nums.length-1;j>0;j--){`\\n`              nums[j]=nums[j-1];`\\n`            }`\\n`           nums[0]=n;`\\n\\n\\nwhat\\'s the issue or what i\\'m doing wrong coz it didn\\'t passesed the last test case.\\uD83D\\uDE25"
                    },
                    {
                        "username": "apoorv-5369",
                        "content": "The time limit will exceed in the last test case because the value of \\'k\\' is big and the time complexity of this code is O(k*n). While the approach is fine but won\\'t work as the value of \\'k\\' increases."
                    },
                    {
                        "username": "prushikesh",
                        "content": "this code is only used for shift one element at a time and one more think is you do not run loop k times only you have to shift whole array k times so that is the reason your program did not pass the test case"
                    },
                    {
                        "username": "shrawank22",
                        "content": "I think you should replace nums.length with nums.size(), since vector is passed as function parameter and std::vector has no member named  \\'length\\'. So just replace where ever you have written nums.lenght()"
                    },
                    {
                        "username": "letmewrite",
                        "content": "Hi,\\n\\nThe attached solution I have built. In the second screenshot, it is displaying correct output for second Test case but while submitting the solution is failing. Can any one please take a look and let me know what I am missing here. Thank you\\n\\n![image](https://assets.leetcode.com/users/images/82bb5bb2-7870-4e22-b495-ec65c12c7cc7_1649104330.3177848.png)\\n![image](https://assets.leetcode.com/users/images/59b78984-6f78-456d-82e2-d9c22821140b_1649104334.3844523.png)\\n"
                    },
                    {
                        "username": "ninachen01",
                        "content": "when the input is [1,2], 1, the expected result is [2,1].\\nWhen the input is[1,2,3], 1, the expected result should be [2, 3, 1], however it is [3,1,2]. Now I am confused about what rotation means? Doesnt it mean shift the first element to the last slot, and move the second to be the first?"
                    },
                    {
                        "username": "Coder0622",
                        "content": "Rotate means place the last element in the first spot, k amount of times. "
                    }
                ]
            },
            {
                "id": 1566408,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1565946,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1568788,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1570644,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1574819,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1990408,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1569717,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1573089,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1572666,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1571855,
                "content": [
                    {
                        "username": "mlikhar3",
                        "content": "\\n        k = k%len(nums)\\n        nums[:] = nums[-k:]+nums[:-k]\\n"
                    },
                    {
                        "username": "Freezen",
                        "content": "If you are using python to solve this problem, the OJ is not expecting your function to return anything, so just write your new result back into the original array"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "g_a_t_r_i_x_12",
                        "content": "\\'\\'\\' for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\'\\'\\'"
                    },
                    {
                        "username": "alanlfc273",
                        "content": "Doesn\\'t work for the huge test case. Time out"
                    },
                    {
                        "username": "user3954J",
                        "content": "I am trying python solution to modify num in place. \\nWhen I give print (nums[(k+1):]+nums[:(k+1)]), it is giving solution as expected but not modifying nums.\\nWhen I do \"Run Code\", \\'nums\\' output are not changed\\nWhat wrong I am doing here?\\n\\n\"\"\"\\nnums = nums[(k+1):]+nums[:(k+1)]\\n\\n\"\""
                    },
                    {
                        "username": "hassan12ammar",
                        "content": "you can\\'t just change the whole list at once, you have to change one element at a time."
                    },
                    {
                        "username": "sha443",
                        "content": "Try reversing the array, apply your logic on this [-1,-100,3,99]"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "What the hell is the meaning of 38/38 test case passed and last executed input was none and TLE. wtd\\n"
                    },
                    {
                        "username": "user6547D",
                        "content": "\\'\\'\\'\\nnums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\\n\\'\\'\\'\\n\\nassuming k <= len(nums), we find the starting position of elements to shift from the back and add it to the first part of the list."
                    },
                    {
                        "username": "thequinn",
                        "content": "\\tvar rotate = function(nums, k) {\\n\\t  let arr1 = nums.slice(nums.length - k, nums.length);\\n\\t  let arr2 = nums.slice(0, nums.length - k);\\n\\t  return arr1.concat(arr2);\\n\\t}\\n\\nNewbie here.....Any idea why my code works on my PC but not here?"
                    },
                    {
                        "username": "Md-RH-Maruf",
                        "content": "you should modify the \"nums\" array, no need to return new array"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The function return type is void so it\\'s expected that the actual array nums is modified"
                    },
                    {
                        "username": "JacquelineQi",
                        "content": "Hi did you figure out why this happened? I\\'m having the same issue."
                    },
                    {
                        "username": "dmtrr",
                        "content": "def rotate(nums, k)\\n  k.times { |r| nums.unshift(nums.pop) }\\nend"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "'rotation' is never defined in the question description. The single example given isn't enough to define what it means to 'rotate'.\n\nWhat happens if K > n? What happens if K=0? What if K is negative.\n\nCan someone give a formal defintion of rotation. I can't solve a badly defined question."
                    }
                ]
            },
            {
                "id": 1569005,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1955277,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1782449,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1704032,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576984,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576950,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1576934,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1574489,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1573724,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1573176,
                "content": [
                    {
                        "username": "lishubing",
                        "content": "    nums[:] = nums[-k % len(nums):]+nums[:-k % len(nums)]"
                    },
                    {
                        "username": "nraymundipinheiro",
                        "content": "I got to a \"solution\" where I printed `nums` at the end of the function and all of my print statements were exactly like the expected output, only my output considered for grading displayed that no rotations were made. I programmed this in Python3. This is what I coded in the function:\n\n```\nwhile k > 0:\n    temp = nums.copy()\n    temp[0] = nums[-1]\n    temp[1:] = nums[:-1]\n\n    nums = temp.copy()\n    print(nums)\n    k -= 1\n        \nprint(nums)\n```\nI know it isn't the best approach (and I have since found a better solution that works), but I'm still curious to know why it's not considering `nums` to be the right answer even though, when I print it out, I get the right answer. I'm assuming it has to do with modifying it locally---I'm not an expert in Python so I don't know if I just goes back to being whatever it was before lol. I'd appreciate some help."
                    },
                    {
                        "username": "zaknev",
                        "content": "did a similar solution and obtained the same problem\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums = a\n        print(a)\n\nwhen printing a it gives the correct answer but nums just stays the same but then i found a solution on stackoverflow wich is to change nums to nums[:]\n        size = len(nums)\n        k = k % size\n        k = size - k\n        a = nums[k:] + nums[:k]\n        nums[:] = a\n"
                    },
                    {
                        "username": "RealOkabe",
                        "content": "Once again, the time limit exceeds after 4 seconds. This sucks."
                    },
                    {
                        "username": "chandraketyadav505",
                        "content": " Why my code is not working?\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n):\\n            ans[(k+i)%n] = nums[i]\\n        nums = ans"
                    },
                    {
                        "username": "SHAHAREYAR_HOSSAIN",
                        "content": "try this \\nfor i in range (n) :\\nnums[i] = ans[i]"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n\\n"
                    },
                    {
                        "username": "sh_77074",
                        "content": "![image](https://assets.leetcode.com/users/images/80fca6fa-6ca4-4aaf-ad95-2e9321003963_1656098641.1384192.png)\\n"
                    },
                    {
                        "username": "dragon13",
                        "content": "\\tfunction rotate(&$nums, $k) {\\n\\t\\treturn $nums = array_merge(array_splice($nums,($cnt=count($nums))-($k %$cnt)),$nums);\\n\\t}"
                    },
                    {
                        "username": "abhi6689",
                        "content": "\\'\\'\\'\\n        for i in range(k):\\n            nums.insert(0,nums[-1])\\n            nums.pop()\\n\\'\\'\\'"
                    },
                    {
                        "username": "zjplab",
                        "content": "At first, I don\\'t understand this method on the editorial board either partly because the original proof is basicially bullshit. It took me a morning to think about this problem and posted some doubts math stackexchange. [Later some number theory expert solved my doubts](https://math.stackexchange.com/questions/3429899/traverse-an-array-with-step-k/3430325#3430325). \\n\\nDenote:\\n* `n=nums.size()`\\n* d=gcd(k,n)\\n\\n\\n**How many k-steps at least does it take to get back where you start? **\\n\\nThe answer is c=n/d times k-step\\n\\n**Well, we start from 0, and then 1,2... to do k-step jump, will they collide?**\\n\\nIt\\'s possbile. But in order to collide. Assume your two start position is i1 and i2. i1 and i2 have to statisfy d | (i1-i2) (d divides their difference). \\n\\nFor example, if (k,n)=1 (if k and n are co-prime, i.e., they have max comon divisor of 1). Then you start from position 0 and can get to every other position. In the program, count will reach nums.size() and the whole procesure stops before it gets wrong, perfect.\\n\\nBut if (k,n)>1. Let\\'s say we have array of size 8, k=4. gcd(4,8)=4. Then obviously you can check to find you have to start from 0,1,2,3 separately to traverse every element. In this case the interval is 1< gcd(j,n)=4. No collision can occur."
                    }
                ]
            },
            {
                "id": 1572523,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1572431,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1572350,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571398,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571400,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571399,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1576672,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1575642,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1574089,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 1571397,
                "content": [
                    {
                        "username": "VickieYan",
                        "content": "var rotate = function(nums, k) {\\n    nums.unshift(...nums.splice(nums.length - k))\\n};"
                    },
                    {
                        "username": "oyoondal",
                        "content": "\\tdef rotate(self, nums, k):\\n\\t\\tfor _ in range(k):\\n\\t\\t\\tnums.insert(0,nums.pop())"
                    },
                    {
                        "username": "sjBao",
                        "content": "/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\n\\n// assumming that javascript garbage collection removes memory allocation as soon as the array is spliced, this solution is O(1) and not O(k) because for every k blocks of memory allocated, we are removing that amount from nums.\\n\\nvar rotate = function(nums, k) {\\n    let pos = (k % nums.length)\\n    let n = nums.splice(nums.length - pos)\\n    nums.splice(0, 0, ...n)\\n};"
                    },
                    {
                        "username": "handsomeOne",
                        "content": "var rotate = function(nums, k) {\\n\\n    k %= nums.length;\\n    [].unshift.apply(nums, nums.splice(nums.length - k, k));\\n\\n};"
                    },
                    {
                        "username": "rainhu",
                        "content": "it appears that the k = k % n when k>n from the cases."
                    },
                    {
                        "username": "ishmnnit",
                        "content": "My Python code is -\\n\\n    def rotate(self, nums, k):\\n        nums = nums[::-1][:k%len(nums)][::-1] + nums[::-1][k%len(nums):][::-1]\\n        print nums\\n\\nWhen I submitted my solution\\n\\nYour stdout\\n[5, 6, 7, 1, 2, 3, 4]\\nYour answer\\n[1,2,3,4,5,6,7]\\n\\nHow can It is possible ? . It seems any change I made in this function is not reflected in the\\nmy answer."
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Full explanation C++ || Python || JavaScript || Java solution:\\nhttps://www.nileshblog.tech/2022/04/24/leet-code-rotate-array-c-python-javascript-java-solution/\\n"
                    },
                    {
                        "username": "bogdan90",
                        "content": "Everyone just copies the best solution and claims it! WHAT THE HELL"
                    },
                    {
                        "username": "oktayibis",
                        "content": "var rotate = function(nums, k) {\\n    let length = nums.length;\\nlet removedFromArray = nums.splice(length - k,k)\\nnums.unshift(...removedFromArray)\\n    \\n};"
                    },
                    {
                        "username": "Irving_cl",
                        "content": "I got error with an input: [1, 2], k = 3.\\n\\nI don't understand why the expected output is [2, 1]. I saw some solutions. They all did\\n\\n `'k = k % num.size()`'. \\n\\nWhy? What does that mean\\uff1f"
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right?\\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up).\\n\\nHope that helps!"
                    }
                ]
            },
            {
                "id": 2072457,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2064220,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2060082,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2059111,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2057847,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2056136,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2049672,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2046527,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2044804,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2043830,
                "content": [
                    {
                        "username": "webbrother",
                        "content": "Why leetcode dont accept this solution?\\n\\n```javascript\\nvar rotate = function(nums, k) {\\n    k = k % nums.length;\\n\\n    for (let i = 0; i < k; i++) {\\n      nums.unshift(nums.pop());\\n    }\\n\\n    return nums;\\n};\\n```"
                    },
                    {
                        "username": "obireddyharshavardhanreddy",
                        "content": "nums=nums[:k]+nums[k:]  \\nwhy this is not working?"
                    },
                    {
                        "username": "bprashant782",
                        "content": "Can someone identify the problem with my code, its throwing runtime error.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k%n;i++)\\n        {\\n            int temp=nums[n-1];\\n            nums.insert(nums.begin(),temp);\\n            nums.erase(nums.end());\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "user3717al",
                        "content": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n    }\n};\n\nthis code is running correctly on my PC but I'm getting wrong testcase on LC for:\nnums =[1,2,3]\nk =1\nOutput:  [2,1,2]\nExpected:  [3,1,2]\n\nBut after using another vector and performing insert and erase I'm getting correct TCs\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        vector<int>temp=nums;\n        temp.insert(temp.begin(),temp.end()-k,temp.end());\n        temp.erase(temp.end()-k,temp.end());\n        nums=temp;\n    }\n};\nWhy was I getting wrong TCs on first code?"
                    },
                    {
                        "username": "SuperCodeur2000",
                        "content": "Hello I am new on leetcode and i was wondering if my solution is correct or there we are limited in the fonctions that we can use to resolve a problem ?\\nThank you\\n\\n\\nnums = [1,2,3,4,5,6,7]\\nk = 3\\nb=[]\\n\\na=len(nums)\\n\\n\\nc=len(nums)-k\\nx=0\\nwhile(x<c):\\n    b.append(nums[x])\\n    x=x+1\\n    \\ni=-1\\nh=k\\ny=0\\nwhile y<h:\\n        \\n    b.insert(0,nums[i])\\n    y=y+1\\n    i=i-1\\n\\n\\nfor i in b:\\n    print(i)"
                    },
                    {
                        "username": "Yuvarraj-S",
                        "content": "will anyone explain why this doesn\\u2019t work \" arr = list(nums[-k::]+nums[:len(nums)-k:])\""
                    },
                    {
                        "username": "kakran56",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int x=nums.size()-1;\\n        for(int j=0;j<k;j++)\\n        {int temp=nums[x];\\n        for(int i=x-1;i>=0;i--)\\n        {\\n            nums[i+1]=nums[i];\\n\\n        }nums[0]=temp;\\n            \\n\\n        }\\n        \\n    }\\n};\\nwhy in this time limit is being exceeded . and can you tell how cAN I OPTimize it\\n"
                    },
                    {
                        "username": "nodirbekrejabaliyev",
                        "content": " When I RUN my code on the IDLE python, it is working \\nBut if I run it on the leedcode it is not working \\n\\nnums=nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]"
                    },
                    {
                        "username": "Likith_Codebook369",
                        "content": "why can\\'t we use index slicing for this problem?\\ntemp=nums[:k+1]\\nnums=nums[k+1:]+temp"
                    },
                    {
                        "username": "Anshul29",
                        "content": "maybe we can like this (not sure what array[:k] means because i dont use python:\\ntemp=nums[:k]\\nnums=nums[nums.length-k:]+temp"
                    },
                    {
                        "username": "user2229xH",
                        "content": "For Golang functions, when we have slice in the parameters, it would be a lot better to return a slice rather than expecting the input slice to be modified.  "
                    }
                ]
            },
            {
                "id": 2043037,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2041259,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2037594,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2036097,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2035298,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2029994,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2027648,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2027478,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2026895,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2025598,
                "content": [
                    {
                        "username": "GiulianoV",
                        "content": "My code works in a separate IDE, but not in leetcode. The only difference between my code in the IDE is my function returns the value of num, but that is only because i have to print out the solution in the terminal. In leetcode, i just set the value of num to the solution, but the solution is different than my IDE\\'s solution. Any ideas why?"
                    },
                    {
                        "username": "Nick2440",
                        "content": "why doesn\\'t this work? i\\'m certain the logic is correct\\n\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [nums[-1]] + nums[:-1]\\n```\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "This one was a lot harder than rotating a linked list, not sure why"
                    },
                    {
                        "username": "ShivnathTathe",
                        "content": "    class Solution(object):\n        def rotate(self, nums, k):\n            z = nums[:len(nums)-k]\n            b = nums[len(nums)-k:]\n            man = b+z\n            return man\nwhy my code is not working? please help me!"
                    },
                    {
                        "username": "M_sarwar",
                        "content": "stuck at [-1] and k = 2 case , help me . "
                    },
                    {
                        "username": "DeepakAM",
                        "content": " `var rotate = function(nums, k) {\\n    const numLen = nums.length;\\n\\n    if(k > numLen){\\n        k = k % numLen;\\n    }\\n\\t\\t\\n    return [...nums.slice(k+1), ...nums.slice(0,k+1)];\\n};`\\n\\nwhy this doesn\\'t work. i checked in jsfiddle it works. Please tell if something is wrong in this solution."
                    },
                    {
                        "username": "mynameisshrish",
                        "content": "   while(k!=0):\\n            l=nums.pop()\\n            l=[l]\\n            # print(l)\\n            nums=l+nums\\n            # print(nums)\\n            k=k-1\\n\\nIn this code i am changing the nums list but the output for first test case is showing as [1,2,3,4,5,6]. i.e the state of the list when only the last element is popped. I used print statements to debug it and the nums is printing as the expected value. Now why is my main nums is not getting changed."
                    },
                    {
                        "username": "kevindflowright",
                        "content": "You can use deque to solve the problem "
                    },
                    {
                        "username": "martha1705",
                        "content": "wtf is this question, took so long for this piece of shit!!\\n"
                    },
                    {
                        "username": "tanuj_kumar_001",
                        "content": "Why my code is not accepted stille its showing that all 38/38 test case passsed \n`\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        ArrayList<Integer> ar = new ArrayList<>();\n\n        for(int i : nums){\n            ar.add(i);\n        }\n        if(k==0){\n            return;\n        }\n        for(int i = 0;i<k;i++){\n                int size = ar.size();\n                int last = ar.get(size-i-1);\n                ar.add(0,last);\n        }\n        for(int i  = 0;i<nums.length;i++){\n            nums[i] = ar.get(i);\n        }\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 2024602,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2015754,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2009311,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2008045,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 2002384,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1999297,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1998505,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1997302,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1995442,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1994744,
                "content": [
                    {
                        "username": "rtanishka",
                        "content": "Why this code is showing one extra rotation?\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& arr, int k) {\\n    int n = arr.size();\\n    int temp[k];\\n  for (int i = 0; i < k; i++)\\n  {\\n    temp[i] = arr[i];\\n  }\\n  for (int i = 0; i < n - k; i++)\\n  {\\n    arr[i] = arr[i + k];\\n  }\\n  for (int i = n - k; i < n; i++)\\n  {\\n    arr[i] = temp[i - n + k];\\n  }\\n    }\\n};"
                    },
                    {
                        "username": "nipunagarwal322",
                        "content": "Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\n\\nwhat does this error mean ?"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Please tell me the problem in my code. It is working fine for given test case.\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        k=k%n;\\n        if(k==0) return;\\n        int temp = nums[n-k-1];\\n        int j=n-k,i=0;\\n        while(j<n)\\n        {\\n            nums[j-1]=nums[i];\\n            nums[i]=nums[j];\\n            i++;j++;\\n        }\\n        nums[n-1]=temp;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "yawen50424",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int number;\\n        int size=nums.size();\\n        k = k % size;\\n        vector<int>::iterator h;\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        // cout<< endl;\\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\\n        // for(h=nums.begin();h!=nums.end();h++)\\n        //     cout<< *h << \"  \" ;\\n        nums.erase(nums.end()-k,nums.end());\\n    }\\n};\\n\\nWhen code run the question about nums=[1,2,3] ,k=3\\nwhy the answer output = [2,1,2]  in my code???\\n"
                    },
                    {
                        "username": "HarshitUpadhyay",
                        "content": "how does my solution is wrong  \\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int t=0;\\n        int [] arr=new int[nums.length];\\n        for(int i=k;i>=0;i--){\\n            arr[t]=nums[i];\\n            t++;\\n        }\\n        for(int j=nums.length-1;j>k;j--){\\n            arr[t]=nums[j];\\n            t++;\\n        }    \\n        for(int l=arr.length-1;l>=0;l--){\\n            System.out.print(arr[l]);\\n        }    \\n        \\n    }\\n}"
                    },
                    {
                        "username": "__ro",
                        "content": "This is for anyone who is trying to do this in the fastest time, not considering space.\\nHint: Try using deque, it will pay dividends when array length is huge. And the solution will have time complexity of O(2n+(k%len(nums))) == O(n) and space complexity of O(n)."
                    },
                    {
                        "username": "Prince__1",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& arr, int d) {\\n        int n=arr.size();\\n        d = d % n;\\n        int y=n-d;\\n        reverse(arr.begin(),arr.begin()+y);\\n        reverse(arr.begin()+y,arr.end());\\n        reverse(arr.begin(),arr.end());\\n    \\n\\t     \\n\\t        \\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pavangowdasn",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        return nums[len(nums)-k:len(nums)]+nums[0:len(nums)-k]\\nwhats wrong in this code\\n"
                    },
                    {
                        "username": "ajitsai",
                        "content": "Can anyone explain me why does this code work?\nk = k % len(nums)\nnums = nums[-k:]+nums[:-k]"
                    },
                    {
                        "username": "bhavik13",
                        "content": "Can anyone tell me why this is working but last code is not working , what the difference between these two  codes.\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+(n-k));\\n        reverse(arr.begin()+(n-k), arr.end());\\n        reverse(arr.begin(), arr.end());\\n\\n\\nWhy this is not working?\\n        int n = arr.size();\\n        k = k % n;\\n        reverse(arr.begin(), arr.begin()+k+1);\\n        reverse(arr.begin()+k+1, arr.end());\\n        reverse(arr.begin(), arr.end());"
                    }
                ]
            },
            {
                "id": 1990421,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1989384,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1985169,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1984556,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1984279,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1981254,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1981008,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1980793,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1980177,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1978922,
                "content": [
                    {
                        "username": "aviii24x7",
                        "content": "class Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n            \\n        a=nums[:-k]\\n        b=nums[-k:]\\n        nums=b+a\\n\\n\\n\\nWHY this shows that nums is still same while in other editor nums is perfect!!!!"
                    },
                    {
                        "username": "rahul__mishra",
                        "content": "Why is below not acceptable solution in java\\npublic void rotate(int[] nums, int k) {\\n     int arr[] =new int[nums.length];   \\n      for(int i=0;i<nums.length;i++){\\n          if(k>0){\\n         arr[i]=nums[nums.length-k];\\n         k--;\\n      }\\n       else{\\n          arr[i]=nums[0-k];\\n          k--;\\n      }\\n      }\\n    nums=arr;\\n    }"
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "TLE for 38 testcase, why? even I am using k%l"
                    },
                    {
                        "username": "akshat90",
                        "content": "I dont understand whats wrong with my solution\\n `if len(nums) > 2: nums[:] = nums[-k:] + nums[:len(nums)-k]`\\nthe test case [1,2[ fails on this console, but works as expected on my local pc"
                    },
                    {
                        "username": "ROHAN_RAJ123",
                        "content": "Use the concept of cyclic shifting means\\nshift array of elements based on the formulae\\ntemp[(i+k)%nums.length] = nums[i]\\nafter that every elements will move k times and after n-1 th index it will perform cyclic shifting"
                    },
                    {
                        "username": "studyworkhours",
                        "content": "who the world can answer nums[1,2] and k =3 should output as [2,1] and not [1,2]"
                    },
                    {
                        "username": "bishwasxdgautam",
                        "content": "var rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n     nums.unshift(nums.pop())\\n    }\\n    return nums  \\n};\\nlet array = [1,2,3,4,5,6,7]\\nlet k = 3\\nconsole.log(rotate(array,k))\\nit says time limit exceeded, why is that?"
                    },
                    {
                        "username": "riyazzzzzz",
                        "content": "print(nums[-k:]+nums[:k+1])\\n does this work??\\ni m actually new so idk"
                    },
                    {
                        "username": "shakilofficial0",
                        "content": "Can Anyone Explain Why this code is not working?\\n\\n ```\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        p1 = nums[len(nums)-k:]\\n        p2 = nums[0:len(nums)-k:]\\n        return p1+p2\\n\\n```"
                    },
                    {
                        "username": "Tiantian2020",
                        "content": "Why Arrays.copyOf() and conle did not work in this solution?"
                    }
                ]
            },
            {
                "id": 1978792,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1978060,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1973220,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1971281,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1971252,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1965079,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1964577,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1962944,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1958740,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1954006,
                "content": [
                    {
                        "username": "Simo_Ben_Eckert",
                        "content": "Somone made this question unsolvable by putting in a testcase that always exceeds the time limit :/"
                    },
                    {
                        "username": "abu_talaha",
                        "content": "Few test cases are still not passing, like those test cases which have rotation size greater than the array size.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        int K;\\n        if(n>k){\\n            K=n-k;\\n        }else{\\n            K=k-n;\\n        }\\n        \\n\\n        int p=1;\\n        while(p<=K){\\n            int last=nums[0];\\n            for(int i=0; i<n-1; i++){\\n                nums[i]=nums[i+1];\\n            }\\n            nums[n-1]=last;\\n            p++;\\n        }\\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "this is a brute force approach try to come up with more optimized approach or look Editorial/Solutions"
                    },
                    {
                        "username": "_quack_quack",
                        "content": "isn\\'t there any formula which can be used here to store the original element and the new rotated element at same place such that both can be extracted afterward\\n=> for ex- if all elements are non-negative then i can use formula like `nums[(i + k)%n] = (nums[i]%mx) * mx + nums[(i+k)%n]` ,where, mx -> max_element(nums) + 1\\n=> to extract the new element at any index i, nums[i]/mx will give the answer\\n\\nbut problem for me here is that i\\'m unable to apply above formula in case of negative numbers\\n\\nQ-> can\\'t we do something like above in case of negative numbers? "
                    },
                    {
                        "username": "SamareshDas",
                        "content": "In test case 38 someone put such a large array, dude what? What what what?"
                    },
                    {
                        "username": "lakshtomar588",
                        "content": "Tip : Try to solve using Deque."
                    },
                    {
                        "username": "developer03",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=n-k;i<n;i++){\\n            ans.push_back(nums[i]);\\n        }\\n        for(int i=0;i<n-k;i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n};       \\n\\ncan anyone help me why this is not working\\n"
                    },
                    {
                        "username": "krishanJat",
                        "content": "var rotate = function(nums, k) {\\n      for(let i=0;i<k;i++){\\n         let temp=nums.pop()\\n           nums.unshift(temp)\\n     }\\n    return nums\\n};\\n\\nplz explan why time limet exeed"
                    },
                    {
                        "username": "smit_02",
                        "content": "This is very easy if you use ArrayQueue"
                    },
                    {
                        "username": "hasanseam37",
                        "content": "This is irony it shows the wrong ans with this code\\n\\nvar rotate = function(nums, k) {\\n  k = k%nums.length;\\n  let leftElements = nums.slice(nums.length-k,nums.length);\\n  let rightElements = nums.slice(0,nums.length-k);\\n  nums = leftElements.concat(rightElements);\\n  console.log(nums)\\n};"
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "What is wrong in this code.. Can anyone please help!\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int saturation_point=nums.length-k-1;\\n        int n=nums.length;\\n        for(int i=saturation_point;i<n;i++){\\n            int tmp=nums[i];\\n            int in=(i-k);\\n            nums[i]=nums[in];\\n            nums[in]=tmp;\\n        }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1952038,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950970,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950923,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1950137,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949957,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949544,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949134,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1949075,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1942822,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1941674,
                "content": [
                    {
                        "username": "ajax108",
                        "content": "It took me 1hr to come up with the solution using O(1) space complexity.\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        \\n        k=k% nums.length;\\n        if(k==0){\\n            return;\\n        }\\n        int start= 0;\\n        int end=nums.length-1;\\n        //reverse the window of size K\\n        reverse(nums,nums.length-k,end);\\n        //reverse the entire array\\n        reverse(nums,start,end);\\n        //reverse the window of size (n-k)\\n        reverse(nums,start+k,end);\\n\\n    }\\n\\n    public static void reverse(int[] arr,int start,int end){\\n\\n        while (start<end){\\n            int tmp=arr[start];\\n            arr[start++]=arr[end];\\n            arr[end--]=tmp;\\n        }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "cionx",
                        "content": "Heads up: the largest testcase has $10^5$ entries (the maximal allowed value) and $k ≈ 5 ⋅ 10^4$ (half the array size), so make sure that your solution can handle such a test case without TLE."
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "I dont understand where is the constraint given that if k is > len(nums) , k should be k % len(nums) , am i missing out something, how did everyone assume this?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you\\'ve done rotation problems or any problem that wraps around, its same thing here \\n\\nIf you rotate an array of length 7 7 times, it ends back in the same position. Rotate 14,21 etc times, same position. \\n\\nSame idea here "
                    },
                    {
                        "username": "laichbr",
                        "content": "So since we are doing a rotation, this is similar to how a clock face works. If you think about doing something 13 hours from now, on the clock face you will really only still move 1 hour, right? \\n\\nThe same thing is going on here with k > len(nums). How much greater k is than length of nums doesn\\'t really matter. What matters is how many paces past length of nums it will move (the hours after the last full rotation is used up). \\n\\nHope that helps! "
                    },
                    {
                        "username": "aka_niju",
                        "content": "Why am i encountering runtime error, Please Help (New to Programming) ??\\nexample: \\n\\n==21==ERROR: AddressSanitizer: heap-use-after-free on address 0x603000000010 at pc 0x564ffa6b0f2c bp 0x7ffe78675730 sp 0x7ffe78675720\\n\\nEven though i haven\\'t used any dynamic or extra array in solution ??? Can anyone tell ?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple code in python \\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        while(k>len(nums)):\\n        \\n                k-=len(nums)\\n        c=len(nums)-k\\n        L=[]\\n        L1=[]\\n        for i in range(c,len(nums)):\\n            L.append(nums[i])\\n        for i in range(0,c):\\n            L1.append(nums[i])\\n        L+=L1\\n        for i in range(0,len(nums)):\\n            nums[i]=L[i]"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Good for you!\\nBut have you seen the rule number 1 in Discussion section?\\nIt says \"Please don\\'t post any solutions in this discussion.\""
                    },
                    {
                        "username": "nyutonov787",
                        "content": "\n        int len = nums.length;\n        int c = len - (k % len);\n        \n        nums = Arrays.copyOf(nums, len + c);\n        \n        int index = 0;\n\n        for (int i = len; i < nums.length; i++) {\n            nums[i] = nums[index++];\n        }\n\n        nums = Arrays.copyOfRange(nums, c, nums.length);\n\n        System.out.println(Arrays.toString(nums));\n\n\nwhy is this this Solution wrong, please help?\n\nI test this in intelliJ and working properly but in leetcode wrong"
                    },
                    {
                        "username": "dhruvshah2k3",
                        "content": "int n = nums.size();\\n        k = k % n;\\n        cout << n << endl;\\n        cout << k << endl;\\n        while(k--){\\n            int temp {nums[n - 1]};\\n            for(int i{n - 2};i >= 0;i--){\\n                nums[i + 1] = nums[i]; \\n            }\\n            nums[0] = temp;\\n        }\\nWhy is this getting time limit exceed"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "temp[(k+i)%n]=nums[i]"
                    },
                    {
                        "username": "as504919",
                        "content": "var rotate = function(nums, k) {\\n\\n  nums=[...nums.splice(nums.length-k),...nums] \\n\\n}\\n\\nDoes the work but doesn\\'t run correctly on this editor. Suggestions are welcome."
                    },
                    {
                        "username": "Hasanabbas_Momin",
                        "content": "        k = k%nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\nThis is giving wrong ans for one of the case : {1,2,3} k=1\nBut it works fine on my pc, can somone tell me whats going on with LeetCode compiler? "
                    }
                ]
            },
            {
                "id": 1937356,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1931736,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1930182,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1930174,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1928875,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1928101,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1926218,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1924877,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1924275,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1923155,
                "content": [
                    {
                        "username": "AkhilAduvala",
                        "content": "I wrote a java code the logics works fine,\\n        System.arraycopy(nums,l-k,result,0,k);\\n        System.arraycopy(nums,0,result,k,l-k);\\n        System.out.println(Arrays.toString(result));\\n        return result;\\n but when I return the result it is just showing the input array. I tried printing result before return and the print also gives correct result."
                    },
                    {
                        "username": "alshine",
                        "content": "func rotate(nums []int, k int) {\\n\\tn := nums[len(nums)-k:]\\n\\tnums = nums[:len(nums)-k]\\n\\tnums = append(n, nums...)\\n}\\n\\n\\u041F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u044D\\u0442\\u043E\\u0442 \\u043C\\u0435\\u0442\\u043E\\u0434 \\u043D\\u0430 \\u0433\\u043E \\u043D\\u0435 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 "
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY DOES MY CODE SHOW TLE FOR LAST CASE HAVING THOUSANDS OF ELEMENTS:-\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "Ankush_Jain",
                        "content": "WHY BIG ARRAY HAVING THOUSANDS OF ELEMENTS IS SHOWING TLE IN MY CODE:-\\n\\n#include<vector>\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n                int a = nums.size();\\n        int j=0;\\n        while(j<k){\\n            int temp= nums.back();\\n            nums.pop_back();\\n            auto itPos = nums.begin()+0;\\n            auto newIt= nums.insert(itPos,temp);\\n            j++;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "satvik_pandey22",
                        "content": "why we used this line :\\nk=k% nums.[size]();"
                    },
                    {
                        "username": "bohemiandev",
                        "content": " Perhaps I'm missing something about how judging works, but why is this solution not being accepted?\n`let nShifts = k % nums.length;`\n `let tempLength = nums.length - nShifts;`\n `nums = nums.slice(tempLength).concat(nums.slice(0,tempLength));`\n `console.log(nums);`\n\n\nstdout returns the same output as expected, but the output shows the same array parameter. Any advice would be appreciated."
                    },
                    {
                        "username": "fishhh_",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if (nums.empty() || (k %= n) == 0) return;\\n        for (int i = 0; i < n - k; ++i) {\\n            nums.push_back(nums[0]); // push_back() is push the element to the last one of vector\\n            nums.erase(nums.begin());\\n        }\\n    }\\n};\\nwhy does this code cause time limit exceeded? "
                    },
                    {
                        "username": "ankits745",
                        "content": "var rotate = function(nums, k) {\\n    let i=0;\\n    while(i<k){\\n        nums.unshift(nums.pop())\\n        i++;\\n    }\\n    // console.log(nums)\\n    return nums;\\n\\n};\\n\\nWhat is wrong in this? It gives TLE."
                    },
                    {
                        "username": "Nitesh_KG",
                        "content": "Getting TLE for 38th test case of 10^5 size array with a O(N) approach\n\n[leetcode](https://leetcode.com/problems/rotate-array/?envType=study-plan-v2&envId=top-interview-150)\n\n\nStdout\nTime Limit Exceeded\n('size_of_array', 100000)\n('no of rotation', 54944)"
                    },
                    {
                        "username": "himanshuu_shrma",
                        "content": "can someone please tell me whether size taken is nums.size() or nums.size()-1;"
                    }
                ]
            },
            {
                "id": 1921703,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1918924,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1916464,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1914328,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1901175,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1900704,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1900152,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1899139,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1884733,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1881492,
                "content": [
                    {
                        "username": "po-sheng",
                        "content": "People are talking about using reverse 3 times solution, but any idea how can we come up with that solution? is it based on what math characteristic? or it\\'s simply the observation? "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "Every time I have to modify a list or string in-place with Python, I know that my operations on that list / string won't be taken into account by the solution. Example below. If anyone else has run into similar issues, can you teach me how to bypass?\n\nExample solution:\n```python\nk = k % len(nums)\nnums = nums[-k:] + nums[:-k]\nprint(nums) # returns correct answer\n```\n`print(nums)` returns expected answer, but the solution doesn't register my changes to nums. Why? ¯\\_(ツ)_/¯"
                    },
                    {
                        "username": "laichbr",
                        "content": "[@nichonifroa](/nichonifroa) No problem! I\\'m on here to improve my skills and look for good problems as an adjunct at my local college. Knowing it helped helps me too! :) "
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) This makes a lot of sense. Thanks for teaching me!"
                    },
                    {
                        "username": "nichonifroa",
                        "content": "[@laichbr](/laichbr) Thanks, this worked. Can you explain the difference between using `nums = nums[-k:] + nums[:-k]` and `nums[:]`?"
                    },
                    {
                        "username": "laichbr",
                        "content": "nums[:] = nums[-k:] + nums[:-k] would do the trick"
                    },
                    {
                        "username": "arsenrustem123",
                        "content": "please help me.\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n    vector<int>::iterator it = nums.begin();\\n    for (int i = 0; i < k; i++)\\n    {\\n        nums.insert(nums.begin(), nums[(nums.size() - 1)]);\\n        nums.erase(nums.end() - 1);\\n\\n    }\\n    }\\n};"
                    },
                    {
                        "username": "laichbr",
                        "content": "To get the rotation right, consider how to limit the size of k. \\n\\nIf k is a factor of the length of the array, rotating it k times does nothing to it. \\n\\nIf k is 0, it still does nothing. \\n\\nIf k is strictly less then the length, then you can map more easily. \\n\\nTo make k strictly less, consider modulo "
                    },
                    {
                        "username": "md_moaz",
                        "content": "Can anyone help in this I use temprory array to rotate array by k but these give me runtime error =================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000002b4 at pc 0x00000034ca55 bp 0x7ffd44e62a30 sp 0x7ffd44e62a28\\n\\nclass Solution {\\npublic:\\nvoid rotate(vector& nums, int k)\\n{\\nint t = 0;\\nint n=nums.size();\\nint temp[n+1];\\n\\nfor (int i = n-k; i < n; i++) {\\ntemp[t] = nums[i];\\nt++;\\n}\\n\\nfor (int j = 0; j <= k; j++) {\\ntemp[t] = nums[j];\\nt++;\\n}\\n\\nfor (int i = 0; i < n; i++) {\\nnums[i] = temp[i] ;\\ncout<<nums[i];\\n}\\n}\\n};\\n"
                    },
                    {
                        "username": "laichbr",
                        "content": "k may end up being much larger than length of nums. Before you start doing any modification you need to make sure it is worth it to do the computation, and that the value of k is strictly less than length of nums. \\n\\nTo do this, think about what happens if k is 0, k is length of nums, or k is modular multiple of nums. If these are true, you may be able to have your solution return sooner. \\n\\nOtherwise, k may still be too large, in which case you will want to reduce k to be less than length of nums. \\n\\nIf you think of it like hands on a clockface, if k is going to move the hour hand 13 times, is that not the same as moving it once? This will help reason out why k should be strictly less than length of nums before starting. "
                    },
                    {
                        "username": "GabrielDillenburg",
                        "content": "Works on \"Run Code\\'\" but does not work on \\'Submit\\' with Time Limit Exceeded Error. Why?!!\\n\\n`var rotate = function(nums, k) {\\n  const len = nums.length -1\\n  const currentIndex = 0\\n  for (let i=len, j=0; j < k; j++) {\\n    nums.unshift(nums[i])\\n    nums.pop()\\n  }\\n};`"
                    },
                    {
                        "username": "tejas_bhosale",
                        "content": "JAVA Simplest Solution Please Suggest The Corrections\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        int n=nums.length;\\n        while(x<k){\\n            int temp=0;\\n            temp=nums[n-1];\\n            for(int m=n-1;m>0;m--)\\n            {\\n            nums[m]=nums[m-1];\\n            }\\n            nums[0]=temp;\\n            x++;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "aman291108",
                        "content": "Use mod operator and it will give the output."
                    },
                    {
                        "username": "sanjaykrishna1203",
                        "content": "The follow Up said try to solve it in o(1) extra space with in-place approach, but when i tried the same I got TLE. below is the code.\\n int n = nums.size();\\n        cout<<n;\\n        while(k--) {\\n            int key = nums[n-1];\\n            int prev = nums[0];\\n            for(int i = 0; i<n-1; i++) {\\n                int temp = nums[i+1];\\n                nums[i+1] = prev;\\n                prev = temp;\\n            }\\n            nums[0] = key;\\n        }\\n\\nCan anyone tell how it can be optimized more?"
                    },
                    {
                        "username": "dasujoy1999",
                        "content": "When K > length, how to follow up that approach ? Please can someone explain ?"
                    },
                    {
                        "username": "Roupstrer02",
                        "content": "When I print the answer, it shows the right answer, but the output shows the original unmodified input. Can someone tell me why this is happening?\\n\\nclass Solution(object):\\n    def rotate(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for i in range(0,k):\\n            temp = nums[-1]\\n            nums = nums[:len(nums) - 1]\\n            nums = [temp] + nums\\n        \\n        print(nums)\\n        "
                    }
                ]
            },
            {
                "id": 1876237,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1874740,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1874638,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1872906,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1869856,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1859385,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1859261,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1854508,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1849246,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1842088,
                "content": [
                    {
                        "username": "Sneha57",
                        "content": "Can anyone please explain why this code didn\\'t pass all the test cases and why i am getting time limit exceeded error?\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        long n = nums.size();\\n        int p = 0;\\n        for(long j=0; j<k; j++){\\n            int temp = nums[n-1];\\n            for(long i=n-1; i>=0; i--){\\n                if(i==p){\\n                    nums[i]=temp;\\n                }\\n                else{\\n                    nums[i]=nums[i-1];\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "makhov1",
                        "content": "Output bar is stacked, doesn`t matter what do i return, it always shows that my output is a list of initial nums"
                    },
                    {
                        "username": "gaussiao",
                        "content": "nums and k are empty for test case 38. Does anyone have the this testcase so I can debug my code? "
                    },
                    {
                        "username": "jobhunter99",
                        "content": "Does anyone else having issues with their solution working on their IDEs but not here on LeetCode? "
                    },
                    {
                        "username": "tapabrata_007",
                        "content": "What the shit !! testcase number 37 is out of box. Hats off "
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "This function is giving the desired result in console, but not working here, can anyone tell me what is wrong with this approach?      \\n `var rotate = function (nums, k) {\\n        let a = nums.slice(0, k + 1);\\n        let b = nums.slice(k + 1, nums.length);\\n        nums = [...b, ...a];\\n        return nums;\\n      };`"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "I got TLE error with 38/38 testcases passed, what does that even mean??"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "siriuszyx",
                        "content": "Why list slicing generates the same result?\\nnums = nums if k % len(nums) == 0 else nums[-k % len(nums):] + nums[:-k % len(nums)] "
                    },
                    {
                        "username": "Vinchester",
                        "content": "`int[] rotatedHalf = Arrays.copyOfRange(nums, nums.length - k , nums.length);\\n        System.out.println(Arrays.toString(rotatedHalf));\\n        int[] rootHalf = Arrays.copyOfRange(nums, 0, nums.length - k);\\n        System.out.println(Arrays.toString(rootHalf));\\n        int[] result = new int[nums.length];\\n        System.arraycopy(rotatedHalf, 0, result, 0, rotatedHalf.length);\\n        System.arraycopy(rootHalf, 0, result, rotatedHalf.length, rootHalf.length);\\n        System.out.println(Arrays.toString(result));\\n        nums = result;`\\n\\nStdout\\n  [5, 6, 7]\\n  [1, 2, 3, 4]\\n  [5, 6, 7, 1, 2, 3, 4]\\nOutput - [1,2,3,4,5,6,7]\\nExpected - [5,6,7,1,2,3,4]\\n\\nWhy it\\'s wrong?\\nSdout says that it is correct\\n"
                    },
                    {
                        "username": "balusamymanoj7",
                        "content": "[leetcode](https://leetcode.com)"
                    }
                ]
            },
            {
                "id": 1838597,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1834705,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1833950,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1828039,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1827935,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1826189,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1823892,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1812603,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1807561,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1805792,
                "content": [
                    {
                        "username": "mishanin",
                        "content": "this rotate function output always the same indifferently of what I do with return, something wrong.\nUPD - I'm stupid -> @return {void}"
                    },
                    {
                        "username": "akshaynot",
                        "content": "Why when i\\'m printing the nums it\\'s returning correct answer but on return it\\'s giving wrong answer."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can do it in-place with partial reversing or math. But in practice, a temporary array will be faster, because it is more cache-friendly, and there are specialized string copy CPU instructions at hand."
                    },
                    {
                        "username": "abutant",
                        "content": "Could someone explain why :\nnums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] works\nwhen\nnums = nums[len(nums) - k:] + nums[:len(nums) - k]\ndoesn't ?\n\nThanks in advance !"
                    },
                    {
                        "username": "Emin-ACIKGOZ",
                        "content": "It appears to not allow me to assign the resulting array to nums. I do not understand why this is happening"
                    },
                    {
                        "username": "zenfred",
                        "content": "Which language are you using?"
                    },
                    {
                        "username": "veraxa",
                        "content": "this problem seems to be easy rather than medium. It probably can become medium with 0(1) space requirement but not sure "
                    },
                    {
                        "username": "zenfred",
                        "content": "There are several shades of Medium lol"
                    },
                    {
                        "username": "user2030W",
                        "content": "The conclusion is broken. Outputs the original array. There is a one line python solution.\n`return nums[-k:] + nums[:-k]`"
                    },
                    {
                        "username": "OlegychS",
                        "content": "\\nCase 1\\nInput nums = [1,2,3,4,5,6,7] k = 3\\nOutput\\n[4,5,6,7,1,2,3]\\nExpected\\n[5,6,7,1,2,3,4]\\n\\nHow it can be? If we expecting to get [5,6,7,1,2,3,4] so k should be 4?"
                    },
                    {
                        "username": "theaniket",
                        "content": "Can k be greater than the size of array? "
                    },
                    {
                        "username": "mshivam019",
                        "content": "yes"
                    },
                    {
                        "username": "asifmuztaba",
                        "content": "What is wrong with this program?\\n`func rotate(nums []int, k int) []int {\\n\\tres := nums\\n\\tt := len(nums)-1\\n\\tfor i := 1; i<= k; i++ {\\n        temp:= res[t]\\n        nums=append([]int{temp},nums...)\\n        nums=nums[:len(nums) - 1]\\n        t--;\\n\\t}\\n    res = nums\\n\\treturn res\\n}`"
                    }
                ]
            },
            {
                "id": 1805186,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801954,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801209,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1801165,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800614,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800606,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1800299,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1799625,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1796362,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1795501,
                "content": [
                    {
                        "username": "kshakti",
                        "content": "Approach: \\n1. Reduce k to k % n (as array will come to its original state after n rotations (n: size of array)\\n2. Reverse last n - k - 1 elements.\\n3. Reverse first n - k elements.\\n4. Reverse the entire array.\\nArray is rotated by k positions in O(1) Space complexity"
                    },
                    {
                        "username": "raghavb039",
                        "content": "what is the expected time complexity ?"
                    },
                    {
                        "username": "mshivam019",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        List<Integer> num = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            num.add(nums[i]);\\n        }\\n        int l=nums.length-1;\\n        while(k>0){\\n            if(l<0)\\n            l=nums.length-1;\\n            num.add(0,nums[l--]);\\n            --k;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=num.get(i);\\n        }\\n    }\\n} \\nCan anyone help me optimize this It passes all the test cases but it says timelimit exceeded."
                    },
                    {
                        "username": "t5810m",
                        "content": "Can anyone explain why & how this line `$arr[($i + $k) % count($nums)] = $nums[$i];` from solution 2 works? I have no idea who & how come to this idea? Can this line be written in any other, easier to understand way? Any explanation will be deeply appreciated."
                    },
                    {
                        "username": "Abhi_NUY",
                        "content": "Divide the array into two parts, reverse each part separately, then reversing the whole array"
                    },
                    {
                        "username": "wdasddadwq",
                        "content": "https://leetcode.com/problems/rotate-array/solutions/3184255/the-use-of-simple-swapping-with-an-explanation-0ms-100-faster/\n\nnice approach\n"
                    },
                    {
                        "username": "klu_2100031301",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;k=k%n;\\n       for(int i=0,j=n-k-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n       for(int i=n-k,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n        for(int i=0,j=n-1;i<j;i++,j--)\\n       {\\n           int t=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=t;\\n       }\\n    }\\n} "
                    },
                    {
                        "username": "yashwanth818",
                        "content": "//why dosent this work\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=sizeof(nums)/sizeof(int);\n        int A[n];\n        for(int i=0;i<n;i++){\n            A[(i+k)%n]=nums[i];\n        }\n       for(int i=0;i<n;i++){\n            nums[i]=A[i];\n        }\n        \n    }\n};\n"
                    },
                    {
                        "username": "nakshaman",
                        "content": "why vector is not properly woking here ??\\n"
                    },
                    {
                        "username": "cclab006",
                        "content": "         int a  =k%nums.size();\\n         reverse(nums.begin(),nums.end());\\n    reverse(nums.begin(),nums.begin()+a);\\n    reverse(nums.begin()+a,nums.end());\\n  4 LINE SOLUTION"
                    }
                ]
            },
            {
                "id": 1793199,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1791639,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1791556,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1786047,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1781793,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1780304,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1777153,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1776951,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1776446,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1775035,
                "content": [
                    {
                        "username": "someshpandey25072002",
                        "content": "Can someone please tell me why \n\n\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k-k,nums.end());\n\n\nThis piece of code giving me correct answer but \n\n\n        nums.insert(nums.begin(),nums.end()-k,nums.end());\n        nums.erase(nums.end()-k,nums.end());\n\n\n Not this one !!!!"
                    },
                    {
                        "username": "Himanshi_18",
                        "content": "\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        temp=[]\\n        l=len(nums)\\n        for i in range(l):\\n            temp[(i+k)%l]=nums[i]\\n        nums=temp\\n        \\n//it it showing error as list assignment  index out of range"
                    },
                    {
                        "username": "shandilyaajish",
                        "content": "I have written below code\\nvar rotate = function(nums, k) {\\n    for(let i=0;i<k;i++){\\n            let temVar=nums[nums.length-1];\\n            nums.splice(nums.length-1,1);\\n            nums.unshift(temVar);\\n        }\\n        return nums;\\n};\\n\\nCan anyone tell me the issue with this code, I am getting TLE error. This is working fine in my local, working fine."
                    },
                    {
                        "username": "iamtj45",
                        "content": "public class Solution {\\n    public void Rotate(int[] nums, int k) {\\n      int x,l,i,n,temp;\\n\\n      n=nums.Length;\\n\\n      l=0;\\n       for(l=0;l<k;l++){\\n          x=nums[n-1];\\n          for(i=0;i<n-1;i++){\\n             temp=nums[i+1];\\n             nums[i+1]=nums[i];\\n             nums[i]=temp;\\n          }\\n          nums[0]=x;\\n      \\n\\n      }\\n    }\\n}\\n\\nplz anyone help me its not giving correct output"
                    },
                    {
                        "username": "akritim",
                        "content": "I am getting a runtime error stated below:\\nLine 11: Char 18: runtime error: variable length array bound evaluates to non-positive value 0 (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:20:18.\\n\\nline that seems to be creating problem is-\\nint temp[(k%n)];\\n\\n\\nThe code i wrote is:\\n\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==0|| n==1 ){\\n            return;\\n        }\\n        if(k<=0){\\n            return;\\n        }\\n        int temp[(k%n)];\\n        int i=0;\\n        \\n        for(int j=n-(k%n);j<n;j++){\\n            temp[i]=nums[j];\\n            i++;\\n        }\\n        for(int w=n-1;w>=k;w--){\\n            nums[w]=nums[w-(k%n)];\\n        }\\n        for(int q=0;q<(k%n);q++){\\n            nums[q]=temp[q];\\n        }\\n        \\n    }\\n};\\n\\nCan anyone please help me in this."
                    },
                    {
                        "username": "kingdesign2014",
                        "content": "### Javascript solution problem, and need help\\nDon\\'t understant why this hit time limitatiion?\\n```\\n    let index = nums.length - 1\\n\\n    while(k > 0){\\n        nums.unshift(nums[index])\\n        k--\\n    }\\n    \\n    nums.length = index + 1\\n```"
                    },
                    {
                        "username": "HappyGiraffe96",
                        "content": "The void method has by its type no return statement. What is considered as the output? Is it the nums array?"
                    },
                    {
                        "username": "ayush_07_",
                        "content": "my time limit exceeded, what should i do"
                    },
                    {
                        "username": "akshatmiddha",
                        "content": "is anybody else having problem with using insert for vectors"
                    },
                    {
                        "username": "abhii010620",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        for(int i=0;i<k;i++){\\n            int temp=nums.back();\\n            nums.pop_back();\\n            nums.insert(nums.begin(),temp);\\n        }\\n        \\n    }\\n};\\n\\nHere I am getting TLE error in last case. Can anyone resolve this issue and what mistake i am making here."
                    }
                ]
            },
            {
                "id": 1773348,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1769395,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1769382,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1767529,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1759287,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1756392,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1754579,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1754571,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1753927,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1753042,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "Solution below doesn\\'t work, but can anyone make it work? It passes like 21 testcases.\\n\\n `           \\n var startRotationPointer = nums.Length < k ?  k % nums.Length  : nums.Length - k;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (startRotationPointer > nums.Length - 1) break;\\n\\n                var temp = nums[startRotationPointer];\\n                nums[startRotationPointer] = nums[i];\\n                nums[i] = temp;\\n                startRotationPointer++;\\n            }\\n\\n            return nums;\\n`"
                    },
                    {
                        "username": "cr1msonn",
                        "content": " `class Solution(object):\\n    def rotate(self, nums, k):\\n        \\n        item = nums[-k:]\\n        print(\"defining item: \",item)\\n        res = [i for i in nums if i not in item]\\n        print(\"defining res\", res)\\n        item.extend(res)\\n        print(\"after extention\", item)\\n        print(\"WHAT THE FUCK?\")\\n        return item`\\n\\nwhat it wants from me?"
                    },
                    {
                        "username": "AnitaSahani",
                        "content": "i am getting output as 7,7,7,1,2,3,4\\n"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "ajadjaj"
                    },
                    {
                        "username": "optimus1998",
                        "content": "i am getting only one error by swapping will it work\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "[@LeetCode](/LeetCode) I found a bug on  your approach. Your compiler shows invalid output as I tested on colab it works fine but here its showing incorrect output. Check this code/simple approach (nums=nums[-k:]+nums[:-k]) for this problem\n `your inline code...your inline code...`\ndef rotate_array(nums=[1,2,3,4,5,6,7,8,9],k=3):\n  if len(nums)>=1 and len(nums)<=100000:\n    if k >= 0 and k <= 100000:\n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    else:\n      print(\"k Should be positive\")\n  else:\n      print(\"nums Should be in range of 1 and 100000\")\n\nrotate_array()\n\n\nor simply try this one \ndef rotate_array(nums=[1,2,3,4,5,6,7],k=3):\n  \n      nums=nums[-k:]+nums[:-k]\n      print(\"Final Rotated Array Is:\",nums)\n    \nrotate_array()"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums=v;\\n    }\\n};"
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "0th::let 500th time rotate array so rotate a array seventh time meet a same ,again to again rotate array,then 497 time meet a same ,then 500%7=3,so rotate array 3time.formula k=k%sizeof array\\n1st::total array reverse means swap\\n2nd::Kth position reverse and again remaining position reverse"
                    },
                    {
                        "username": "shreyav5",
                        "content": " for i in range(k):\\n        elem = nums.pop(len(nums)-1)\\n        nums.insert(0, elem)\\n\\n\\nWhy is this python solution timing out? Isn\\'t it O(n) time complexity and O(1) space?"
                    }
                ]
            },
            {
                "id": 1751638,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1748130,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1747675,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1746753,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1739439,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1738265,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1737568,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735160,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735104,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1735042,
                "content": [
                    {
                        "username": "user0866x",
                        "content": "Why leetcode is not accepting my this solution even after same stdout as expected one:\\n\\nclass Solution {\\n    public void rotate(int[] nums, int k) {\\n        int N = nums.length;\\n        int arr[]=new int[k];\\n        for(int i=0;i<k;i++){\\n            arr[i]=nums[(N-k)+i];\\n        }\\n        int arr2[]=new int[N-k];\\n        for(int i=0;i<(N-k);i++){\\n            arr2[i]=nums[i];\\n        }\\n        int res[]=new int[nums.length];\\n        System.arraycopy(arr,0,res,0,k);\\n        System.arraycopy(arr2,0,res,k,(N-k));\\n        String result = Arrays.toString(res).replaceAll(\" \",\"\");\\n        System.out.print(result);\\n    }\\n} \\n\\nsomeone please help"
                    },
                    {
                        "username": "csAshish",
                        "content": "double reverse of number = number\\nint n = nums.size();\\n        k = k%n;\\n        reverse(nums.begin() , nums.end()-k);\\n        reverse(nums.end()-k , nums.end());\\n        reverse(nums.begin() , nums.end());\\n"
                    },
                    {
                        "username": "loia5tqd001",
                        "content": "```ts\\nfunction reverseInPlace(nums: number[], startIdx: number, endIdx: number) {\\n    while (startIdx < endIdx) {\\n        const tmp = nums[startIdx];\\n        nums[startIdx] = nums[endIdx];\\n        nums[endIdx] = tmp;\\n        startIdx++;\\n        endIdx--;\\n    }\\n}\\nfunction rotate(nums: number[], k: number): void {\\n    // when rotate nums.length times, we\\'ll end up at the same place, \\n    // so only k % nums.length times are useful\\n    k = k % nums.length; \\n\\n    // let\\'s say: 1 2 3 4 5 6 7, k = 2\\n\\n    // step 1: 5 4 3 2 1 6 7\\n    reverseInPlace(nums, 0, nums.length - 1 - k);\\n\\n    // step 2: 5 4 3 2 1 7 6\\n    reverseInPlace(nums, nums.length - k, nums.length - 1);\\n\\n    // step 3: 6 7 1 2 3 4 5\\n    reverseInPlace(nums, 0, nums.length - 1);\\n};\\n```"
                    },
                    {
                        "username": "leetabel245",
                        "content": "Tip:\\nk=4\\nlen(nums)= 9\\n4%9 =4\\nk=10\\nlen(nums)= 7\\n10 % 7 = 3 it is not guaranteed that k is greater than length of the list\"\\nSolve by adding this line :\\nk = k % len(nums)\\n"
                    },
                    {
                        "username": "sourabhtan",
                        "content": "Google  \"Reversal Algorithm\", \"Block Swap Algorithm\" and \"Juggling Algorithm\" for array rotation, for this question."
                    },
                    {
                        "username": "_anup_",
                        "content": "for O(1) space \\nleet arr--1234567 ,k=3\\nstep 1: reverse all array->1234567--->7654321\\nstep 2 :reverse till k-1->   7654321--> 5674321\\nstep 3: reverse from k to arr.length-1->5674321-->5671234"
                    },
                    {
                        "username": "H_Han_Zhou",
                        "content": "Question about why the code is not working. \\n\\nI was thinking I can add an extra place at the beginning of the list, and make it equals to the end, then pop the end. \\n\\nRepeat it k times, I printed out the process, seems to be working, but the solution is not accepted for some reason. \\n\\nThe code looks like this:\\n\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        for _ in range(k):\\n            nums = [0] + nums\\n            nums[0] = nums[-1]\\n            nums.pop(-1)"
                    },
                    {
                        "username": "NagendraPatil",
                        "content": "it says 38/38 testcases passed , yet TLE, why? anyone facing this?"
                    },
                    {
                        "username": "sumanshekhar698",
                        "content": "I think you are using two nested for loops and  the logic is working fine, but as O(n) = n^2 for your case, it is exceeding time."
                    },
                    {
                        "username": "Rheinhard",
                        "content": "In Python,  use `nums[:] = ` to copy and replace every element in the original list in order to modify nums in-place.\n\nLike `nums[:] = nums[offset:] + nums[:offset]`"
                    },
                    {
                        "username": "chandu0987654321c",
                        "content": "can anyone help me why it is nor getting\\n\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        nums = (nums[len(nums)-k:]+nums[:len(nums)-k])"
                    }
                ]
            },
            {
                "id": 1730559,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1727491,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1724223,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1722409,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721908,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721770,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721628,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721364,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721363,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1721143,
                "content": [
                    {
                        "username": "anujkr12",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n     int temp;\\n     for(int i =0;i<k;i++){\\n         int m = nums.size();\\n         temp = nums[m-1];\\n         for(int j=m;j>0;j--){\\n             nums[j]=nums[j-1];\\n         }\\n         nums[0]=temp;\\n     }   \\n    }\\n};\\nwhy this code is showing runtime error?"
                    },
                    {
                        "username": "dev691047",
                        "content": " k=k%nums.size();\\n    reverse(nums.begin(),nums.end());\\n       reverse(nums.begin(),nums.begin()+k);\\n       reverse(nums.begin()+k,nums.end());"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/189_rotate_array.cpp"
                    },
                    {
                        "username": "ankit_nsfw",
                        "content": "the leet code compiler is bad AF , What ever you write it wont give the correct out come"
                    },
                    {
                        "username": "brijkishorsoni2019",
                        "content": "//easy to understand solution\\nlet array =[1,2,3,4,5,6] ,n=6, k=3\\nstep 1 reverse complete array\\n[6,5,4,3,2,1]\\nstep 2 reverse the array untill k-1 index\\n[6,5,4,3,2,1] --> [4,5,6,3,2,1]\\nstep 3 reverse the array from k index to n-1 (if  index start from 0)\\n[4,5,6,3,2,1]--> [4,5,6,1,2,3]\\noutput=[4,5,6,1,2,3]\\n//Code in java\\nclass Solution {\\n\\n    public void rotate(int[] nums, int k) {\\n        int n=nums.length;\\n        k=k%n;\\n        reverseArray(nums,0,n-1);\\n        reverseArray(nums,0,k-1);\\n        reverseArray(nums,k,n-1);\\n        \\n    }\\n   void reverseArray(int[] nums,int start, int end)\\n    {\\n        for(int i=start,j=end;i<j;i++,j--)\\n        {\\n            int temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "mohitgupta13102001",
                        "content": "cpp solution\\n\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n      vector<int> temp(nums.size());\\n      for(int i=0; i<nums.size(); i++){\\n          temp[(i+k)%nums.size()]=nums[i];\\n      }  \\n      nums=temp;\\n    }\\n};"
                    },
                    {
                        "username": "bhawna_06",
                        "content": "class Solution {\\n    public void rotate(int[] arr, int k) {\\n     int temp;\\n            while(k>0) {  \\n            temp = arr[arr.length-1];    \\n             for(int j = arr.length-1; j > 0; j--){       \\n                arr[j] = arr[j-1];    \\n            }    \\n            arr[0] = temp;\\n            k=k-1;  \\n            }  \\n      }\\n     }  \\nIn this their is exceed time limit ,kindly help me out"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "akshayrs096",
                        "content": "void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "Che_09",
                        "content": " `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 1715159,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1714225,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1707192,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1704724,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1704313,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1701179,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1697952,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1692642,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1691298,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            },
            {
                "id": 1686108,
                "content": [
                    {
                        "username": "sahilwagh142",
                        "content": "    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        }\\n        nums = temp;\\n    }"
                    },
                    {
                        "username": "mdasad00",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int x=0;\\n        for(int i=0 ;i<k;i++)\\n        {\\n            x=nums[nums.length-1];\\n            for(int j=0;j<nums.length-1;j++)\\n            {   \\n                nums[(nums.length-1)-j]=nums[(nums.length-2)-j];\\n            }\\n            nums[i-i]=x;\\n        }\\n    }\\n}\\n\\nits shows time limit exceed\\n"
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...`class Solution {\\n    public static void rotateright(int[]nums,int left,int right){\\n        while(left < right){\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left ++;right--;\\n        }\\n    }\\n    public void rotate(int[] nums, int k) {\\n        \\n     //   for(int idx = 0 ; idx < nums.length; idx++){\\n          int n = nums.length;\\n             k = k % n;\\n              rotateright(nums,0,n-k-1);\\n              rotateright(nums,n-k,n-1);\\n              rotateright(nums,0,n-1);\\n       \\n          \\n      //  }\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\n\\nhttps://leetcode.com/problems/rotate-array/solutions/2875064/easiest-faang-method-ever/?orderBy=most_relevant"
                    },
                    {
                        "username": "spoiler_007",
                        "content": "  temp[(i+k)%nums.size()]=nums[i]"
                    },
                    {
                        "username": "laichbr",
                        "content": "Why is list splicing not a valid answer? \\nnums = nums[len(nums)-k:] + nums[:len(nums)-k]"
                    },
                    {
                        "username": "Vedang_Nagar",
                        "content": "class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        vector<int> temp(nums.size());\\n\\n        for(int i=0;i<nums.size();i++){\\n            temp[(i+k)%nums.size()] = nums[i];\\n        } \\n        nums = temp;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ritik_47",
                        "content": "Help me understand Time complexity of this solution.\nIt is giving me tle.\n\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        for(int i = 0; i < k ; i++){\n            rotate(nums);\n        }\n    }\n    public static void rotate(int[] nums){\n        int idx1 = nums.length - 1;\n        int idx2 = nums.length - 2;\n        while(idx2 >= 0){\n            swap(idx1 , idx2 , nums);\n            idx1 = idx2;\n            idx2 = idx2-1;\n        }\n    }\n    public static void swap(int a , int b , int[] nums){\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}"
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public void rotate(int[] nums, int k) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[(i+k)%nums.length]=nums[i];\\n        }\\n        for(int i=0; i<ans.length; i++){\\n            nums[i]=ans[i];\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "w25536",
                        "content": "    public void rotate(int[] nums, int k) {\n    \n    int[] tmp = new int[nums.length];\n\n    for(int i=0; i< nums.length; i++){\n       tmp[i] = nums[i];\n   }\n\n    // 1. reversing all numbers\n    for(int i=0 ; i<nums.length; i++){\n       nums[i] = tmp[nums.length-1-i]; \n    }\n\n    // 2. reversing first k numbers\n      Arrays.sort(nums, 0, k);\n   \n    //3. reversing last n-k numbers \n      int n = nums.length;\n\n\n      for(int i=n-k; i < nums.length; i++){\n         nums[i] = tmp[i-k];\n         System.out.println(i);\n      }\n\n   While I was try to solve this problem using Arrays  it seems to be have a problem on #3 causing a collision in looping if test case1 is correct the other is incorrect. I know why this is happening but if there is any good solutions could you pls help teaching me a guidance? if not I will follow the  while loop solution that has provided in the solution page. "
                    }
                ]
            }
        ]
    }
]