[
    {
        "title": "Divide Two Integers",
        "question_content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\nReturn the quotient after dividing dividend by divisor.\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [&minus;231, 231 &minus; 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n&nbsp;\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n&nbsp;\nConstraints:\n\n\t-231 <= dividend, divisor <= 231 - 1\n\tdivisor != 0",
        "solutions": [
            {
                "id": 13407,
                "title": "c-bit-manipulations",
                "content": "The key observation is that the quotient of a division is just the number of times that we can subtract the `divisor` from the `dividend` without making it negative.\\n\\nSuppose `dividend = 15` and `divisor = 3`, `15 - 3 > 0`. We now try to subtract more by *shifting* `3` to the left by `1` bit (`6`). Since `15 - 6 > 0`, shift `6` again to `12`. Now `15 - 12 > 0`, shift `12` again to `24`, which is larger than `15`. So we can at most subtract `12` from `15`. Since `12` is obtained by shifting `3` to left twice, it is `1 << 2 = 4` times of `3`. We add `4` to an answer variable (initialized to be `0`). The above process is like `15 = 3 * 4 + 3`. We now get part of the quotient (`4`), with a remaining dividend `3`.\\n\\nThen we repeat the above process by subtracting `divisor = 3` from the remaining `dividend = 3` and obtain `0`. We are done. In this case, no shift happens. We simply add `1 << 0 = 1` to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle one overflow case: `dividend = INT_MIN` and `divisor = -1`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516367,
                "title": "complete-thinking-process-intuitive-explanation-all-rules-followed-c-code",
                "content": "# **Explanation:**\\n```\\n\\tdividend = (quotient) * divisor + remainder\\n```\\nWe have to find the quotient in this equation and we are given divisor and dividend.\\nAny number can be represented in binary form. Same goes for `quotient` :\\n\\nLet us have an example: `58/5`:\\n`58 = (11) * 5 + 3`\\nRepresenting the quotient in binary form:  (11)<sub>10</sub> = (1011)<sub>2</sub>:\\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\\n\\nSince we dont know the quotient and remainder the equation we know is:\\n`58 = (q) * 5 + rem`\\n\\nWe get a hint at what we would like to do here. We will first multiply 5 with maximum power of 2 such that the resulting number is still smaller than the dividend (read further if you don\\'t understand why). Since multiplication operator is not allowed, we would use bitwise left shift to achieve this multiplication: each time we shift 5 by 1, we multiply it by 2:\\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\\n\\nWe observe that:\\n`58 = (2^3 * 5) + (something * 5) + rem      // --- (III)`\\nYou can see we are getting close to the equation we initialy wanted (eqa II). \\n\\nSince 5 is multiplied with 2<sup>3</sup>, ***we add 2<sup>3</sup> to our answer***.\\nFurther operating on equation III:\\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\\n\\nWhat we effectively have done is, subtracted the result we got from our first step from dividend `(58 - 40)`.\\nWe arived at the same question again but with a smaller dividend this time. \\n`dividend = 18, divisor = 5`\\n\\nTherefore let us repeat the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>1</sup> to our answer***.\\nLooking back: \\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\\nYou can notice we are gradually advancing towards equ II:\\nOur new dividend is now:\\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\\n`dividend = 8, divisor = 5`\\nRepeating the process:\\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\\n***We add  2<sup>0</sup> to our answer.***\\nNew dividend: \\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\\n`dividend = 3, divisor = 5`\\nAt this step, we stop iterating as our dividend is less than the divisor (we have also found our remainder = 3, as 5 should be multiplied with 0 and what remains is the remainder).\\n\\nLooking back again for the last time:\\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\\nIn the process, we have finally reached the equation we wanted to, and have got the answer as:\\n`quotient = (2^3 + 2^1 + 2^0)`\\n\\n# **Code:**\\nSince we are not allowed to have any numerical data type bigger than 32 bit integer, we will use the last bit reserved for sign to avoid overflow by using the unsinged int in c++:\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```\\n***Please upvote if you find this helpful, or if you think someone else might find it useful :)***\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tdividend = (quotient) * divisor + remainder\\n```\n```\\n\\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\\n\\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\\n```\n```\\n\\t5 << 0 = 5               // less than dividend\\n\\t5 << 1 = 5*2 = 10        // less than dividend\\n\\t5 << 2 = 5*2*2 = 20      // less than dividend\\n\\t5 << 3 = 5*2*2*2 = 40    // less than dividend\\n\\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t58 - (2^3 * 5)  =  (something * 5) + rem\\n\\t58 - (8 * 5) = something * 5 + rem\\n\\t58 - 40 = something * 5 + rem\\n\\t18 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // less than dividend\\n\\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t18  =  (2^1 * 5) + (something * 5) + rem\\n\\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\\n\\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\\n```\n```\\n\\t18 - (2^1 * 5)  =  (something * 5) + rem\\n\\t18 - (2 * 5) = something * 5 + rem\\n\\t18 - 10 = something * 5 + rem\\n\\t8 = something * 5 + rem\\n```\n```\\n\\t5 << 0 = 5           // less than dividend\\n\\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\\n```\n```\\n\\t8 = (2^0 * 5) + (something * 5) + rem\\n\\t8 - 5 = something * 5 + rem\\n\\t3 = something * 5 + rem\\n```\n```\\n\\t3 = 0*5 + rem\\n\\t8 = (2^0 * 5) + 3\\n\\t18  =  (2^0 * 5) + (2^1 * 5) + 3\\n\\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\\n```\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142849,
                "title": "c-java-python-should-not-use-long-int",
                "content": "## **Update 2019/02**\\nUsed to work on Leetcode when I wrote this solution, before 2019/02.\\nNow it\\'s broken. The C++ compiler on the Leetcode is changed.\\nI have locally clang-1000 and the solutions work very well.\\n\\n## **Preword**\\nThe description note that:\\n\"Assume we are dealing with an environment,\\nwhich could **only store integers within the 32-bit** signed integer range: `[\\u22122^31,  2^31 \\u2212 1]`.\"\\n\\nBut most of solution use \"long\" integer.\\nSo I share my solution here.\\n\\n## **Solution 1**\\n\\nOnly one corner case is `-2^31 / 1` and I deal with it at the first line.\\n\\nThis solution has `O(logN^2)` time complexity.\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n## **Solution 2**\\nAnother solution is also `O(32)`\\n\\n**C++:**\\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\\n**Python:**\\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0, x = 0;\\n        while (a - b >= 0) {\\n            for (x = 0; a - (b << x << 1) >= 0; x++);\\n            res += 1 << x;\\n            a -= b << x;\\n        }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```cpp\\n    int divide(int A, int B) {\\n        if (A == INT_MIN && B == -1) return INT_MAX;\\n        int a = abs(A), b = abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((signed)((unsigned)a >> x) - b >= 0)\\n                res += 1 << x, a -= b << x;\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```java\\n    public int divide(int A, int B) {\\n        if (A == 1 << 31 && B == -1) return (1 << 31) - 1;\\n        int a = Math.abs(A), b = Math.abs(B), res = 0;\\n        for (int x = 31; x >= 0; x--)\\n            if ((a >>> x) - b >= 0) {\\n                res += 1 << x;\\n                a -= b << x;\\n            }\\n        return (A > 0) == (B > 0) ? res : -res;\\n    }\\n```\n```python\\n    def divide(self, A, B):\\n        if (A == -2147483648 and B == -1): return 2147483647\\n        a, b, res = abs(A), abs(B), 0\\n        for x in range(32)[::-1]:\\n            if (a >> x) - b >= 0:\\n                res += 1 << x\\n                a -= b << x\\n        return res if (A > 0) == (B > 0) else -res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13403,
                "title": "clear-python-code",
                "content": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        positive = (dividend < 0) is (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n        if not positive:\\n            res = -res\\n        return min(max(-2147483648, res), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 13397,
                "title": "clean-java-solution-with-some-comment",
                "content": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "  \\tpublic int divide(int dividend, int divisor) {\\n\\t\\t//Reduce the problem to positive long integer to make it easier.\\n\\t\\t//Use long to avoid integer overflow cases.\\n\\t\\tint sign = 1;\\n\\t\\tif ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n\\t\\t\\tsign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\t\\n\\t\\t//Take care the edge cases.\\n\\t\\tif (ldivisor == 0) return Integer.MAX_VALUE;\\n\\t\\tif ((ldividend == 0) || (ldividend < ldivisor))\\treturn 0;\\n\\t\\t\\n\\t\\tlong lans = ldivide(ldividend, ldivisor);\\n\\t\\t\\n\\t\\tint ans;\\n\\t\\tif (lans > Integer.MAX_VALUE){ //Handle overflow.\\n\\t\\t\\tans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;\\n\\t\\t} else {\\n\\t\\t\\tans = (int) (sign * lans);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ldivide(long ldividend, long ldivisor) {\\n\\t\\t// Recursion exit condition\\n\\t\\tif (ldividend < ldivisor) return 0;\\n\\t\\t\\n\\t\\t//  Find the largest multiple so that (divisor * multiple <= dividend), \\n\\t\\t//  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.\\n\\t\\t//  Think this as a binary search.\\n\\t\\tlong sum = ldivisor;\\n\\t\\tlong multiple = 1;\\n\\t\\twhile ((sum+sum) <= ldividend) {\\n\\t\\t\\tsum += sum;\\n\\t\\t\\tmultiple += multiple;\\n\\t\\t}\\n\\t\\t//Look for additional value for the multiple from the reminder (dividend - sum) recursively.\\n\\t\\treturn multiple + ldivide(ldividend - sum, ldivisor);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 13467,
                "title": "very-detailed-step-by-step-explanation-java-solution",
                "content": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This seems to be a very difficult question with whole lot of restriction, but if you break down the question and tackle every sub-problem individually, it might not seem as hard as it is.\\n\\nFirst, we need to check whether the end result is positive or negative. Two cases will lead to negative case which is when dividend and divisor has different signs. Alright, first part is done.\\n\\nSecond part is to deal with overflow. You know, there are so many corner cases which will lead to overflow. So it is better to convert them to long first, and convert it back to integer when returning the value.\\n\\nAlright, now we get to the main part. We know that division is actually the backward of multiplication, for example , `20 / 5  = 4` can be seen as `4 * 5 = 20`. Here what we are going to do is to find the multiplication. We set tmp as divisor `(5)` and set count to `1`.  As long as the tmp is less than or equal to dividend `(20)`, we left shift `<<` **which is same as multiply 2 but without using multiplication**. \\n\\n    1st loop --- tmp = 10 , count = 2 \\n    2nd loop --- tmp = 20, count = 4\\n    3rd loop --- tmp = 40, count = 8 (exit the loop)\\n\\nNow we right shift both tmp and count by 1, which gives us result of `4` . After subtraction of `20` from dividend, which gives us dividend = `0` and that we break out the outer loop and get to the last part.\\n\\nFinally, we gotta check if the sign is positive or negative. If it is negative, then we apply negation `~result` + `1` (two's complement) to get the negative result (why not just `result * -1` ? Well, critics might say you use multiplication -_-!!! (lol jk). Also make sure to check if result is overflow, because you know, leetcode is pretty strict to corner cases as well.\\n\\n----------\\n\\nAnother example : `10 / 3 = 3`\\n\\n    1st outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6 , count = 2\\n    2nd inner loop --- tmp = 12, count = 4 (exit the inner loop, result = 0 + (4 >> 1) = 2)\\n\\n    dividend = 10 - (12 >> 1) = 10 - 6 = 4 (4 >  divisor, so here we go second outer loop)\\n\\n    2nd outer loop\\n    --------------\\n\\n    1st inner loop --- tmp = 6, count = 2 (exit the inner loop, result = 2 + (2 >> 1) = 3)\\n\\n    dividend = 4 - (6 >> 1) = 4 - 3 = 1( divisor > 1, exit outer loop, return result)\\n\\n----------\\n\\nCredits to @HelloWorld123456. Here is the simplified code: \\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\\n        long absDividend = Math.abs((long) dividend);\\n        long absDivisor = Math.abs((long) divisor);\\n        long result = 0;\\n        while(absDividend >= absDivisor){\\n            long tmp = absDivisor, count = 1;\\n            while(tmp <= absDividend){\\n                tmp <<= 1;\\n                count <<= 1;\\n            }\\n            result += count >> 1;\\n            absDividend -= tmp >> 1;\\n        }\\n        return  isNegative ? (int) ~result + 1 : result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089533,
                "title": "easy-solution-in-c",
                "content": "The idea here is to use addition efficiently to compute the final result...\\nwe know that division can be done using addition or subtraction...\\nfor example 20/3 = 3+3+3+3+3+3+(2, ignored) (result is 6 times 3 hence 6)\\n\\nHence the loop is run, n times where n is our result...\\nTo more efficiently compute this, we can reduce the loops to log n time by adding divisor everytime it is added on...\\n\\nSo 20/3 = 3 + 6 + 12 + (24, ignore) (curr result is 2^(3-1)=4, 3 here is number of iterations...) \\nleft over sum, 20-12 = 8, and we repeat the process...\\nSo 8/3 = 3 + 6 + (12, ignore) (this time result is 2^(2-1)=2, 2 here is number of iterations...)\\nleft over sum, 8-6 = 2, since 2 is less than 3, we terminate the process...\\n\\nHence final result is 4+2 = 6\\n\\n**Pls upvote the  thread if you found it helpful.**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        //Handling corner cases\\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n        //Converting divisors and dividend to their positive values\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n        //Result Variables\\n        int res=0;\\n        while(dv<=dd) {\\n            long int mul=dv, tmp=1;\\n            while(mul<=dd-mul) {\\n                mul+=mul;\\n                tmp+=tmp;\\n            }\\n            res+=tmp;\\n            dd-=mul;\\n        }\\n        \\n        //If either of dividend or divisor is negative our result will be negative\\n        if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13417,
                "title": "no-use-of-long-java-solution",
                "content": "Integer.MIN_VALUE as dividend is really troublesome. Thus, I turn everything to negative value and keep finding closest 1,2,4,8... multiples and recursive on rest. The only case that will cause overflow is Integer.MIN_VALUE / -1, so I list it alone as an edge case. \\n\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }\\n        \\n        private int divideHelper(int dividend, int divisor){\\n            // base case\\n            if(divisor < dividend) return 0;\\n            // get highest digit of divisor\\n            int cur = 0, res = 0;\\n            while((divisor << cur) >= dividend && divisor << cur < 0 && cur < 31) cur++;\\n            res = dividend - (divisor << cur-1);\\n            if(res > divisor) return 1 << cur-1;\\n            return (1 << cur-1)+divide(res, divisor);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n    \\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n            if(dividend > 0 && divisor > 0) return divideHelper(-dividend, -divisor);\\n            else if(dividend > 0) return -divideHelper(-dividend,divisor);\\n            else if(divisor > 0) return -divideHelper(dividend,-divisor);\\n            else return divideHelper(dividend, divisor);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 427345,
                "title": "python-24ms-beats-99-with-and-w-o-bitwise-operators",
                "content": "**With [bitwise operators](https://wiki.python.org/moin/BitwiseOperators):**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\nRuntime: 24 ms, faster than 99.56% of Python3 online submissions for Divide Two Integers.\\nMemory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Divide Two Integers.\\n\\n**Without bitwise operators:**\\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\\n**How it works**\\nFor example, we `divide(5000, 14)`:\\n1) After the first inner loop: `the_sum = 3584` which is `14` multiplied `256` times. \\nWe can\\'t multiply any more \\u2014 because after `256` is coming `256 + 256 = 512` and `14 * 512 = 7168` which is larger than our `dividend`, so we exit the inner loop,\\nReducing dividend: `dividend = 5000 - 3584 = 1416` \\nAnd moving to another cycle of outer loop\\n2) After the second inner loop: `the_sum = 896` which is `14` multiplied `64` times.  \\n3) Third: `the_sum = 448` which is `14` multiplied `32` times.  \\n4) And so on\\n5) Finally we have: `quotient = 256 + 64 + 32 + 4 + 1 = 357`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        divisor, dividend = abs(divisor), abs(dividend)\\n\\n        quotient = 0\\n        the_sum = divisor\\n\\n        while the_sum <= dividend:\\n            current_quotient = 1\\n            while (the_sum << 1) <= dividend:\\n                the_sum <<= 1\\n                current_quotient <<= 1            \\n            dividend -= the_sum\\n            the_sum = divisor\\n            quotient += current_quotient\\n\\n        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```\n```\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tis_negative = (dividend < 0) != (divisor < 0)\\n\\t\\tdivisor, dividend = abs(divisor), abs(dividend)\\n\\n\\t\\tquotient = 0\\n\\t\\tthe_sum = divisor\\n\\n\\t\\twhile the_sum <= dividend:\\n\\t\\t\\tcurrent_quotient = 1\\n\\t\\t\\twhile (the_sum + the_sum) <= dividend:\\n\\t\\t\\t\\tthe_sum += the_sum\\n\\t\\t\\t\\tcurrent_quotient += current_quotient\\n\\t\\t\\tdividend -= the_sum\\n\\t\\t\\tthe_sum = divisor\\n\\t\\t\\tquotient += current_quotient\\n\\n\\t\\treturn min(2147483647, max(-quotient if is_negative else quotient, -2147483648))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13428,
                "title": "15-line-easy-understand-solution-129ms",
                "content": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "solutionTags": [
                    "Python"
                ],
                "code": "for example, if we want to calc (17/2)\\n\\nret = 0;\\n\\n17-2  ,ret+=1; left=15\\n\\n15-4  ,ret+=2; left=11\\n\\n11-8  ,ret+=4; left=3\\n\\n3-2    ,ret+=1; left=1\\n\\n\\nret=8;\\n\\n\\n\\n\\n\\n\\n    class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        isMinus= ((dividend<0 and divisor >0) or (dividend>0 and divisor <0));\\n        ret=0;        \\n        dividend,divisor=abs(dividend),abs(divisor);\\n        c,sub=1,divisor;\\n\\n        while(dividend >= divisor):\\n            if(dividend>=sub):\\n                dividend-=sub;\\n                ret+=c;\\n                sub=(sub<<1);\\n                c=(c<<1);\\n            else:\\n                sub=(sub>>1);\\n                c=(c>>1);\\n        \\n        if(isMinus):\\n            ret=-ret;\\n        return min(max(-2147483648,ret),2147483647);",
                "codeTag": "Java"
            },
            {
                "id": 13460,
                "title": "6-line-solution-c",
                "content": "Basic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if (dividend==0) return 0;\\n            if (divisor==0) return INT_MAX;\\n            long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n            if ((dividend<0)^(divisor<0)) res=-res;\\n            if (res>INT_MAX) res=INT_MAX;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1327339,
                "title": "java-0ms-100-faster-obeys-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor and find the remainder.\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13420,
                "title": "32-times-bit-shift-operation-in-c-with-o-1-solution",
                "content": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "we assure the factor `ret`'s binary fomula is\\n\\n`ret = a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31;  ai = 0 or 1, i = 0......31`\\n\\nthe dividend `B` and divisor `A` is non-negative, then\\n\\n`A(a0 + a1*2 + a2*2^2 + ...... + a29*2^29 + a30*2^30 + a31*2^31) = B;    Eq1`\\n\\n(1) when `Eq1` divided by `2^31`, we can get  `A*a31 = B>>31`;  then `a31 = (B>>31)/A`;\\n\\nif `(B>>31) > A`, then `a31 = 1`; else `a31 = 0`;\\n\\n(2) when `Eq1` divided by `2^30`, we can get  `A*a30 + A*a31*2 = B>>30`;  then `a30 = ((B>>30) - a31*A*2)/A`;  and `(B>>30) - a31*A*2` can be rewritten by `(B-a31*A<<31)>>30`, so we make `B' = B-a31*A<<31`, the formula simplified to `a30 = (B'>>30)/A`\\n\\nif `(B'>>30) > A`, then `a30 = 1`; else `a30 = 0`;\\n\\n(3) in the same reason, we can get  `a29 = ((B-a31*A<<31-a30*A<<30)>>29)/A`, we make `B'' = B' - a30*A<<30`, the formula simplified to `a29 = (B''>>29)/A`;\\n\\ndo the same bit operation `32` times, we can get `a31 ..... a0`, so we get the `ret` finally.\\n\\nthe C solution with constant time complexity\\n\\n    int divide(int dividend, int divisor) {\\n        //special cases\\n        if(divisor == 0 || (dividend == INT_MIN && divisor == -1))\\n            return INT_MAX;\\n        \\n        // transform to unsigned int\\n        bool sign = (dividend > 0)^(divisor > 0);\\n        unsigned int A = (divisor < 0) ? -divisor : divisor;\\n        unsigned int B = (dividend < 0) ? -dividend : dividend;\\n        int ret = 0;\\n        \\n        // shift 32 times\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            if((B>>i) >= A)\\n            {\\n                ret = (ret<<1)|0x01;\\n                B -= (A<<i);   // update B\\n            }\\n            else\\n                ret = ret<<1;\\n        }\\n        \\n        if(sign)\\n            ret = -ret;\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3233898,
                "title": "best-c-2-solution-easy-solution-math-bit-manipulation-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Math + Bit Manipulation.\\n2. Solved using Math.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(log(N)*log(N)), The time complexity of the code is O(log(N)*log(N)) since the outer loop\\n    and the inner loop both runs log(N) times, where N is the dividend.\\n\\n    Space Complexity : O(1), The space complexity of the above code is O(1) since we\\u2019re using constant extra\\n    space.\\n\\n    Solved using Math + Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        long long dvd = labs(dividend), dvs = labs(divisor), result = 0;\\n        int sign = (dividend > 0) ^ (divisor > 0) == 0 ? 1 : -1;\\n        while(dvd >= dvs){\\n            long long temp = dvs, mul = 1;\\n            while(temp << 1 <= dvd){\\n                temp <<= 1;\\n                mul <<= 1;\\n            }\\n            dvd -= temp;\\n            result += mul;\\n        } \\n        return sign*result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1), Constant Operation.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Math.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        return dividend/divisor;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13402,
                "title": "fast-and-simple-python-solutions-56ms-64ms-no-bitwise-operators",
                "content": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "solutionTags": [
                    "Python"
                ],
                "code": "idea: \\nkeep subtracting the new divisor `div` from the remaining `left` and then doubling `div` (by `div += div`). if `left < div`, start from the original divisor. Do these until `left < divisor.`<p>\\n\\n\\n----------\\n\\n\\n    def divide(self, dividend, divisor):     \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)\\n        Q = 1\\n        ans = 0\\n        while left >= divisor:\\n            left -= div\\n            ans  += Q \\n            Q    += Q\\n            div  += div\\n            if left < div:\\n                div = divisor\\n                Q = 1\\n        if neg:\\n            return max(-ans, -2147483648)\\n        else:\\n            return min(ans, 2147483647)\\n\\n\\n----------\\n\\n\\nRecursive version: \\n\\n    def divide(self, dividend, divisor):  \\n        neg=( (dividend < 0) != (divisor < 0) )\\n        dividend = left = abs(dividend)\\n        divisor  = div  = abs(divisor)       \\n        if dividend < divisor:\\n            return 0\\n        Q = 1\\n        ans = 0\\n        while left >= div:\\n            left -= div\\n            ans  += Q\\n            Q    += Q\\n            div  += div\\n        if neg:\\n            return max(-(ans + self.divide(left, divisor)), -2147483648)\\n        else:\\n            return min(ans + self.divide(left, divisor), 2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 13528,
                "title": "ac-javascript-code",
                "content": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "The algorithm is just the same as many other posts, double the divisor by shifting left 1 bit.\\n\\nBut I still got TLE 3 times, the trick is: JavaScript bitwise op is for signed 32-bit, so \\n\\n    while ((base << 1) <= dividend) {\\n\\ndoesn't work. Because \"base\" overflows.\\n\\n    while (base <= (dividend >> 1)) {\\n\\nworks.\\n\\n    /**\\n     * @param {number} dividend\\n     * @param {number} divisor\\n     * @return {number}\\n     */\\n    var divide = function(dividend, divisor) {\\n      if (divisor === 0) return 0;\\n      if (dividend === 0) return 0;\\n      if (dividend === -2147483648 && divisor === -1) return 2147483647;\\n    \\n      var isPositive = true;\\n      if (dividend > 0 !== divisor > 0) isPositive = false;\\n    \\n      divisor = Math.abs(divisor);\\n      dividend = Math.abs(dividend);\\n    \\n      var count = 1,\\n        result = 0,\\n        base = divisor;\\n    \\n      while (dividend >= divisor) {\\n        count = 1;\\n        base = divisor;\\n        while (base <= (dividend >> 1)) {\\n          base = base << 1;\\n          count = count << 1;\\n        }\\n        result += count;\\n        dividend -= base;\\n      }\\n    \\n      if (!isPositive) result = -result;\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 13426,
                "title": "simple-o-log-n-2-c-solution",
                "content": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Long division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations. \\n So  the overall complexity is O(( log N)^2) \\n\\n    typedef long long ll;\\n\\n    int divide(int n_, int d_) {\\n        ll ans=0;\\n        ll n=abs((ll)n_);\\n        ll d=abs((ll)d_);\\n        while(n>=d){\\n            ll a=d;\\n            ll m=1;\\n            while((a<<1) < n){a<<=1;m<<=1;}\\n            ans+=m;\\n            n-=a;\\n        }\\n        if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n            return -ans;\\n        return ans;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1163652,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 4 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func divide(_ dd: Int, _ dr: Int) -> Int {\\n        let dd64 = Int64(abs(dd)), dr64 = Int64(abs(dr))\\n        var val: Int64 = 0, lhs: Int64 = 1, rhs = dd64\\n        while lhs <= rhs {\\n            let mid = (lhs + rhs) / 2\\n            if mid * dr64 <= dd64 {\\n                val = mid\\n                lhs = mid + 1\\n            } else {\\n                rhs = mid - 1\\n            }\\n        }\\n        return max(min(Int((dd * dr) < 0 ? -val : val), Int(Int32.max)), Int(Int32.min))\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // 10/3 = 3.33333.. which is truncated to 3.\\n    func test0() {\\n        let value = solution.divide(10, 3)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    // 7/-3 = -2.33333.. which is truncated to -2.\\n    func test1() {\\n        let value = solution.divide(7, -3)\\n        XCTAssertEqual(value, -2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.divide(0, -1)\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    func test3() {\\n        let value = solution.divide(1, 1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084819,
                "title": "python-o-log-n-honest-solution-explained",
                "content": "I do not really like these type of problems, where you restricted in using operations. What we can use if we can not use multiplications and divisions: we can use only addition and subtraction. Let consider an example:\\n`100 // 7`\\n\\nWe can try just to subtract `7` while it is possible.  However potentially it can be quite long, if `dividend` is big and `divisor` is small. Let us multiply `7` by `2` (in fact it is not multiplication, but addition with itself), until we are smaller than `100`.  `7 -> 14 -> 28 -> 56`. Ans subtract `56` now, so we have `8` as result and we need to divide `44` by `7` now. Repeat procedure, so we subtract `28`, and we have `8 + 4` as result and `44 - 28 = 16 = 2`. Finally, we subtract `14` and we have `8 + 4 + 2 = 14` as result.\\n\\nLet us precalculate pairs `(7, 1), (14, 2), (28, 4), (56, 8)`. Then we iterate through these pairs in opposite direction and if we can subtract corresponding number, we subtract, if not - we go to the next one. Also we need to deal with signs and overflows here.\\n\\n**Complexity**: time complexity is `O(log n)`, where `n = divident/divisor`: there will be `O(log n)` terms in our `cand` list as well as this is limit for number of steps. Space complexity is `O(log n)` as well. What I mean by **honest** here, that a lot of people here in discussion either use some tricks which are not allowed, or complexity is wrong.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        if dividend == -1<<31 and divisor == -1: return (1<<31)-1\\n\\n        a, b = abs(dividend), abs(divisor)\\n        sign = (dividend < 0) == (divisor < 0)\\n        res, cand = 0, [(1, b)]\\n        \\n        while b << 1 <= a:\\n            cand += [(cand[-1][0]<<1, b<<1)]\\n            b <<= 1\\n            \\n        for pw, num in cand[::-1]:\\n            if a >= num:\\n                a, res = a - num, res + pw\\n                \\n        return res if sign else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715094,
                "title": "python-fast-code-with-detailed-explanation",
                "content": "I took the code of  [@tusizi](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code) and made it easier to understand by changing variable names, and adding a detailed explanation for each line. I\\'m also not experienced myself and whatever I right here comes from discussion forums and googling. The high level idea is that you substract `dividend` by `divisor` until `dividend` is less than `divisor`.  Also, the solution has two `while` loops. The inner `while` loop tries to substract `divisor`, `2*divisor`, `4*divisor` and so on, until `dividend` is less than `divisor` where it starts over the outer `while` loop. \\n\\n```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```\\n\\n`#1`: `is` operator is similar to `==` operator except that it compares that whether both the operands refer to the same object or not. check [this](https://www.***.org/difference-operator-python/).\\nSo here, if both of `dividend` and `divisor` have similar sign, it returns `True`. Otherwise, `False`. This will be used in line `#11` when we check if the `positive` variable is `True` or `False`. And, if it\\'s not `True` (meaning if they don\\'t have similar signs, we add a `-` to the output (`#12`). Note that in this example `==` works just fine as `is`. \\n\\n`#2`: No that we decided on the sign in line `#1`, we can use absolute values of `dividend` and `divisor`. That\\'s what\\'s being done here. \\n\\n`#3`: Initiating the output by setting it to zero. \\n\\n`#4`: So the high level idea is that we substract `divisor` from `dividend` until we can\\'t substract anymore. Imagine you want to divide 7 by 2. 7-2 =5, 5-2=3, 3-2 = 1 ! You can\\'t substract anymore. Them the `while` loope stops. \\n\\n`#5`: Now, we enter the main (tricky, challenging, confusing) part of the code. This line is not complicated. It simply initilize some values, meaning `curr_divisor` and `num_divisors\\' with `divisor` and `1`, recpectively. This means we assume `curr_divisor = divisor` and `num_divisor = 1`, initially. \\n\\n`#7` and `#8`: These two lines are updating `dividend` and `res`. When you substract `dividend` by `curr_divisor`, you\\'re basically saying if I was going to calculating the quotient of division, I could still cut another piece with the size of `divisor` from `dividend`, and that\\'s why you update the `res` variable by num_divisor (`res += num_divisors` means `res = res + num_divisors`). \\n\\n`#9` and `#10`: `currdivisor = currdivisor << 1` is the same as `currdivisor = currdivisor  2`, and `numdivisors = numdivisors << 1`, is the same as`numdivisors = numdivisors2`. This is called bitwise operation. Check [this](https://wiki.python.org/moin/BitwiseOperators). `<<` sign is left-shifting bitwise operator which shift bits in binary of a number by one to the left. Imaging you have number 4, (`bin(4) = 0b100`)! doing `4 >> 1` make the new binary `1000` (shifted to the left by 1 and added a zero to the rightmost bit) which is the binary for 8. The reason it tries to do the multiplicaion is to fasten the process. From [here](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/329694), A naive method here is to repeatedly subtract divisor from dividend, until there is none enough left. Then the count of subtractions will be the answer. Yet this takes linear time and is thus slow. A better method is to subtract divisor in a more efficient way. We can subtract divisor, 2divisor, 4divisor, 8*divisor... as is implemented above. .It will go to the outer loop once it cannot substract anymore of `curr_divisor` from `dividend`, and set the `curr_divisor = divisor` and tries the actual divisor (no 2  multiplications). \\n\\n`#13`: We are told by problem statement to limit the output to 32-bit integers, meaning the `res` parameter fall in the [-2^31, 2*^31-1] range. Here, the line has two components. First, it compares output (`res`) with -2^31 value and return the max of the two since we don\\'t want values less than -2^31. Next, it compares the value from `max(-2147483648, res)` with the maximum allowable value (meaning 2^31). So, if we put `a = max(-2147483648, res)`, then it does `min(a, 2147483647)` and return the min of two since we\\'re not allowed to go above 2^31 = 2147483647 number. \\n\\n=========================================\\n\\nFinal note: In order to fully understand the code, I suggest to grab a piece of paper and pen (or write on a notepad or something similar in out laptop/pc) and write a simple example and try to pass through the algorithm by hand. Here is an example from [this](https://leetcode.com/problems/divide-two-integers/discuss/13403/Clear-python-code/144026). \\n\\nLet\\'s take an example: `50 / 4`\\nAt the start,\\n`curr_divisor, num_divisors = divisor, 1` # dividend = 50, curr_divisor = 4, num_divisors = 1\\n`dividend -= curr_divisor` # dividend = 46, curr_divisor = 4 ,num_divisors = 1\\n`res += num_divisors` # res = 1\\n`num_divisors <<= 1 ` # dividend = 46, curr_divisor = 4 , num_divisors = 2\\n`curr_divisor <<= 1` # dividend = 46, curr_divisor = 8 , num_divisors = 2\\n\\nSecond iteration:\\n`dividend -= curr_divisor` # dividend = 38, curr_divisor = 8 , num_divisors= 2\\n`res += num_divisors` # res = 3\\n`num_divisors <<= 1` # dividend = 38, curr_divisor = 8 , num_divisors = 3\\n`curr_divisor <<= 1` # dividend = 38, curr_divisor = 12 ,  num_divisors = 3\\n\\nand so on, when `dividend > curr_divisor`, we start over again with `curr_divisor = 4`, and `num_divisors = 1`\\n\\n\\n===========================================================================\\nFinal note 2: Since I believe if I could explain something to others in a simple manner, it would be helpful to me, I try to add more posts like this as I move forward through my leetcode journey. \\n\\nFinal note 3: There might be some typos in the writing above!!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n# @return an integer\\ndef divide(self, dividend, divisor):\\n    positive = (dividend < 0) is (divisor < 0) # 1\\n    dividend, divisor = abs(dividend), abs(divisor) # 2\\n    res = 0 # 3\\n    while dividend >= divisor: # 4\\n            curr_divisor, num_divisors = divisor, 1 # 5\\n            while dividend >= curr_divisor: # 6\\n                dividend -= curr_divisor # 7\\n                res += num_divisors # 8\\n                \\n                curr_divisor = curr_divisor << 1 # 9\\n                num_divisors = num_divisors << 1 # 10\\n\\t\\t\\t\\t\\n    if not positive: # 11\\n        res = -res # 12\\n\\t\\t\\n    return min(max(-2147483648, res), 2147483647) # 13\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076061,
                "title": "broken-calculator-js-python-java-c-simple-solution-w-detailed-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first thing we should be able to understand is that one of the operations increases **X** while the other one decreases it. So the natural tendency is to think about the solution in terms of applying these operations in order. That is, multiply as many times as you need to before subtracting as many times as you need to.\\n\\nWe see that that\\'s not a viable solution, however, once we recognize that one of the operations is quite obviously multiplicative rather than additive, meaning that a subtraction done *before* a multiplication has twice the impact, for example.\\n\\nSo the trick here is to think of the problem backwards: moving from **Y** to **X** instead of from **X** to **Y**. If **Y** is odd, we\\'re forced to do the additive operation (reversed from the subtractive operation) as we can\\'t divide an odd number by **2** and be able to reach **X**. If **Y** is even, we can prioritize the division operation instead. At each step we can increment our **ans**.\\n\\nOnce **Y** drops below **X**, the remaining difference must be made via the additive operation, so we can just **return** that difference plus **ans**.\\n\\n**To illustrate why the backwards order leads to the correct solution**, let\\'s take a look at an example: **X = 3, Y = 13**. Under the naive approach discussed at the very beginning of this section, we could apply the multiplication operation **3** times to achieve **24**, then apply the subtraction operation **11** times to bring **Y** back down to **13**.\\n\\nAs we observed before, that **11** is not very efficient, considering that some/all of those subtraction operations could have been done before some/all of the multiplication operations with greater impact.\\n\\nSo what if we had applied as many of those operations as necessary just *before* the last of the three multiplications? Then we would only have needed **5** operations to effect **10** subtraction, plus the leftover **1** to get to **11** at the end.\\n\\nIf we go back one more step before the second of three multiplications, we could have instead done **2** operations then which would have the effect of **8** substraction, plus an extra operation after the second multiplication (adding another **2** subtraction), plus the final operation after all multiplications to reach **11**.\\n\\nThis quickly begins to represent a binary representation of our target difference of **11**:\\n```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\\nWe can already see that this is starting to look like our backwards approach. At each additional multiplication operation available, we\\'re forced to perform a subtraction operation if the difference is still odd, otherwise, we can divide the remainder by **2** and push it back one multiplication earlier.\\n\\nBasically, for each multiplication we need to take **X** over **Y**, we take the remaining difference, count the first bit, then shift the difference to the right. And that should sound *exactly* like our backwards approach, because the first bit is a **0** if even and **1** if odd, and shifting to the right is the same as dividing by **2**.\\n\\n**So why can\\'t we go forwards with X instead of backwards with Y?** As mentioned before, the multiplication operation is, quite obviously, multiplicative, and will have an enhancing effect on any subtraction operations performed before it. Therefore, *we cannot possibly know* how much impact any given subtraction operation will have on the difference between **X** and **Y** until we find out how many multiplication operations we will need after it.\\n\\nSo any solution involving moving **X** to **Y** would at least require \"peeking\" ahead at part of the solution before progressing with the subtraction operations.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThis solution is almost identical in all four languages.\\n\\nPython will convert our integer into a float if we simply divide by 2, so we can use the floor division operator instead to maintain the integer.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.2MB** (beats 100% / 90%).\\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **20ms / 14.1MB** (beats 99% / 90%).\\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.4MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     Total multiplications:                                 In binary: (11 = 1011)\\n        3    2    1    0\\n                      11   =   11 in 11 operations                   1011   =   11\\n                  5    1   =   11 in 6 operations                 101 + 1   =   6\\n             2    1    1   =   11 in 4 operations              10 + 1 + 1   =   4\\n        1    0    1    1   =   11 in 3 operations           1 + 0 + 1 + 1   =   3\\n```\n```javascript\\nvar brokenCalc = function(X, Y) {\\n    let ans = 0\\n    while (X < Y) {\\n        ans++\\n        if (Y % 2) Y++\\n        else Y /= 2\\n    }\\n    return X - Y + ans\\n};\\n```\n```python\\nclass Solution:\\n    def brokenCalc(self, X: int, Y: int) -> int:\\n        ans = 0\\n        while X < Y:\\n            ans += 1\\n            if Y % 2: Y += 1\\n            else: Y //= 2\\n        return X - Y + ans\\n```\n```java\\nclass Solution {\\n    public int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2 > 0) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int brokenCalc(int X, int Y) {\\n        int ans = 0;\\n        while (X < Y) {\\n            ans++;\\n            if (Y % 2) Y++;\\n            else Y /= 2;\\n        }\\n        return X - Y + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871168,
                "title": "python3-easiest-solution",
                "content": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "1) Define the result\\'s sign and operate with positive dividend and divisor.\\n2) Calculate the result using the length of range.\\n3) Apply the sign.\\n4) Apply the 32-bit integer limitations.\\n\\nNo multiplication, division, or mod used.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 778597,
                "title": "javascript-with-explanation-80ms-21-lines",
                "content": "Think of multiplication as just a * b = c. This can be rewritten as a + a + a + ... + a + a = c where a is repeated b times. Using this fact, we could naively keep subtracting a from c until c is too small, but this takes too long for large numbers. In order to speed this up, we keep doubling the total number of a\\'s we can subtract, there by making large calculations logarithmic instead of linear. I.e. we check if we can subtract one a, then 2 a\\'s, then 4 a\\'s, then 8 a\\'s, all the way until we cannot subtract anymore. \\n\\nI\\'ll also note that I\\'ve seen a lot of bit manipulation answers here as well. While that is cool, and very useful for lower level coding, if your goal is to understand algorithms I wouldn\\'t worry about these implementations. Just my two cents.\\n\\nStay coding!\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    const retIsNegative = Math.sign(divisor) !== Math.sign(dividend);\\n    dividend = Math.abs(dividend)\\n    divisor = Math.abs(divisor)\\n    \\n    let ret = 0\\n    while (divisor <= dividend) {\\n        let value = divisor\\n        let multiple = 1\\n        while (value + value <= dividend) {\\n            value += value\\n            multiple += multiple\\n        }\\n        dividend = dividend - value\\n        ret += multiple\\n    }\\n    \\n    if (ret > ((2**31) - 1)) {\\n        return retIsNegative ? -(2**31) : 2**31 - 1\\n    }\\n    return retIsNegative ? -ret : ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13422,
                "title": "accepted-java-solution-with-comments",
                "content": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "solutionTags": [],
                "code": "    public int divide(int dividend, int divisor) {\\n\\t\\tlong result = divideLong(dividend, divisor);\\n\\t\\treturn result > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;\\n    }\\n\\t\\n\\t// It's easy to handle edge cases when\\n\\t// operate with long numbers rather than int\\n\\tpublic long divideLong(long dividend, long divisor) {\\n\\t\\t\\n\\t\\t// Remember the sign\\n\\t\\tboolean negative = dividend < 0 != divisor < 0;\\n\\t\\t\\n\\t\\t// Make dividend and divisor unsign\\n\\t\\tif (dividend < 0) dividend = -dividend;\\n\\t\\tif (divisor < 0) divisor = -divisor;\\n\\t\\t\\n\\t\\t// Return if nothing to divide\\n\\t\\tif (dividend < divisor) return 0;\\n\\t\\t\\n\\t\\t// Sum divisor 2, 4, 8, 16, 32 .... times\\n        long sum = divisor;\\n        long divide = 1;\\n        while ((sum+sum) <= dividend) {\\n        \\tsum += sum;\\n        \\tdivide += divide;\\n        }\\n        \\n        // Make a recursive call for (devided-sum) and add it to the result\\n        return negative ? -(divide + divideLong((dividend-sum), divisor)) :\\n        \\t(divide + divideLong((dividend-sum), divisor));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085017,
                "title": "js-python-java-c-updated-logarithmic-bit-manipulation-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n*(Note: Some have questioned whether or not bitwise shifts should count as multiplication/division, so I\\'ve added an alternate solution explanation taking advantage of the algebraic qualities of logarithms below in the **Alaternate Idea** section.)*\\n\\nThe naive approach here would be to use a loop to just work down the difference between the dividend (**A**) and the divisor (**B**) through subtraction, but that\\'s obviously not a very efficient solution.\\n\\nInstead, we can use **bit manipulation** to simulate multiplication/division. Since a **bitwise shift** to the left is the equivalent of a multiplication by **2**, if we count how many times we can bitwise shift **B** to the left while still staying under **A**, then we can quickly work out a chunk of the solution. All that\\'s left is to start over with the remaining amount of **A** and repeat this process, adding the results to our answer (**ans**) as we go.\\n\\nOf course, negative numbers will play havoc with our bitwise shifting, so we should first extract the **sign** difference and then use only positive numbers for **A** and **B**.\\n\\nThere\\'s also the stated edge case, which only occurs at one permutation of **A** and **B**, so we can handle that at the outset.\\n\\n---\\n\\n#### ***Alternate Idea:***\\n\\nFor those who consider bitwise shifts to be too close to multiplication/division, we can instead use the rules of **logarithms** to our advantage:\\n```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\\nSince we\\'ll have to use the absolute values of **A** and **B**, we\\'ll have to define the same edge cases as in the earlier solutions. Finally, we\\'ll also have to apply a **floor()** to the result to truncate the decimal before we **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript and Python both handle numbers larger than **32-bit** internally, and Java requires only a small change to the conditions on its loops to avoid an issue.\\n\\nC++, on the other hand, adheres strictly to the **32-bit** limit, so we have to define a few more edge cases to avoid exceeding these boundaries. That does allow us to simplify the code for both loops, however.\\n\\n---\\n\\n#### ***Javascript Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **84ms / 39.8MB** (beats 99% / 96%).\\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\\n\\n---\\n\\n#### ***Javascript Code w/ Logarithms:***\\n\\nThe best result for the code below is **84ms / 40.1MB** (beats 99% / 63%).\\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **20ms / 14.0MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Logarithms:***\\n\\nThe best result for the code below is **28ms / 14.1MB** (beats 92% / 95%).\\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\\n\\n---\\n\\n#### ***Java Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 100% / 97%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***Java Code w/ Logarithms:***\\n\\nThe best result for the code below is **1ms / 35.9MB** (beats 100% / 84%).\\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Bit Manipulation:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code w/ Logarithms:***\\n\\nThe best result for the code below is **0ms / 6.1MB** (beats 100% / 48%).\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```c++\\n  if:  exp(log(c) = c                   // Logarithmic rule #1\\n  if:  log(a / b) = log(a) - log(b)     // Logarithmic rule #2\\n\\nthen:  a / b = exp(log(a / b))          // From rule #1\\n       a / b = exp(log(a) - log(b))     // From rule #2\\n\\n       (if m and n are > 0)\\n```\n```javascript\\nvar divide = function(A, B) {\\n    if (A === -2147483648 && B === -1) return 2147483647\\n    let ans = 0, sign = 1\\n    if (A < 0) A = -A, sign = -sign\\n    if (B < 0) B = -B, sign = -sign\\n    if (A === B) return sign\\n    for (let i = 0, val = B; A >= B; i = 0, val = B) {\\n        while (val > 0 && val <= A) val = B << ++i\\n        A -= B << i - 1, ans += 1 << i - 1\\n    }\\n    return sign < 0 ? -ans : ans\\n};\\n```\n```javascript\\nvar divide = function(A, B) {\\n    let ans = 0\\n    if (B === -2147483648) return A === B\\n    if (A === -2147483648)\\n        if (B === 1) return -2147483648\\n        else if (B === -1) return 2147483647\\n        else A += Math.abs(B), ans++\\n    ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))))\\n    return A > 0 === B > 0 ? ans : -ans\\n};\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans, sign = 0, 1\\n        if A < 0: A, sign = -A, -sign\\n        if B < 0: B, sign = -B, -sign\\n        if A == B: return sign\\n        while A >= B:\\n            b = 0\\n            while B << b <= A: b += 1\\n            A -= B << b - 1\\n            ans += 1 << b - 1\\n        return -ans if sign < 0 else ans\\n```\n```python\\nclass Solution:\\n    def divide(self, A: int, B: int) -> int:\\n        if A == 0: return 0\\n        if A == -2147483648 and B == -1: return 2147483647\\n        ans = math.floor(math.exp(math.log(abs(A)) - math.log(abs(B))))\\n        return ans if (A > 0) == (B > 0) else -ans\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        if (A == -2147483648 && B == -1) return 2147483647;\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (A < 0) A = -A;\\n        if (B < 0) B = -B;\\n        if (A == B) return sign;\\n        for (int i = 0, val = B; A - B >= 0; i = 0, val = B) {\\n            while (val > 0 && A - val >= 0) val = B << ++i;\\n            A -= B << i - 1;\\n            ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B ? 1 : 0;\\n        if (A == -2147483648) {\\n            if (B == 1) return -2147483648;\\n            if (B == -1) return 2147483647;\\n            A += Math.abs(B);\\n            ans++;\\n        }\\n        ans += Math.floor(Math.exp(Math.log(Math.abs(A)) - Math.log(Math.abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0, sign = A > 0 == B > 0 ? 1 : -1;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        A = abs(A), B = abs(B);\\n        for (int i = 0; A >= B; i = 0) {\\n            while (A >> i >= B) i++;\\n            A -= B << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        int ans = 0;\\n        if (B == -2147483648) return A == B;\\n        if (A == -2147483648)\\n            if (B == 1) return -2147483648;\\n            else if (B == -1) return 2147483647;\\n            else A += abs(B), ans++;\\n        ans += floor(exp(log(abs(A)) - log(abs(B))));\\n        return A > 0 == B > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084803,
                "title": "python-bitwise",
                "content": "We don\\'t need multiplication, division, or modulo operator, as long as we have addition, subtraction, and bitwise shift.\\n\\nSuppose that `x,y >0` (we handle negatives at the end) and `x = y*m + remainder` where we are interested in `m`. This multiple is a positive integer and can be expressed in binary form. Consider a simple case and say `m=16`. In terms of bit strings, `m = \\'0b10000\\'`. How do you multiply `y` by `m` here? Simply shift `y` by the number of shifts `1` has in `m`. So in python-speak this is `y<<4`. For the general case just do it iteratively.\\n\\n```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def divide(self, x, y):\\n        ans = 0\\n        xx, yy = abs(x), abs(y)\\n        for i in range(32, -1, -1):\\n            if xx >= (yy<<i):\\n                xx -= (yy<<i)\\n                ans += (1<<i)\\n        \\n        if (x>0 and y<0) or (x<0 and y>0): \\n            ans = -ans\\n        \\n        return min(2**31-1, max(-2**31, ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13524,
                "title": "summary-of-3-c-solutions",
                "content": "-1-  log-based solution\\n \\n\\n       class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }\\n        };\\n\\n\\n-2-   Binary Index tree idea inspired solution, \\n\\nas we can decompose any result number to sum of the power \\n\\nof 2.\\n\\nHere is the C++ implementation.\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor || (dividend==INT_MIN && divisor==-1))   return INT_MAX;\\n            \\n            int sign=((dividend<0)^(divisor<0)) ? -1:1;\\n            long long m=labs(dividend);\\n            long long n=labs(divisor);\\n            int result=0;\\n            \\n            /** dvd >= 2^k1*dvs + 2^k2*dvs ... **/\\n            while(m>=n){\\n                long long temp=n, count=1;\\n                while(m >= (temp<<1)){\\n                    temp<<=1;\\n                    count<<=1;\\n                }\\n                m-=temp;\\n                result+=count;\\n            }\\n            \\n            return sign==1?result:-result;\\n        }\\n    };\\n\\n-3-  concise version of the solution 2\\n\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            long long result=0;\\n            long long m=abs((long long)dividend);\\n            long long n=abs((long long)divisor);\\n            while(m>=n){\\n                long long s=n, power=1;\\n                while((s<<1) <= m) { s<<=1; power<<=1; }\\n                result+=power;\\n                m-=s;\\n            }\\n            \\n            if( (dividend>0) ^ (divisor>0))  result = -result;\\n            return result>INT_MAX ? INT_MAX:result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int divide(int dividend, int divisor) {\\n                /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/\\n                if(dividend==0)  return 0;\\n                if(divisor==0)  return INT_MAX;\\n                \\n                double t1=log(fabs(dividend));\\n                double t2=log(fabs(divisor));\\n                long long result=double(exp(t1-t2));\\n                if((dividend<0) ^ (divisor<0))  result=-result;\\n                if(result>INT_MAX)  result=INT_MAX;\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 251447,
                "title": "c-easy-to-understand-code-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long divide(long long dividend, long long divisor) {\\n        if (dividend < divisor)\\n            return 0;\\n        \\n        long long sum = divisor;\\n        long long multiple = 1; // 1 2 4 8 16 32 64...\\n        while ((sum + sum) <= dividend) {\\n            sum += sum;\\n            multiple += multiple;\\n        }\\n        \\n        return multiple + divide(dividend - sum, divisor);\\n    }\\n    \\n    int divide(int dividend, int divisor) {\\n        bool positive = (dividend >= 0 == divisor > 0);\\n        \\n        long long ldividend = abs((long long) dividend);\\n        long long ldivisor = abs((long long) divisor);\\n        long long lres = divide(ldividend, ldivisor);\\n        if (lres > INT_MAX) {\\n            lres = positive ? INT_MAX : INT_MIN; \\n        } else {\\n            lres = positive ? lres : -lres;\\n        }\\n        \\n        return lres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179759,
                "title": "python-7-lines-beats-99-how-you-learned-to-divide-when-you-were-7-years-old",
                "content": "The core algorithm is simple. There are 2 phases:\\n1. Determine how far left to shift the divisor.\\n2. Divide like a 7-year-old (or 5, or 6, or 8, or 9, depending on where you\\'re from).\\n\\nTime: O(log(answer)) = O(log(dividend // divisor)) = O(log(dividend) - log(divisor))\\nSpace: O(1)\\n\\nAlgorithm for integer division of `p/q`, where `p` and `q` are positive:\\n```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\\n---\\n\\n### Explanation\\n\\nYou probably learned to do something like this in school:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nHere\\'s a clearer view of what\\'s happening behind the scenes:\\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\\nBinary division is actually a lot easier, because at each step, `?` can only be 0 or 1. Example:\\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\\nThe algorithm should be pretty obvious now: First you try to subtract `110000`; it\\'s too big, so you try to subtract `11000`; it\\'s still too big, so you try to subtract `1100`; it works, so you subtract it and add `100` to the result; then you try to subtract `110`; it\\'s too big, so you try to subtract `11`; it works, so you subtract it and add `1` to the result. That\\'s it.\\n\\nOf course, in the example above, we know that the first two `0`s are unnecessary. That is what Phase 1 is for: Shift `q` as far left as possible without exceeding `p`.\\n\\nFull solution:\\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "solutionTags": [],
                "code": "```python\\ni, result = 0, 0 # Initialize stuff.\\n\\nwhile q << i <= p: i += 1 # Phase 1: Figure out how far left you should go.\\n\\nfor j in reversed(range(i)): # Phase 2: Divide like a 7-year-old.\\n    if q << j <= p:\\n        p -= q << j\\n        result += 1 << j\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n                         60         60         60  \\n                         ----       ----       ----\\n                          78         78         78 \\n                                     72         72 \\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```abc\\n   ?          0?         05?        056?       0565\\n  +----      +----      +----      +----      +----\\n12|6789    12|6789    12|6789    12|6789    12|6789\\n              0000       0000       0000       0000\\n              ----       ----       ----       ----\\n              6789       6789       6789       6789\\n                         6000       6000       6000\\n                         ----       ----       ----\\n                          789        789        789\\n                                     720        720\\n                                    ----       ----\\n                                      69         69\\n                                                 60\\n                                               ----\\n                                                  9\\n```\n```\\n   00101\\n  +-----\\n11|10001\\n       0 == 0 * 110000 because 110000 >  10001\\n   -----\\n   10001\\n       0 == 0 * 11000  because  11000 >  10001\\n   -----\\n   10001\\n    1100 == 1 * 1100   because   1100 <= 10001\\n   -----\\n     101\\n       0 == 0 * 110    because    110 >  101\\n   -----\\n     101\\n      11 == 1 * 11     because     11 <= 101\\n   -----    ^\\n      10    |\\n            this column is the answer (00101)\\n```\n```python\\ndef divide(self, dividend, divisor):\\n\\n    # this is necessary; otherwise phase 1 never terminates\\n    if dividend == 0: return 0\\n\\n    # initialize\\n    i, result, p, q = map(abs, (0, 0, dividend, divisor))\\n    \\n    # phase 1\\n    while q << i <= p: i += 1\\n\\n    # phase 2\\n    for j in reversed(range(i)):\\n        if q << j <= p: p, result = p - (q << j), result + (1 << j)\\n\\n    # stupid leetcode restrictions\\n    if (dividend > 0) != (divisor > 0) or result < -1 << 31: result = -result\\n    return min(result, (1 << 31) - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13591,
                "title": "a-readable-java-implementation",
                "content": "At first, I used dividend / divisor, just to check. But that was cheating.\\n\\nThen, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating.\\n\\nAt last, I came up with this solution. It handles all the corner cases. Running time analysis after the code.\\n\\n    public class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }\\n            \\n            // Compute the result by shifting mult to the right.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop\\n            // (in total, not per outer iteration).\\n            int result = 0;\\n            int power = 1 << shifts; // = 2^shifts\\n            while (dividend <= divisor) {\\n                shifts = 0;\\n                while (mult < dividend) {\\n                    mult >>= 1;\\n                    ++shifts;\\n                }\\n                dividend -= mult;\\n                power >>= shifts;\\n                result |= power; // Adds power to result\\n            }\\n            \\n            return result;\\n        }\\n    }\\n\\nI see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I'm not sure the Big-Oh notation is appropriate here. Anyway, here's a rough worst-case analysis of this code.\\n\\nThe first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are\\n\\n - 2 comparisons\\n - 1 bit shift\\n - 1 increment\\n\\nThe second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are\\n\\n - 1 comparison\\n - 1 assignment\\n - 1 substraction\\n - 1 bit shift\\n - 1 bitwise or\\n\\nThe inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are\\n\\n - 1 comparison\\n - 1 bit shift\\n - 1 increment\\n\\nSo, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int divide(int dividend, int divisor) {\\n            if (divisor == 1) // Trival case 1\\n                return dividend;\\n            \\n            // Use negative integers to avoid integer overflow\\n            if (dividend > 0)\\n                return -divide(-dividend, divisor);\\n            if (divisor > 0)\\n                return -divide(dividend, -divisor);\\n            \\n            if (dividend > divisor) // Trivial case 2\\n                return 0;\\n            \\n            if ((dividend == Integer.MIN_VALUE) && (divisor == -1)) // Overflow case\\n                return Integer.MAX_VALUE;\\n            \\n            // Find the highest mult = (divisor * 2^shifts) which is <= dividend\\n            // by shifting mult to the left without causing an overflow.\\n            // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations.\\n            int min_divisor = Integer.MIN_VALUE >> 1;\\n            int mult = divisor; // = divisor * 2^shifts\\n            int shifts = 0;\\n            while ((mult >= min_divisor) && (mult > dividend)) {\\n                mult <<= 1;\\n                ++shifts;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2139178,
                "title": "simple-eficient-100-faster",
                "content": "**<++++++++ Press upvote Button Please !!!!!!!**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/da759167-b79f-448a-b13b-07fbbd8b216d_1654964334.5319335.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n    \\n        if(dividend==INT_MIN && divisor==-1) return INT_MAX;\\n        if(dividend==INT_MIN && divisor==1) return INT_MIN;\\n\\n        \\n\\n        long int dd = abs(dividend), dv = abs(divisor);\\n        \\n     \\n        int res=0;\\n        while(dv<=dd) {\\n            long int sum=dv, count=1;\\n            while(sum<=dd-sum) {\\n                sum+=sum;\\n                count+=count;\\n            }\\n            res+=count;\\n            dd-=sum;\\n        }\\n        \\nif((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n        \\n        return res;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179466,
                "title": "20ms-binary-search-java-with-explanations",
                "content": "We eastablish variables `sum` and `quotient` with the invariant `quotient * divisor = sum`.\\nTake dividend = 20, divisor = 3 for example,\\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\\nCode\\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\\n****\\nTo increase `quotient` one by one costs much time. We could apply **Binary Search** here, i.e. `quotient = quotient * 2` each time. \\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\\nWe remove negative sign of dividend and divisor in the beginning and add `signNegative` to make up the difference.\\nIn case of Integer Overflows, we use long to while addition. And we need to make sure the final result is within the range `[\\u22122^31,  2^31 \\u2212 1]`.\\n\\n**Code**\\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n9     3        11\\n12    4        8\\n15    5        5\\n18    6        2\\n ^\\n 18 + 3 > 20, so the answer is 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n        // Corner cases\\n        if (dividend == 0) return 0;\\n        if (divisor == 1) return dividend;\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        long ldividend = (long)dividend; // To avoid integer overflow in calculations after\\n        if (ldividend < 0) ldividend = -ldividend;\\n        long ldivisor = (long)divisor; // To avoid integer overflow in calculations after\\n        if (ldivisor < 0) ldivisor = -ldivisor;\\n        \\n        // sum = ldivisor * lquotient\\n        long lquotient = 1, sum = ldivisor; \\n        while (sum < ldividend) {\\n            lquotient++;  \\n            sum += ldivisor;  \\n        }\\n        \\n        if (sum > ldividend) lquotient--;\\n        boolean isPositive = (dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0);\\n        \\n        return isPositive ? (int)lquotient: -(int)lquotient;\\n    }\\n```\n```\\nsum  quotient  target\\n3     1        17\\n6     2        14\\n12    4        8\\n ^\\n 12 + 12 > 20, so the answer is 4 --- X wrong for we missed quotient of 8 / 3\\nInstead, \\nsum  quotient  target\\n3     1        8\\n6     2        5\\n^\\n6 + 6 > 8, so the answer for 8 / 3 is 2\\n\\nThe final answer is 4 + 2 = 6\\n```\n```\\n    public int divide(int dividend, int divisor) {\\n\\n        long ldividend = (long) dividend, ldivisor = (long) divisor;\\n\\n        boolean signNegative = false;\\n        if (ldividend < 0) {\\n            signNegative = !signNegative;\\n            ldividend = -ldividend;\\n        }\\n        if (ldivisor < 0) {\\n            signNegative = !signNegative;\\n            ldivisor = -ldivisor;\\n        }\\n\\n        long result = divideRecur(ldividend, ldivisor);\\n\\n        if (result > Integer.MAX_VALUE && !signNegative) {\\n            result = Integer.MAX_VALUE;\\n        } else if (result < Integer.MIN_VALUE) {\\n            result = Integer.MIN_VALUE;\\n        }\\n\\n        return signNegative ? (int) -result : (int) result;\\n    }\\n\\n    private long divideRecur(long dividend, long divisor) {\\n\\n        if (dividend < divisor)\\n            return 0;\\n\\n        long sum = divisor, quotient = 1;\\n        while (sum + sum < dividend) {\\n            sum += sum;\\n            quotient += quotient;\\n        }\\n\\n        return quotient + divideRecur(dividend - sum, divisor);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246094,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Algorithm**\\n\\n- A **brute-force** approach is to iteratively subtract `y` from `x` until what remains is less than `y`. The number of such subtractions is exactly the quotient, `x / y`, and the remainder is the term that\\'s less than `y` the complexity of brute-force approach is very high.\\nFor Example- when x = 2<sup>31</sup> - 1 and `y = 1`, then it will take 2<sup>31</sup> - 1 iterations.\\n\\nTime complexity: `O(x) ` - where `x` is the `dividend`.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\n- A **better approach** is to try and get more work done in each iteration. The idea is to compute the largest `k` such that 2<sup>k</sup>y <= x, then subtract 2<sup>k</sup>y from `x` and 2<sup>k</sup> to the `quotient`.\\nFor Example- if x = (1011)<sub>2</sub> and y = (10)<sub>2</sub>, then `k = 2`, since 2 * 2<sup>2</sup> <= 11 and 2 * 2<sup>3</sup> > 11. We subtract (1000)<sub>2</sub> from (1011)<sub>2</sub> to get (11)<sub>2</sub>, add 2<sup>k</sup> = 2<sup>2</sup> = (100)<sub>2</sub> to the `quotient`, and continue by updating `x` to (11)<sub>2</sub>.\\n- The advantage of using 2<sup>k</sup>y is that it can be computed very efficiently using shifting, and `x` is halved in each iteration. If it takes `n` bits to represent `x / y`, there are `O(n)` iterations. If the largest `k` such that 2<sup>k</sup>y <= x is computed by iterating through `k`, and since each iteration has time complexity `O(n)`, this leads to O(n<sup>2</sup>) algorithm.\\n\\nTime complexity: O(n<sup>2</sup>) - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\\n\\n**Solution 3:**\\n\\n- The **best way** to find the largest `k` in each iteration is to recongnize that it keeps decreasing. Therefore, instead of testing in each iteration whether 2<sup>0</sup>y, 2<sup>1</sup>y, 2<sup>2</sup>y . . . is less than or equal to `x`, after we initially find the largest `k` such that 2<sup>k</sup>y <= x, in susequent iterations we test 2<sup>k-1</sup>y, 2<sup>k-2</sup>y, 2<sup>k-3</sup>y, . . . with `x`.\\n- For the example given earliar, after setting the `quotient`, to (100)<sub>2</sub> we continue with (11)<sub>2</sub>. Now the largest `k` such that 2<sup>k</sup>y <= (11)<sub>2</sub> is `0`, so we add 2<sup>0</sup> = (1)<sub>2</sub> to the `quotient`, which is now (101)<sub>2</sub>. We continue with (11)<sub>2</sub> - (10)<sub>2</sub> = (1)<sub>2</sub>. Since (1)<sub>2</sub> < y, we are done. So the `quotient` is (101)<sub>2</sub> and the `remainder` is (1)<sub>2</sub>.\\n\\nTime complexity: `O(n)` - where `n` is the number of bits required to represent `x / y`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            x -= y;\\n            result++;\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n\\t\\tlong x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n\\t\\twhile(x >= y)\\n\\t\\t{\\n            int shift = 1;\\n\\n            while(x >= (y << shift))\\n\\t\\t\\t{\\n                shift++;\\n            }\\n            x -= y << (shift - 1);\\n            result += 1 << (shift - 1);\\n        }\\n        return result * sign;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int divide(int dividend, int divisor)\\n\\t{\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        \\n\\t\\tint sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\\n        int result = 0;\\n        int power = 32;\\n        long x = Math.abs((long)dividend);\\n        long y = Math.abs((long)divisor);\\n        \\n       while(x >= y)\\n\\t\\t{\\n            while((y << power) > x)\\n\\t\\t\\t{\\n                power--;\\n            }\\n            x -= y << power;\\n            result += 1 << power;\\n        }\\n        return result * sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13516,
                "title": "javascript-solution-with-o-logn-time-and-o-logn-stack-space",
                "content": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "solutionTags": [],
                "code": "    function divide(dividend, divisor) {\\n        if (dividend === -2147483648 && divisor === -1) {\\n            return 2147483647;\\n        }\\n        var isNeg = dividend > 0 ^ divisor > 0;\\n        var res = 0;\\n        \\n        dividend = Math.abs(dividend);\\n        subtract(Math.abs(divisor), 1);\\n        \\n        function subtract(d, q) {\\n            if (dividend > d) {\\n                subtract(d + d, q + q);\\n            }\\n            if (dividend >= d) {\\n                dividend -= d;\\n                res += q;\\n            }\\n        }\\n        \\n        return isNeg ? -res : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3222214,
                "title": "efficient-bit-manipulation-algorithm-for-integer-division-without-multiplication-or-mod-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to divide two integers, `dividend` and `divisor`, and return the quotient without using multiplication, division, and mod operator.\\n\\nWe can solve this problem using bit manipulation and binary search. We can find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. Then we can perform division using binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Handle division by zero: If the divisor is 0, return `2**31 - 1`.\\n\\n- Handle overflow case: If the dividend is `-2**31` and divisor is `-1`, return `2**31 - 1`.\\n\\n- Get the sign of the result: If both dividend and divisor are negative or positive, the sign of the result will be positive. If either dividend or divisor is negative, the sign of the result will be negative.\\n\\n- Find the largest multiple of the divisor that is less than or equal to the dividend using bit manipulation. We can do this by left-shifting the divisor and multiple by 1 until the left-shifted divisor is greater than the dividend.\\n\\n- Perform division using binary search. We can do this by right-shifting the divisor and multiple by 1 until multiple is 0. If the dividend is greater than or equal to the divisor, subtract the divisor from the dividend and add the multiple to the quotient. Repeat until multiple is 0.\\n\\n- Apply the sign to the quotient and return it.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is $$O(log(dividend))$$.\\n\\nFinding the largest multiple of the divisor that is less than or equal to the dividend takes `log(dividend)` iterations. Performing division using binary search takes `log(dividend) `iterations as well.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this solution is `O(1)`.\\n\\nWe only use a constant amount of extra space to store variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Explanation\\n\\nThe code is an implementation of the binary division algorithm. The algorithm is used to divide two integers (dividend and divisor) and return the quotient (integer division result). Here is how the code works:\\n\\n- The function accepts two integer parameters, dividend and divisor, and returns an integer (quotient).\\n- The function first checks if the divisor is zero. If it is, it returns the maximum 32-bit integer value (2^31 - 1). This is because dividing by zero is not possible, and we need to handle this edge case.\\n- The function then checks for an overflow case where the dividend is the minimum 32-bit integer value (-2^31) and the divisor is -1. In this case, the quotient is the maximum 32-bit integer value (2^31 - 1) since dividing the minimum value by -1 would result in an overflow error.\\n- The function determines the sign of the result by checking the signs of the dividend and divisor. If both are negative or both are positive, the sign is positive. Otherwise, the sign is negative, and we make both values positive for the next step.\\n- The function then finds the largest multiple of the divisor that is less than or equal to the dividend. It does this by left-shifting the divisor and multiple variables (initially set to 1) until the shifted divisor is greater than the dividend. At this point, the last multiple that was less than or equal to the dividend is the largest multiple we need to find. The function keeps track of this multiple value and the divisor value for the next step.\\n- The function then performs the division using binary search. It does this by right-shifting the divisor and multiple variables until multiple is zero. At each step, it checks if the dividend is greater than or equal to the divisor. If it is, it subtracts the divisor from the dividend, adds the multiple to the quotient, and continues the loop. Otherwise, it right-shifts the divisor and multiple variables to check for the next value. At the end of this step, the quotient variable contains the integer division result.\\n- Finally, the function applies the sign to the result and returns it.\\n\\n\\nOverall, the binary division algorithm is an efficient way to perform integer division using bit manipulation. The code handles edge cases such as division by zero and overflow and returns the correct result with the correct sign.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # Handle division by zero\\n        if divisor == 0:\\n            return 2**31 - 1\\n        \\n        # Handle overflow case\\n        if dividend == -2**31 and divisor == -1:\\n            return 2**31 - 1\\n        \\n        # Get the sign of the result\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        \\n        # Find the largest multiple of the divisor that is less than or equal to the dividend\\n        multiple = 1\\n        while dividend >= (divisor << 1):\\n            divisor <<= 1\\n            multiple <<= 1\\n        \\n        # Perform division using binary search\\n        quotient = 0\\n        while multiple > 0:\\n            if dividend >= divisor:\\n                dividend -= divisor\\n                quotient += multiple\\n            divisor >>= 1\\n            multiple >>= 1\\n        \\n        # Apply the sign to the result\\n        return sign * quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086538,
                "title": "c-bit-manipulation-o-logn-2-0ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n- First, find the **highest number (less than dividend)** that can be **substracted** from the `dividend` which is a **multiple of divisor**, then subtract it from the `dividend` and add that multiplier to the answer (`ans`).\\n- **Repeat** the process as long as `dividend >= divisor`.\\n- The algorithm is implemented on positive `dividend` and positive `divisor`, so we add the **sign** at the *end*.\\n- Also, handle few **special cases** before starting the algorithm (shown in the code below).\\n\\n**Note**: Instead of directly finding the \"highest number (less than dividend) that can be subtracted from the dividend which is a multiple of divisor\", we will be finding the lowest multiple of dividend that is greater than the divisor. This is because of handling the case of **integer overflow**.\\n\\n---\\n\\n**EXAMPLE**\\nConsider the **input** as `dividend = 10` and `divisor = 3`,\\n**(1)** Now, first we find the **lowest number** (formed by dividing the `dividend` by 2) that is **greater** than the `divisor` in a loop. Initially `curr_dvd = dividend = 10` and multiplier(`t`) is `1`. The loop will continue only if `curr_dvd >= divisor`. Here, we are trying to find the multiplier by right shifting the `dividend`  by 2 (dividing by 2) in each iteration, this makes the *worst-case time complexity* of finding it `O(logn)`.\\n- **First Iteration** : 10/2 = 5, Since `5>=3(divisor)`, so `curr_dvd=5`, so our multiplier(`t`) becomes `t = t*2 = 2`.\\n- **Second Iteration** : 5/2 = 2, Since `2<3(divisor)`, so after this we will stop.\\n\\nNow, subtract `divisor * multiplier` from `dividend`, that is 10 - 3`*`**2** = 4.\\nAfter that add the multiplier to answer that is `ans+=2`\\n\\n**(2)** From the output of the previous step, since `4>=3(divisor)` repeat **(1)** on 4,\\n- **First Iteration** : 4/2 = 2, Since `2<3(divisor)`, so we will stop.\\n\\nAgain, do the same thing as **(1)**, 4 - 3`*`**1** = 1, so `ans+=1`. (As by default our *multiplier* is `1`)\\n\\n**(3)** From the output of the previous step, `1<3(divisor)`, so we will not repeat **(1)**.\\n\\nHence, the final answer is **`ans = 2 (from 1) + 1 (from 2) = 3`**.\\n\\n***Note**: The code is more optimized than explained in the above example. But, the working is the same.*\\n\\n---\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(logn * logn)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { // dividend / divisor\\n        \\n        int ans = 0;\\n\\n        // Handle special cases\\n        if (divisor == INT_MIN)\\n            if (dividend == divisor) return 1;\\n            else return 0;\\n        \\n        if (dividend == INT_MIN)\\n            if (divisor == 1) return INT_MIN;\\n            else if (divisor == -1) return INT_MAX;\\n            else dividend += abs(divisor), ans++; // INT_MIN + abs(divisor) / abs(divisor) = 1 + INT_MIN / abs(divisor)\\n\\n        // find the sign of the answer\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        \\n        // making both dividend and divisor positive\\n        dividend = abs(dividend), divisor = abs(divisor);\\n        \\n        // main code\\n        while(dividend >= divisor) { \\n            int t=1; // multiplier by default 1 since (dividend >= divisor)\\n            int curr_dvs=divisor;\\n            int curr_dvd=dividend >> 1;\\n            \\n            while (curr_dvd >= divisor){\\n                curr_dvs = curr_dvs << 1;\\n                t = t << 1;\\n                curr_dvd = curr_dvd>>1;\\n            }\\n\\n            dividend -= curr_dvs;\\n            ans += t;\\n        }\\n        return sign > 0 ? ans : -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367837,
                "title": "building-up-solution-in-python-with-easy-explaination",
                "content": "How do we do division if we couldn\\'t use multiplication or division? \\nThe easiest way: we just substract or diviser from the dividend until there is nothing to substract.\\n# Easy but slow\\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\\n\\nOnly problem with that.. It\\'s too slow. \\n# Fast solution\\nWe want to speed up the process by substracting not the divisor, but divisor multiplied by something. \\nBut we couldn\\'t multiply directly due to the task conditions.\\nHow do we do than ? \\nWe use the fact that **bitwise left shift is equal to multiplying by two**:\\n101 << 1 = 1010 \\nSo we shift the divisor left as much as we can before substracting: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\\n# The final solution\\nThe last thing we need to do is to account for the max number: \\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tdividend -= divisor\\n\\tres += 1\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nreturn -res if sign else res\\n```\n```\\nif not dividend:\\n\\treturn 0\\nsign = 1 if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0) else 0\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\nres = 0\\nwhile dividend >= divisor:\\n\\tk = 0\\n\\twhile dividend >= divisor << (k + 1):\\n\\t\\tk += 1\\n\\tdividend -= (divisor << k)\\n\\tres += (1 << k)\\nMAX_INT =  (1 << 31) - 1\\nreturn -res if sign else (res if res <= MAX_INT else MAX_INT)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13653,
                "title": "compiler-does-not-actually-check-for-division-operator",
                "content": "    return dividend / divisor;\\n\\nwas accepted.",
                "solutionTags": [],
                "code": "    return dividend / divisor;\\n\\nwas accepted.",
                "codeTag": "Unknown"
            },
            {
                "id": 1601170,
                "title": "java-1ms-single-recursive-function",
                "content": "This solution is based on the following two posts.\\nhttps://leetcode.com/problems/divide-two-integers/discuss/1579861/Java-no-longs-simple-solution-that-someone-could-actually-come-up-with\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nI thought both of these were very nice but they used two different functions so I turned it into a single recursive function mainly for aesthetic purposes. \\nThe second link has bit manipulation if you\\'re freaky like that.\\nI much prefered the easier to understand and arguably prettier solution in the first link.\\n```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```\\nI hope this helps someone who wanted a neat answer in java.\\nthe while loop is used to basically create multiples of the divisor with the powers of 2 (eg 2 x divisor,4 x divisor,8 x divisor, ...) which makes the time complexity O(log n) vs the O(n) time complexity with the repeated subtraction method. (n being the quotient)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t//all of these if else statements are only for edge cases and to make both dividend and divisor negative\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        if (divisor == 1)\\n            return dividend;\\n        if (dividend > 0 && divisor > 0)\\n            return divide(-dividend, -divisor);\\n        else if (dividend > 0)\\n            return -divide(-dividend, divisor);\\n        else if (divisor > 0)\\n            return -divide(dividend, -divisor);\\n        if (divisor < dividend || dividend == 0)\\n            return 0;\\n        int sum = divisor;\\n        int mult = 1;\\n        while ((sum + sum) < sum && (sum + sum) >= dividend) {\\n            sum += sum;\\n            mult += mult;\\n        }\\n        return mult + divide(dividend - sum, divisor);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837822,
                "title": "python-clean-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1\\n        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        ans = 0      \\n        \\n        for power in range(31, -1, -1) :\\n            if (divisor << power) <= dividend:\\n                ans += (1 << power)\\n                dividend -= (divisor << power)\\n           \\n        ans = ans * sign\\n        \\n        if not (-2**31 <= ans <= 2**31-1):\\n            return 2**31 - 1\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204883,
                "title": "56ms-python-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        dividend1, divisor1 = abs(dividend), abs(divisor)\\n        quotient = 0\\n        while dividend1 >= divisor1:\\n            temp, i = divisor1, 1\\n            while dividend1 >= temp:\\n                dividend1 -= temp\\n                temp += temp\\n                quotient += i\\n                i += i\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            quotient = -quotient\\n        return min(max(quotient, -pow(2,31)),pow(2,31)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13436,
                "title": "java-3ms-using-bit-operation-and-recursion",
                "content": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    public int divide(int a, int b) {\\n    \\t\\tif (b == 0)\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t\\t//\\u7531\\u4e8eInteger.MINVALUE\\u7684\\u7279\\u6b8a\\u6027(\\u5176\\u8865\\u7801\\u662f\\u5b83\\u672c\\u8eab)\\uff0c\\u4e0d\\u5f97\\u4e0d\\u5c06int\\u578b\\u8f6c\\u4e3along\\u578b\\n    \\t\\tlong dividend = (long)a;\\n    \\t\\tlong divisor = (long)b;\\n    \\t\\t//\\u7b26\\u53f7\\u4f4d\\u505a\\u548c\\uff0c-1\\u8868\\u793a\\u7ed3\\u679c\\u4e3a\\u8d1f\\uff0c\\u5426\\u5219\\u7ed3\\u679c\\u4e3a\\u6b63\\u6570\\n    \\t\\tlong sign = (dividend >> 31) + (divisor >> 31);\\n    \\t\\tdividend = (dividend >> 31) == 0 ? dividend : (~dividend + 1);\\n    \\t\\tdivisor = (divisor >> 31) == 0 ? divisor : (~divisor + 1);\\n    \\t\\t//\\u521d\\u59cb\\u5224\\u65ad\\uff0c\\u88ab\\u9664\\u6570\\u5c0f\\uff0c\\u76f4\\u63a5\\u8fd4\\u56de0\\n    \\t\\tif(divisor > dividend)\\n    \\t\\t\\treturn 0;\\n    \\t\\t//\\u5f00\\u59cb\\u9012\\u5f52\\n    \\t\\tlong quotient = recurse(dividend, divisor, divisor, 1);\\n    \\t\\t//\\u7ed9\\u5546\\u52a0\\u4e0a\\u7b26\\u53f7\\n    \\t\\tquotient = (sign == -1) ? (~quotient + 1) : quotient;\\n    \\t\\t//\\u5224\\u65ad\\u662f\\u5426\\u6ea2\\u51fa\\uff0c\\u5982a=Integer.MINVALUE,b=-1\\u7ed3\\u679c\\u662f\\u6ea2\\u51fa\\u7684\\n    \\t\\tif(quotient >= Integer.MIN_VALUE && quotient <= Integer.MAX_VALUE)\\n    \\t\\t\\treturn (int)quotient;\\n    \\t\\telse\\n    \\t\\t\\treturn Integer.MAX_VALUE;\\n    \\t}\\n    \\t/*\\n    \\t * \\u5927\\u81f4\\u601d\\u8def\\uff1a\\n    \\t * \\u9664\\u6570\\u4f9d\\u6b21\\u5de6\\u79fb\\u4e00\\u4f4d(\\u4e582)\\uff0c\\u76f4\\u81f3\\u5927\\u4e8e\\u88ab\\u9664\\u6570\\n    \\t * \\u56de\\u9000\\uff0c\\u5224\\u65ad\\uff0c\\u82e5\\u5dee\\u5c0f\\u4e8e\\u521d\\u59cb\\u9664\\u6570\\uff0c\\u7ed3\\u675f\\uff0c\\u5426\\u5219\\u88ab\\u9664\\u6570\\u7f6e\\u4e3a\\u4e24\\u8005\\u4e4b\\u5dee\\uff0c\\u9664\\u6570\\u4e3a\\u521d\\u59cb\\u6570\\uff1b\\n    \\t * \\u4f8b\\u5982\\uff0c(7,2,2,1)->(7,4,2,2)->(7,8,2,4)->(3>2)->(3,2,2,1)+2->(3,4,2,1)+2->(1<2)->return 1+2=3;\\n    \\t */\\n    \\tpublic long recurse(long dividend, long divisor, long init, long quotient){\\n    \\t\\tif(dividend > divisor){\\n    \\t\\t\\treturn recurse(dividend, divisor << 1, init, quotient << 1);\\n    \\t\\t} else if(dividend == divisor){\\n    \\t\\t\\treturn quotient;\\n    \\t\\t} else{\\n    \\t\\t\\tif(dividend-(divisor >> 1) < init)\\n    \\t\\t\\t\\treturn quotient>>1;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\treturn recurse(dividend - (divisor >> 1), init, init, 1) + (quotient >> 1);\\n    \\t\\t}\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2029618,
                "title": "c-easy-to-understand-detailed-explanation-beginner-friendly-bitwise-o-log-n",
                "content": "Ayo! Another question that\\'s a bit tricky to get because, you guessed it, it involves a trick lol.\\nDon\\'t worry though, here\\'s the explanation, as simple as it can get!\\n\\nWe will follow a simple rule here.\\n- We are given 2 things. Dividend and Divisor.\\n- The dividend is divided by the divisor.\\n- Our job is to multiply divisor as long as it\\'s less than dividend.\\n\\n**Take this example: Dividend = 10. Divisor = 3.**\\nWe know the answer should be 3 because 3x3=9. Which is the greatest number we can achieve, by multiplying 3 n times and when subtracted from dividend, will be as close to 0 as possible. So, 10-9=1, which is very close to 0. \\n\\nOur job is to multiply divisor again and again, to make it such a large number that when subtracted from dividend, will give us a number as close to 0 as possible.\\n\\n**Steps Taken:**\\n1. The dividend and divisor can be negative. So store their sign for later use and for now, convert them into positive integers by using the abs() function.\\n2. While dividend is greater than divisor, we do the following operations on divisor:\\n3. We take a copy of divisor and try to double it as long as it\\'s smaller than dividend.\\n4. The number of times we double, is twice the number of times we multiply. So, if we double once, we are just multiplying the number by 2^1 in reality. If we double 4 times, then we\\'re actually multiplying the number by 2^4=8 (basic math: we\\'re just multiplying the number by 2 every time).\\n5. So keep doubling divisor\\'s copy and keep tracking how many times we multiplied divisor\\'s copy.\\n6. Now after a while, the divisor\\'s copy\\'s double will be greater than the dividend. So stop the doubling loop for now.\\n7. Now, whatever we have from doubling divisor\\'s copy. Subtract that from the dividend and store that back into the dividend. So, if we doubled 5 thrice, the divisor\\'s copy will be 40 or in other words, we multiplied 5 by 2^3=8 (5 doubled=10 doubled=20 doubled=40). So if we doubled 3 times, we basically multiplied 5 by 2^3=8. So if the divisor\\'s copy is now 40 and if our dividend was 48, our dividend after subtraction will be: 48-40=8, which is still less than original divisor 5. So our loop will run once again. This time, dividend is 8. Divisor is 5. Divisor\\'s copy\\'s double is 10, which is greater than 8. So we won\\'t double the divisor this time. So, if we didn\\'t double it, we just multiplied the 5 with 1, instead of 2. Now again, subtract 8-5=3. So, we first multiplied 5 by 8, then multiplied 5 by 1. Overall, we multiplied 5 by 9 (8+1), which is our answer. More loops won\\'t work because dividend is now 3, which is less than 5.\\n8. If our original dividend and divisor would have given positive result, we return ans as is.\\n9. Otherwise, if one of the numbers was negative, then we return ans with negative sign.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int divide(int divd, int divs) {\\n        // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(divd == INT_MIN and divs == -1){\\n            return INT_MAX;\\n        }\\n        // If dividend and divisor are both positive/negative\\n        // total is positive, else not.\\n        bool positiveSign = (divd < 0 == divs < 0);\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long dividend = abs(divd);\\n        long divisor = abs(divs);\\n        // our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n        long ans = 0;\\n        \\n        // while dividend is less/equal to divisor do the following:\\n        while(dividend >= divisor){\\n            // take a copy of divisor. we\\'re not modifying divisor,\\n            // because we still need to check if dividend is greater/equal to\\n            // our original divisor\\n            long divisor2 = divisor;\\n            // divisorMultipliedBy tells us how many times we can double\\n            // divisor so as to keep it less than dividend.\\n            // for example: 3x2=6. 3 doubled is 6, which is still less than 10\\n            long divisorMultipliedBy = 1;\\n            \\n            // while dividend is greater than double the divisor2 do the following:\\n            while(dividend >= (divisor2 << 1)){\\n                // double the divisor2, if it was 3 at first, make it 6\\n                divisor2 = divisor2 << 1;\\n                // Since we doubled divisor, store the amount of how many times\\n                // we multiplied divisor.\\n                // 3 doubled once=6, so we multiplied divisor by 2.\\n                // 3 doubled twice=12. So we multiplied 3 by 4.\\n                divisorMultipliedBy = divisorMultipliedBy << 1;\\n            }\\n            // divisorMultipliedBy should now have the number of times\\n            // we multiplied divisor to get a value less than dividend.\\n            ans+= divisorMultipliedBy;\\n            // so if now divisor2 is 6, after doubling once.\\n            // dividend was 10, but after subtracting dividend will become 10-6=4.\\n            // So now 4 is dividend, 3 is divisor and we try to find out the number\\n            // of multiplications again and add them up.\\n            // In the second iteration, we\\'ll multiply 3 by 1. So now it\\'ll be\\n            // 4-3=1. dividend is now as close to 0 as possible and is also less\\n            // than divisor. So, our final ans is 3. We x2 the 3 once and now x1.\\n            dividend -= divisor2;\\n        }\\n                  \\n        // if PositiveSign was true, then we return ans as is.\\n        if(positiveSign){\\n            return ans;\\n        }\\n        // otherwise, multiply by -1 (you can also directly write `return -ans`\\n        return ans * -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902484,
                "title": "100-fastest-swift-solution-log-n",
                "content": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func divide(_ dividend: Int, _ divisor: Int) -> Int {\\n        let is_negtive = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)\\n        let dividend = abs(dividend)\\n        let divisor = abs(divisor)\\n        var tmp = divisor\\n        var rem = dividend\\n        var res = 0\\n\\n        while rem >= tmp {\\n            var count = 0\\n            while rem >= tmp {\\n                count += 1\\n                tmp *= 10\\n            }\\n            tmp = divisor\\n            rem = rem - Int(pow(10, Double(count-1))) * tmp\\n            if rem >= 0 {\\n                res += Int(pow(10, Double(count-1)))\\n            }\\n        }\\n        \\n        if (is_negtive && res >= 2147483648) { res = 2147483648 }\\n        if (!is_negtive && res >= 2147483647) { res = 2147483647 }\\n        return is_negtive ? -1 * res : res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303141,
                "title": "python-beats-99-77-time-28ms-and-88-memory",
                "content": "Uses bit shifting until it cannot be performed anymore. Shifting by 1 bit to the left means multiplying the number by 2. If we shift two times, then it means we multiplied number by 4, etc.\\nExample `dividend = 31` and `divisor = 2`:\\n```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\\nSo far we got `quotient = 8`, now we adjust `dividend = divident - 16 = 15` and repeat:\\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\\nNow `quotient = 8 + 4` and new `dividend = divident - 8 = 15 - 8 = 7`\\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\\nUpdate `quotient = 8 + 4 + 2` and `dividend = 7 - 4 = 3`\\nAs `2 << 1 = 4` which is > 3, but 3 > 2, we add one more unit to the quotient, resulting in `q = 15`.\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n2 << 1 = 4 (31 > 4 == True)\\n4 << 1 = 8 (31 > 8 == True)\\n8 << 1 = 16 (31 > 16 == True)  # <-- pause here\\n16 << 1 = 32 (31 > 32 == False)\\n```\n```\\n2 << 1 = 4 < 15\\n4 << 1 = 8 < 15\\n8 << 1 = 16 > 15\\n```\n```\\n2 << 1 = 4 < 7\\n4 << 1 = 8 > 7\\n```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend >= 0 and divisor >= 0 or (dividend < 0 and divisor < 0):\\n            sign = 1\\n        else:\\n            sign = -1\\n        \\n\\t\\t# some shortcuts\\n        if divisor == -1 and dividend == -2147483648:\\n            return 2147483647\\n        elif divisor == 1:\\n            return abs(dividend) if sign == 1 else -abs(dividend)\\n        \\n        divisor = abs(divisor)\\n        dividend = abs(dividend)\\n        \\n        if dividend < divisor:\\n            return 0\\n        \\n        d = divisor\\n        q = 1\\n        rq = 0\\n        while True:\\n            t = divisor << 1\\n            if dividend >= t:\\n                divisor = t\\n                q += q\\n            else:\\n                rq += q\\n                q = 1\\n                dividend -= divisor\\n                divisor = d\\n                if (divisor << 1) > dividend:\\n                    if dividend >= divisor:\\n                        rq += 1\\n                    break\\n\\n        return rq if sign == 1 else -rq\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203085,
                "title": "python-best-explanation-line-by-line-fast-efficient-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        #A condition to check whether both are positivie or not\\n        positive = (dividend < 0) == (divisor < 0)\\n        \\n        #Now we\\'ve stored our sign in poistive variable so we make both numbers positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        #This is the quotient\\n        ans = 0\\n        \\n        #Outer while loop which checks the lower multiples of divisor\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            \\n             #Inner while loop where values value of multiples of divisor keep doubling after each iteration for less number of operations\\n            while dividend >= temp:\\n                dividend -= temp\\n                \\n                ans += i #Storing the number of times number multiplied\\n                \\n                i <<= 1 #Doubling -- 1,2,4..\\n                \\n                temp <<= 1 #Doubling Divisor values -- x,2x,4x...\\n        \\n        #Re-assigning the sign to our answer\\n        if not positive:\\n            ans = -ans\\n            \\n        #Returning answer within range\\n        return min(max(-2147483648, ans), 2147483647)",
                "codeTag": "Java"
            },
            {
                "id": 314856,
                "title": "c-0ms-100-using-log",
                "content": "\\nUsing  Fact : log(a/b) = log(a)-log(b)\\nans = a/b\\nlog(ans) = log(a/b)\\nlog(ans) = log(a)-log(b)\\nans = exp( log(a)-log(b) )\\n\\n```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        int sign= (dividend<0 ^ divisor<0) ? -1 : 1; //same ? 0(false) (XOR)\\n        \\n        long ldividend=labs(dividend);\\n        long ldivisor=labs(divisor);\\n     \\n        long res = exp(log(ldividend)-log(ldivisor));\\n        cout<<ldividend<<\"/\"<<ldivisor<<\"=\"<<res;\\n        if(res>INT_MAX)\\n            return sign==1 ? INT_MAX:INT_MIN;\\n        return sign*(int)res;\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13607,
                "title": "accepted-cpp-solution-with-explainations",
                "content": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "solutionTags": [],
                "code": "    int divide(int64_t n, int64_t m) {\\n    \\t// determine sign of the quotient\\n    \\tint sign = n < 0 ^ m < 0 ? -1 : 1;\\n    \\n    \\t// remove sign of operands\\n    \\tn = abs(n), m = abs(m);\\n    \\n    \\t// q stores the quotient in computation\\n    \\tint64_t q = 0;\\n    \\n    \\t// test down from the highest bit\\n    \\t// accumulate the tentative value for valid bits\\n    \\tfor (int64_t t = 0, i = 31; i >= 0; i--)\\n    \\t\\tif (t + (m << i) <= n)\\n    \\t\\t\\tt += m << i, q |= 1LL << i;\\n    \\n    \\t// assign back the sign\\n    \\tif (sign < 0) q = -q;\\n    \\n    \\t// check for overflow and return\\n    \\treturn q >= INT_MAX ? INT_MAX : q <= INT_MIN ? INT_MIN : q;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2089781,
                "title": "go-back-to-the-elementary-school-basics-w-examples",
                "content": "We will follow the **same exact division algorithm we all learn in elementary school** to divide integers, but in binary:\\n\\n*\"We traverse `dividend` from left to right, looking at the first `k` digits, where `k` is the number of digits of `divisor`. If the number formed by those first `k` digits is larger than or equal to `divisor`, then we write `1` in the quotient, subtract and move on to the next digit.\"*\\n\\n# Examples\\n*53 &div; 3 = 17*\\n![image](https://assets.leetcode.com/users/images/0cbe7c91-feb1-4c1b-8527-5b820aa35478_1653891963.4127522.png)\\n\\n\\n*246 &div; 7 = 35*\\n![image](https://assets.leetcode.com/users/images/5b1e8a36-cc5e-4eee-a01d-3128b1ac4f4a_1653891972.2472856.png)\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```\\n# Notes\\n* **Time complexity:** *O(log(`dividend`))*\\n* **Space complexity:** *O(1)*\\n\\nWe don\\'t need to worry about `quotient` being smaller than `-2 ** 31` since `abs(quotient) <= abs(dividend) <= 2 ** 31`.\\n\\nEdit: Updated handling of corner case so that we **only** work with integers in `[-2 ** 31, 2 ** 31 - 1]` at all times.",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0:\\n            return 0\\n\\t\\t# only case that gives answer outside of [-2 ** 31, 2 ** 31 - 1]\\n        if dividend == -2 ** 31 and divisor == -1:\\n            return 2 ** 31 - 1\\n\\t\\t\\t\\n\\t\\t# we work with positive numbers only and worry about the sign in the end\\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\\n            positiveSign = True\\n        else:\\n            positiveSign = False\\n        dividend, divisor = abs(dividend), abs(divisor)\\n\\n        quotient = 0\\n        for i in reversed(range(dividend.bit_length() - divisor.bit_length() + 1)):\\n            if dividend >> i >= divisor:\\n                dividend -= divisor << i\\n                quotient |= 1 << i\\n        \\n        return quotient if positiveSign else -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089277,
                "title": "with-explanation-3-possible-solution-in-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\\nsolution 1:\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12. Now 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice, it is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens. We simply add 1 << 0 = 1 to the answer variable.\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\\n\\nsolution 2:\\nBasic idea: a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b))\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\\n\\nsolution 3:\\nLong division in binary:\\nThe outer loop reduces n by at least half each iteration. So It has O(log N) iterations.\\nThe inner loop has at most log N iterations.\\nSo the overall complexity is O(( log N)^2)\\n\\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE IT\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend == INT_MIN && divisor == -1) {\\n            return INT_MAX;\\n        }\\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\\n        while (dvd >= dvs) {\\n            long temp = dvs, m = 1;\\n            while (temp << 1 <= dvd) {\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            dvd -= temp;\\n            ans += m;\\n        }\\n        return sign * ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (dividend==0) return 0;\\n        if (divisor==0) return INT_MAX;\\n        long long res=double(exp(log(fabs(dividend))-log(fabs(divisor))));\\n        if ((dividend<0)^(divisor<0)) res=-res;\\n        if (res>INT_MAX) res=INT_MAX;\\n        return res;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\n\\nint divide(int n_, int d_) {\\n    ll ans=0;\\n    ll n=abs((ll)n_);\\n    ll d=abs((ll)d_);\\n    while(n>=d){\\n        ll a=d;\\n        ll m=1;\\n        while((a<<1) < n){a<<=1;m<<=1;}\\n        ans+=m;\\n        n-=a;\\n    }\\n    if((n_<0&&d_>=0)||(n_>=0&&d_<0))\\n        return -ans;\\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13418,
                "title": "c-8ms-solution-without-long-long",
                "content": "\\n    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}\\n                else {return -dividend;}\\n            }\\n            \\n            bool s1 = dividend<0;\\n            bool s2 = divisor<0;\\n            \\n            unsigned int nom = s1?-dividend:dividend;\\n            unsigned int den = s2?-divisor:divisor;\\n            \\n            unsigned int rem = 0;\\n            unsigned int quot = 0;\\n            \\n            for(int i=31; i>=0;--i){\\n                rem <<= 1;\\n                rem |= (nom >> i) & 1;\\n                if(rem >= den){\\n                    rem -= den;\\n                    quot |= (1<<i);\\n                }\\n            }\\n    \\n            return s1^s2?-quot:quot;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            if(!divisor) return INT_MAX;\\n            if(divisor == 1) return dividend;\\n            if(divisor == -1){\\n                if(dividend == INT_MIN) {return INT_MAX;}",
                "codeTag": "Java"
            },
            {
                "id": 2719043,
                "title": "python-subtraction-o-logn",
                "content": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "You can refer to this [video solution](https://www.youtube.com/watch?v=xefkgtd44hg&ab_channel=CheatCodeNinja) \\n\\nHere we are doubling the divisor everytime and hence compressing the total number of subtraction operations. \\nIf the doubled divisor is greater than the dividend, we reset our divisor to its initial value and try again.\\n\\nAt the end, we make sure that the output is within the given range and avoid an overflow.\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        a = abs(dividend)\\n        b=abs(divisor)\\n        \\n        negative = (dividend<0 and divisor>=0) or (dividend>=0 and divisor<0)\\n        \\n        output = 0\\n        \\n        while a>=b:\\n            counter = 1\\n            decrement = b\\n            \\n            while a>=decrement:\\n                a-=decrement\\n                \\n                output+=counter\\n                counter+=counter\\n                decrement+=decrement\\n                \\n        output = output if not negative else -output\\n        \\n        return min(max(-2147483648, output), 2147483647)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1929540,
                "title": "java-solution-with-explanation",
                "content": "Logic explain\\nA dividend can be construct by the multiple of divisor\\n\\nE.g \\n`dividend = 20, divisor = 5 => 20 = 5 + 5 + 5 + 5 = 5 * 4`\\nOR\\n`dividend = 19, divisor = 5 => 19 = 5 + 5 + 5 +4 = 5 * 3 + 4 `\\nand what we need is to return the multiply of 5, which is  4 and 3 respectively.\\n\\nFirstly, we check dividend and divisor is negative. Then to ensure divident and divisor is possitive, do absolute value. \\n\\nThen all we need to do is to find out how many divisor is needed for dividend become 0 or less than divisor\\nwe create a counter to count number of divisor. \\n```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\\nThis count is number of left shift divisor did, for example 3 << 2 means 3 left shifted 2 times, each left shift equal to * 2, so 3 << 2 = 3 * 2 * 2 =  12. \\n\\nAnother example, dividend = 15, divisor = 3,\\nIn first outer loop, counter++ twice in inner loop, leading to 15 - 3 << 2, r += 1 << 2 (which is 4)\\nSince dividend (15 - 12 = 3) - divisor == 0, loop second times. Skip inner loop as the condition is false, r += 1 << 0 = 5 (1 << 0 == 1)\\n\\nLastly, if negative true, do\\n```\\n\\tr = ~r + 1;\\n```\\nwhich change a possitive number to negative, return answer.\\n\\n\\nThe most difficult part of this question is edge case.\\n\\nLets handle the first edge case, divident = -2147483648 and divisor =  -1.\\nthe answer should be 2147483648, however this overflow. We cannot calculate this, hence use this as if statement condition, and return max value directly.\\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\\n\\nAnother edge case is dividend = max_value or min_value and divisor =  1 (or -1 if divident = max_value)\\nYou can see in our inner loop, it is \\n```\\ndivisor << 1 << count\\n```\\ninstead of\\n```\\ndivisor << count\\n```\\nthis << 1 is a extra * 2 in order to prevent overflow. For example when dividend = min_value and divisor = 1, in\\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\\ndivisor << count will eventually equal to -2147483648 (1 << 31 will overflow and get -2147483648), while dividend (for min_value, after abs it is overflow, so remain min_value) - -2147483648, it equal to 0 and while loop repeat endlessly. Adding << 1, 1 << 1 << 31 equal 0, and min_value - 0 will break the inner while loop.\\n\\nComplete code\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n\\t\\t\\tdividend -= divisor << count;\\n        }\\n```\n```\\n\\tr = ~r + 1;\\n```\n```\\n\\tif(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n```\n```\\ndivisor << 1 << count\\n```\n```\\ndivisor << count\\n```\n```\\n\\twhile(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n```\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean neg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int r = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            r += 1 << count;\\n            dividend -= divisor << count;\\n        }\\n\\n        if(neg){\\n            r = ~r + 1;\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084897,
                "title": "c-o-1-using-exponential-and-log",
                "content": "**Approach** - \\n\\nLet\\'s say, a/b = c.\\n1 . Take log on both sides -> ```log(a/b) = log(c)```\\n2. Use log propery (log(a/b) = log(a) - log(b)) -> ```log(a) - log(b) = log(c)```\\n3. Take exponential on both sides (e(x) = 1/ln(x)) -> ```c = e^(log(a) - log(b))```, Find c now.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "solutionTags": [],
                "code": "```log(a/b) = log(c)```\n```log(a) - log(b) = log(c)```\n```c = e^(log(a) - log(b))```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        int sign = (dividend < 0) ^ (divisor < 0);\\n        \\n        long dvnd = abs(dividend);\\n        long dvsr = abs(divisor);\\n        \\n        long res = exp(log(dvnd) - log(dvsr));\\n        \\n        res *= (sign ? -1 : 1);\\n        \\n        if(res > INT_MAX)\\n            return INT_MAX;\\n        \\n        if(res < INT_MIN)\\n            return INT_MIN;\\n        \\n        return res;\\n    }\\n};\\n\\n/*\\n\\na/b = c\\nlog(a) - log(b) = log(c)\\nc = e^(log(a) - log(b))\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016568,
                "title": "java-a-proper-approach",
                "content": "## Java: A proper approach\\n\\nSo a lot of the topics in this discussion are useless because they either do exactly what the problem tells you not to do and say \"look at me I can cheat\" or work around the problem by typecasting or some other bs. I will attempt to explain how you can implement this algorithm using only type `int`. I am open to questions, comments, concerns and improvements. \\n\\n*Note:* This problem and its solution are somewhat peculiar in that they\\'re less about practicing your algorithms than coming up with an interesting approach to a dull problem using what tools you have.\\n\\n### Approach \\n\\nSo you can\\'t (or at least the problem description tells you not to) use any math operations that would seem useful in this situation... thats a shame. \\n\\n#### Brute-force\\n\\nFrom a brute-force perspective, we can make a loop where we increment some counter by one and increment value $d$ by divisor until $d > $ dividend; then the answer we are looking for is simply the value of counter right before  $d > $ dividend. However, the runtime for this approach is linear, and so the solution won\\'t submit be accepted with a `Time Limit Exceeded` message.\\n\\nBut wait... if we can\\'t use multiplication or division to solve this problem, how can we achieve better than linear runtime (linear in the size of divisor that is)?\\n\\n#### The trick\\n\\nTurns out you can actually use integer multiplication and division ... as long as you realize that [bitwise shifting](https://stackoverflow.com/questions/3312853/how-does-bitshifting-work-in-java]) by 1 left or right is identically integer multiplication or division by 2 respectively and consequently accept that bitwise shifting is indeed allowed as part of the solution\\n\\n*Note:* I actually kind of just lied; bitwise operations only behave as I just described for `int` values $\\\\geq 0$, so well work around this by making both the dividend and that divisor positive and applying the proper sign at the end.\\n\\nNow, there are a couple of different directions we can go once we embrace the power of division by two. The solution I\\'ve chosen to role with here is simply long division... you know the long division that you learned in elementary school but don\\'t remember any more... just done in base two. Apparently this has a name, and it\\'s called binary division. If you can\\'t be bothered to remember/figure out exactly how it works, which is totally fair IMO, then the pseudo code is illustrated reasonably clearly [here](https://en.wikipedia.org/wiki/Division_algorithm#Integer_division_(unsigned)_with_remainder).\\n\\n### Why couldn\\'t they have restrained the dividend range by one more?\\n\\nI don\\'t want to spend a lot of time here, but there are some annoying and subtle problems that come with allowing the dividend to be `Int.MIN_VALUE` for example:\\n\\n``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\\n\\nThus you need to be really careful dealing with this edge case, and I jerry-rigged my code so that I dealt with the consequences as I found them. It would have been so much nicer if LeetCode had just instead had the minimum allowed value be `Integer.MIN_VALUE + 1`\\n\\n### Runtime\\n\\nIts $O(log_2N)$ where $N$ is the size of the dividend: There only as many iterations as the number of bits in $N$. Note that in practice, we are restricting the inputs ot type `int`, which means that there is a maximum size of $N$, so in that sense the runtime is actually constant. I\\'m tired so someone else can come up with a better way to say this.\\n\\n### Ramblings\\n\\n- If you squint at the solution, you might be able to argue that binary long division is essentially\"binary-searching\" for the answer... but I think that\\'s a stretch.\\n\\n- Again, feel free to yell at me about the ways the code could be clearer... Looking back over it, it definitely doesn\\'t read easy.\\n\\n### Code\\n\\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\n    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE\\n```\n``` java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Edge cases:\\n        // min integer value breaks things...\\n        boolean minValFlag = false;\\n        if(dividend == Integer.MIN_VALUE) {\\n            if(divisor == -1) return Integer.MAX_VALUE;\\n            else if(divisor == 1) return Integer.MIN_VALUE;\\n            // do the first iteration of binary division manually below\\n            else minValFlag = true;\\n        }\\n        if(divisor == Integer.MIN_VALUE) return minValFlag ? 1 : 0;\\n        \\n        //Determine the sign of the result (we know at this point neither is 0)\\n        boolean isNegative = dividend < 0 ^ divisor < 0;\\n        \\n        //make both dividend and divisor positive\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        //find the number of significant bits in the dividend\\n        int n = 1, dvdn = 1;\\n        while(dvdn < dividend && dvdn != Integer.MIN_VALUE) {\\n            dvdn <<=1;\\n            n++;\\n        }\\n        \\n        //Approach: do long division in binary\\n        int quotient = 0, remainder = 0;\\n        \\n        //deal with min-value annoyance\\n        if(minValFlag) {\\n            n = 31;\\n            remainder = 1;\\n        }\\n        \\n        for(n-- ; n >= 0; n--) {\\n            remainder <<= 1;\\n            remainder += (dividend >> n ) & 1;\\n            if(remainder >= divisor || remainder == Integer.MIN_VALUE) {\\n                remainder -= divisor;\\n                quotient += 1 << n;\\n            }\\n            //System.out.println(String.format(\"n is: %d %nremainder is: %d %nquotient is: %d %n\",n,remainder,quotient));\\n        }\\n        \\n        //return statement\\n        return isNegative ? 0 - quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240862,
                "title": "c-solution-without-using-long-clear-fast",
                "content": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\ntypedef numeric_limits<int> lim;\\n\\nint divide(int A, int B) {\\n    if (B == 0) return lim::max();\\n    // Check A and B for lim::min() before applying abs() to avoid overflow.\\n    if (B == lim::min()) return A == lim::min() ? 1 : 0;\\n    int quotient = 0;\\n    if (A == lim::min()) {\\n        // quotient is int thus cannot carry -lim::min() 1s,\\n        // so take special care when abs(B) == 1.\\n        if (B == -1) return lim::max();\\n        if (B == 1) return lim::min();\\n        // Add one B to A to avoid overflow.\\n        A += abs(B);\\n        quotient = 1;\\n    }\\n    bool positive = (A >= 0) == (B > 0);\\n    A = abs(A);\\n    B = abs(B);\\n    while (A >= B) {\\n        int quotient_ = 1;\\n        int B_ = B;\\n        while (A >= (B_ << 1) && (B_ << 1) > 0) {\\n            quotient_ <<= 1;\\n            B_ <<= 1;\\n        }\\n        A -= B_;\\n        quotient += quotient_;\\n    }\\n    return positive ? quotient : -quotient;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3357353,
                "title": "beats-100-java-runtime-1ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (divisor == 0) {\\n            return 0;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        int quotient = 0;\\n        boolean negative = (dividend < 0) != (divisor < 0);\\n        long longDividend = Math.abs((long) dividend);\\n        long longDivisor = Math.abs((long) divisor);\\n        while (longDividend >= longDivisor) {\\n            int shift = 0;\\n            while (longDividend >= (longDivisor << shift)) {\\n                shift++;\\n            }\\n            shift--;\\n            longDividend -= longDivisor << shift;\\n            quotient += 1 << shift;\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130236,
                "title": "best-2-lines-of-code-in-java-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==(-2147483648) && divisor==(-1)) return 2147483647;\\n        return dividend/divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563104,
                "title": "c-bit-manuplation-easy-and-fast",
                "content": "**please upvote if it\\'s helpful**\\n```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tint divide(int dividend, int divisor) {\\n        if(dividend == divisor)\\n            return 1;\\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\\n        unsigned int a = abs(dividend);\\n        unsigned int b = abs(divisor);\\n        unsigned int ans = 0;\\n        while(a >= b){  // while dividend is greater than or equal to divisor\\n            short q = 0;\\n            while(a > (b<<(q+1)))\\n                q++;\\n            ans += (1<<q);  // add the power of 2 found to the answer\\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\\n        }\\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\\n            return INT_MAX;\\n        return isPositive ? ans : -ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1400899,
                "title": "c-2-approaches-explained-brute-to-better-accepted-4ms",
                "content": "There are various approaches for this problem, two of them here I have discussed below :\\n\\n# Approach 1\\nThe first approach which comes to our mid is : **Repeated Subtraction**.\\nAll we need to do in this approach is keep subtracting divisor from dividend until dividend becomes less than divisor. The number of times we subtract will be our quotient and what\\'s left in dividend will be the remainder.\\n\\nExample: if dividend = 33 and divisor = 6, then we do\\n33 - 6 = 27\\n27 - 6 = 21\\n21 - 6 = 15\\n15 - 6 = 9\\n9 - 6 = 3\\nnow 3<6 , so we stop here and hence our remainder is 3 and no, of times we subtracted is 5 = quotient.\\n\\nFor this approach,\\n\\n```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\\n\\n**Time Complexity** : O(dividend) [consider case when dividend=n and divisor=1]\\n\\nNow we\\'ll try to optimize this time complexity.\\n\\n# Approach 2\\n\\nThe second approach includes **BIT MANIPULATION**.\\n\\nconsider the same example as above , dividend=33 and divisor=6\\n\\nhere we try to increase our divisor until it attains maximum value less than or equal to dividend, i.e.\\n\\n6 < 33\\n6 + 6 = 12 < 33\\n6 + 6 + 6 = 18 < 33\\n6 + 6 + 6 + 6 = 24 < 33\\n6 + 6 + 6 + 6 + 6 = 30 < 33\\n6 + 6 + 6 + 6 + 6 + 6 = 36 > 33 -----------------> stop here\\n\\nthus, max value of divisor can be 30 which is 5 times 6, hence quotient is 5.\\nnow instead of repeatedly adding this (which is same as in case of previous approach), we\\'ll use bit manipulation to do it more efficiently.\\n\\nwe iterate from i= 31 to 0 and try to find (divisor * (2^i)) if it is less than our dividend, we store it in a var, update our quotient and do the same. like in this example where dividend = 33 and divisor = 6\\n\\nintial t=0 (here we\\'ll be storing the current updated divisor), q=0 (quotient)\\nwe\\'ll be checking if t + (divisor * (2^i) <= dividend, if it is true we\\'ll do \\nt = t + (divisor * (2^i)) and q = q + (2^i)\\n\\ni = 31 : 0 + (6 * 2^31) > 33\\ni = 30 : 0 + (6 * 2^30) > 33\\n...\\n...\\n...\\n...\\ni = 3 : 0 + (6 * 2^3) = (6 * 8) = 48 > 33\\ni = 2 : 0 + (6 * 2^2) = (6 * 4) = **24 < 33** => t= 0 + 24 = 24  and  q = 0 + (2^2) = 4\\ni = 1 : 24 + (6 * 2^1) = 24 + 12 = 36 > 33\\ni = 0 : 24 + (6 * 2^0) = 24 + 6 = **30 < 33** => t = 24 + 6 = 30  and q = 4 + (2^0) = 5 \\n\\nnow we\\'ll put appropriate sign in front of q (if any one of divisor or dividend negative the negative else positive), then if q lies in range of int ,we return q else we return INT_MAX.\\n\\n**BIT Manipulation PART :**\\nsince , we aren\\'t allowed to use multiplication operator , thus we can calculate\\n\\ndivisor * (2^i)  as (divisor<<i) as left shift by i means same as multiplyin the number by (2^i)\\n\\n**CODE :**\\n\\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```\\n\\n**Time Complexity :** O( log(dividend) )",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint divide(int dividend, int divisor) {\\n \\n // if any one of them is negative then quotient will be negative else positive\\n  int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1; \\n \\n  // Update both divisor and\\n  // dividend positive\\n  dividend = abs(dividend);\\n  divisor = abs(divisor);\\n \\n  // Initialize the quotient\\n  int quotient = 0;\\n  while (dividend >= divisor) {\\n    dividend -= divisor;\\n    ++quotient;\\n  }\\n  //if the sign value computed earlier is -1 then negate the value of quotient\\n  if(sign==-1) quotient=-quotient;\\n   \\n  return quotient;\\n}\\n```\n```\\nint divide(int dividend, int divisor) {\\n        \\n        long long t=0, q=0, n=labs(dividend), m=labs(divisor);\\n\\t\\t\\n\\t\\t//here we find the sign of the quotient, if both dividend and divisor\\n\\t\\t//have same sign then sign will be +1 else -1\\n        int sign = (dividend<0) ^ (divisor<0) ? -1 : 1;\\n        \\n        for(long long i=31;i>=0;i--)\\n        {\\n\\t\\t\\t//(m<<i) = m * (2^i)\\n            if(t + (m<<i) <= n)\\n            {\\n                t += (m<<i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//since 2^i here can be large for int so we typecast it in long long to prevent overflow \\n                q += (1LL<<i);\\n            }\\n        }\\n        \\n        if(sign<0) q=-q;\\n        \\n\\t\\t//if q goes out of bound, we return INT_MAX.\\n        return ((q>INT_MAX) or (q<INT_MIN)) ? INT_MAX : q;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286238,
                "title": "0ms-java-solution-complies-to-all-conditions",
                "content": "If you are furiously looking for answers as i was, let me shed some light. I had to spend a lots of time to understand the secret behind the solutions to this problem. \\n\\nFirst of all, As we all know already the basic idea for solving the problem with out the mod operator is simply **identifying the number of times the divisor can fully SUBSTRACT the dividend as a whole** but iterations are so costly and it will not work for large numbers. The obvious secret is to identify **effective way to reduce the number of substractions**\\n\\nThe following is simply my idea but there can be many as well, \\n\\n**1. Exponensly increase the divisor until before it surpass the dividend then substract with it.\\n2. Add up the divisor until reduced\\n3. Repeat the same until it brings to 0**\\n\\nFor an example, 116 divided by 3, Following is the way to gradually reduce the possibilities and idendify the final quotient\\n\\n![image](https://assets.leetcode.com/users/images/31c9c3ac-8bd5-437a-a976-ad74d369e0f0_1624215160.6451015.png)\\n\\nLets start with 3, then double it which is 6 then 12, 24,..until we stop at 96 because 192 can be substracted. So here 96 == 3 * 2^5 ==  3 << 5 and quotient = 32, remainder = 20\\n\\nLet start the same process again with 20, it can go upto which gets to 12 == 3 * 2^2 == 3 << 2 then the quotient is now 32 + 4 = 36, reminder = 8\\n\\nLets start over again, i can go upto 6 which is again 6 == 3 * 2^1 == 3 << 1 the quotient is not 36+2 = 38, remainder = 2 which is less than divisor so we can not continue with the cycle and all ends here.\\n\\nHowever multiplication is not allowed to use let see what else we can do for replacing it. \\n\\n**Programmatic Rule:**\\nLeft Shift (<<) shall be considered as multiplication by 2^N\\nSimilarly, Right Shift (>>) shall be considered as division by 2^N \\n\\nSince the environment only allows to accomodate `integer`  data type, overflow cases are the corner cases.\\n\\nLets dive into the code,\\n\\n```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n     public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE; //Cornor case when -2^31 is divided by -1 will give 2^31 which doesnt exist so overflow \\n         \\n        boolean negative = dividend < 0 ^ divisor < 0; //Logical XOR will help in deciding if the results is negative only if any one of them is negative\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        int quotient = 0, subQuot = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuot = 0; dividend - (divisor << subQuot << 1) >= 0; subQuot++);\\n            quotient += 1 << subQuot; //Add to the quotient\\n            dividend -= divisor << subQuot; //Substract from dividend to start over with the remaining\\n        }\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356127,
                "title": "small-c-program-logic-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint divide(long long int dividend, long long int divisor){\\n    if (dividend / divisor > pow(2,31) - 1)\\n    {\\n        return(pow(2,31) - 1);\\n    }\\n    else\\n     {\\n        return (dividend / divisor);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750712,
                "title": "java-faster-solution-runtime-2-ms-faster-than-81-21-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}\\n\\t\\t\\tldividend -= ldivisor << value;\\n\\t\\t\\tresult += 1 << value;\\n\\t\\t}\\n\\t\\tif (result > Integer.MAX_VALUE) result = Integer.MAX_VALUE;\\n\\t\\tif(dividend==Integer.MIN_VALUE && divisor==-1) result=Integer.MAX_VALUE;\\n        result= sign > 0 ? result : -result; return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int sign,result=0,value=31;\\n\\t\\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) sign = 1;  else sign = -1;\\n\\t\\tlong ldividend = Math.abs((long) dividend);\\n\\t\\tlong ldivisor = Math.abs((long) divisor);\\n\\t\\twhile (ldividend >= ldivisor) {\\n\\t\\t\\twhile (ldividend < ldivisor << value) {\\n\\t\\t\\t\\tvalue--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2089333,
                "title": "c-short-easy-explanation-w-comments",
                "content": "**Please upvote if you like it :)**\\n\\nUsing **long long** instead of **int** or **long** to avoid overflow.`\\n\\n***Code w/ Bit Manipulation:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN^2)\\nSpace Complexity : O(N)**\\n\\n***Code w/ Logarithms:***\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```\\n**Time Complexity : O(LogN)\\nSpace Complexity : O(N)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t\\t// corner cases\\n        if (dividend == INT_MIN && divisor == -1 ) return INT_MAX;\\n        if (dividend == INT_MIN && divisor == 1 ) return INT_MIN;\\n\\t\\t\\n\\t\\t// initialization\\n        long long ans = 0, sign = dividend > 0 == divisor > 0 ? 1 : -1;\\n        if (divisor == -INT_MAX) return dividend == divisor;\\n        if (dividend == -INT_MAX)\\n            if (divisor == 1) return -INT_MAX;\\n        else if (divisor == -1) return INT_MAX;\\n        else dividend += abs(divisor), ans++;\\n        long long numerator = abs(dividend), denominator = abs(divisor);\\n        for (int i = 0; numerator >= denominator; i = 0) {\\n            while (numerator >> i >= denominator) i++;\\n            numerator -= denominator << i - 1, ans += 1 << i - 1;\\n        }\\n        return sign < 0 ? -ans : ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) { \\n        long long ans = 0; \\n        if ((long long)divisor== -INT_MAX) return dividend == divisor; \\n\\t\\t\\n\\t\\t//corner cases\\n        if ((long long)dividend == -INT_MAX) \\n            if ((long long)divisor == 1) return -INT_MAX; \\n            else if ((long long)divisor == -1) return INT_MAX; \\n\\t\\t\\t\\n\\t\\t\\t//update ans variable\\n            else dividend += abs((long long)divisor), ans++; \\n        ans += floor(exp(log(abs((long long)dividend)) - log(abs((long long)divisor)))); // exp(x) = e^x\\n        return dividend > 0 == divisor > 0 ? ans : -ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898053,
                "title": "a-c-solution-using-bitwise-shift",
                "content": "To simplify the logic, assume dividend and divisor are positive. The main idea is making a loop to keep minusing divisor. But this way will lead to time limit exceeded when occuring a large dividend and a small divisor. So, let\\'s change the strategy. Before minusing divisor, we can make divisor as close dividend as possible but still lower than dividend. Then, we can greedily minus a large divisor in time complexity O(log(n)). And making this large divisor can be done by bitwise left-shift.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\t\\n\\t    // If dividend is zero, return zero directly.\\n        if (dividend == 0) {\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t// To let our strategy to work, we should handle the case if divisor is INT_MIN.\\n        if (divisor == INT_MIN) {\\n            return dividend == INT_MIN ? 1 : 0;\\n        }\\n        \\n\\t\\t// Use exclusive or to check the sign of answer.\\n        bool is_pos = (dividend > 0) ^ (divisor < 0);\\n        int ans = 0;\\n        \\n\\t\\t// Here is different from the description above.\\n\\t\\t// In practice, we force our dividend to be negative.\\n\\t\\t// Because the range of negative values (2^31) is larger than the range of positive values (2^31 - 1).\\n\\t\\t// If we force dividend to be positive, there may be integer overflow.\\n        if (dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        \\n\\t\\t// Divisor should be positive.\\n\\t\\t// Because we will apply bitwise shift to it.\\n\\t\\t// And we have handled the case when divisor is INT_MIN.\\n        if (divisor < 0) {\\n            divisor = 0 - divisor;\\n        }\\n        \\n\\t\\t// To compare negative dividend and positive divisor, we need to add negative sign to divisor.\\n        while (dividend <= -divisor) {\\n            int tmp = divisor;\\n            int step = 1;\\n            \\n\\t\\t\\t// \"tmp < 0x40000000\" is a trick. 0x40000000 is 2^30.\\n\\t\\t\\t// If we don\\'t limit the upper bound, tmp may keep shifting and lead an integer overflow.\\n            while (tmp < 0x40000000 && -tmp > dividend) {\\n                tmp <<= 1;\\n                step <<= 1;\\n            }\\n            \\n\\t\\t\\t// Here we find the largest divisor.\\n            if (-tmp < dividend) {\\n                tmp >>= 1;\\n                step >>= 1;\\n            }\\n            \\n            dividend += tmp;\\n\\t\\t\\t\\n\\t\\t\\t// Another trick is that using minus instead of using add.\\n\\t\\t\\t// The same reason as above: the range of negative values is larger than the range of positive values.\\n            ans -= step;\\n        }\\n        \\n        if (!is_pos) {\\n            return ans;\\n        } else {\\n            return ans == INT_MIN ? INT_MAX : -ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914066,
                "title": "3-approach-for-your-interview-prep-o-dividend-o-1-o-logn",
                "content": "\\n<h4> <strong>Approach  1: Brute force (repetitve deduction) [ O(dividend) ] </strong> </h4><br>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** repetitive deduction logic\\n\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  2: using log properties [ O(1) ] </strong> </h4>\\n\\n**step1:**  if a,b is like any one the below case, \\n{-ve, +ve}, or { `-a/b` }  ->set the sign flag\\n{+ve, -ve}   or  { ` a/-b` } ->set the sign flag\\n\\n**step2:** handle the overflow result at first\\n\\n**step3:** using formula: \\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\\n**step4:** if any of them(divisor,dividend) is negative, \\nthen to match the result, we have to make the result negative \\n<br> <br> <hr><hr>\\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\\n<hr><hr><br><br> <br>\\n<h4> <strong>Approach  3: Double the divisor everytime, and decrease it from dividend [ O(Logn) ] </strong> </h4>\\n\\n**step1:**  handle overflow cases\\n**step2:**  handle negative cases\\n**step3:**  \\nExample : dividend = 10, divisor = 3\\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\\n\\n\\n\\n<br><br><br>\\n\\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n    \\n\\t\\n\\t\\n\\t// step2\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n    // step3 \\n    let res=0\\n    b = Math.abs(b)\\n    a = Math.abs(a)\\n    \\n    while (a >= b) {\\n      a -= b;\\n      res++;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (res*-1) // res = (-res)\\n    else return res\\n    \\n};\\n\\n```\n```\\na/b = result\\nlog(a/b) = log(result)\\nlog(a)-log(b) = log(result)\\nexp(log(a) - log(b)) = result\\n```\n```\\nvar divide = function(a, b) {\\n    \\n\\t// step1\\n    let flag=0\\n    if(a<0){ if(b>0) flag = 1 }\\n    else if(b<0) flag = 1\\n\\n      \\n\\t  \\n\\t\\n\\t\\n\\t// step2 : overflow error handling\\n    if( a == -2147483648 && b == -1)  return 2147483647\\n    \\n\\t\\n\\t\\n\\t\\n\\t//step3\\n    let ans = Math.exp(   Math.log(Math.abs(a))  -  Math.log(Math.abs(b))    )\\n    ans = Math.floor(ans)\\n    \\n\\t\\n\\t\\n\\t// step4\\n    if (flag == 1 ) return (ans*-1) // ans = (-ans)\\n    else return ans\\n    \\n};\\n```\n```\\n 10      10                  10\\n- 3    -3x2              -3x2x2\\n---     ---               ------\\n\\n  7       4      (dvsr>dvd) exit\\n  \\nso, here twice we operated\\n\\n\\n\\n\\n 4                       4\\n-3                    -3x2\\n---                  -----\\n1            (dvsr>dvd) exit\\n\\nso here once we operated\\n\\n\\n\\n\\n\\n\\nso, twice+once= 3\\nso result is 3.\\n\\n```\n```\\n\\n\\n\\n\\nvar divide = function(dividend, divisor) {\\n    \\n\\n\\n\\t // step 1 \\n     let INT_MAX =(2**31)-1, INT_MIN = -(2**31) \\n     if(dividend==INT_MIN && divisor==-1) return INT_MAX\\n     if(dividend==INT_MIN && divisor== 1) return INT_MIN\\n      \\n\\n\\t let double = 0, count = 0, res = 0\\n\\n\\n\\n\\n\\n\\t // step 2\\n     let sign = dividend<0 ^ divisor<0     \\n     dividend = Math.abs(dividend)\\n     divisor = Math.abs(divisor)\\n        \\n\\n\\n\\n\\n\\n     // step 3\\n     while (divisor <= dividend) {\\n        let double = divisor, count = 1\\n\\n        while( (double*2) <= dividend) {\\n            double = double*2\\n            count  = count*2\\n        }\\n\\n        res = res + count \\n        dividend = dividend - double\\n    }\\n\\n    return sign ? -res : res\\n};\\n    \\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186952,
                "title": "notes-on-solution-not-using-long-bit-shifting-etc-for-realistic-interview",
                "content": "At this point I'm sure most solutions are well understood. Without simply posting yet another ever so slightly different solution, I want to discuss a few points where some have discussed in comments, but may not be easily found; as well as giving those who don't have as many real interview experiences some ideas about what companies may prefer. \n\nFirst of all, this question is all about the limitation and constraints. For these type of questions, there may be cheesy ways to make it easier, but in a real interview, you shouldn't bank on it being allowed. For this very question it is specified the system can only handle Integers, thus **using Long should be out of the question.** If it's not clearly stated, you can always ask, just don't assume. We see it ain't too hard without long by turning numbers negative as many solutions have.\n\nSecondly, a straight forward adding solution may return wrong answers due to overflow during adding. A better way would be to use bit shifting, but unless you started interview solution on this direction initially (which can be weird tbh unless you do bits a lot), **it is easy to add a condition check to make sure that new sum isn't overflowing by seeing if it switched signs**. Though I find this slightly hacky from coding perspective because the purpose isn't obvious from code.\n\nIt is a good chance to discuss with interviewer what's preferred. For example, another cheap way is to define a value that's half of Max or Min (for using negatives), and use that as a loop guard to be more explicit. The constraint of not allowing multiplication and division is obviously for avoiding direct solutions, but we should always be able to hardcode a value if necessary. \n\nThough for this question, **some interviewer may be looking specifically for bit shifting operations** cuz it can be better or \"leet\", in which case communication is the most important to find out. I'd argue for code readability above all else.\n\nLast but not least, when discussing edge cases, it's important to not blast thru it without thought. For things like dividing by 0, if it wasn't explicitely stated to be impossible by the question, **It should be handled as an Exception**. Same for MIN_VALUE divide by -1 as well. \n\nPeople never throw catch exceptions on Leetcode but it's a great talking point in interviews. They may follow up and say for now assume it won't happen, or return a specific value to represent error for simplicity. If the interviewer said that, it's fine, but you should never come up with that yourself, that's bad code, confusing and can be factually incorrect. Of course, Leetcode make these explicit so people don't rage over unclear requirements, but it's good to think about. If an exception is to be thrown, it's also good to discuss with interviewer about whose responsibility it should be for handling it. This method, or the caller. \n\nI will attach my solution for reference, but nothing special. Recursive, no long or bit shifting though. \n\n```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n\nAnd a quick reminder on throwing exceptions - if others should handle it, simply modify method signature to be \n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n\nIf you were to handle it yourself, but have to return a value for the time. Then it's pointless unless printing a message or calling a log would suffice \n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```\n\nI know this isn't the standard solution for leetcode discussion. But I hope it will help some newer people out there. Cheers. ",
                "solutionTags": [],
                "code": "```\n    public int divide(int dividend, int divisor) {\n        // Handle edge cases\n        if (dividend == 0) {\n            return 0;\n        } else if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE; \n        } \n        \n        // Get sign and switch to negative\n        boolean positive = true; \n        if (dividend > 0) {\n            dividend = -dividend;\n            positive = !positive;\n        }\n        \n        if (divisor > 0) {\n            divisor = -divisor;\n            positive = !positive;\n        }\n        \n        int res = helper(dividend, divisor);\n        return positive ? res : -res;\n    }\n    \n    public int helper(int dividend, int divisor) {\n        if (dividend > divisor) {\n            return 0;\n        } \n        \n        int multiple = divisor;\n        int count = 1;\n        while (multiple + multiple > dividend && multiple + multiple < 0) {\n            count += count;\n            multiple += multiple; \n        }\n        \n        int leftOver = dividend - multiple; \n        \n        int res = count + helper(leftOver, divisor);\n        \n        return res;\n    }\n```\n```\n    public int divide(int dividend, int divisor) throws Exception {\n        if (divisor == 0) {\n            throw new Exception(\"plz no\"); // Can make or use a more meaningful Exception class \n        } \n        ...\n```\n```\n    public int divide(int dividend, int divisor) {\n        try {\n            ...\n        } catch (Exception e) {\n            System.out.println(e.getMessage()); // or call some log / method to make this meaningful\n            return Integer.MAX_VALUE; // or w.e defined value to resolve this so caller can move on\n        } \n```",
                "codeTag": "Java"
            },
            {
                "id": 13573,
                "title": "wrong-answer-input-2147483648-1-output-2147483648-expected-2147483647",
                "content": "\\n\\n{\\n\\nclass Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}\\n\\n{\\nSubmission Result: \\nWrong Answer  Input:\\t-2147483648, -1 \\nOutput:\\t2147483648 \\nExpected:\\t2147483647\\n}\\n\\nI think my output is correct instead of the expected answer, but my code cannot be accepted. I think it should be some overflow problem. Could someone tell me how can I make this problem? Thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return an integer\\n    def divide(self, dividend, divisor):\\n        \\n        if dividend == 0:\\n            return 0\\n            \\n        sign = 1 if(dividend <0 and divisor <0) or (dividend >0 and divisor >0) else -1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        \\n        ans = 0\\n        \\n        while dividend >= divisor:\\n            shift = 0\\n            while ((divisor << shift) <= dividend):\\n                shift +=1\\n            \\n            ans += 1<<(shift-1)\\n            dividend -= divisor<<(shift-1)\\n            \\n        return ans if (sign==1) else -ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3849831,
                "title": "c-solution-with-explanation-bit-manipulation-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Bit Manipulation concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to represent the dividend in terms of power of 2 using divisor.\\nex1 -> `43/8 = 8*5 + 3 => 8(pow(2,2)+pow(2,0))+1`\\nex2 -> `7/3 = 3*2 + 1 => 3(pow(2,0))+1`\\n\\n1. Store the sign bit and make the dividend and divisor positive as it is difficult to work on the negative numbers \\n2. Now starting from the highest power of 2 if any multiple of (divisor * pow(2,i)) is less than dividend we add it to temp and store that power of 2 in ans. \\n3. Boundary condition are if (dividend is Minimum value and divisor is -1 then it led to bufferoverflow) and if (dividend is minimum and divisor is 1 than return the minimum value)\\n# Complexity\\n- Time complexity:O(31) ~ O(1)      \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long a = (long long) dividend, b = (long long)divisor;\\n        if (a == INT_MIN and b == -1) return INT_MAX;\\n        if (a == INT_MIN and b == 1) return INT_MIN;\\n        bool flg = (a > 0) == (b > 0) ? true : false;\\n        a = abs(a);\\n        b = abs(b);\\n        long long ans =0, temp = 0;\\n        for (int i = 31 ; i >= 0 ; i--){\\n            if (temp + ( b << i ) <= a){\\n                temp+= (b<<i);\\n                ans+= (1<<i);\\n            }\\n        }\\n        if (!flg) ans = -ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219166,
                "title": "easy-and-fast-python-solution-with-explanation-and-example",
                "content": "**Approach**\\n1. Get sign \\n\\t```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\\n2. Till divisor exceeds dividend:\\n\\t- Get nearest multiple of 2 greater than dividend.\\n\\t- Once get the multiple, do right shift and get the multiple of 2 less than dividend.\\n\\t- Add quotient to result and update dividend.\\n\\t```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\\n3. Return result based on sign.\\n\\t```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\\n\\n**Example**\\n- Lets say, dividend = 48 and divisor = 5. So its quotient should be 9 with remainder as 3.\\n- With first step sign will be 1.\\n- Here\\'s the second step:\\n![image](https://assets.leetcode.com/users/images/6504b41f-6bd5-47d1-804c-df87376c5f61_1656606768.27768.jpeg)\\n\\n- Will simply return result since sign is 1.\\n\\n\\n**Complete Solution**\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\tsign = 1\\n\\tif (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n\\t```\n```\\n\\tresult = 0\\n\\tdividend = abs(dividend)\\n\\tdivisor = abs(divisor)\\n\\tmax_int = 2 ** 31 - 1\\n\\n\\twhile dividend >= divisor:\\n\\t\\ttemp = divisor\\n\\t\\tquotient = 1\\n\\t\\twhile temp <= dividend:\\n\\t\\t\\ttemp <<= 1\\n\\t\\t\\tquotient <<= 1\\n\\t\\tresult += quotient >> 1\\n\\t\\tdividend -= temp >> 1\\n\\t```\n```\\n\\t# edge_case\\n\\tif result > max_int:\\n\\t\\tif sign == -1 and divisor == 1: return ~max_int\\n\\t\\telse: return max_int\\n\\n\\t# If sign is -1, take 1\\'s compliment of result and add 1 to get negative value\\n\\treturn ~(result) + 1 if sign == -1 else result\\n\\t```\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = 1\\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0): sign = -1\\n        \\n        result = 0\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        max_int = 2 ** 31 - 1\\n        \\n        while dividend >= divisor:\\n            temp = divisor\\n            quotient = 1\\n            while temp <= dividend:\\n                temp <<= 1\\n                quotient <<= 1\\n            result += quotient >> 1\\n            dividend -= temp >> 1\\n        \\n        if result > max_int:\\n            if sign == -1 and divisor == 1: return ~max_int\\n            else: return max_int\\n        \\n        return ~(result) + 1 if sign == -1 else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091540,
                "title": "c-bit-manipulation-easy",
                "content": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nThe key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making\\nit negative.\\n\\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12.\\nNow 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice,\\nit is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the \\nquotient (4), with a remaining dividend 3.\\n\\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens.\\nWe simply add 1 << 0 = 1 to the answer variable.\\n\\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle \\none overflow case: dividend = INT_MIN and divisor = -1.\\n\\n\\nclass Solution {\\npublic:\\n\\tint divide(int dividend, int divisor) {\\n         if (dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\tlong a = labs(dividend), b = labs(divisor), ans = 0;\\n        long sign = dividend<0 ^ divisor<0? -1 : 1;\\n\\t\\twhile (a >= b) {\\n\\t\\t\\tlong temp = b, m = 1;\\n\\t\\t\\twhile (temp << 1 <= a) {\\n\\t\\t\\t\\ttemp <<= 1;\\n\\t\\t\\t\\tm <<= 1;\\n\\t\\t\\t}\\n\\t\\t\\ta -= temp;\\n\\t\\t\\tans += m;\\n\\t\\t}\\n\\t\\treturn sign *ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091148,
                "title": "java-solution-1ms-bit-manipulation",
                "content": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n       public static int divide(int dividend, int divisor) {\\n        if (Integer.MIN_VALUE == dividend && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int ans = 0;\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        while (a - b >= 0) {\\n            int temp = b;\\n            int count = 1;\\n            while (a - (temp << 1) >= 0) {\\n                temp <<= 1;\\n                count <<= 1;\\n            }\\n            a -= temp;\\n            ans += count;\\n        }\\n        return (dividend > 0) == (divisor > 0) ? ans : -ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089759,
                "title": "easy-c-sol-time-o-logn-2-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        if(dividend == divisor){\\n            return 1;\\n        }\\n        \\n        bool flag = (dividend >= 0) == (divisor>=0)?true:false;\\n        \\n       unsigned int dividnd = abs(dividend);\\n       unsigned int divsor = abs(divisor);\\n        \\n        unsigned int res = 0;\\n        \\n        while(dividnd >= divsor){\\n            \\n            short cnt=0;\\n            \\n            while(dividnd > (divsor << cnt+1)){\\n                cnt++;\\n            }\\n            res += 1 << cnt;\\n            dividnd -= divsor<<cnt;\\n        }\\n        \\n        return flag?res: - res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n     \\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 979719,
                "title": "js-bitwise-division",
                "content": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar divide = function (dividend, divisor) {\\n    var rem = Math.abs(dividend);\\n    var div = Math.abs(divisor);\\n    var quo = 0;\\n    // subtract divisor bit by bit, starting from most significant bit\\n    for (var b = 31; b >= 0; b--) {\\n        if ((rem >>> b) >= div) {\\n            quo |= 1 << b;\\n            rem -= div << b;\\n        }\\n    }\\n    quo >>>= 0; // make unsigned\\n    if (dividend > 0 !== divisor > 0) quo = -quo; // add sign\\n    return quo > -0x80000000 ? quo < 0x7FFFFFFF ? quo : 0x7FFFFFFF : -0x80000000; // check bounds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709731,
                "title": "java-very-slow-but-simple",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }\\n        \\n        return (dividend >= 0 && divisor >= 0) || (dividend <= 0 && divisor <= 0) ? cnt : -cnt;   \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        // stupid edge case\\n        if (divisor == -1 && dividend == Integer.MIN_VALUE)\\n            return Integer.MAX_VALUE;\\n        \\n        int cnt = 0;\\n        int a = Math.abs(dividend), b = Math.abs(divisor);\\n        \\n        while (a - b >= 0) {\\n            cnt++;\\n            a -= b;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 472298,
                "title": "short-python-3-only-and-logical-operators-took-20-40-ms",
                "content": "Many solutions avoid mul/div by left/right shifting operators. I don\\'t believe it\\'s cheating, because these are different operators, and because these solutions are not easier than the ones using only +-. It\\'s just absolutely unnecessary, because it\\'s enough to double value simply using a += a which is also faster than a >>= 1 in python.\\n(Abs technically also uses only logical operators and -.)\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == 0 or divisor == 1: #not necessary but makes things simpler\\n            return dividend\\n        if dividend == -2**31 and divisor == -1: #accurately deal with overflow\\n            return 2**31-1\\n        neg = (dividend < 0) ^ (divisor < 0)\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        endres = 0\\n        while dividend >= divisor:\\n\\t\\t   #At each iteration subtract the largest possible divisor*r=divisor*(2**k)\\n            resm = divisor\\n            r = 1\\n            while resm + resm < dividend:\\n                r += r\\n                resm += resm\\n            dividend -= resm\\n            endres += r\\n        return 0 - endres if neg else endres\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383218,
                "title": "easy-peasy-python-bit-solution-with-example",
                "content": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tdef divide(self, dividend: int, divisor: int) -> int:\\n        if dividend == -2147483648 and divisor == -1:\\n            return 2147483647\\n        if divisor == 1:\\n            return dividend\\n        negative = (dividend < 0) ^ (divisor < 0)\\n        dvd = abs(dividend)\\n        dvs = abs(divisor)\\n        res = 0\\n\\n        while dvd >= dvs:\\n            tmp = dvs\\n            m = 1\\n            while (tmp << 1) <= dvd:\\n                tmp <<= 1\\n                m <<= 1  # I am doubling m\\n            dvd -= tmp\\n            res += m\\n            \\n        if not negative:\\n            return res\\n        else:\\n            return ~res + 1\\n\\t\\t\\t\\n\\t\\n\\t# example, \\n\\tlet dividend = 23\\n\\tdivisor = 2\\n\\t\\n\\tso basically in each for loop I am finding the max number which is multiple of divisor \\n\\tif num = 23, then 16 is the max that I can reach by doubling divisor each time\\n\\tso remaning is 23 - 16 = 7\\n\\tNow, 4 is the max that I can reach by doubling 2 and still be less than 7\\n\\tremaining = 7 - 4 = 3\\n\\tand so on untill my divisor is not greater than dividend",
                "codeTag": "Python3"
            },
            {
                "id": 2425683,
                "title": "using-repeated-exponential-searches-approach-c",
                "content": "Implementation\\n\\n**Using Repeated exponential searches approach\\nTime Complexity = O(logN * logN), we can store the internal while loop generated number and power of two into an array as well, but it was will cause us O(logN) space complexity as well.\\nSpace Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        \\n        // special case\\n        // bcz, if dividend is INT_MIN = -2147483648, and divisor is -1, and if we are converting into positive (2147483648), it will overflow the int value, so in this case we need to return the INT_MAX value which is 2147483647\\n        if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n        \\n        int HALF_INT_MIN = -1073741824;\\n        int countNegativeNumber = 2;\\n        \\n        // converting into negative to avoid int overflow\\n        if(dividend > 0){\\n            countNegativeNumber--;\\n            dividend = -dividend;\\n        }\\n        \\n        if(divisor > 0){\\n            countNegativeNumber--;\\n            divisor = -divisor;\\n        }\\n        \\n        int quotientResult = 0;\\n        while(dividend <= divisor){\\n            \\n            int value = divisor;\\n            int powerOfTwo = -1;\\n            \\n            // check HALF_INT_MIN as well bcz of the int overflow issue\\n            while(value >= HALF_INT_MIN && value+value >= dividend){\\n                value += value;\\n                powerOfTwo += powerOfTwo;\\n            }\\n            \\n            dividend -= value;\\n            quotientResult += powerOfTwo;\\n        }\\n        \\n        if(countNegativeNumber != 1){\\n            return -quotientResult;\\n        }\\n        \\n        return quotientResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194697,
                "title": "python-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```\\n***Pls upvote if you find it helpful.***",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        is_negative = (dividend < 0) != (divisor < 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        sum = divisor\\n        quo=0\\n        while sum<=dividend:\\n            q2=1\\n            while (sum<<1) <=dividend:\\n                sum<<=1\\n                q2<<=1\\n            dividend -= sum\\n            sum = divisor\\n            quo += q2\\n        return min(2147483647, max(-quo if is_negative else quo, -2147483648))   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889305,
                "title": "python-solution-faster-than-92",
                "content": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int):\\n        sign = 1 if (dividend > 0) == (divisor > 0) else -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        res = 0\\n        while dividend >= divisor:\\n            temp, i = divisor, 1\\n            while dividend >= temp:\\n                dividend -= temp\\n                res += i\\n                i <<= 1\\n                temp <<= 1\\n\\n        if sign < 0:\\n            res = -res\\n\\n        return min(max(-2147483648, res), 2147483647)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318451,
                "title": "solution-explanation-not-just-code",
                "content": "Let\\'s assume, \\na = dividend and b = divisor\\n\\nwe can write a/b as, a/b = q  or a = b*q\\n\\nNow, any number can be expressed as a unique sum of some powers of 2\\nFor example, 7 = 2^0 + 2^1 + 2^2 and 11 = 2^0 + 2^1 + 2^3\\n\\nLet\\'s assume,\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\n \\nNow,\\na = b * (2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n)\\nor\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + ... + (b * 2^p_n)\\n\\nWe need to calculate these terms without using any sort of multiplication or division or modulo\\n\\nThe key to the solution is the \\'<<\\' operator or the left shift operator\\nx = x << 1 is equivalent to multiplying x with 2\\n\\nConsider this code,\\n```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\\n\\nThe above for loop would calculate the following,\\nb_value = b\\nb_value = b * 2\\nb_value = b * 2^2\\nb_value = b * 2^3\\nb_value = b * 2^4 and so on.....\\n\\nBut remember q = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\nSo we need the powers of 2\\n\\nWe can do it like this,\\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\\n\\nNow the for loop would calculate the following,\\nb_value = b, q_value = 1\\nb_value = b * 2, q_value = 2\\nb_value = b * 2^2, q_value = 4 or 2^2\\nb_value = b * 2^3, q_value = 8 or 2^3\\nb_value = b * 2^4, q_value = 16 or 2^4 and so on.....\\n\\nBut this for loop is just multiplying b and 1 by 2s. We need to figure out which power of 2s sum up to q.\\nTo do this we need to first collect all the b_values and q_values into two vectors,\\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\\n\\nAnother interesting fact!\\nIf we have power_of_2s = [2^0, 2^1, 2^2, ... , 2^n], we can figure out the terms that sum up to m like this (here m < 2^n+1),\\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\\n\\nif power_of_2s = [1, 2, 4, 8] and m = 11 the for loop proceeds like this,\\niteration 1: 8 <= 11 is true, m is changed to 3, terms = [8]\\niteration 2: 4 <= 3 is false, terms = [8]\\niteration 3: 2 <= 3 is true, m is changed to 1, terms = [8, 2]\\niteration 4: 1 <= 1 is true, m is changed to 0, terms = [8, 2, 1]\\nThe sum of the terms, 8 + 2 + 1 = 11\\n\\nNow lets see the two equations that started all this\\nq = 2^p_1 + 2^p_2 + 2^p_3 + ... + 2^p_n\\na = (b * 2^p_1) + (b * 2^p_2) +  (b * 2^p_3) + (b * 2^p_n)\\n\\nLet\\'s say we have collected the necessary b_values and q_values (see above) such that\\nq_values = [1, 2, 4, ... , 2^n]\\nb_values = [b, b * 2, b * 4, ..., b * 2^n] where a < b * 2^n+1\\nWe have to select the b_values that sum up to a\\nWhenever we select a b_value, we also select the corresponding q_value. These will sum up to q\\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```\\nSumming up the q_terms will get us q\\nIt can also be verified that the b_terms sum up to a\\n\\nFor a = 36 and b = 3, q_values = [1, 2, 4, 8] and b_values = [3, 6, 12, 24]\\nThe for loop proceeds like this, \\niteration 1: 24 <= 36 is true, a is changed to 12, q_terms = [8], b_terms = [24]\\niteration 2: 12 <= 12 is true, a is changed to 0, q_terms = [8, 4], b_terms = [24, 12]\\niteration 3: 4 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\niteration 4: 1 <= 0 is false, q_terms = [8, 4], b_terms = [24, 12]\\n\\nq = 8+4 = 12\\nand\\nb = 24+12 = 36\\n\\nHope that clears things up ^_^\\n(P.S. I omitted to discuss the overflow issues as the explanation was getting too long. The code for handling overflow can be easily understood from other user\\'s code)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint b_value = b;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nint q_value = 1;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tq_value = q_value << 1;\\n}\\n```\n```\\nint b_value = b;\\nvector<int> b_values;\\nint q_value = 1;\\nvecotr<int> q_values;\\nwhile( b_value <= a )\\n{\\n\\tb_value = b_value << 1;\\n\\tb_values.push_back(b_value);\\n\\tq_value = q_value << 1;\\n\\tq_values.push_back(q_value);\\n}\\n```\n```\\nvector<int> terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(power_of_2s[i] <= m)\\n\\t{\\n\\t\\tterms.push_back(power_of_2s[i]);\\n\\t\\tm -= power_of_2s[];\\n\\t}\\n}\\n```\n```\\nvector<int> b_terms\\nvector<int> q_terms;\\nfor(int i=n-1; i>=0; i--)\\n{\\n\\tif(b_values[i] <= a)\\n\\t{\\n\\t\\tb_terms.push_back(b_values[i]);\\n\\t\\tq_terms.push_back(q_values[i]);\\n\\t\\ta -= b_values[i];\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084794,
                "title": "divide-two-integers-java-easy-solution-w-explanation",
                "content": "In this problem we are asked two divide two integers without using multiplication, division, and mod operator.\\n\\nWe know that multiplication of M and N is nothing but addition of M, N times.\\nSimilarly, Division of M and N is nothing but subtraction of N from M as long as resulting value is positive. Here the number of subtractions made is the quotient and the last remaining positive number (including zero)  is the remainder.\\n\\nAlso, the problem wants us to limit the division result in integer range.\\nExtreme cases:\\n1. To always consider sign of the dividend and divisor. This will help in determining final sign of quotient\\n2. If dividend is Integer.MIN_VALUE and divisor is -1. Then quotient will exceed Integer.MAX_VALUE\\n\\n\\n```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if(dividend == 0) {\\n            return 0;\\n        }\\n\\n        long posDivd = dividend;\\n        long posDivr = divisor;\\n        boolean divdSign = true, divrSign = true;\\n\\n        if(dividend < 0) {\\n            posDivd = -posDivd;\\n            if(posDivd < 0) {\\n                posDivd = Integer.MAX_VALUE;\\n            }\\n            divdSign = false;\\n        }\\n\\n        if(divisor < 0) {\\n            posDivr = -posDivr;\\n            if(posDivr < 0) {\\n                posDivr = Integer.MAX_VALUE;\\n            }\\n            divrSign = false;\\n        }\\n\\n        if(posDivr == 1) {\\n            if(divdSign == divrSign) {\\n                return (int) Math.min(posDivd, Integer.MAX_VALUE);\\n            } else {\\n                return (int) Math.max(-posDivd, Integer.MIN_VALUE);\\n            }\\n        }\\n\\n        long temp = posDivr;\\n        long count = 0;\\n        while(temp <= posDivd) {\\n            temp += posDivr;\\n            count++;\\n        }\\n\\n        if(divdSign == divrSign) {\\n            return (int) Math.min(count, Integer.MAX_VALUE);\\n        } else {\\n            return (int) Math.max(-count, Integer.MIN_VALUE);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480305,
                "title": "explained-java-1ms-without-long-100",
                "content": "**LOGIC:**\\n\\n![image](https://assets.leetcode.com/users/him431/image_1579014954.png)\\n\\n\\n **For a/b,\\n  1) We check like b,2b,4b,8b ,.. max value that can be subtracted from a\\n  2) Subtract from a , add 2^x in result and continue**\\n\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        //Base Cases\\n        if (divisor == 1) {\\n            return dividend;\\n        }\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n        \\n        int result = 0;\\n        int a = dividend<0 ? -dividend : dividend;\\n        int b = divisor<0 ? -divisor : divisor;\\n        \\n        while(a-b>=0){\\n            int x=0;//by default start with : a-b*(2^0) = a-b\\n            while(a-(b<<x) >=0){ // a- b*(2^x) >= 0 , to get max x for this\\n                x++;\\n            }\\n            x--; // bcoz loop condition was not satisfied after last x++\\n            \\n            result += 1<<x; // count how many times b was added to itself i.e. 2^x\\n            a-= b<<x;       // subtract that max subtractable i.e. b*(2^x) from a\\n        }\\n        \\n        return (dividend >= 0) == (divisor >= 0) ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448102,
                "title": "very-simple-c-solution-using-bit-shifting-using-only-32-bit-variables",
                "content": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tDivision using bit manipulation without using long (constraint: use 32 bit values only)\\n    https://leetcode.com/problems/divide-two-integers/\\n*/\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        unsigned int divisor = static_cast<unsigned int>(y);\\n        unsigned int dividend = static_cast<unsigned int>(x);\\n        unsigned int quotient = 0;\\n        \\n        // decide the sign\\n        bool negative = (x < 0) ^ (y < 0);\\n        if(dividend == INT_MIN  && divisor == -1)\\n            return INT_MAX;\\n        if(y < 0) \\n            divisor = -1 * divisor;\\n        if(x < 0)\\n            dividend = -1 * dividend;\\n        \\n        // We start with the largest permissible multiple for the divisor\\n        // such that the divisor is still smaller than dividend,\\n        // then we add that bit to the quotient. The dividend is updated \\n        // with dividend = dividend - divisor*multiple\\n        // Then we again find the next largest multiple that when multiplied with divisor\\n        // gives a value closer to dividend. Continue doing this till we get 0\\n        const int N_BITS = sizeof(int) * 8;\\n        \\n        // find the MSB set bit(1 indexed)\\n        int msb_pos = 0;\\n        for(int i = N_BITS - 1; i >= 0; i--) {\\n            if((1 << i) & divisor) {\\n                msb_pos = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = (N_BITS - msb_pos); i >= 0; i--) {\\n            // 2^i * divisor <= dividend\\n            if((divisor << i) <= dividend) {\\n                dividend -= divisor << i;  // dividend = dividend - divisor*2^i\\n                quotient |= 1 << i;\\n            }\\n        }\\n        \\n        // check for overflow, happens when the quotient is storing max value\\n        // which in case negative sign is not there, needs to be made +ve and that\\n        // time overflow happens, quotient = INT_MIN and nagtive = false\\n        if(quotient == numeric_limits<int>::min() && !negative)\\n            return numeric_limits<int>::max();\\n        // add the sign if required\\n        quotient = negative ? -1 * quotient: quotient;\\n\\n        return quotient; \\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13555,
                "title": "ac-python-solution",
                "content": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "solutionTags": [
                    "Python"
                ],
                "code": "    MAX_INT = 0x7FFFFFFF\\n\\n    def divide(self, dividend, divisor):\\n        if divisor == 0:\\n            return self.MAX_INT\\n        if dividend == 0:\\n            return 0\\n        negative = (dividend > 0) ^ (divisor > 0)\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        ans = 0\\n        while dividend >= divisor:\\n            x = divisor\\n            i = 1\\n            while dividend >= x + x:\\n                x += x\\n                i += i\\n            dividend -= x\\n            ans += i\\n        ans = self.MAX_INT if not negative and ans > self.MAX_INT else ans\\n        return -ans if negative else ans\\n\\n\\n    # 988 / 988 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 85.93%",
                "codeTag": "Python3"
            },
            {
                "id": 13605,
                "title": "15-ms-c-solution-with-explaination",
                "content": "    class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            } else if (b == 1) {\\n                 return sign * a;\\n             }\\n            \\n            \\n            long result = 0;\\n            int i = 0;\\n            while(a >= b) {\\n                i = 0;\\n                while(a >= b<<i) {\\n                    a -= b<<i;\\n                    result += 1<<i;\\n                    i++;\\n                }\\n            }\\n            return (sign * result);\\n        }\\n    \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int divide(int dividend, int divisor) {\\n            // for cases where dividend or divisor is INT_MIN, \\n            // by using a higher type, we take the whole number\\n            // else abs cannot work since its based on 2's complement\\n            // and 2's complement of n bit number is undefined if its \\n            // the min number. try taking out the 2's complement of \\n            // -8 for a 4 bit number, behaviour is undefined \\n            long a = labs(dividend);\\n            long b = labs(divisor);\\n            long sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;\\n            // overflow cases : denominator == 0 or dividing by a number makes the number \\n            // greater than INT_MAX\\n            if (b == 0 || dividend == INT_MIN && divisor == -1) {\\n                return INT_MAX;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13631,
                "title": "difference-between-int-and-long",
                "content": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "solutionTags": [],
                "code": "this may be so silly question, but I do not get it :\\nI found this solutions for the problem works ,\\nbut when I do not use long, it will get error, run out of time.\\nDo anyone can explain to me why. thanks a lot\\n\\n\\n\\n    public int divide(int dividend, int divisor) {\\n        boolean signA = dividend >= 0, signB = divisor > 0;\\n    \\n        long num = Math.abs((long) dividend), div = Math.abs((long) divisor), res = 0, curr = 0;\\n    // using Long division\\n        for (int idx = 31; idx >= 0; idx--) {\\n            curr <<= 1;\\n            curr |= ((num >> idx) & 1);\\n    \\n            res = res << 1;\\n            if (curr >= div) {\\n                curr -= div;\\n                res |= 1;\\n            }\\n        }\\n    \\n        if (signA ^ signB)\\n            return -(int) res;\\n        return (int) res;\\n    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3795128,
                "title": "c-follow-the-rules-only-use-int-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow the rules, only use int + - & << operations\\n\\nIt handles edge cases like division by INT_MIN and potential overflows. The main algorithm involves repeated subtractions of B from A to calculate the quotient, accounting for signs and avoiding integer overflow. The dividend A is taken to be non-postive for the reason when A=INT_MIN, the number -INT_MAX=2^31 is not  32-bit unsigned int.\\n\\nThe implementation for integer division utilizes bit manipulation techniques. It handles edge cases and performs division using bit shifts, which is more efficient than repeated subtractions. Bit manipulation helps in efficiently doubling the divisor and finding the quotient by checking bit positions in the operands.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry these test cases\\n```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\\n![division.png](https://assets.leetcode.com/users/images/5398d3ee-d05a-4f89-b84b-528c66ef1905_1689916104.5670538.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N), where N is the absolute value of the dividend A\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code with Runtime 0 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n-2147483648\\n2147483647\\n2147483647\\n2147483647\\n1981445587\\n1172010393\\n1100540749\\n-1090366779\\n-2147483648\\n2\\n-2147483648\\n1\\n2147483647\\n2\\n```\n```\\nclass Solution {\\npublic:\\n    int divide(int A, int B) {\\n        //Consider the edge case INT_MIN=-2^31 whose change sign is not INT\\n        if (A==INT_MIN && B==-1) \\n            return INT_MAX;\\n        if (A==INT_MIN && B==1)\\n            return INT_MIN;\\n        if (B==INT_MIN && A!=INT_MIN) return 0;\\n\\n        //Edge cases can lead to TLE\\n        if (A==B) return 1;\\n        if ( (0<=A && A<B)||(A<0 && B<A)) return 0;\\n\\n        int ch_sgn=0;\\n        if (A>0){//A!=INT_MIN\\n            A=-A;\\n            ch_sgn++;\\n        }\\n        if (B<0){//quarantee B!=INT_MIN\\n            B=-B;\\n            ch_sgn++;\\n        }\\n        int sgn=(ch_sgn&1)?1:-1;\\n        int q=0;\\n        while(-B>=A){//TLE can happen when -A/B is large if only performing A+=B\\n            int b=B;\\n            int k=0;//Performing A+=b where b=B*(2^k)<=INT_MAX\\n            while(A<=-b && b<=INT_MAX){\\n                A+=b;\\n                q+=(1<<k);\\n                if (b<(1<<30)){\\n                    b<<=1;\\n                    k++;\\n                } \\n            } \\n        }\\n        return (sgn==1)?q:-q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250771,
                "title": "superb-logic-whithout-operators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        m,n=abs(dividend),abs(divisor)\\n        answer=0\\n        while (m-n)>=0:\\n            count=0\\n            while (m-(n<<1<<count))>=0:\\n                count+=1\\n            answer+=1<<count\\n            m-=n<<count\\n        if  dividend<0 and divisor<0:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            else:\\n                return answer\\n        elif dividend<0 or divisor<0:\\n            if answer<-2**31:\\n                return -2**31\\n            return -answer\\n        else:\\n            if answer>2**31-1:\\n                return 2**31-1\\n            return answer\\n\\n\\n\\n\\n        \\n        \\n\\n\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705667,
                "title": "easy-java-solution-beats-75",
                "content": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int divide(int dividend, int divisor)\\n {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1)\\n             return Integer.MAX_VALUE; \\n\\n        boolean negative = dividend < 0 ^ divisor < 0; \\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n       \\n int quotient = 0, subQuotient = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            for (subQuotient = 0; dividend - (divisor << subQuotient << 1) >= 0; subQuotient++);\\n            quotient += 1 << subQuotient; \\n            dividend -= divisor << subQuotient; \\n}\\n        return negative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511149,
                "title": "i-think-this-is-a-mistake-check-please",
                "content": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/3ca98b1f-e1dc-4301-8d33-1ed9cc8d7ce4_1661981987.023198.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2501524,
                "title": "using-substraction-and-addition-only",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        n = 0\\n        md = 1\\n        if (dividend < 0):\\n            md = -md\\n            dividend = abs(dividend)\\n        if (divisor < 0):\\n            md = -md\\n            divisor = abs(divisor)\\n        nn = 1\\n        dvd = dividend\\n        dvr = divisor\\n        sn = 0\\n        while (dvd >= dvr):\\n            nn = 1\\n            dd = dvr\\n            while (dvd >= dd):\\n                sn += nn\\n                dvd -= dd\\n                dd += dd\\n                nn += nn\\n\\n        ans = sn\\n\\n        if (md < 0):\\n            ans = -ans\\n        if (ans > 2 ** 31 - 1):\\n            ans = 2 ** 31 - 1\\n        if (ans < -2 ** 31):\\n            ans = -2 ** 31\\n        return (ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358872,
                "title": "javascript-solution-bit-manipulation-time-log-n-space-o-1",
                "content": "It\\'s important to understand how we\\'re using base(2) for our integers and that each bit is a power of 2...so for example the first bit is 2 to the power of 0 and the second is 2 to the power 1 and the third is 2 to the power of 2...all the way to 31. Basically you should be comfortable with converting a positive numbers by hand and the basics of negative numbers in binary to understand how we can use bit manipulation to solve this problem \\n\\nWe use that logic to count the number of times our divisor fits into the dividend and since we\\'re shifting the bits to get our answer the time complexity will be O(log(n))\\n\\nBasically here initially we set our count to 1 if the dividend is greater than or equal to the divisor. We check to see if we can shift the bit over by checking to see if the number will still be greater than our dividend. If it is than we shift the bits of the count, dividend and divisor. Probably best to write it down to see how the shifts are shifting to understand how we\\'re using the power of 2 to get our result. We handle negatives by converting the input to a positive number and than adding the sign at the end.\\n```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * bit manipulation\\n * space O(1) \\n * time O(log n) we\\'re shifting the n bits\\n */\\n var divide = function(n, d) {\\n    if (n === 0 || d === 0) return 0\\n    let isNegative = false;\\n    let result = 0;\\n    if ((d < 0 || n < 0) && !(d < 0 && n < 0)) isNegative = true;\\n    n = Math.abs(n)\\n    d = Math.abs(d)\\n\\n    while (n >= d) {\\n        let count = 1, temp = n, tempd = d\\n        while (tempd <= (temp >> 1)){\\n            count <<= 1\\n            temp >>= 1\\n            tempd <<= 1\\n        }\\n        result += count\\n        n -= tempd\\n    }\\n    if (isNegative) return -result\\n    if (result >= 2**31) {\\n        return 2**31 - 1\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2305274,
                "title": "easy-and-very-neat-code-bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\n**If you like the code then please upvote it. This will motivate me to post more codes with full explanation.**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n\\t  // When given dividend is -INFINITY and divisor is -1. The\\n        // answer should be -Inf*-1=Inf\\n        if(a == INT_MIN and b == -1) \\n            return INT_MAX;\\n        // since we know what sign the result should be,\\n        // we can remove the negative sign from both divisor and dividend\\n        long num = labs(a), div = labs(b);\\n\\t\\t// our final answer will be \\'ans\\', the number of times we need to multiply\\n        // divisor to make dividend as close to 0 as possible.\\n      \\tlong ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n        // while div is less/equal to num do the following:\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090734,
                "title": "c-solution-0-ms-three-approaches-bit-manipulation",
                "content": "__Thanks for checking out my solution\\nMake sureyou upvote if it helped you :)__\\n\\n__Method 1:\\nTime Complexity : O(Dividend / Divisor) \\nNaive Method to get the solution, \\nGives TLE therefore it has to be optimised__\\n\\n```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Now the task is to optimise the time-complexity, using bit-manipulation__\\n\\n>__The idea here is to understand that any number can be represented\\nas sum of powers of 2__\\n>>__Check for the sign of the quotient\\nint sign = (divisor < 0) ^ (divendend < 0);\\n//if only one of them is negative, sign = 1, else 0__\\n\\n>>__Pseudo Code\\nfor i = 31 to i = 0,  since the question assumes that the number is 32 bit__\\n>>>  __So check till (divisor << i)  <= dividend,    \\n>>>   i.e.  [ divisor * (2 ^ i) ]    <=  dividend \\n>>>   if true, add the power of 2 to the answer, and substract (divisor << i) from dividend\\n>>>   ans += 1 << i, i.e ans = ans + 2^i (power of 2)\\n>>>   dividend -= divisor << i__\\n\\n>>__if sign = 1\\nans = -ans;           //the quotient will be negative__\\n\\n>>__Now that we have to give the answer in the required constraints\\nif ans > INT_MAX ( 2^31 -1), return INT_MAX, min(ans, INT_MAX )\\nif ans < INT_MIN (-2^31), return INT_MIN, max(INT_MIN, ans )__\\n\\n\\n__Below is the coding implementation\\nMethod 2:\\nTime Complexity : O(31) ~ O(1)__\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n__Variation of the above given solution\\nThis time instead of taking the dividend to 0\\nWe take the divisor to the dividend\\nMethod 3:\\nTime Complexity : O(31) ~ O(1)__\\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{ // There is Reason why this questioh has so low accuracy\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        int sgn = ((dividend < 0) ^ (divisor < 0));\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;\\n        if (dv == 1)\\n            ans = d;\\n        else\\n            while (d >= dv)        //Exhaustive subtraction\\n            {\\n                ++ans;\\n                d -= dv;\\n            }\\n        if (sgn == 1)\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);    //Speed Game\\n        cin.tie(0);\\n        int sgn = (dividend < 0) ^ (divisor < 0);     //Get the sign of the quotient \\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0;   //Since left shift works only on positives, take absolute value\\n        for (int i = 31; i >= 0; i--)             //Explore all the 32 bits\\n            if (dv << i <= d)                     //If divisor * 2^i   <= dividend\\n            {\\n                ans += 1LL << i;                  //1LL prevents 2^31, to be treated as negative\\n                d -= dv << i;                      //Reduce the dividend\\n            }\\n        if (sgn == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```\n```\\n// Same method but with addition with no subtraction\\nclass Solution\\n{\\npublic:\\n    int divide(int dividend, int divisor)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        int sign = ((dividend < 0) ^ (divisor < 0));   //If only one of them is true, the quotient will be negative, i.e. sign = 1\\n        long long int d = abs(dividend), dv = abs(divisor), ans = 0, temp = 0;\\n        for (int i = 31; i >= 0; --i)\\n            if (temp + (d << i) <= dd)\\n            {\\n                temp += d << i;             //Taking the temp as close as to the dividend\\n                ans |= 1LL << i;\\n            }\\n        if (sign == 1) // Number is negative\\n            ans = -ans;\\n        return ((ans < INT_MIN) ? INT_MIN : ((ans > INT_MAX) ? INT_MAX : ans ));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090591,
                "title": "rust-negative-division-i32-only",
                "content": "Since we are permitted to operate within the range of `i32` only, avoiding overflow with `i64` or `u32` should be considered illegal.\\n\\nThe problem is trivial when the dividend and the divisor are both positive. So it\\'s tempting for us to use `i32::abs()` to convert them into positive numbers and negate the result if necessary. But in this approach `i32::MIN.abs()` becomes a grave problem. According to the doc, it either panics or returns `i32::MIN` itself, which isn\\'t what we expect. So let\\'s do it the opposite way: convert both operands into their *negative* absolute values. \\n\\n```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn divide(dividend: i32, divisor: i32) -> i32 {\\n\\n        let is_neg = (dividend < 0) ^ (divisor < 0);\\n\\t\\t\\n        let mut p = if dividend > 0 { -dividend } else { dividend };\\n        let q = if divisor > 0 { -divisor } else { divisor };\\n\\n        // res is the *negative* absolute value of the quotient, in case the quotient is i32::MIN.\\n        let mut res = 0;\\n\\t\\t\\n\\t\\t// Here is the magic: the negative divisor(aka q) can left-shift atmost q.leading_ones() - 1 bits before it overflows.\\n        for shift in (0..q.leading_ones()).rev() {\\n\\t\\t\\t// Don\\'t apply \"p -= (q << shift)\" before overflow checking. Consider p = 0, q << shift = i32::MIN.\\n            if (p <= (q << shift)) {\\n                p -= q << shift;\\n                res += -1 << shift; // Not \"res -= 1 << shift;\" which may cause overflow.\\n            }\\n        }\\n        \\n        if is_neg {\\n            res\\n        } else if res == i32::MIN {\\n            i32::MAX\\n        } else {\\n            -res\\n        }\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2090009,
                "title": "c-bit-manipulation-easy-to-understand-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```\\n\\n```\\n/*\\na = 15 , b  = 3;\\nwhile 15>=3 (outer while loop)\\n{\\ntemp = 3, m = 1;\\nif 3<<1 which is 6 <= 15\\nso, 3<<1 => temp = 6, m = m<<1 => 2;\\nif 6<<1 => 12<=15\\nso, 6<<1 => temp = 12 , m = 2<<1 => 4;\\nif(12<<1 => 24 <= 15) wrong \\nout of while loop ,\\nnow temp = 12, m = 4 => ans += 4 => 4;\\nsubtract 15-12 = 3;  \\n}  again\\nwhile 3>=3 (outer while loop)\\n{\\nso temp = 3, m = 1;\\nin inner while loop 3<<1 => 6 <= 3 (wrong) \\nso dnd = 3-3 = 0;\\nans += m => ans += 1 => ans = 5;\\n\\n}\\n(0>=3) (outer while loop ) (wrong)\\nso our ans is 5;\\n*/\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if(dividend == INT_MIN && divisor == -1)\\n            return INT_MAX;\\n     \\n        long long ans = 0;\\n        int s = 1;\\n        if(dividend<0 && divisor<0)\\n        s = 1;\\n        else if(divisor<0 || dividend<0)\\n        s = -1;\\n        long long dnd = abs((long)dividend),dsr = abs((long)divisor);\\n        while(dnd>=dsr)\\n        {\\n            long long temp = dsr, m = 1;\\n            while(temp<<1 <= dnd)\\n            {\\n                temp = temp<<1;\\n                m = m<<1;\\n                \\n            }\\n            dnd -= temp;\\n            ans += m;\\n        }\\n        return ans*s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089488,
                "title": "division-using-the-left-shift-operator-python3",
                "content": "# --> Division using the left shift operator\\n**The Bitwise left shift operator:-**\\nWe know that the binary number system is based on powers of 2. So, positional weight of each of the following bits is twice the previous bit i.e. its power is increased by 1. As a result, when we push a number towards the left by 1 bit the whole number gets multiplied by 2 power 1. Similarly when a number is pushed to the left by n bits means the number is multiplied by 2 power n.\\n\\nThus in general if you shift a number to left by n bits, it gets multiplied n times by 2.\\n\\n**Steps:**\\n1. Initially, set the quotient to 0.\\n2. Check if any one of the numbers is negative and store it in a separate variable.\\n3. Make both the numbers positive.\\n4. Start from n = 31 the most significant bit and loop till n = 0 the least significant bit.\\n\\t* \\tCheck if shifting the divisor by n bits is less than or equal to the dividend\\n\\t   a) if so subtract it from the dividend and update the dividend\\n\\t   b) Add 2 power n to the answer\\n\\t   ( Note: Here the dividend is reduced to the reminder each time the condition is true. )\\n5. And finally, return the quotient after checking if it should be positive or negative with the result from step 2.\\n\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```\\n*The time complexity of this algorithm is going to be O(log a), where a is the dividend.*\\n*The space complexity of this algorithm is O(1).*\\n\\n***Please upvote, if you found it helpful. Thanks..!!***",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        if dividend < 0 or divisor < 0:\\n\\t\\t\\t #Setting Negative Flag To true if any of the number is negative.\\n            Negative_Flag = True\\n        else:\\n            Negative_Flag = False\\n        \\n        quotient  = 0 #Initializing Quotient\\n\\t\\t\\n\\t\\t#Making negative number positive\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n\\t\\t\\n\\t\\t#Calculating Max and Min Limit\\n        maxLimit = (2**31)-1\\n        minLimit = -(2**31)\\n\\n        for i in range(31, -1, -1):\\n            if (divisor << i) <= dividend: # checking if divisor multiplied by 2**i is <= dividend\\n                dividend -= (divisor << i) #subtracting divisor << i from dividend\\n                quotient += 1 << i # adding 2 power i to the quotient\\n\\n\\t\\t # and finally checking if the output should be negative\\n        if Negative_Flag:\\n            quotient = -abs(quotient)\\n\\n        if quotient >= maxLimit:\\n            return maxLimit\\n        elif quotient <= minLimit:\\n            return minLimit\\n        else:\\n            return quotient\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774409,
                "title": "go-succinct-intuitive-100-with-explanation",
                "content": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nFor anyone confused about the bitshifts (`<<`), the idea is that it makes the subtractions and additions faster by multiplying each value by a higher power of 2 with each shift, requiring fewer iterations. This is logically equivalent to this more intuitive code but much faster:\\n\\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\\n\\nIn the most extreme case of `2147483647 / 1` (`math.MaxInt32` divided by `1`), the second program would take 2147483647 iterations and the first would only take 465.",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc divide(dividend int, divisor int) int {\\n\\t// single special case that would cause overflow\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor divid >= divis {\\n\\t\\tsub := divis\\n\\t\\tadd := 1\\n\\t\\tfor divid >= sub<<1 {\\n\\t\\t\\tsub <<= 1\\n\\t\\t\\tadd <<= 1\\n\\t\\t}\\n\\t\\tdivid -= sub\\n\\t\\tquotient += add\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```\n```\\nfunc divide_intuitive_but_slow(dividend int, divisor int) int {\\n\\tif dividend == math.MinInt32 && divisor == -1 {\\n\\t\\treturn math.MaxInt32\\n\\t}\\n\\n\\tquotient := 0\\n\\tdivid := abs(dividend)\\n\\tdivis := abs(divisor)\\n\\tfor ; divid >= divis; quotient++ {\\n\\t\\tdivid -= divis\\n\\t}\\n\\n\\tnegative := (dividend < 0) != (divisor < 0)\\n\\tif negative {\\n\\t\\treturn -quotient\\n\\t}\\n\\n\\treturn quotient\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1579861,
                "title": "java-no-longs-simple-solution-that-someone-could-actually-come-up-with",
                "content": "\\nThis post basically steals ideas from the following,\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution\\nhttps://leetcode.com/problems/divide-two-integers/discuss/13397/Clean-Java-solution-with-some-comment.\\n\\ncombining the clean solution to use only integers, and stealing some of the logic from the first, please take a look at both if you are confused.\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\\nI created this solution because I really did not enjoy any of the popular solutions posted here, my goals were to make it actually read-able and using the logic some of the better solutions had using longs, but supporting integers as well. There\\'s 3 things to really go over with this solution that are confusing.\\n\\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\\n This case has to be checked because it\\'s a edge case, similar to other solutions.\\n \\n ```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\\n\\nHere we do a big conditional in order to conver the numbers to negative if they aren\\'t, there\\'s probably easier ways to do this. Why do we make our numbers negatives, well because programming sucks and negative numbers have 1 more than positives... so that means we get integer overflow if we try and convert all the negatives to positives. This might still not make sense why we do this, I encourage you to try programming the solution and you will see why it is advantageous to have all the numbers be either positive or negative ( makes defining the actual long division algorithm much more easy ), other solutions that don\\'t do this tend to lead to worse code in my opinion that would be hard to come up with without a lot of debugging...\\n\\n\\n\\n```\\n(sum + sum) < sum\\n```\\n\\nLastly this nice little line of code actually handles all of our overflow! since we are dealing with negatives, if we add two negative numbers and get a value that isn\\'t smaller, something went wrong!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        \\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        \\n        boolean neg = false;\\n        if(dividend < 0) neg = !neg;\\n        if(divisor < 0) neg = !neg;\\n        \\n        int res = 0;\\n        \\n        if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\n        return neg ? -res : res;\\n        \\n    }\\n    \\n    private int divideR(int dividend, int divisor){\\n        \\n        \\n        if(divisor < dividend || dividend == 0) return 0;\\n        \\n        int sum = divisor;\\n        int mult = 1;\\n        \\n        while((sum + sum) < sum && (sum + sum) >= dividend){\\n            sum += sum;\\n            mult += mult;\\n        }\\n        \\n        return mult + divideR(dividend - sum, divisor);\\n    }\\n   \\n}\\n\\n```\n```\\n if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n ```\n```\\n if(dividend > 0  && divisor > 0)\\n            res = divideR(-dividend, -divisor);\\n        else if(dividend > 0)\\n            res = divideR(-dividend, divisor);\\n        else if(divisor > 0)\\n            res = divideR(dividend, -divisor);\\n        else \\n            res = divideR(dividend, divisor);\\n\\t\\t\\t\\n```\n```\\n(sum + sum) < sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424021,
                "title": "c-easy-soln-using-bit-manipulation-in-o-logn-2",
                "content": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "solutionTags": [],
                "code": "```\\n  int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        \\n        long a = abs(dividend);\\n        long b = abs(divisor);\\n        long res=0;\\n        while(a-b>=0){\\n            int x=0;\\n            while(a-(b<<x<<1)>=0){\\n                x++;\\n            }\\n            res+= 1<<x;\\n            a-= b<<x;\\n        }\\n        return (dividend>=0)==(divisor>=0)? res: (-res);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1085593,
                "title": "c-bitwise-solution-explained-100-time-85-space",
                "content": "I started to think about this problem with the same approach [I used for the power problem](https://leetcode.com/problems/powx-n/discuss/739646/): considering a number (`dividend`) as a sum of another (`divisor`) multiplied by 2 and this would have allowed me to know the quotient.\\n\\nFor example, assume that `dividend` is `60` and `divisors` is `3`: I can see `60 == 12 + 48` or, in a more explicit form (with `**` implying the power operation):\\n`60 == 3 * 2 ** 4 + 3 * 2 ** 2` and again: `60 == 1 * 3 * 2 ** 4 + 0 * 3 * 2 ** 3 + 1 * 3 * 2 ** 2 + 0 * 3 * 2 ** 1 + 0 * 3 * 2 ** 0`.\\n\\nIf I extract the first multiplying factors (`1` and `0`) and align them, I would get `10100`, which is indeed the binary representation of `20`, my goal!\\n\\nNow, to generalise this approach, we first of all need a few variables:\\n* `bits` is our counter variable that we will use in a bit (no pun intended) to know how many times we need to multiply our `divisor` by `2` to get a result, with initial value of `1`  (since down below we will increase the divisor by one extra step with my approach);\\n* `res` is our usual accumulator variable and it is going to be a `long`, same as `d1` and `d2`, to avoid annoyng overflows/edge cases;\\n* `isMinus` is a boolean to remind us what the sign of the final result should be, initially set to `false`.\\n\\nWe will then proceed making sure both `d1` and `d2` have the same sign (positive, for simplicity), flipping `isMinus` if we have to flip their sign.\\n\\nNow, in order to proceed with our logic discussed above, we will need a `d2` which is just bigger than `d1` and to keep track of how many times we need to multiply it by `2` - I know you could achieve the same with logarithms, but this is cheaper since we just stop with the last integer and on top of that we are also growing `d2` just as needed.\\n\\nAnd since after the previous loop we are going to know how many bits will make our result, time to go for a main loop `bits` time and:\\n* set `res` to double its previous value, plus `1` if `d1 >= d2` (meaning we can subtract it and it will make a bit in our final result);\\n* if the above condition is `true`, we will also have to decrease `d1` accordingly, subtracting `d2` to it;\\n* finally, time to reduce `d2` by one bit.\\n\\nA bit of (painfully annoying) extra logic to handle the edge cases and we can finally return `res` or `-res`, depending from `isMinus` :)\\n\\nOne more time, let\\'s assume we are dividing `70` by `3`, so we will have at the beginning of the main loop:\\n\\n```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\\n\\nFirst iteration, since `70 > 96`, we proceed changing little, other than `d2` and of course decreasing `bits`:\\n\\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\\n\\nOkay, now we can subtract, so we have:\\n\\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\\n\\nAgain our condition `d1 >= d2` is `false`, so we just update `d2`, `bits` and this time also `res` increases (in the first step it was the same, given its initial value of `0`):\\n\\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\\n\\nSince `22 >= 12`, we proceed like this:\\n\\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\\n\\nAnd again, since `10 >= 4`:\\n\\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\\n\\nAnd finally, since `4 >= 3`:\\n\\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\\n\\nAnd at this point we can exit with the right result (and note that `d1` would also be our remainder).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n70 // d1\\n96 // d2\\n6 // bits\\n0 // res\\n```\n```cpp\\n70 // d1\\n48 // d2\\n5 // bits\\n0 // res\\n```\n```cpp\\n22 // d1\\n24 // d2\\n4 // bits\\n1 // res\\n```\n```cpp\\n22 // d1\\n12 // d2\\n3 // bits\\n2 // res\\n```\n```cpp\\n10 // d1\\n6 // d2\\n2 // bits\\n5 // res\\n```\n```cpp\\n4 // d1\\n3 // d2\\n1 // bits\\n11 // res\\n```\n```cpp\\n1 // d1\\n1 // d2\\n0 // bits\\n23 // res\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        // support variables\\n        int bits = 1;\\n        long d1 = dividend, d2 = divisor, res = 0;\\n        bool isMinus = false;\\n        // setting the sign\\n        if (d1 < 0) isMinus = !isMinus, d1 = -d1;\\n        if (d2 < 0) isMinus = !isMinus, d2 = -d2;\\n        // adjusting d2\\n        while (d2 <= d1) d2 <<= 1, bits++;\\n        // composing res\\n        while (bits--) {\\n            res = res * 2 + (d1 >= d2);\\n            if (d1 >= d2) d1 -= d2;\\n            d2 >>= 1;\\n        }\\n        // handling overflows\\n        if (res > 2147483647l + isMinus) res = 2147483647;\\n        return isMinus ? -res : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085349,
                "title": "rust-0ms-solution-using-32-bit-signed-integers-only",
                "content": "Question tells us to assume we are using an environment that only has up to 32-bit signed integers available, so let\\'s only use `i32`s for our computation.\\nAlso, we\\'re not allowed to use the `*`, `/ ` or `%` operators, obviously.\\n\\nTo achieve logarithmic runtime, we want to split the `dividend` into components of `divisor * (2^x)`, where `x` is a natural number (possibly including 0).\\nThe result of the division will be the sum of the `2^x` terms in our split components.\\n_For example, if we wish to divide 99 by 3: `99 == 3*(2^5) + 3*(2^0)`; therefore the answer is `2^5 + 2^0 == 32 + 1 == 33`._\\n\\nThe `2^x` terms are convenient, as we can use bitwise shifts to multiply and divide the `dividend` by powers of 2, due to binary being a base-2 number system.\\nIn many cases, we won\\'t be able to split `dividend` exactly, as there\\'ll be a remainder; in those cases we\\'ll want to get as close as possible such that the sum of our components doesn\\'t surpass `dividend`.\\n\\nTo avoid issues regarding overflow, we make our `dividend` and `divisor` negative, and use the negative signed integer range for our computation.\\nThe reason for this is that the negative integer range is always 1 greater than the positive range (excluding 0), which makes overflow checking a bit nicer (also avoids the temptation of cheesing the problem using `u32`s or `i64`s or similiar, **which is _very_ naughty**).\\n\\n```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```\\n\\nAlso, seeing that integers are stored as 2s complement, you may instead prefer to use `~variable + 1` to negate signs, rather than `-variable`. Do whatever suits you. :)\\n\\nTime complexity: `O(~log32) == O(1)` due to the constraints on the inputs.\\nExtra-space complexity: `O(1)`.",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn divide(mut dividend: i32, mut divisor: i32) -> i32 {\\n        assert!(divisor != 0);\\n\\n        let is_ans_neg = (dividend < 0) ^ (divisor < 0);\\n        dividend = -dividend.abs();\\n        divisor = -divisor.abs();\\n\\n        let (mut neg_ans, mut curr_div, mut curr_mul) = (0, divisor, -1);\\n        while curr_div <= divisor {\\n            if curr_div < dividend {\\n                curr_div = if curr_div == -1 { 0 } else { curr_div >> 1 };\\n                curr_mul = if curr_mul == -1 { 0 } else { curr_mul >> 1 };\\n            } else {\\n                neg_ans += curr_mul;\\n                dividend -= curr_div;\\n                curr_div <<= 1;\\n                curr_mul <<= 1;\\n            }\\n        }\\n\\n        match neg_ans {\\n            std::i32::MIN if !is_ans_neg => std::i32::MAX,\\n            _ if is_ans_neg => neg_ans,\\n            _ => -neg_ans,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976341,
                "title": "java-1ms-100-faster-bit-manipulation-with-comments",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n    \\n        \\n        if(dividend==Integer.MIN_VALUE&&divisor==-1) \\n            return Integer.MAX_VALUE;\\n        \\n        boolean isNegative=false;\\n        if(dividend<0||divisor<0){\\n            isNegative = true;\\n        }\\n        // if both are -ve it will be cancelled out\\n         if(dividend<0&&divisor<0){\\n            isNegative = false;\\n        }\\n        \\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int result=0;\\n        // 10-3>=0\\n        while(a-b>=0){\\n            int x = 0; //  its like 2^0=1 , at the end u will get to know\\n            \\n            //checking further we can able to subtract divisor(3)\\n            //10 - (3<<1<<0)\\n            //10 - (6) >=0\\n            while(a-(b<<1<<x)>=0){\\n                x++;\\n            }\\n            // after 1st iteration x = 1\\n            // 0 = 0 + (1<<1)\\n            // 0 = 0 + 2\\n            result +=1<<x;\\n            \\n            \\n            //10 =10 - (3<<1)\\n            //10 =10 - (6)\\n            a =  a-(b<<x);//  a = 4\\n\\t\\t\\t//again while loop continue.....\\n            \\n        }\\n        \\n        return isNegative?-result:result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919712,
                "title": "well-explained-python-solution",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    # division without using divide or multiply\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        # repeatedly subtracting divisor n times is too slow, it times out\\n        # ( O(n) where n=dividend/divisor)\\n        # To speed it up we will still subtract divisor but instead of one at a time,\\n        # we will subtract divisor, divisor*2, divisor*4, divisor*8, divisor*16 etc\\n        # O(log n)\\n        \\n        if divisor == 0:\\n            return 2147483647 # error case\\n        positive = (dividend>0) == (divisor>0) # same sign? result will be positive\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        # first find the largest power of two we need:\\n        power = 1\\n        current_divisor = divisor\\n        current_dividend = dividend\\n        while current_dividend > current_divisor:\\n            current_dividend -= current_divisor\\n            power += power # double to next power of 2\\n            current_divisor += current_divisor # double to next power of 2 * divisor\\n        # divisor is now the largest power of two * divisor smaller than the dividend\\n        # (actually one larger)\\n        \\n        quotient = 0\\n        while power >= 1:\\n            if dividend >= current_divisor: # is this power of two in our dividend?\\n                dividend -= current_divisor # subtract it out\\n                quotient += power # and count it towards our answer\\n            power >>= 1 # half to next lower power of 2\\n            current_divisor >>= 1 # half to next lower power of 2 * divisor\\n            # Using bit shift for divide by 2 isn\\'t cheating. But is it really?\\n        if positive:\\n            if quotient > 2147483647:\\n                return 2147483647\\n            return quotient\\n        else:\\n            if quotient < -2147483648:\\n                return 2147483647\\n            return -quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840662,
                "title": "very-short-math-pythonic-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = +1 if dividend ^ divisor >= 0 else -1        \\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        ans = math.exp(math.log(dividend) - math.log(divisor))\\n\\n        return min(2147483647, sign*math.trunc(ans))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752513,
                "title": "solution-using-log-in-c",
                "content": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```\\n\\nWe use the property : log(a/b) = log(a) - log(b)",
                "solutionTags": [],
                "code": "```\\nint divide(double dividend, double divisor) { \\n\\n        int negFlag = (dividend < 0 ^ divisor < 0) ? 1 : 0;\\n        double logDiv = log(abs(dividend)) - log(abs(divisor));\\n\\t\\t\\n\\t\\t// take antilog to calculate the value \\n        double val = exp(logDiv);\\n        \\n        if(val >= INT_MAX)\\n            return negFlag ? INT_MIN : INT_MAX;\\n    \\n        return negFlag ? -val : val;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558335,
                "title": "seems-to-expect-the-wrong-answer-for-js",
                "content": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```\\n\\nThis can\\'t be right, right? Why would it expect this 214748347? It should not be truncating when dividing by zero\\n",
                "solutionTags": [],
                "code": "```\\nInput: \\n\\t-2147483648\\n\\t-1\\nOutput: \\n\\t2147483648\\nExpected: \\n\\t2147483647\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546970,
                "title": "c-faster-than-99-60-less-than-33-33-mem-o-1",
                "content": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "O(1) since the while loops do at most 32 bit shifts combined.\\n\\nRuntime: 32 ms\\nMemory Usage: 14.7 MB\\n\\nLogic Highlights:\\n* If the dividend is int.MinValue, just remove the divisor from it one time to make sure we can convert it to a positive number. This allows us to stick to the int type. \\n* Convert dividend and divisor to positive numbers to simplify logic. \\n* Find out how many bits make up the divisor. Substracting this number from 31 gives us how far we can shift the divisor before it overflows. \\n* Starting with the largest possible multiple of the divisor to the smallest, see if we can remove it from the dividend. \\n\\nThanks to [jonlist](http://https://leetcode.com/problems/divide-two-integers/discuss/475971/C++-bitwise-and-32bit-int.-0ms-less100-8.2MBless72), that solution made me see things in a different way.\\n\\n```\\n    public int Divide(int dividend, int divisor) {\\n        if (divisor == 1) { return dividend; }\\n        if (divisor == -1 &&  dividend == int.MinValue) { return int.MaxValue; }\\n        if (dividend == divisor) { return 1; }\\n        if (dividend == 0 || divisor == int.MinValue) { return 0; }\\n        \\n        bool isNeg = (dividend < 0 && divisor > 0) ||  (dividend > 0 && divisor < 0);\\n        \\n        int count = 0;\\n        if (dividend == int.MinValue)\\n        {\\n            if (divisor < 0) {  dividend -= divisor; } else { dividend += divisor; }\\n            count++;\\n        }\\n        \\n        int dvd = (dividend < 0)? -dividend: dividend;\\n        int dvs = (divisor < 0)? -divisor: divisor;\\n         \\n        int temp = dvs;\\n        int i = 0;\\n        while(temp > 0)\\n        {\\n           i++;\\n           temp>>=1;\\n        }   \\n        \\n        int multi=31-i;\\n        \\n        while (dvd >= dvs)\\n        {   \\n            temp = dvs;\\n            while((temp << multi) > dvd) { multi--; }\\n                 \\n            dvd -= temp << multi;\\n            count += 1 << multi; \\n        }  \\n                  \\n        if (isNeg) { count = -count; }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 484686,
                "title": "javascript",
                "content": "Runtime: 3396 ms, faster than 24.62% of JavaScript online submissions for Divide Two Integers.\\nMemory Usage: 36.2 MB, less than 33.33% of JavaScript online submissions for Divide Two Integers.\\n\\n```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar divide = function(dividend, divisor) {\\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\\n      return Math.pow(2, 31) - 1;\\n    }\\n    if (divisor === 1) {\\n      return dividend;\\n    }\\n    let isNegative = false;\\n    if (dividend < 0 && divisor > 0 || (dividend > 0 && divisor < 0)) {\\n      isNegative = true;\\n    }\\n    let newDividend = Math.abs(dividend);\\n    const newDivisor = Math.abs(divisor);\\n    let result = 0;\\n    while(newDividend >= newDivisor) {\\n      newDividend = newDividend - newDivisor;\\n      result++;\\n    }\\n    return isNegative ? -result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385840,
                "title": "c-0ms-without-using-long-math-h-covert-both-to-negative-to-avoid-coding-for-different-cases",
                "content": "My idea is coverting both dividend and divisor to be negative, to make the code shorter. Here is my code:\\n```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint divide(int dividend, int divisor) {\\n        // I will change both dividend and divisor to be negative\\n        \\n        bool sign = true; // true -> result positive; false -> result negative;\\n        if (dividend > 0) {\\n            sign = !sign;\\n            dividend = -dividend;\\n        }\\n        if (divisor > 0){\\n            sign = !sign;\\n            divisor = -divisor;\\n        }\\n        \\n        // now dividend and divisor are both smaller than or equal to 0\\n        int res = 0;\\n        while (dividend <= divisor){\\n            int i = 0;\\n            int x = divisor;\\n            // This while loop finds i \\n            // such that  2^(i+1) * divisor < dividend <= 2^i * divisor\\n            while (true) {\\n                if (x < - (1<<30)) break; // keep x + x in integer range\\n                if (dividend > x + x) break;\\n                x = x + x;\\n                i++;\\n            }\\n            res += 1<<i;\\n            dividend -= x;\\n        }\\n        // res should be larger than 0\\n        // If res == INT_MIN && sign, \\n        // it indicates the result is -INT_MIN, which overflows;\\n        if (res == INT_MIN) return sign?INT_MAX:INT_MIN;\\n        return sign? res:-res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165649,
                "title": "another-clear-python-code-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend, divisor):\\n        \"\"\"\\n        :type dividend: int\\n        :type divisor: int\\n        :rtype: int\\n        \"\"\"\\n        sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\\n        \\n        dividend = abs(dividend)\\n        divisor =  abs(divisor)\\n        \\n        if dividend == 0:\\n            return 0 \\n        else:\\n            ans = sign * math.exp(math.log(dividend) - math.log(divisor))\\n            if ans > 0:\\n        \\t    return min(max(-2147483648, math.floor(ans)), 2147483647)\\n            else:\\n                return math.ceil(ans)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n        ",
                "codeTag": "Java"
            },
            {
                "id": 161358,
                "title": "concise-java-solution-without-using-long",
                "content": "To avoid using long, the key point is to represent both dividend and divisor as negative integer, and check the corner case that will cause overflow at the beginning.\\n\\nThen use a while loop and addition to calculate the quotients.\\n\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\\n**UPDATE**\\nThanks to @yuhangjiang for pointing out the use of * at the return statement. Please see the updated version, to completely avoid using *, I used bit operations instead to get the negative result.\\n\\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n        int flag = 1;\\n        if((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))\\n            flag = -1;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        int result = 0;\\n        while(dividend <= divisor){\\n            int count = 1, tempDivisor = divisor;\\n            while(dividend - tempDivisor <= tempDivisor){\\n                count <<= 1;\\n                tempDivisor <<= 1;\\n            }\\n            result += count;\\n            dividend -= tempDivisor;\\n        }\\n        return flag * result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n        boolean neg = dividend > 0 && divisor < 0 || dividend < 0 && divisor > 0;\\n        if(dividend > 0)\\n            dividend = -dividend;\\n        if(divisor > 0)\\n            divisor = -divisor;\\n        int res = 0;\\n        while(divisor >= dividend){\\n            int count = 1;\\n            int newDivisor = divisor;\\n            while(newDivisor >= dividend - newDivisor){\\n                newDivisor <<= 1;\\n                count <<= 1;\\n            }\\n            dividend -= newDivisor;\\n            res += count;\\n        }\\n        if(neg)\\n            res = ~res + 1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13543,
                "title": "a-concise-java-solution",
                "content": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "solutionTags": [],
                "code": "        public int divide(int dividend, int divisor) {\\n            if (dividend == Integer.MIN_VALUE && divisor == -1)\\n                return Integer.MAX_VALUE;\\n    \\n            long divd = Math.abs((long)dividend);\\n            long divs = Math.abs((long)divisor);\\n    \\n            int ret = 0;\\n            while (divd >= divs) {\\n                int counter = 0;\\n                while (divd >= (divs << counter)) { // keep multiply by 2 until divs > divd\\n                    counter++;\\n                }\\n                counter--;  // rollback counter so that (divs<<counter) <= divd\\n                ret += 1 << counter;  // quotient\\n                divd -= divs << counter;\\n            }\\n    \\n            if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\\n                return ret;\\n            else\\n                return -ret;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13634,
                "title": "my-fast-solution-using-bit-operation-36ms",
                "content": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "solutionTags": [],
                "code": "As for any integer can be writen by 2n+1 or 2n. Think about 123/5:\\n\\ndivisor        dividend\\n\\n5                     123\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   <<1\\n\\n   5*16 = 80\\n\\n5                    123-80=43\\n\\n  <<1\\n\\n  <<1\\n\\n  <<1\\n\\n5*8 = 40\\n\\n5                     43-40=3\\n\\n5<3, thus result = 16+8 = 24\\n\\n(if dividend == 125, finally we have:)\\n\\n5==5, thus result = 16+8+1 = 25;\\n\\n\\nHowever, I play a little trick by using long long .. o_____O\\n\\n--------------------------------------------------------------------------------------------\\n\\n    int divide(long long a, long long b) {\\n        if(b==0) return a>=0?0x7fffffff:0x80000000;\\n        if(a==0) return 0;\\n        if(b==1) return a;\\n        int sgn = (a^b) & 0x80000000; //0 -> +,  0x80000000 -> -\\n        if(a<0) a=-a;\\n        if(b<0) b=-b;\\n        //a,b>0\\n        if(a<b) return 0;\\n        int res = 0, _b = b, twon;\\n        while(a>b)\\n        {\\n            twon = 1;\\n            while(a>b)\\n            {\\n                //cout <<b<<' '<<a<<' '<<twon<<endl;\\n                b<<=1;\\n                twon<<=1;\\n                //getchar();\\n            }\\n            b>>=1;\\n            twon>>=1;\\n            a -= b;\\n            b = _b;\\n            res += twon;\\n        }\\n        if(a==b) res++;\\n        if(sgn) \\n            return -res;\\n        else return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 13608,
                "title": "after-5-tle-finally-got-ac-and-i-cant-figure-out-the-complexity",
                "content": "**(Given that English not my mother tongue, please forgive my mistake about my words below)**\\n\\nHere coming my code without / * % operator:\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}\\n    \\t\\tif (dividend > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdividend = -dividend;\\n    \\t\\t}\\n    \\n    \\t\\tunsigned int acc = divisor, tmp = 0;\\n    \\t\\tint counter = 0, ans = 0;;\\n    \\t\\twhile (dividend <= divisor){\\n    \\t\\t\\tacc = divisor; tmp = 0, counter=0;\\n    \\t\\t\\twhile (acc >= dividend){\\n    \\t\\t\\t\\ttmp = acc;\\n    \\t\\t\\t\\tacc += acc;\\n    \\t\\t\\t\\tcounter++;\\n    \\t\\t\\t}\\n    \\t\\t\\tans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1)\\n    \\t\\t\\tdividend -= tmp;\\n    \\t\\t}\\n    \\t\\treturn flag*ans;\\n    \\t}\\n    };\\n\\nFirstly, let me give you some hints with the input:\\n\\nI.have you ever thought that dividend or divisor maybe negative or both;\\n\\nII.have you ever thought about this input{2^32-1, 1};\\n\\nIII.have you ever thought that there existing -2^32 meanwhile the largest int is 2^32-1;\\n\\n**Now is my thoughts:**\\n\\nConsidering the III hints I gave above, I played a trick that making dividend and divisor both negative, and using a flag judging the sign symbol of answer. **(ooops, i use * operator in the end of my code, but never mind, it's nothing to do with my algorithm)**\\n\\n1 I double the acc (initialize  acc=divisor) if acc <= dividend. Like 1, 2, 4, 8, 16...etc; Count the times I double the acc, storage in variable counter \\n\\n2.If acc >dividend, then dividend = dividend-acc/2;(can use / operator, i used extra variable tmp to storage the acc/2 ) . \\n\\n3. calculate how many time I double the  divisor: ans += (counter > 0) ? 1 << (counter - 1) : 0;// 1*pow(2, counter-1), **Then**, dividend-=tmp;\\n\\n4. Loop 1-3  while divisor<dividend**(remember I make them both negative)**\\n\\n \\n**The complexity** when the **worst** situation dividend = 2^32 -1 and divisor = 1;\\n\\ncomplexity = (lg dividend) + (lg dividend/2) + (lg dividend/4) + (lg dividend/8) + ...=(lg dividend)^2\\n\\nI don't know if there any problems in my proof.\\n\\n\\n**FOOL I AM, I CAN USE BINARY OPERATOR**\\n\\n        class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tlong long a = abs((long long)dividend);\\n    \\t\\tlong long b = abs((long long)divisor);\\n    \\t\\tint ans = 0, i = 0;\\n    \\t\\twhile (a > b){\\n    \\t\\t\\ti++;\\n    \\t\\t\\tb = b << 1;\\n    \\t\\t}\\n    \\t\\twhile (i >= 0){\\n    \\t\\t\\tif (a >= b){\\n    \\t\\t\\t\\ta -= b;\\n    \\t\\t\\t\\tans += (1 << i);\\n    \\t\\t\\t}\\n    \\t\\t\\tb = b >> 1;\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\n    \\t\\treturn (((dividend >> 31)==(divisor >> 31))) ? ans : -ans\\n    \\t}\\n    };\\n\\n \\n**It's more simple somehow**",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint divide(int dividend, int divisor) {\\n    \\t\\tint flag = 1;\\n    \\t\\tif (divisor > 0){\\n    \\t\\t\\tflag = -flag;\\n    \\t\\t\\tdivisor = -divisor;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3654349,
                "title": "bits-of-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        sign = -1 if (dividend >= 0 and divisor < 0) or (dividend < 0 and divisor >= 0) else 1\\n        dividend = abs(dividend)\\n        divisor = abs(divisor)\\n        result = len(range(0, dividend-divisor+1, divisor))\\n        if sign == -1:\\n            result = -result\\n        minus_limit = -(2**31)\\n        plus_limit = (2**31 - 1)\\n        result = min(max(result, minus_limit), plus_limit)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529137,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long ans;\\n    public int divide(int dividend, int divisor) {\\n        ans=(long)dividend/(long)divisor;\\n        if(ans > (long)Math.pow(2,31)-1) ans = (long)Math.pow(2,31)-1;\\n        if(ans < (-1)*(long)Math.pow(2,31)) ans = (long)Math.pow(-2,31);\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268612,
                "title": "easy-c-solution-beat-100-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long int s=1,e=abs(dividend),mid=0,ans=0;\\n        if (divisor == 0 || (dividend == INT_MIN && divisor == -1)) {\\n            return INT_MAX;\\n        }\\n          if (divisor == 0 || (dividend == INT_MIN && divisor == 1)) \\n            return INT_MIN;\\n        \\n        while(s<=e){\\n            mid=s+(e-s)/2;\\n            if(abs(divisor*mid)==abs(dividend))\\n            {\\n                ans=mid;\\n                break;\\n            }\\n            else if(abs(divisor*mid)>abs(dividend))\\n            e=mid-1;\\n            else\\n            {\\n                ans=mid;\\n                s=mid+1;\\n            }\\n        }\\n        if((divisor>0&&dividend>0)||(divisor<0&&dividend<0))\\n        return ans;\\n        else\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033336,
                "title": "100-bit-manipulation-simple-explanation-no-long-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas we cant use multiplication & division and modulo operators , first thing that comes to mind is to maintain a variable quotient and substract divisor from dividend till it is greater or equal to it.\\nthis will take a lot of time but it is a accepted solution\\ncan we do it in better Time complexity ? \\'yes\\'\\nrather substracting the divisor linearly we can do it exponentially that is using left shift operator(1<<1 == 2 left is used to multiply any number by 2 in binary);\\nit is nothing but rather substracting 3 , 6 , 9 , 12 .... we gonna substract 3 , 6 , 12 , 24 , 48 ......\\n**hope you like the intution give a \\uD83D\\uDC4D to improve my profile**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain a variable `quotient`.\\n- extract the resultant sign and typecast to `long` to avoid overflows.\\n- while `dividend is >= divisor` left shift the divisor till it is smaller than dividend.maintain number of leftshifts.\\n- substract dividend with the `divisor<<shift-1` as we shifted one extra bit. add number `1<<shifts-1` to quotient(number of times divisor is multiplied).\\n- return corresponding values for signs\\n# Complexity\\n- Time complexity:$$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\\n> we can store one bigger value in negetive numbers than positive numbers so this is an asset here to avoid using long, as question clearly says the environment can only store 32 bit integers.\\n- rather performing division of positive values we can do it with negative values and even quotient also can be integer.\\n\\n**Note : while rightshifting the divisor check for overflow.**\\n### updated code:\\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        long quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        long dd = (long)dividend , dv = (long)divisor;\\n        dd = Math.abs(dd);dv = Math.abs(dv);\\n        while(dd >= dv){\\n            int shift = 0;\\n            while(dd >= (dv<<shift))shift++;\\n            quotient += (long)1l<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dd -= dv<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient > max)return max;\\n            return (int)quotient;\\n        }else{\\n            if((~quotient)+1 < min)return min; // ~quotient+1 = -quotient\\n            return (int)(~quotient)+1;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        // System.out.println(-2147483648<<3);\\n        // System.out.println(Integer.toBinaryString(-1<<0));\\n        int quotient = 0;\\n        int sign = 1;\\n        int max = Integer.MAX_VALUE,  min = Integer.MIN_VALUE;\\n        if(dividend < 0 && divisor > 0 || dividend > 0 && divisor < 0)sign = -1;\\n        if(dividend > 0)dividend = -dividend;\\n        if(divisor > 0)divisor = -divisor;\\n        while(dividend <= divisor){\\n            int shift = 1;\\n            while((divisor<<shift) < divisor && dividend <= (divisor<<shift))shift++;\\n            quotient -= 1<<(shift-1);\\n            // System.out.println(quotient+\"-\"+shift);\\n            dividend -= divisor<<(shift-1);\\n        }\\n        if(sign == 1){\\n            if(quotient == min)return max;\\n            return -quotient;\\n        }else{\\n            return quotient;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644837,
                "title": "easy-c-solution-faster-than-100-00-of-c-online-submissions",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*Please Upvote If You Find It Helpful.*\\n\\n\\t int divide(int dividend, int divisor) {\\n\\t\\t\\tif(divisor==-1 && dividend == INT_MIN)\\n\\t\\t\\t\\treturn INT_MAX;\\n\\t\\t\\tbool sign = (dividend>=0) == (divisor>=0) ? true : false;\\n\\t\\t\\tlong int did = abs(dividend);\\n\\t\\t\\tlong int div = abs(divisor);\\n\\t\\t\\tlong int result=0;\\n\\t\\t\\t// int count=0, temp=divisor;\\n\\t\\t\\twhile(did - div >= 0){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile((did - (div<<1<<count))>=0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tresult += 1<<count;\\n\\t\\t\\t\\tdid -= div<<count;\\n\\t\\t\\t}\\n\\t\\t\\treturn sign ? result : -result;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2350079,
                "title": "java-solution",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t//edge case ( we cant have quotient 2^31 ) since -2^31 / -1 gives 2^31 ( overflow case)  \\n        if (Integer.MIN_VALUE == dividend && divisor == -1) {\\n            return Integer.MAX_VALUE;\\n        }\\n\\t\\t\\n        int a = Math.abs(dividend);\\n        int b = Math.abs(divisor);\\n        int quo = 0;\\n        while (a - b >= 0) {\\n            int x = 0;\\n            while (a - ((b << 1) << x) >= 0) {\\n                x++;\\n            }\\n            quo += 1 << x;\\n            a -= b << x;\\n        }\\n\\t\\t\\n\\t\\t//both +ve or both -ve (dividend  and divisor) should return quo as it is else with a -ve sign\\n          if ((dividend >= 0) == (divisor >= 0)) {\\n            return quo;\\n        } else {\\n            return -1 * quo;\\n        }\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2091391,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```\\nDo consider upvoting if found useful :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if(a == INT_MIN and b == -1) return INT_MAX;\\n        long num = labs(a), div = labs(b), ans = 0;\\n        long temp = div, m=1;\\n        int sign = a > 0 ^ b > 0 ? -1 : 1;\\n\\n        while(num >= div){\\n            if(temp <= num){\\n                temp <<= 1;\\n                m <<= 1;\\n            }\\n            else{\\n                ans += m >> 1;\\n                num -= temp >> 1;\\n                temp = div;\\n                m = 1;\\n            }\\n        }\\n        \\n        return sign*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090270,
                "title": "easy-to-understand-c-beats-100",
                "content": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "**Pls upvote the thread if you found it helpful.**\\n\\t\\t\\n\\tint divide(int dividend, int divisor) {\\n\\t\\t\\t//Edge cases\\n\\t\\t\\tif(dividend == INT_MIN && divisor == -1) return INT_MAX;\\n\\t\\t\\tif(dividend == INT_MIN && divisor == 1) return INT_MIN;\\n\\n\\t\\t\\t//Absolute\\n\\t\\t\\tlong int dd = abs(dividend), dv = abs(divisor);\\n\\t\\t\\t\\n\\t\\t\\t//Result\\n\\t\\t\\tint res =0;\\n\\t\\t\\twhile(dv<=dd){\\n\\t\\t\\t\\tlong int mul=dv,temp=1;\\n\\t\\t\\t\\twhile(mul<=dd-mul){\\n\\t\\t\\t\\t\\tmul+=mul;\\n\\t\\t\\t\\t\\ttemp+=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\tres+=temp;\\n\\t\\t\\tdd-=mul;\\n\\t\\t}\\n\\t\\t\\t//If dividend or divisor < 0 res will be -ve\\n\\t\\t\\t if((dividend<0&&divisor>0) || (dividend>0&&divisor<0)) return -res;\\n\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2089466,
                "title": "c-do-binary-removals-explainations",
                "content": "Dividing b/a means number of times we can remove a from b \\nb - a -a - a- a- a ............k time\\nb - k*a\\n\\nInstead of removing a one by one , we can remove it in groups. How?\\nany number k , can be written in the form of 2\\'s powers. So the algorithm will be:\\nWe solve the problem for positive dividend and divisior only and then decide the sign\\n1. Iterate from i=31 to 0, and try to remove the biggestpower * divisor\\n2. If it is removable, add it to the quotient and remove from dividend . Here adding and | is same as adding 2\\'s powers will give same ans as using or operator in binary\\n3. Use long long as during multiplication the values may overflow\\n4. In the end check the limits specified by the question.\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int x, int y) {\\n        int sign = ((x<0)^(y<0))?-1:+1;\\n        long long dividend = x, divisor=y,q=0;\\n        dividend=abs(dividend), divisor = abs(divisor);\\n        for(int i=31;i>=0;i--){\\n            if((divisor<<i) > dividend) continue;  \\n            q |= (1LL<<i);\\n            dividend -=  (divisor<<i);\\n        }\\n        q*=sign;\\n        if(q<0 and q<INT_MIN) q=INT_MIN;\\n        if(q>0 and q>INT_MAX) q=INT_MAX;\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089279,
                "title": "python-solution",
                "content": "*I am a bit unsure about the complexity of my solution but I think it is O(n) with n being the length of dividend,\\nplease feel free to confirm.\\nPython is not my main language, there\\'s probably some part of my code that you could write in a more elegant\\nand more readable way, same here, feel free to let me know.*\\n\\n**Full solution:**\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\n**Step by step:**\\n* First handling the sign of the result and getting rid of `-` signs for simplicity (**EDIT** : **USE OF MULTIPLICATION**, see next ):\\n\\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\\n**EDIT** Thanks to @mihir_jr comment, finding absolute value without multiplication:\\n\\t\\t\\t\\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\\n\\n* This part is optional, just handling simple `-1 / 1` divisor case:\\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\\n\\n* All our result will for through this function before being returned, to handle `-2^31 / 2^31 - 1` result cases:\\n\\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\\n\\n* This is the main part of the solution: \\n\\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\\n\\nWe determine the maximum number of zeros our quotient can have.\\nWe return this quotient to be added to the result and the `divisor` concatenated to the computed number of zeros which we will substract to dividend for the next loop round.\\n\\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n\\t\\tsign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        if dividend < 0 :\\n            dividend = dividend - dividend - dividend\\n        if divisor < 0:\\n            divisor = divisor - divisor - divisor\\n            \\n        if divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n       \\n        result = 0\\n        while dividend >= divisor:\\n            toSubstract, quotient = self.computeIteration(dividend, divisor)\\n            dividend -= toSubstract\\n            result += quotient\\n\\n        \\n        return self.handleResult(sign * result)\\n    \\n    def handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n    \\n    def computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\n\\t\\tsign = 1\\n        if dividend < 0 :\\n            sign *= -1\\n            dividend *= -1\\n        if divisor < 0 :\\n            sign *= -1\\n            divisor *= -1\\n```\n```\\nsign = 1\\nif (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n\\tsign = -1\\nif dividend < 0 :\\n\\tdividend = dividend - dividend - dividend\\nif divisor < 0:\\n\\tdivisor = divisor - divisor - divisor\\n```\n```\\nif divisor == 1 :\\n            return self.handleResult(sign * dividend)\\n```\n```\\ndef handleResult(self, result):\\n        if result < pow(-2, 31):\\n            return pow(-2, 31)\\n        if result > pow(2, 31) - 1:\\n            return pow(2, 31) - 1\\n        return result\\n```\n```\\ndef computeIteration(self, dividend, divisor):\\n        dividendStr = str(dividend)\\n        divisorStr = str(divisor)\\n        numberOfZeros = len(dividendStr) - len(divisorStr)\\n        if int(dividendStr[0:len(divisorStr)]) < divisor:\\n            numberOfZeros -= 1\\n        return int(divisorStr + \\'0\\' * numberOfZeros), int(\\'1\\' + \\'0\\' * numberOfZeros)\\n```\n```\\nresult = 0\\nwhile dividend >= divisor:\\n\\ttoSubstract, quotient = self.computeIteration(dividend, divisor)\\n\\tdividend -= toSubstract\\n\\tresult += quotient\\n\\nreturn self.handleResult(sign * result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957404,
                "title": "java-100-faster-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == 1<<31 && divisor == -1){\\n            return Integer.MAX_VALUE;\\n        }\\n        boolean sign = (dividend >= 0) == (divisor >= 0) ? true : false;\\n        \\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        \\n        int result = 0;\\n        while(dividend - divisor >= 0){\\n            int count = 0;\\n            while(dividend - (divisor << 1 << count) >= 0){\\n                count++;\\n            }\\n            result += 1 <<count;\\n            dividend -= divisor << count;\\n        }\\n        return sign ? result : -result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888339,
                "title": "cpp-0ms-100",
                "content": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "solutionTags": [],
                "code": "```\\n/*\\n    childhood method:\\n     3) 10 (2\\n         6\\n    _________\\n       3)4(\\n         3\\n    __________\\n       3)1(\\n       \\n      same here too \\n      first we will remove maximum 2 multiple of divisor\\n      example: 10 3\\n      3 6 12 24  ---doubling each time\\n      so we can subtract 6 from 10 so we remainded with 10-6=>4  add 2 to result\\n      3 6 ..  \\n      so we can subtract 3 from 4 so remainded with 4-3=>1 add 1 to result\\n      \\n      2<<1 ==>4\\n      if we left shift 1 bit it indicates we are multiplying num by\\'2\\'\\n      \\n     \\n      \\n    */\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)return INT_MAX;\\n        bool sign= ((dividend>=0)==(divisor>=0))?true:false;\\n        long int res=0;\\n        long int ldividend=abs(dividend);\\n        long int ldivisor=abs(divisor);\\n        while((ldividend-ldivisor)>=0){\\n            int cnt=0;\\n            while(ldividend>=(ldivisor<<cnt))cnt++;\\n            res+=(1<<(cnt-1));\\n            ldividend-=ldivisor<<(cnt-1);\\n        }\\n        if(res>INT_MAX) return (sign)?INT_MAX:INT_MIN;\\n        return (sign)?res:-res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846693,
                "title": "c-0ms-solution-that-follows-all-constraints-explained",
                "content": "Constraints:\\n- \"Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1].\" This means **no long long or unsigned int**.\\n- \"If the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\"\\n- No multiplication, division, or mod operator.\\n\\n```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\\n\\t\\nThe general idea is similar to many others. We change both the dividend and divisor to positive and then add in the negative sign at the end if needed. But firstly, we have a few edge cases:\\n- If dividend = int_min and divisor = -1, then the actual result of the divison would be -int_min, oer +2147483648. But this overflows int_max, so we just return int_max in this case.\\n- If dividend = int_min and divisor = int_min, then return 1.\\n- Even if the above two cases do not happen, we still need to modify dividend. The reason is if dividend = int_min, then abs(dividend) would overflow int_max, so we can\\'t allow this to happen. I take care of this by simply subtracting or adding one divisor from dividend, based on the sign of divisor. If you don\\'t understand this, consider the following logic: The quotient when 10000 is divided by 3 is also equal to 1 + the quotient of 9997 / 3. We basically remove one instance of divisor from the dividend so that abs(dividend) no longer overflows. \\n- If none of the above happens (basically, if dividend != int_min), but divisor is int_min, then obviously the correct quotient is `0`.\\n\\nWithout multiplication, division, or modulo operators, the only way we can do this is through **bit shift operators**. But more specifically, this program mainly relies on the **binary right shift (>>)** operator, because this helps us avoid overflow. This loop is the main part of the program:\\n\\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\\n\\nWhat happens here is the following.\\n- Loop from the most significant bit to the least significant bit in a 32-bit number. For each bit, we determine if the final quotient (result) should have this bit set or not. How do we decide this for each position i? Just do the following:\\n- Let ```shifted_dividend = (dividend >> i)```, which is the quotient of dividend / 2^i. Basically this is just how many times 2^i can go into dividend. Now, obviously, if 2^i can go into dividend at least ```divisor``` times, then we know that ```divisor * 2^i <= dividend```, which means that we should add 2^i to the quotient, and subtract ```divisor * 2^i``` from ```dividend```!\\n- Notice how ```(dividend >> i)``` never overflows, since it must result in a number smaller than ```dividend```. Also, it never becomes negative; if `i` too large, then ```(dividend >> i)``` would just equal `0`. This fits up with the conceptual definition that this is the number of times 2^i can go into ```dividend```.\\n- Obviously, we return ```result```, and make sure to take care of whether it\\'s negative or positive.\\n\\n**Note about C++ Undefined Behavior:** Right-shifting a negative signed integer is undefined behavior, but right-shifting a positive signed integer isn\\'t. cppreference.com says that \"For unsigned a and for signed and non-negative a, the value of a >> b is the integer part of a/2^b.\" This is one of the main reasons why we choose to change both numbers to positive before finding the quotient (and only adding the negative sign at the very end).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int int_min = -2147483648, int_max = 2147483647;\\n    \\n    int divide(int dividend, int divisor) {\\n        \\n        // edge cases (dividend or divisor is int_min)\\n        if(dividend == int_min) {\\n            if(divisor == -1) {return int_max;}\\n            else if(divisor == int_min) {return 1;}\\n            else if(divisor < 0) {\\n                // do this so we can avoid abs(dividend) overflowing the upper int limit\\n                return 1 + divide(dividend - divisor, divisor);\\n            }\\n            else {\\n                // same as above comment\\n                return -1 + divide(dividend + divisor, divisor);\\n            }\\n        }\\n        else if(divisor == int_min) {return 0;}\\n        \\n        // take care of negative later\\n        bool neg = (dividend < 0) ^ (divisor < 0); // final answer is negative if either dividend or divisor is negative\\n        dividend = abs(dividend); divisor = abs(divisor); // change both to positive\\n        \\n        int result = 0;\\n        for(int i = 31; i >= 0; --i) {\\n            int shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n            if(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n                result += (1 << i);\\n                dividend -= (divisor << i);\\n            }\\n        }\\n        \\n        return (neg ? -result : result);\\n    }\\n```\n```\\nint result = 0;\\nfor(int i = 31; i >= 0; --i) {\\n\\tint shifted_dividend = (dividend >> i); // = floor(dividend / 2^i)\\n\\tif(shifted_dividend >= divisor) { // then divisor * 2^i <= dividend\\n\\t\\tresult += (1 << i);\\n\\t\\tdividend -= (divisor << i);\\n\\t}\\n}\\n```\n```shifted_dividend = (dividend >> i)```\n```divisor```\n```divisor * 2^i <= dividend```\n```divisor * 2^i```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```(dividend >> i)```\n```dividend```\n```result```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826773,
                "title": "my-o-1-solution-in-c",
                "content": "It\\'s been 15 years since I wrote C, please a gentle...\\n\\nHere\\'s my implementation based on the long division algorithm everyone learned in grade school.  It uses only 32 bit types and no multiplication or division, including in the standard library.\\n\\nThe solution is O(1) for 32 bit types, because it always loops exactly 32 times, one for each significant bit.  There\\'s probably opportunities to use bitwise math to speed up the loop body, and the loop itself could be unrolled.\\n\\n```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Glibc\\'s implementation of abs uses multiplication for negative numbers and is undefined for\\n// INT_MIN as per the standard, because the return type is also a signed integer.\\ninline uint32_t uabs(int i)\\n{\\n    return i < 0 ? ~(uint32_t) i + 1 : i;\\n}\\n\\nint divide(int dividend, int divisor) {\\n    // Get rid of signs because bitwise math is easier with positive numbers\\n    uint32_t remainder = uabs(dividend);\\n    uint32_t positiveDivisor = uabs(divisor);\\n    \\n    // Long division algorithm everyone learned in grade school, except in binary instead of decimal\\n    uint32_t result = 0;\\n    for (int i = 31; i >= 0; --i) {\\n        uint32_t curDividend = remainder >> i;\\n        if (curDividend >= positiveDivisor) {\\n            result += 1u << i;\\n            remainder -= positiveDivisor << i;\\n        }\\n    }\\n    \\n    // Reintroduce the sign as appropriate\\n    if ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) {\\n        return result >= (uint32_t) INT_MAX ? INT_MAX : (int) result;\\n    }\\n    else {\\n        // Invert bits and add one instead of multiplying by -1\\n        return result > (uint32_t) INT_MAX ? INT_MIN : ((int) ~result) + 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696904,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == Integer.MIN_VALUE && divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = dividend>0 ^ divisor>0 ? true : false;\\n        int q = 0;\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n        while(dividend - divisor >= 0) {\\n            int temp = divisor;\\n            int c=0;\\n            while (dividend - temp >= 0) {\\n                temp = temp << 1;\\n                c++;\\n            }\\n            temp = divisor;\\n            dividend = dividend - (temp << c-1);\\n            q += 1 << c-1;\\n        }\\n\\n        if(sign) return -q;\\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691917,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        long long ans = 0;\\n        bool cneg = false;\\n        if((dividend<0 && divisor>0) || (dividend>0 && divisor<0)){\\n            cneg = true;\\n        }\\n        long long divid = abs(dividend);\\n        long long divis = abs(divisor);\\n        if((dividend == INT_MAX && divisor==1) ||(dividend == INT_MIN && divisor==-1)){\\n            return INT_MAX;\\n        }\\n        if((dividend == INT_MIN && divisor == 1) || (dividend == INT_MAX && divisor==-1)){\\n            return INT_MIN;\\n        }\\n        int count = 1;\\n        if(divid-divis<0){\\n            return 0;\\n        }\\n        divid-=divis;\\n        ans = 1;\\n        while(divid-divis >= 0){\\n            divid-=divis;\\n            divis = divis<<1;\\n            ans+=count;\\n            count = count<<1;\\n        }\\n        divisor = abs(divisor);\\n        while(divid-divisor>=0){\\n            ans++;\\n            divid-=divisor;\\n            \\n        }\\n        return cneg ? (-1*ans) : ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560454,
                "title": "python-easy-solution-faster-than-98",
                "content": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef divide(self, dividend: int, divisor: int) -> int:\\n\\t\\t\\tif dividend == 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tsign = 1 if ((dividend < 0) ^ (divisor < 0)) else 0\\n\\t\\t\\tdividend = abs(dividend)\\n\\t\\t\\tdivisor = abs(divisor)\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile dividend >= divisor:\\n\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\twhile dividend >= divisor << (k+1):\\n\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\tdividend -= (divisor << k)\\n\\t\\t\\t\\tres += 1 << k\\n\\t\\t\\tMAX_INT = (1 << 31)-1\\n\\t\\t\\treturn -res if sign else (res if res <= MAX_INT else MAX_INT)",
                "codeTag": "Java"
            },
            {
                "id": 1548253,
                "title": "python-24ms-98-38-without-bit-manipulation",
                "content": "The code is currently patchy for integer boundaries. Its on my todos.\\n\\nThe idea is to greedily increase divisor till we can\\'t.\\n\\nIf we have 14 / 2. (2 is the divisor, 14 is the dividend)\\n1. then we can increase 2 to 4 then to 8. Store the number of steps of the currend divisor 8. (4 steps)\\n2. Now reduce the dividend 14-8 = 6 and start divisor from 2 again. 2 then 4 (2 steps).\\n3. Reduce again ... 6-4=2. (1 step) since divisor == dividend.\\n\\nTotal number of steps = 7 which matches with integer divide of 14//2\\n\\nNumber of steps explanation\\nIf we have 8 .. then number of steps is 4 since .. \\nnumber of steps to reach 4 is 2 steps from 2. \\n\\nOriginal submisson:\\nhttps://leetcode.com/problems/divide-two-integers/submissions/\\n\\nLess code version:\\n\\n```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:        \\n                        \\n        sign = False\\n        if dividend < 0 and divisor > 0:\\n            sign = True\\n        if dividend > 0 and divisor < 0:\\n            sign = True        \\n                \\n        dividend = abs(dividend)\\n        divisor = abs(divisor) # original divisor\\n        \\n        # INT MIN PART IS PATCHY ... \\n        if dividend > 2147483647 and not sign:\\n            dividend = 2147483647\\n        if divisor > 2147483647 and not sign:\\n            divisor = 2147483647        \\n                \\n        if divisor > dividend:\\n            return 0\\n        \\n        cdivisor = divisor # current divisor\\n        count = 0\\n        prevCount = 0                \\n             \\n        count = 1        \\n        while dividend >= divisor:\\n            # if dividend is 14 .. and we get o 8+8= 16 .. deduct 14 - 8 = 6            \\n            if cdivisor + cdivisor > dividend:                \\n                dividend = dividend - cdivisor\\n                prevCount = prevCount + count\\n                \\n                # test case: 2 2\\n                if dividend >= divisor:\\n                    cdivisor = divisor\\n                    count = 1\\n                else:\\n                    count = 0\\n            else:                                                    \\n                cdivisor =  cdivisor + cdivisor\\n                count = count + count                                                     \\n                \\n        if sign:\\n            return - count - prevCount\\n        return count + prevCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532163,
                "title": "wrong-testcase",
                "content": "-2147483648\\n-1\\n\\nwith the expected result\\n2147483647\\n\\nWas forced to do some dirty hacks. Seems that the testcases are generated by running the written  code.\\n```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::uint64_t divideImpl(std::uint64_t dividend, std::uint64_t divisor, std::uint64_t origin, std::uint64_t count){\\n       auto tmp_count = count; \\n       if((divisor+divisor) > dividend) {\\n           divisor = origin;\\n           tmp_count = 1;\\n       }\\n        \\n       if(dividend < divisor) return 0;\\n       return tmp_count+divideImpl(dividend - divisor, divisor+divisor, origin, tmp_count+tmp_count);\\n    }\\n    \\n    int divide(std::int64_t dividend, std::int64_t divisor) {\\n       int sign = 1;\\n       if(dividend < 0) {\\n           sign = -sign;\\n           dividend = -dividend;\\n       }\\n       if(divisor < 0) {\\n           sign = -sign;\\n           divisor = -divisor;\\n       }\\n        \\n       auto result = divideImpl(dividend, divisor, divisor, 1);\\n       return (sign > 0)? std::min<std::uint64_t>(result, 2147483647u): -result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450328,
                "title": "python3-python-solution-w-comments",
                "content": "**WHY on the earth you need not to use divison, muliplication and mode operator?**\\n*This problem is just waste of time*\\n```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        # -2147483648 through 2147483647\\n        MIN_VAL = -2147483648\\n        MAX_VAL = 2147483647\\n        \\n        # If divisor is 1 or -1\\n        if abs(divisor) == 1:\\n            if dividend == MIN_VAL and divisor == -1:\\n                return MAX_VAL\\n            else:\\n                return dividend if divisor > 0 else -dividend\\n            \\n        # Get if the answer will be negative or positive\\n        sign = -1 if (dividend < 0 and divisor > 0) or (divisor < 0 and dividend > 0) else 1\\n        res = 0 # result\\n        shift = 31 # At max 31 left shift can be done on a integer value \\n        dividend = abs(dividend) # always take absolute value\\n        divisor = abs(divisor) # always take absolute value\\n        \\n        # While dividend is greater than divisor\\n        while dividend >= divisor:\\n            \\n            # Check how many shifts require of divisor\\n            # to reach dividend in whole\\n            while dividend < (divisor << shift):\\n                shift -= 1\\n            \\n            # subtract the left shifted divisor from dividend\\n            # and do the same process for the remaining value\\n            dividend = dividend - (divisor<<shift)\\n            \\n            # Answer will be how many total left shifted value of 1\\n            res = res + (1<<shift)\\n\\n        # return result within range and with proper sign\\n        res = min(MAX_VAL, max(MIN_VAL, res))\\n        \\n        # return\\n        return  res if sign > 0 else -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401070,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n\\t\\t// checking for overflow\\n        if(dividend == 1<<31 && divisor == -1) return Integer.MAX_VALUE;\\n\\t\\t\\n\\t\\t// deciding the sign of the quotient\\n        boolean sign = (dividend>=0) == (divisor >=0) ? true : false;\\n\\t\\t\\n\\t\\t//using absolute values for the answer\\n        dividend = Math.abs(dividend);\\n        divisor = Math.abs(divisor);\\n\\t\\t\\n\\t\\t// our answer\\n        int result=0; \\n\\t\\t\\n        while(dividend - divisor >= 0 ){\\n\\t\\t // the number of times we need to left shift (or double our divisor)\\n            int count=0;\\n\\t\\t\\t\\n\\t\\t\\t// increment count till we can subtract the doubled divisor form dividend\\n            while(dividend  - (divisor<<1<<count) >= 0 ){\\n                count++; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t // incrementing quotient by the power of 2 by which we multiplied divisor\\n\\t\\t\\t// 2 power x can be written as 1<<x\\n            result += 1 << count;\\n\\t\\t\\t\\n\\t\\t\\t// decrease the dividend by the maximum value we can subtract\\n\\t\\t\\t//which is divisor*(2 power count)\\n            dividend -= divisor << count ; \\n        }\\n\\t\\t // if sign is false it means negative quotient\\n        return sign?result: -result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258780,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int divide(int dividend, int divisor) {\\n        if (divisor == INT_MIN) {\\n            if (dividend == INT_MIN) {\\n                return 1;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        if (dividend == INT_MIN) {\\n            if (divisor == -1) {\\n                return INT_MAX;\\n            } \\n            if (divisor > 0) {\\n                return -1+divide(dividend+divisor, divisor);\\n            } else if (divisor < 0) {\\n                return 1+divide(dividend-divisor, divisor);\\n            }\\n        }\\n        \\n        int sign = 1;\\n        if ((dividend >0 && divisor <0) || (dividend <0 && divisor >0)) {\\n            sign = -1;\\n        }\\n        dividend=abs(dividend);\\n        divisor=abs(divisor);\\n        int remainder = dividend, quotient = 0;\\n        while (remainder >= divisor) {\\n            int shift = 0;\\n            while ((divisor<<shift) <= remainder && (divisor<<shift)>0 ) {\\n                ++shift;\\n            }\\n            --shift;\\n            quotient += (1<<shift);\\n            remainder -= (divisor<<shift);\\n        }\\n        if (sign < 0) quotient = -quotient;\\n        return quotient;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213715,
                "title": "simple-without-bitwise",
                "content": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "solutionTags": [],
                "code": "\\n    public int divide(int dividend, int divisor) {\\n     \\n        if(dividend == 0)  return 0;\\n    \\n        if(dividend == Integer.MIN_VALUE && divisor == -1)  return Integer.MAX_VALUE;\\n          \\n        boolean Negative = true;\\n       \\n        if((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0))\\n           Negative = false;\\n\\n        if(dividend > 0) {\\n            dividend = 0 - dividend;\\n        }\\n        if(divisor > 0) {\\n            divisor = 0 - divisor;\\n        }\\n\\n        int quotient = 0;\\n        while(dividend <= divisor) {\\n            dividend = dividend - divisor;\\n            quotient++;\\n        }\\n        \\n        if(Negative && quotient > 0)    return 0 - quotient;\\n        \\n         else     return quotient;\\n        \\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1087238,
                "title": "java-no-long-no-bitwise-log-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// Can specify the exact half value here as well instead of using the divide symbol\\n\\tint HALF_INT_MIN = Integer.MIN_VALUE/2;\\n\\n    public int divide(int dividend, int divisor) {\\n        \\n\\t\\t// Satisfying the overflow condition as specified in the problem\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) \\n            return Integer.MAX_VALUE;     \\n        \\n\\t\\t// Determining if the output result should be positive or negative;\\n        boolean isResultNegative = (divisor < 0) ^ (dividend < 0);\\n        \\n\\t\\t// Converting dividend and divisor to negative values to satisfy the overflow boundary conditions\\n        dividend = dividend > 0 ? -dividend : dividend;\\n        divisor = divisor > 0 ? -divisor : divisor;        \\n\\n\\t\\t// Defining 2 arrays, one for the powers of 2 that reaches upto the quotient and the other one the doubles of divisor\\n        List<Integer> powersOf2 = new ArrayList<>();\\n        List<Integer> doublesOfDivisor = new ArrayList<>();        \\n        \\n\\t\\t// Populating the 2 arrays\\n\\t\\tint powerOf2 = 1;        \\n        while(dividend <= divisor){\\n            powersOf2.add(powerOf2);\\n            doublesOfDivisor.add(divisor);\\n\\t\\t\\t// This condition check is for overflow condition check\\n            if (divisor < HALF_INT_MIN) \\n                break;                    \\n            powerOf2 += powerOf2;\\n            divisor += divisor;\\n        }\\n        \\n\\t\\t// Now we can iterate through the multiple of divisor list to calculate the quotient -\\n\\t\\t// The quotient of current dividend is the respective power of 2 (number when multiplied with original divisor). \\n\\t\\t// Some part of remainder can again be part of the quotient so we reduce dividend by subtracting it from the corresponding multiple of divisor\\n        int quotient = 0;\\n        for(int i=doublesOfDivisor.size()-1; i >= 0 ;i--){\\n            if(dividend <= doublesOfDivisor.get(i)){\\n                quotient += powersOf2.get(i);\\n                dividend -= doublesOfDivisor.get(i);\\n            }\\n        }\\n        \\n        return isResultNegative ? -quotient : quotient;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084789,
                "title": "ruby-bit-manipulation",
                "content": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bit Manipulation"
                ],
                "code": "```\\n# @param {Integer} dividend\\n# @param {Integer} divisor\\n# @return {Integer}\\ndef divide(dividend, divisor)\\n  sign = (divisor > 0) ^ (dividend > 0) ? -1 : 1\\n\\t\\t\\n  return 2**31-1 if dividend == -2**31 && divisor == -1\\n\\n  dividend = dividend.abs\\n  divisor = divisor.abs\\n  result = 0\\n  \\n  while divisor <= dividend\\n    div = divisor\\n    temp = 1\\n    while (div << 1) <= dividend\\n      temp <<= 1\\n      div <<= 1\\n    end\\n    dividend -= div\\n    result += temp\\n  end\\n  \\n  result*sign \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1020340,
                "title": "shame-on-this-challange",
                "content": "To quote the website exactly, we will solve the following \"challange\":\\n> Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\\n\\n> Return the quotient after dividing dividend by divisor.\\n\\n> The integer division should truncate toward zero, which means losing its fractional part.\\n> For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.\\n\\n> Note:\\n>  Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [-2^31,  2^31 \\u2212 1].\\n>  For this problem, assume that your function returns 2^31 - 1 when the division result overflows.\\n\\nSounds easy enough, that is to people who studied a computer systems course.\\nFirst let\\'s look at a few of the \"best\" submissions that straight up violate the rules:\\n\\n1. Division operator used\\n```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\\n\\n2. Impressive if ladder for sure, but the pesky division operator is still there\\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\\n\\nSo your software restoring division (or something similar) algorithm will compete against cheaters using\\ndivision hardware, no wonder you rank poorly.\\n\\nIn the end it doesn\\'t matter, as this problem in reality is asking for an algorithm that is of no use to any programmer,\\naka implementing division in software. It has a horrible number of edge cases with integer overflow, and is definitely\\nnot of \"medium\" difficulty to anyone, but a hardware designer.\\n\\nLet\\'s see the (terrible and pointless) code I came up with that should fit the requirements:\\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```\\n\\nTo add insult to injury, LeetCode is not able to actually measure the runtime of\\nany reasonable fast C code, so it presents mine and the two cheaters above as\\nhaving a \"0 ms\" runtime, and just as good. While mine is obviously slower, it\\nactually does what the question is asking.\\n",
                "solutionTags": [],
                "code": "```\\nint divide(long long dividend, long long divisor){\\n    if(dividend/divisor>pow(2,31)-1)\\n        return (pow(2,31)-1);//\\u7576\\u7D50\\u679C\\u6EA2\\u4F4D\\u6642\\u8FD4\\u56DE2^31\\u22121\\n    else\\n        return (dividend/divisor);//\\u5176\\u4ED6\\u76F4\\u63A5\\u9664\\u518D\\u8FD4\\u56DE\\u5176\\u7D50\\u679C(\\u56E0\\u6574\\u6578\\u7684\\u9664\\u6CD5\\u6703\\u76F4\\u63A5\\u6368\\u68C4\\u5C0F\\u6578\\uFF0C\\u8F38\\u51FA\\u6574\\u6578\\u503C)\\n}\\n```\n```\\n#define INT_MAX 2147483647\\n#define INT_MIN (-INT_MAX - 1)\\n\\nint divide(int dividend, int divisor){\\n    printf( \"%d\\\\n%d\", dividend, divisor );\\n    int output = 0;\\n    if ( ( dividend == 0 ) || ( divisor == 0 ) ) return 0;\\n    else if ( ( dividend <= INT_MIN ) && ( divisor < 0 ) && ( divisor != INT_MIN )  ) dividend = -INT_MAX;\\n    // else if ( ( dividend >= INT_MAX ) || ( dividend <= INT_MIN ) ) return 0;\\n    // else if ( ( divisor >= INT_MAX ) || ( divisor <= INT_MIN ) ) return 0;\\n    output = dividend / divisor;\\n    // printf(\"%d\\\\n\",output);\\n    return output;\\n}\\n```\n```\\n// This function implements restoring division taking two 32-bit unsigned inputs\\n// and outputs a 32-bit unsigned quotient, with no overflow possible\\nunsigned udiv(unsigned dividend, unsigned divisor) {\\n    unsigned quo = 0;\\n    unsigned long rem = dividend;\\n    unsigned long div = (unsigned long) divisor << 32;\\n\\n    for (int i = 0; i < 32; ++i) {\\n        rem <<= 1;\\n        if (rem >= div) {\\n            rem -= div;\\n            quo = quo << 1 | 1;\\n        } else {\\n            quo <<= 1;\\n        }\\n    }\\n\\n    return quo;\\n}\\n\\n// This function does a bunch of horrific edge case checking to\\n// make sure no integer overflow is possible\\nint divide(int dividend, int divisor) {\\n    int sgn = 0;\\n\\n    unsigned u_dividend;\\n    if (dividend < 0) {\\n        u_dividend = -(long)dividend;\\n        sgn ^= 1;\\n    } else {\\n        u_dividend = dividend;\\n    }\\n    unsigned u_divisor;\\n    if (divisor < 0) {\\n        u_divisor = -(long)divisor;\\n        sgn ^= 1;\\n    } else {\\n        u_divisor = divisor;\\n    }\\n\\n    unsigned u_result = udiv(u_dividend, u_divisor);\\n\\n    if (sgn) {\\n        if (-(long) u_result < INT_MIN)\\n            return INT_MAX;\\n        return -u_result;\\n    } else {\\n        if (u_result > INT_MAX)\\n            return  INT_MAX;\\n        return u_result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981274,
                "title": "neat-python3-solution-fast-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        res = 0\\n        sign = 1\\n        if dividend < 0:\\n            dividend = -dividend\\n            sign = -sign\\n        if divisor < 0:\\n            divisor = -divisor\\n            sign = -sign\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val+val <= dividend:\\n                val += val\\n                n += n\\n            dividend = dividend - val\\n            res += n\\n        \\n        if sign == 1:\\n            return min(res, 2**31-1)\\n        else:\\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937330,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\n        if dividend == 0:\\n            return 0\\n        \\n        sign = 1\\n        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\\n            sign = -1\\n        dividend, divisor = abs(dividend), abs(divisor)\\n        \\n        res = 0\\n        while dividend >= divisor:\\n            val, n = divisor, 1\\n            while val + val <= dividend:\\n                val += val\\n                n += n\\n            \\n            res += n\\n            dividend -= val\\n\\n        \\n        if sign == 1:\\n            return min(res, 2**31 -1)\\n        else: \\n            return max(-res, -2**31)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887275,
                "title": "python-2-solutions-recursion-non-recursion-clean-concise-o-log-n-2",
                "content": "**Solution 1: Recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n\\n**Solution 2: Non recursion**\\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\\nComplexity:\\n- Time: `O(log(N) ^ 2)`, where `N` is absolute value of `dividend`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        def helper(a, b):\\n            if a < b: return 0\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            return multiply + helper(a - sum, b)\\n        \\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        ans = helper(abs(a), abs(b))\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```\n```python\\nclass Solution(object):\\n    def divide(self, a, b):\\n        INT_MAX = 2147483647 # 2**31 - 1\\n        positive = (a >= 0) == (b >= 0) # Positive only if a and b the same sign\\n        a, b = abs(a), abs(b)\\n        ans = 0\\n        while a >= b:\\n            multiply = 1 # 1 2 4 8 16...\\n            sum = b\\n            while (sum + sum) <= a:\\n                sum += sum\\n                multiply += multiply\\n            ans += multiply\\n            a -= sum\\n        ans = ans if positive else -ans\\n        return min(ans, INT_MAX)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829428,
                "title": "java-binary-long-division-o-31",
                "content": "\\n```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int divide(int dividend, int divisor) {\\n        if (dividend == -Integer.MIN_VALUE && divisor == -1)\\n            return Integer.MAX_VALUE;\\n\\n        // Convert to +ves\\n        int negs = 0;\\n        if (dividend < 0) {\\n            negs++;\\n            dividend = -dividend;\\n        }\\n        if (divisor < 0) {\\n            negs++;\\n            divisor = -divisor;\\n        }\\n\\n        /**\\n         * Will do binary long division\\n         * starting from Left most bit of \\'dividend\\' (32),\\n         * going through the bits, comparing with \\'divisor\\'\\n         * and as and when results in \\'>= 0\\' get reminder\\n         * and append to quotient\\n         */\\n        int q = 0;\\n        int x = 31;\\n        while (x >= 0) {\\n            //Unsigned shift to handle case where dividend = Integer.MIN_VALUE\\n            //In which case -Integer.MIN_VALUE will also be Integer.MIN_VALUE\\n            if ((dividend >>> x) - divisor >= 0) {\\n                q += 1 << x;\\n                dividend -= divisor << x;\\n            }\\n            x--;\\n        }\\n\\n        if (negs == 1) //If only one of dividend/divisor is -Ve result as well is\\n            q = -q;\\n\\n        return q;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 824443,
                "title": "100-faster-solution-using-bit-manipulation-in-cpp",
                "content": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "solutionTags": [],
                "code": "```\\n//----------------------------Upvote if u loved the solution---------------------------------------------------------------\\n\\n\\n    int divide(int dividend, int divisor) {\\n        if(dividend==INT_MIN&&divisor==-1)\\n            return INT_MAX;\\n        long dv=labs(dividend),ds=labs(divisor),ans=0,flag=0;\\n        if((dividend<0&&divisor>0)||(dividend>0&&divisor<0))\\n            flag=1;\\n        while(ds<=dv){\\n            long temp=ds,m=1;\\n            while(temp<<1<dv){\\n                temp<<=1;\\n                m<<=1;\\n            }\\n            ans+=m;\\n            dv-=temp;\\n        }\\n        if(flag)\\n            return -ans;\\n        return ans;\\n    }\\n\\t\\n\\t\\n//----------------------------Upvote if u loved the solution-------------------------------------------------------------\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777656,
                "title": "o-log-dividend-solution-python",
                "content": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "solutionTags": [],
                "code": "\\n\\n    def divide(self, dividend, divisor):\\n        #The final Sign        \\n        sign = (dividend < 0) != (divisor < 0)\\n        \\n        #Absolute of dividend\\n        dividend = abs(dividend)\\n        \\n        #Absolute of divisor\\n        divisor = abs(divisor)\\n\\n        #Let\\'s Search at O(log(dividend)) complexity \\n        \\n        bit_width = 32\\n        remainder = 0\\n        modulus = 0\\n        for i in range(bit_width - 1 , -1, -1):\\n            \\n            # If we found a big 2^i slice that can be subtracted\\n            # Slice it off and search for the remaining value \\n            slice = divisor << i \\n            if remainder + slice <= dividend:\\n                remainder += slice\\n                # Since we \"add\" only less significant bits\\n                # The Addition can be replaced by Bitwise OR\\n                modulus = modulus | (1 << i)         \\n            # If the slice does not fit we continue\\n            # With the next possible slice\\n        \\n        if sign:\\n            return max(-modulus, -2147483648)\\n        else:\\n            return min( modulus,  2147483647)",
                "codeTag": "Python3"
            },
            {
                "id": 554646,
                "title": "c-o-1-solution-runtime-beats-100",
                "content": "Math logic:\\n\\t\\na/b = e^(log(a) - log(b)) \\nSince log(a/b) is equal to log(a) - log(b), raise it to e power as e and log undo each other\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int divide(int a, int b) {\\n        if (a == INT_MAX && b == INT_MIN) return 0;\\n        int x = a;\\n        int y = b;\\n        bool neg1 = 0, neg2 = 0;\\n        if (a < 0) neg1 = 1;\\n        if (b < 0) neg2 = 1; \\n        a = (a == INT_MIN) ? INT_MAX : abs(a);\\n        b = (b == INT_MIN) ? INT_MAX : abs(b);\\n        int ans = exp(log(a) - log(b));\\n        if (neg1 && neg2) return ans;\\n        else if (neg1 || neg2) return ans == INT_MAX ? INT_MIN : \\n                                        ((x == INT_MIN && y == 2) ? -ans-1 :-ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549683,
                "title": "java-o-lgn-time-o-1-space-no-bit-shift-no-long",
                "content": "I checked through all the solutions here and observed these trends:\\n- A lot of solutions use `long`, which violated the requirements of this problem\\n- Bit shift makes the code less readable\\n\\n This solution is similar to Approach 4 in this [solution](https://leetcode.com/problems/divide-two-integers/solution/). But instead of bit shifting, I am using plus and minus operations only. Below are the steps:\\n- First, we check for the special case `dividend == Integer.MIN_VALUE && divisor == -1`\\n- We get the absolute value of dividend and divisor\\n- Do the division for 2 positive numbers using \"Adding Powers Of Two\" technique\\n\\nA note on the check `dividend - divisor >= 0` instead of `divisor <= dividend` is to handle the corner case where original `dividend = Integer.MIN_VALUE` and `absDividend = Integer.MIN_VALUE`. \\n```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int divide(int dividend, int divisor) {\\n        if (dividend == Integer.MIN_VALUE && divisor == -1) return Integer.MAX_VALUE;\\n\\n        int absDividend = getAbs(dividend);\\n        int absDivisor = getAbs(divisor);\\n        int res = dividePositive(absDividend, absDivisor);\\n        return (dividend > 0) == (divisor > 0) ? res : -res;\\n    }\\n    \\n    int getAbs(int num) {\\n        return num < 0 ? -num : num;\\n    }\\n    \\n    int dividePositive(int dividend, int divisor) {\\n        int count = 0;\\n        \\n        while (dividend - divisor >= 0) {\\n            int cur = divisor;\\n            int steps = 1; \\n            while (dividend - (cur + cur) > 0) {\\n                cur = cur + cur;\\n                steps += steps;\\n            }\\n            count += steps;\\n            dividend = dividend - cur;\\n        }\\n        \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566062,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565701,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1565492,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566906,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566683,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1820777,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566695,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566912,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566469,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1566444,
                "content": [
                    {
                        "username": "user5060Qt",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "because if we divide it with -1 we will get 2147483648 which is greater than 2 power 31 -1 so we will return 2 power 31 -1 as the answer . "
                    },
                    {
                        "username": "AjayReddy07",
                        "content": "[@naomi_tesla](/naomi_tesla) I didn\\'t get can you please elaborate\\n"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "[@naomi_tesla](/naomi_tesla) no.. int can store \\'-2147483648\\' also"
                    },
                    {
                        "username": "trishantpahwa",
                        "content": "[@naomi_tesla](/naomi_tesla) 2^31"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@amohajer45](/amohajer45) This behaviour is spesified in the description."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description."
                    },
                    {
                        "username": "amohajer45",
                        "content": "[@naomi_tesla](/naomi_tesla) I hard coded this specific case. I see it as a bug with the test cases. How did you work around it? "
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "mikasalilili",
                        "content": "I wonder do you feel the same? It\\'s just so annoying."
                    },
                    {
                        "username": "ArpitKrishna98",
                        "content": "how to deal with this sht\\n"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "its correct, since we can\\'t store 2147483648 in 32 bit signed integer. its upper limit is 2147483647"
                    },
                    {
                        "username": "CrackJackCoder",
                        "content": "actually\\n"
                    },
                    {
                        "username": "f0901",
                        "content": "makes no sense to have these test case and losing the weight of real point"
                    },
                    {
                        "username": "sAMosa",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nExpected:\\n-2147483647\\n\\nActual:\\n-2147483648"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "[@MatsRivel](/MatsRivel) It\\'s specified. And stop spamming the comments section with unhelpful posts. Copying and pasting the expected result is pointless. Telling someone \"read the instructions\" is also pointless.\\nIf you have nothing to contribute then refrain from posting."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@pratapsinghshreshth123](/pratapsinghshreshth123) -2147483647"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is spesified in the description. Your \"Actual\" is wrong. \"Expected\" is correct."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "[@naomi_tesla](/naomi_tesla) so what will be the solution"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another reply but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Doing this problem correctly is a massive pain in the a55.\\n\\n1. without using multiplication, division, and mod operator\\n2. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\\u22122^31, 2^31 \\u2212 1]\\n\\nMany of the solutions posted in discussions blatantly violate rule #1, which makes this problem completely trivial.\\n\\nAddressing rule #2 is the main pain point in this problem.  Many of those using typed languages use longs to trivially bypass this.  Those using python frequently forget that abs(\\u22122^31) > 2^31 \\u2212 1, which is overflow.\\n\\nI think gained several white hairs dealing with all the edge cases caused by rule #2.  Ugh"
                    },
                    {
                        "username": "jkig",
                        "content": "lol just use C++ for the prob then. jkjkjk, but you gotta pick ur battles, I have no idea how to go about this (i\\'m guessing i would represent the number in binary and try to figure out how to make division work there, i have some ideas how that could work, but realistically, this seems like a waste of time to me, imma check some solutions and see where we are)\\n\\ngood luck friend :)"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah I finally gave up trying to make the binary long division work with negative 31bit numbers and just added `if ($dividend == -2147483648 && $divisor == -1) return 2147483647;` at the beginning."
                    },
                    {
                        "username": "jayramesh0",
                        "content": "Time Limit Exceeded\\n994 / 994 testcases passed"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "[@user5553nw](/user5553nw) hahahahahahaah epic"
                    },
                    {
                        "username": "sahil_azad",
                        "content": "congrats"
                    },
                    {
                        "username": "user5553nw",
                        "content": "You failed succesfully"
                    },
                    {
                        "username": "pawel753",
                        "content": "# Seriously?\\n\\n![image](https://assets.leetcode.com/users/images/e0671065-5658-46b1-b7b2-e46bdbfc55ab_1642021499.672225.png)\\n\\nI mean - I\\'m pretty sure what\\'s the reason for that (an overflow) but we\\'re asked to implement division which is defined by math not the integer size....\\n"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "[@MatsRivel](/MatsRivel) How do I fix this? I used this at the end of my code, before returning the output:\\n\\n    if(divided <= -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "This behaviour is specified in the description. It literally says \"If output would be > 2^31 -1, output 2^31 -1\"..."
                    },
                    {
                        "username": "PeggyZ",
                        "content": "What to do if encounter error with input \"-2147483648, -1\" and 0sm runtime?"
                    },
                    {
                        "username": "iamabadcoder",
                        "content": "For example, if you execute the following code in the python console:\\n\\n    print 7/-3\\n\\nThe answer is -3. **However**, the OJ expects -2. This goes back to how languages decided to round integer division results. Read about it here: http://stackoverflow.com/questions/19517868/integer-division-by-negative-number\\n\\nBasically `7/-3` should be treated in your solution as `-(7/3)` which are two different results in python and OJ!"
                    },
                    {
                        "username": "Kaltu",
                        "content": "python rounds down in integer division, -1.5 rounds to -2 becasue that way is \"down\". but almost all other languages rounds towards zero so -1.5 rounds up to -1"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/divide-two-integers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Repeated Subtraction\n\n  \n**Approach 2:** Repeated Exponential Searches\n\n  \n**Approach 3:** Adding Powers of Two\n\n  \n**Approach 4:** Adding Powers of Two with Bit-Shifting\n\n  \n**Approach 5:** Binary Long Division\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "vasuyan",
                        "content": "The last testcase writes: time limit exceed, last expected input: divided = (that's all, nothing is wrote there), please, help (in C)"
                    }
                ]
            },
            {
                "id": 1568689,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568341,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567137,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1568290,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1566739,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567540,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1569289,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1874916,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567735,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1567731,
                "content": [
                    {
                        "username": "chandra627",
                        "content": "\\nInput:\\n-2147483648\\n-1\\nExpected:\\n2147483647\\n\\nHow is this correct?\\nBad test case."
                    },
                    {
                        "username": "Manish_Malik",
                        "content": "because , if you divide -2147483648 with -1 it leaves you with the quotient 2147483648 which  is               ( 2 to the power 32 +1 )which means strictly greater than( 2 to the power 32 )and in such case you have  to return  2 to the power 32 which is equal to 2147483647 mentioned above in the question.\\n "
                    },
                    {
                        "username": "AdamGold",
                        "content": "Not a bad test case. This is what makes the problem medium instead of easy. Essentially it wants the overflow behavior to cap at the bounds, rather than looping.\n\n2147483648 is greater than Int.MAX_VAUE, hence it wants the answer for that case to be Int.MAX_VAUE\n\nthis question appears too be a bit shifting problem, even though that's arguably multiplication... I got a working solution without bit shifting, but it runs out of time. "
                    },
                    {
                        "username": "bcheco",
                        "content": "Hello,\\n\\nI am currently attempting this problem in swift and the test case is \\n-2147483648\\n-1\\nMy output is 2147483648 but the expected out put is 2147483647. Can someone explained why that is the expected out put?"
                    },
                    {
                        "username": "Rahul_Agnihotri4444",
                        "content": "because 2147483648 is > 2^31 - 1  hence it should return 2^31 - 1 which is 2147483647"
                    },
                    {
                        "username": "Pranjal_Gaur",
                        "content": "I read the question, thought about it for sometime, built an approach and then implemented it. \\nThe solution didn\\'t get accepted. Till now, everything was fine, as it happens often, lol.\\nBut, it got interesting when I even tried submitting the solutions from the discussionf forum, that the solutions didn\\'t get accepted. It has happened with me for the first time."
                    },
                    {
                        "username": "Shashank_Sharma-Developer",
                        "content": "Test case of this question are sense-less\\nbut I learn many new thing in this but waste a full day on it \\nuntil no perfect solution\\n"
                    },
                    {
                        "username": "msbeens",
                        "content": "Ruby solution fails for test case\\n512 / 989 test cases passed.\\n\\nInput:\\n-2147483648\\n-1\\nOutput:\\n2147483648\\nExpected:\\n2147483647\\n\\nOutput expected is definitely wrong."
                    },
                    {
                        "username": "alpiyidir",
                        "content": "\"if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1\" you are attempting to return 2^31 which is not in the range of a 32 bit signed int."
                    },
                    {
                        "username": "jarc",
                        "content": "And then the solution will be trivial, if it's allowed :)"
                    },
                    {
                        "username": "PrasadKarunagoda",
                        "content": "Test case passes for below input with an execution time of 1792ms:\\n-2147483648\\n1\\n\\nBut when I submit, it fails **for the same input** saying \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "charonme",
                        "content": "yes, 1792ms is way too long, you should be able to do it 100x faster"
                    },
                    {
                        "username": "san_py",
                        "content": "I always wonder what do they get by asking these  questions .?"
                    },
                    {
                        "username": "laihm6",
                        "content": "what is testcase 994. it has empty test case. "
                    },
                    {
                        "username": "julianbui",
                        "content": "123456789101"
                    },
                    {
                        "username": "eiko03",
                        "content": "Why is it a wrong answer, can anyone explain please. It is showing -1 the devidend\\n\\n![image](https://assets.leetcode.com/users/images/959a97b8-f9b5-4ca9-91ec-5b386ecffc23_1645611575.0239067.png)\\n"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, It\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    }
                ]
            },
            {
                "id": 1979403,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1929966,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1840585,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816498,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568477,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568331,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1568111,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567815,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1566392,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1962762,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "Try these 7 test cases , before submitting\n```\n-2147483648\n2147483647\n2147483647\n2147483647\n1981445587\n1172010393\n1100540749\n-1090366779\n-2147483648\n2\n-2147483648\n1\n2147483647\n2\n```"
                    },
                    {
                        "username": "user9348239482934",
                        "content": "Has anyone had such an error?\\n![image](https://i.ibb.co/S5zVR0K/2023-06-15-10-11-03.png)"
                    },
                    {
                        "username": "niketsharma22",
                        "content": "Leetcode: How many corner scenarios will you add? \\nComposer: YES!!!!!!!"
                    },
                    {
                        "username": "Timy3005",
                        "content": "The last test case is just empty although it clearly said that dividend and divisor are numbers. (-2^31 <= dividend, divisor <= 2^31 - 1)\\n\\nIt says: \"dividend =\"\\n\\nNo number"
                    },
                    {
                        "username": "Ghosted",
                        "content": "[@Timy3005](/Timy3005) same for me. good.times."
                    },
                    {
                        "username": "Timy3005",
                        "content": "Furthermore, if I try and put \"empty\" (just nothing) in the test case it gives me an error \" is not a valid value or type integer\""
                    },
                    {
                        "username": "priyatanwar2009",
                        "content": "Approach -2 , powerOfTwo = -1 is being initizalized with -1. Why??"
                    },
                    {
                        "username": "MR-D05",
                        "content": "Just curious what some of your thoughts are about why this problem sucks."
                    },
                    {
                        "username": "calvin-li",
                        "content": "-2147483648 / -1 == -2147483648, but output is -2147483647 for python"
                    },
                    {
                        "username": "larryleguo",
                        "content": "https://leetcode.com/submissions/detail/29323275/\\n\\n987 / 988 test cases passed.\\nStatus: Wrong Answer\\nSubmitted: 1 minute ago\\nInput:\\t-2147483648, -1\\nOutput:\\t2147483648\\nExpected:\\t2147483647\\n\\nClearly the test case gives the wrong results. I use python. I think this may be related with a bug in python:\\nFor integer division in C and Java, we have\\n1/2 = 0, \\n-1/2 = 0.\\nHowever, in python, we have\\n1/2 = 0\\n-1/2 = -1.\\nSomeone may argue this is what python defines, but I think it should be a bug since it is incompatible to other programming languages."
                    },
                    {
                        "username": "bodypainter",
                        "content": "Most test cases hinge on the input values being INT_MIN. So, you need to either type cast to long long to solve or do a cumbersome switch case :( :("
                    },
                    {
                        "username": "kemp",
                        "content": "Ah, now I remember why I hate leetcode \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1570818,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1576037,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1570024,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569624,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1569408,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568849,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568850,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568851,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1568548,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1858559,
                "content": [
                    {
                        "username": "waseehaque",
                        "content": "![image](https://assets.leetcode.com/users/images/4b770e88-0628-4893-af62-4663af5dbc28_1647061138.8385103.png)\\nOne of the test cases has wrong answer. Javascript."
                    },
                    {
                        "username": "heyjordn",
                        "content": "Hi, Why is this particular test case wrong?\\n\\nAny number divided by one isnt itself?\\n![image](https://assets.leetcode.com/users/images/7111ea2b-3b46-4837-b889-0891244bdbd1_1638381391.0029366.png)\\n"
                    },
                    {
                        "username": "yogesh_nazi",
                        "content": "-2147483648\\n-1\\n their answer should be  2147483648\\n but its answer is show as 2147483647 \\n correct me if i am wrong"
                    },
                    {
                        "username": "naomi_tesla",
                        "content": "I said this in another comment but, it\\'s due to the signed int32 range, which is between \\'-2147483647\\' and \\'2147483647\\' since \\'-2147483648\\' is one greater!"
                    },
                    {
                        "username": "bullpup",
                        "content": "My time complexity analysis of the standard algorithm. Sorry for the ugly presentation and bad handwriting. Open to corrections and suggestions.\\n![image](https://assets.leetcode.com/users/bullpup/image_1568425821.png)\\n"
                    },
                    {
                        "username": "ishthefish11",
                        "content": "did u end up solving it 4 years later?"
                    },
                    {
                        "username": "dexx1220",
                        "content": "![image](https://assets.leetcode.com/users/dexx1220/image_1548028697.png)\\nI"
                    },
                    {
                        "username": "easonok",
                        "content": "I cannot pass this test case but my answer looks correct to me. I am suspecting there is an off-by-one error in OJ. Does an admin mind checking?\\n\\n![0_1483931624514_Screen Shot 2017-01-08 at 7.11.42 PM.png](/uploads/files/1483931625836-screen-shot-2017-01-08-at-7.11.42-pm.png) \\n\\nPlease see my recent submission for my code if that matters - thanks!"
                    },
                    {
                        "username": "edwardcui",
                        "content": "Python has arbitrary precision integers so there is no true fixed maximum (limited by memory). People have to hard code this overflow limitation if they want their code to be accepted! Is it against the purpose of this website?"
                    },
                    {
                        "username": "sftrytry",
                        "content": "They actually works as * 2 and / 2."
                    },
                    {
                        "username": "jatinx",
                        "content": "The question is good. Some test cases it uses to verify are stupid.\\n\\nOne of the test case is: division of -2147483648 by -1 cannot be represented in type \\'int\\'\\nThats undefined behavior, now just because you(test case writer) think it should round off to a certain number i.e. 2147483647, does not mean it will, its still UB.\\n\\nSince we are not using any division here, we need to understand what you (the test case writer) think will happen (out of many other way better answer) and make sure the code does that.\\n\\nMaybe thats why this question has so few acceptance rate.\\n\\nA good read for test case writer: https://en.cppreference.com/w/cpp/language/ub"
                    },
                    {
                        "username": "haphanquang",
                        "content": "why do we try to reinvent the wheel?"
                    }
                ]
            },
            {
                "id": 1803482,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1734718,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576500,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576029,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1576026,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1575168,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574339,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1574140,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572931,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1572613,
                "content": [
                    {
                        "username": "nbeau",
                        "content": "I\\'m getting Time Limit Exceeded even though I have 994/994 test cases passed, why is this happening?"
                    },
                    {
                        "username": "Andrew0000",
                        "content": "I have the same"
                    },
                    {
                        "username": "mediterraneam",
                        "content": "At first I was wondering why such a simple question have so low pass rate. Now I know it\\'s due to a non-sense test case."
                    },
                    {
                        "username": "ifezec",
                        "content": "I was having a difficult time accepting the solution to the bitshifting approach as I was not able to mentally connect with the answer in code. Therefore, I needed to write it out on paper to make it clearer to reinforce this as a solution that I could reference for any future encounter.\\n\\nI wanted to share an image which may help make this clearer for others. The caveat is that it will only be clear if you know how to work with binary.\\n\\nI have 2 examples.  10/2 which would be 5. and 100/7 which is 14.\\n\\n\\n![image](https://assets.leetcode.com/users/images/8be3abf3-ba7f-415e-be00-ebc273003936_1647196362.826863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "NOMAD14",
                        "content": "**Original post**: [https://leetcode.com/explore/interview/card/top-interview-questions-medium/113/math/820/discuss/13467/Very-detailed-step-by-step-explanation-(Java-solution)](http://)\\n\\nEven though he has explained it well, I could not understand the concept the first time. But then I did a dry run...\\n**Here is the logic if someone is still struggling.**\\nex. 10/3\\nHere we need to get 10 by adding a bunch of 3\\'s multiplications.\\nSince every operation is off-limit, we need to think of something different. \\nWe can obtain multiplication and division by using the left and right shits. But these operations gives (num * 2) or (num / 2) respectively. \\nSo, we need to find a way to express 10 as a sum of `3*(power of 2)`.\\nwe can write it like this: `10 = 3*2 + 3*1 = 3*(2^1) + 3*(2^0) = 3*((2^1)+(2^0))`\\n(here, we only need a quotient as an answer. It will be the same as int division)\\nso every inner loop is finding the second term(count in the original post). \\n1st outer loop:\\n    inner loop finds (2^1)\\n2nd outer loop:\\n    inner loop finds (2^0)\\nVOLLA... we have our answer=>  `((2^1)+(2^0)) = 3`\\nHere\\'s another example : `20 = 3*4+3*2 = 3*(2^2) + 3*(2^1) = 3*((2^2)+(2^1))`\\nHope this helps someone and saves some time!!"
                    },
                    {
                        "username": "jomogalla",
                        "content": "I\\'m using Javascript for this challenge, and LeetCode is telling me my answer is incorrect, when it looks like theirs is?\\n\\n![image](https://assets.leetcode.com/users/images/2d8f9764-6fd7-4641-b1b0-2489d00f1ec8_1638217466.509745.png)\\n"
                    },
                    {
                        "username": "markaleptic",
                        "content": "Perhaps a bad test case, but my understanding was that -2147483648 / -1 = 2147483648.\\n![image](https://assets.leetcode.com/users/images/f9f7c8ed-225d-4076-8121-1931d720c528_1619064244.2609332.png)\\n\\n"
                    },
                    {
                        "username": "ratatouille117",
                        "content": "![image](https://assets.leetcode.com/users/images/2cd2f82e-6302-4f53-bed7-438d3edbcc67_1599423087.9170322.png)\\n"
                    },
                    {
                        "username": "ilias-t",
                        "content": "![image](https://assets.leetcode.com/users/images/cacd01af-7650-4da3-a4bf-40159f4b4680_1596308798.4310975.png)\\n"
                    },
                    {
                        "username": "user2451S",
                        "content": "is\\'nt -2147483648 divided by -1 = 2147483648? why is there a missing 1 in the answer\\n![image](https://assets.leetcode.com/users/user2451s/image_1566028161.png)\\n"
                    },
                    {
                        "username": "diewelt",
                        "content": "C language : -2147483648 / -1 = 2147483648 which can\\'t be expressed in 4 byte integer.\\n\\nWhy is the answer 2147483647?\\n\\nIt should be corrected."
                    }
                ]
            },
            {
                "id": 1571072,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571071,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571075,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571076,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571077,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571078,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571079,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1571080,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1576825,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1574983,
                "content": [
                    {
                        "username": "anthony11",
                        "content": "Dividing Integer.MIN_VALUE by -1 should cause overflow, but here's what I get. Sorry, folks, Int.MAX_VALUE is not the correct answer.\\n`\\nInput:\\n-2147483648\\n-1\\nOutput:\\n0\\nExpected:\\n2147483647`"
                    },
                    {
                        "username": "alexgaas",
                        "content": "Hi,\\n\\nGot pretty funny \"Expected\" answer about this problem - https://leetcode.com/problems/divide-two-integers\\n\\nI've tried to check my solution few times but every time getting:\\n\\nRun Code Result:\\n\\nYour input\\n**-2147483648\\n-1**\\n\\nYour answer\\n**2147483648**\\n\\nExpected answer\\n**2147483647**\\n\\n*Language - javascript*\\n\\nCould someone help to solve this \"issue\" :)? Thanks"
                    },
                    {
                        "username": "nanshu",
                        "content": "Input:\\n-2147483648\\n-1\\n\\nOutput:\\n**2147483648**\\n\\nExpected:\\n**2147483647**"
                    },
                    {
                        "username": "l328",
                        "content": "I wrote the program in JavaScript and it is able to output the correct answer \"2147483648\" based on the given input \"-2147483648, -1\". However OJ is expecting an answer of \"2147483647\" ---> this probably will happen when overflow happens during bitshift. Using \">>>\" unsigned bitshift this shouldn't happen though."
                    },
                    {
                        "username": "erhkang2",
                        "content": "Python gives -1 on my local machine."
                    },
                    {
                        "username": "monte",
                        "content": "I know it depends on the compiler. I am just curious that why with a similar algorithm c version code seems to be always faster than c++ version based on the results from the leetcode OJ. Especially when is no advanced c++ features (e.g. virtual functions) involved like in this \"divide two integers\" problem."
                    },
                    {
                        "username": "rdnz",
                        "content": "The problem did not specify what value is returned for the division. Res?"
                    },
                    {
                        "username": "atul",
                        "content": "What is Expected output when divisor is 0?"
                    },
                    {
                        "username": "luciferjain277",
                        "content": "Easy step by step explanation video in Hindi: https://youtu.be/vgfB4r2HQck\\nIf you like the content do up-vote the post so that it could reach to a larger audience.\\n"
                    },
                    {
                        "username": "nchait",
                        "content": "![image](https://assets.leetcode.com/users/images/a2c5c58d-c7d6-40ab-b9e7-94743475aa96_1614364479.9338746.png)\\nwhy is this output incorrect? last i checked, -x/-1=x not x-1??"
                    }
                ]
            },
            {
                "id": 1573475,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2067311,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055990,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2055445,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2050348,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2039619,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 2026681,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1996576,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1976165,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1975112,
                "content": [
                    {
                        "username": "Mlizhardy",
                        "content": "Input\\n-2147483648\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nproper output IS 2147483648"
                    },
                    {
                        "username": "shashankvashistha1",
                        "content": "gandu question dont do it here."
                    },
                    {
                        "username": "mahmoodn",
                        "content": "For -231/3 the shift algorithm (M and AQ registers) yields Q=-76 and R=-3. So \\n-76x3-3=-231\\nBut the expected output is -77."
                    },
                    {
                        "username": "rgestudillo",
                        "content": "very easy, should be easy"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Why Binary search is not in \"related topics\" of this question??"
                    },
                    {
                        "username": "stonethrow-leetcode",
                        "content": "I think I've encountered the same issue reported by [@jayramesh0](/jayramesh0) on Mar 03, 2023 -- 994/994 testcases passed, yet there is a claimed time limit exceeded.\nIf I try \"Use Testcase\" to add the \"failed\" testcase to my test runs, that testcase _has no dividend or divisor_!\nThis feels like a bug in how this problem or acceptance criteria are implemented.\nIs there a way to get leetcode admins to look into this?\nOr does anyone else who's encountered this problem know what's going on or how to address it?\n\nI'm assuming that \"n/n testcases passed\" is advertised honestly, and that there are therefore no other conditions to that solution being flagged successful."
                    },
                    {
                        "username": "carefree_ladka",
                        "content": "If I ever get this problem in an interview, I\\'ll happily shake hands with the interviewer and walk out the room.\\n"
                    },
                    {
                        "username": "phuonganhthanh1107",
                        "content": "using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace ConsoleApplication3\\n{\\n    class Program\\n    {\\n        public static void Divide(long dividend , long divisor)\\n        {\\n            if (dividend == 0 || Math.Abs(dividend) < Math.Abs(divisor))\\n            {\\n                Console.Write(0);\\n            }\\n            else \\n            {\\n                int devidend_isGreater_than_0 = 1;\\n                int divisor_isGreater_than_0 = 1;\\n                if (dividend < 0) \\n                {\\n                    dividend = dividend * (-1);\\n                    devidend_isGreater_than_0 = -1;\\n                }\\n                if (divisor < 0) \\n                {\\n                    divisor = divisor * (-1);\\n                    divisor_isGreater_than_0 = -1;\\n                }\\n\\n                long count = 0;\\n                for (long i = 0; i < long.MaxValue; i++) \\n                {\\n                    dividend = dividend - divisor;\\n                    if (dividend >= 0)\\n                    {\\n                        count++;\\n                    }\\n                    else \\n                    {\\n                        break;\\n                    }\\n                }\\n                if (devidend_isGreater_than_0 * divisor_isGreater_than_0 < 0) \\n                {\\n                    count *= -1;\\n                }\\n\\n                Console.Write(count);\\n            }\\n        }\\n        static void Main(string[] args)\\n        {\\n            string dividend, divisor;\\n            dividend = Console.ReadLine();\\n            long DIVIDEND = long.Parse(dividend);\\n\\n            long DIVISOR;\\n            do\\n            {\\n                divisor = Console.ReadLine();\\n                DIVISOR = long.Parse(divisor);\\n            } while (DIVISOR == 0);\\n\\n            Divide(DIVIDEND, DIVISOR);\\n            Console.ReadKey();\\n        }\\n    }\\n}\\n\\n\\nnot template , it used to reference \\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I was always wondering about those 'smarties' who add tescases with numbers beyond the 32 bit integers range.  For what, do you wanna win the system? \nCongrats, your testcase was conditioned. \n```\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n```\n\nLol, keep wasting your time. \n"
                    },
                    {
                        "username": "maxlee577",
                        "content": "-231/3 = -77 but according to the test case it should be 76 makes no sense"
                    }
                ]
            },
            {
                "id": 1966655,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1966415,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1956654,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1951407,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1950343,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1944023,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1927471,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1913151,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1906055,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1900273,
                "content": [
                    {
                        "username": "ankith_t22",
                        "content": "How do we account for when the divisor is 0? I do not know what to return then."
                    },
                    {
                        "username": "raflyirham",
                        "content": "Constraint: divisor != 0\\n\\nMeaning that the value of the divisor will never be 0."
                    },
                    {
                        "username": "Pratish10",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIn the above case we can se that dividend has the minimum value and divisor is -1 and the expected output is max value\\n\\nSo handle this error properly\\n1. Check that dividend contains minimum value and divisor is -1 then return the max value\\n2. Check that dividend contains minimum value and divisor is 1 then return min value\\n\\nHit like if it helps you"
                    },
                    {
                        "username": "Saitama109",
                        "content": "bro INT_MIN with some Random Integer is just not possible without using long.... its just too hard for me in int32...cause it overflows every damn second..\\n"
                    },
                    {
                        "username": "awesomeRj01",
                        "content": "what to do when 994/994 testcases passed and it shows TLE"
                    },
                    {
                        "username": "illay8",
                        "content": "rule no 1, it should not use multiplication, division, and mod operator. When I tried a solution that uses division on Solution tab , it can be summited. What a rubbish"
                    },
                    {
                        "username": "aj24197",
                        "content": "can we solve this question by bit manipulations"
                    },
                    {
                        "username": "rajshish333",
                        "content": "my all answer is correct but 1/2 is showing result 1 why ?\\n"
                    },
                    {
                        "username": "talhasebtian",
                        "content": "Here\\'s an example code in Python that performs integer division without using multiplication, division, and mod operator:\\n\\npython\\ndef divide(dividend, divisor):\\n# Handle the case when the dividend is 0\\nif dividend == 0:\\nreturn 0\\n\\n# Handle the case when the divisor is 0\\nif divisor == 0:\\n    raise ZeroDivisionError(\"Cannot divide by zero\")\\n\\n# Handle the case when the dividend and divisor are the same\\nif dividend == divisor:\\n    return 1\\n\\n# Handle the case when the dividend is the minimum value and the divisor is -1\\nif dividend == -2**31 and divisor == -1:\\n    return 2**31 - 1\\n\\n# Determine the sign of the quotient\\nnegative = (dividend < 0) ^ (divisor < 0)\\n\\n# Convert both dividend and divisor to positive\\ndividend = abs(dividend)\\ndivisor = abs(divisor)\\n\\n# Initialize the quotient\\nquotient = 0\\n\\n# Keep subtracting the divisor from the dividend until the dividend becomes smaller than the divisor\\nwhile dividend >= divisor:\\n    # Subtract the divisor from the dividend\\n    dividend -= divisor\\n    # Increment the quotient by 1\\n    quotient += 1\\n\\n# Apply the sign to the quotient\\nif negative:\\n    quotient = -quotient\\n\\nreturn quotient\\nExample usage:\\ndividend = 10\\ndivisor = 3\\nresult = divide(dividend, divisor)\\nprint(result)\\nThe code handles several special cases such as when the dividend is 0, the divisor is 0, or the dividend is the minimum value and the divisor is -1. It determines the sign of the quotient and converts both the dividend and divisor to positive values, pintdd.com. Then, it repeatedly subtracts the divisor from the dividend and increments the quotient until the dividend becomes smaller than the divisor. Finally, it applies the sign to the quotient and returns the result.\\n\\nIn the example usage, the code is called with dividend = 10 and divisor = 3. The result is then printed, which will be 3, representing the quotient after dividing the dividend by the divisor."
                    },
                    {
                        "username": "AndrewEastwood",
                        "content": "cannot complete this task because of shitty testcase:\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nwhaaa? -2147483648 / -1 must be 2147483647 ? really ?"
                    },
                    {
                        "username": "Fandrir",
                        "content": "It must be 2147483647, because 2147483648 would be an int overflow. The largest allowed absolute value for negative numbers is one larger than the largest allowed value for positive numbers. Therefore this falls under the requirement that everything above 2147483647 has to return 2147483647. \\nBasically all this task is, is to account for these weird int rules and exceptions."
                    },
                    {
                        "username": "NOT_FOUND_HERE",
                        "content": "to solve this problem, you just need some basic school math and type casting."
                    }
                ]
            },
            {
                "id": 1899087,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1896844,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1890247,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1875356,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1870594,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1869263,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1866761,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1855176,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1852708,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1846237,
                "content": [
                    {
                        "username": "pratyushshandilyajha2",
                        "content": "The  issue with the problem can be resolved easily by changing the type of dividend , the return type and the type of variable accepting the return to long. "
                    },
                    {
                        "username": "user5037rv",
                        "content": "Time limit exceeded on dividend = 2147483647 divisor = 3, When included in the testcase, the result is accurate"
                    },
                    {
                        "username": "shaikdada",
                        "content": "Why am getting error in leetcode its running fine in my local machine\\ndef divide(dividend, divisor):\\n        s=dividend/divisor\\n        val=f\\'{s:.0f}\\'\\n        return val"
                    },
                    {
                        "username": "user5508IZ",
                        "content": "ValueError: invalid literal for int() with base 10: \\'-\\'\\n    return (int(ch))\\nLine 5 in divide (Solution.py)\\n    ret = Solution().divide(param_1, param_2)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n\\nMeanwhile testcases work perfectly fine in VS and online compilers :/"
                    },
                    {
                        "username": "user5991g",
                        "content": "For the case\\n`dividend =  2147483647 `\\nAnd \\n` divisor = 2 `\\n\\nI am getting error as `Memory Limit Exceeded`"
                    },
                    {
                        "username": "alecn2002",
                        "content": "> For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\\n\\nWe have *dividend* and *divisor* in problem definition. What is ***quotient*** ???"
                    },
                    {
                        "username": "ajay1208",
                        "content": "Read the description carefully, edge cases are mentioned"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this question is playing a little too much with integer limit :("
                    },
                    {
                        "username": "Vinayak-Pandey",
                        "content": "In the testcase the same code is correct but when submittin it is failing?"
                    },
                    {
                        "username": "Abraha111",
                        "content": "Do not try to solve this question, absalutely incorrect in testcase 551!"
                    }
                ]
            },
            {
                "id": 1845848,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1841568,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1840442,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1834980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1827868,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1824198,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1823408,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819980,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1819431,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1818772,
                "content": [
                    {
                        "username": "aman3091",
                        "content": "   int divide(int dividend, int divisor) {\\n      if(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }\\n\\n        return dividend/divisor;\\n     \\n       \\n    }\\n\\nin this code why are we taking dividend ==INT_MIN not INT_MAX . pleas answer\\n"
                    },
                    {
                        "username": "rohit_gupta1001",
                        "content": "Hello everyone ,This question is asked by me in today\\'s Online assessment of Scaler."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647 \\nfor this problem try this-->\\nif(dividend == INT_MIN && divisor == -1){\\n            return INT_MAX;\\n        }"
                    },
                    {
                        "username": "neilkumarwb",
                        "content": "whats the point of solving these type of questions"
                    },
                    {
                        "username": "tonkei0361",
                        "content": "I was first annoyed by this question, especially when I got stuck on the 2**31-1 test case. However, after studying solutions posted by others, I feel this is an underrated question in terms of likes vs. dislikes."
                    },
                    {
                        "username": "CoderrrrMan",
                        "content": "i am gay, what the hell is that ?"
                    },
                    {
                        "username": "andysem3",
                        "content": "I REALY appreciate to this PROBLEM for my 14% acceptance rate."
                    },
                    {
                        "username": "RAJINIKANTH-KAKARLA",
                        "content": "test case2 is wrong!"
                    },
                    {
                        "username": "congener",
                        "content": "Fun problem. Definitely requires careful reading of the description, but its a valuable lesson in types, their sizes and the problems that may arise when pushed to their limits. "
                    },
                    {
                        "username": "jayramesh0",
                        "content": "I have this weird problem where I get a timelimit exceeded  error after only passing 17 cases but other times I passed 990.  Why does this happen?"
                    }
                ]
            },
            {
                "id": 1810021,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1808333,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1807452,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1804280,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803658,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1803105,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1802264,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797100,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795698,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1795003,
                "content": [
                    {
                        "username": "akashshaw01",
                        "content": "\\n#binary search simple solution\\n **take all  long datatype for integer overflow case. and another if condition for INT_MIN test case see my code below for reference**\\n\\n\\nmy code link - https://leetcode.com/problems/divide-two-integers/solutions/3216421/c-binary-search-solution-o-log-n-beginner-frindly-all-tc-handled/?orderBy=most_votes"
                    },
                    {
                        "username": "codesupernova",
                        "content": "Why are you so mad? I solve this within 5 min. What is funny is that I took two days per problem to solve each, which is all acceptance is over 70%.  "
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "This beats 100 % on leetocode--> \\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n\\n  int negative=1;\\n  if(dividend==INT_MIN && divisor<0){\\n      dividend++;\\n  }\\n  if(divisor==INT_MIN && dividend<0){\\n      divisor++;\\n  }\\n  \\n  long long diviS=divisor;\\n  long long diviD=dividend;\\n\\n   if(((diviD^diviS)>0) && (diviD<0)){\\n    // cout << \"inside -> (dividend^divisor > 0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }else if((diviD^diviS)<0 && (diviD<0)){\\n    // cout << \"(dividend^divisor<0) && (dividend<0))\" << endl;\\n    diviD=-1*diviD;\\n    negative=-1;\\n    // cout << \"dividend ->\" << dividend << endl;\\n  }else if((diviD^diviS)<0 && (diviS<0)){\\n    // cout << \"(dividend^divisor<0) && (divisor<0)\" << endl;\\n    diviS=(diviS*(-1));\\n    negative=-1;\\n  }else if((diviD^diviS)==0 && (diviD<0)){\\n    // cout << \"(dividend^divisor==0) && (dividend<0)\" << endl;\\n    diviD=(diviD*(-1));\\n    diviS=(diviS*(-1));\\n  }\\n\\n\\n\\n\\n\\n  long long start=0;\\n  long long end=diviD;\\n\\n  long mid=start+(end-start)/2;\\n\\n  long ans=0;\\n  \\n  while(start<=end){\\n    if(mid*diviS==diviD){\\n      ans=mid;\\n      break;\\n    }else if(mid*diviS>diviD){\\n      end=mid-1;\\n    }else if(mid*diviS<diviD){\\n      ans=mid;\\n      start=mid+1;\\n    }\\n    mid=start+(end-start)/2;\\n  }\\n\\n    return (ans*negative);\\n}};"
                    },
                    {
                        "username": "ssgyanibaba",
                        "content": "This problem is so annoying...I just solved it but using long long int.\\nI wonder how can we solve this by only using int instead of long long int"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "I\\'m at the brink of jumping out the window. My Code works but always gets me Time Limit Exceeded \"dividend =\\n-2147483648\\ndivisor =\\n1\"\\n\\nor other problems because of the int range. I tried using if() but still getting errors. Can someone please help me?\\n\\nThis is my whole code, i tried to use int divided as long long int and normal int.\\n\\nint divide(int dividend, int divisor)\\n{\\n    long long int divided = 0;\\n    \\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divisor >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    if(divisor == 0) // durch 0 kann man nicht teilen\\n    {\\n        return 0;\\n    }\\n    else if( divisor < 0 && dividend > 0 ) // Bsp: 6 / -3 = -2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend < 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend > 0) // Bsp: 10 / 5 = 2\\n    {\\n        while( dividend >= 0 )\\n        {\\n            dividend = dividend - divisor;\\n            divided += 1;\\n            if(dividend < 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n    else if ( divisor > 0 && dividend < 0) // Bsp: -10 / 2 = -5\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = dividend + divisor;\\n            divided -= 1;\\n            if(dividend > 0)\\n            {\\n                divided++;\\n            }\\n        }\\n    }\\n    else if ( divisor < 0 && dividend < 0) // Bsp: -12 / -2  = 6\\n    {\\n        while( dividend <= 0 )\\n        {\\n            dividend = (dividend) - (divisor);\\n            divided += 1;\\n            if(dividend > 0)\\n            {\\n                divided--;\\n            }\\n        }\\n    }\\n\\n    if(divided < -2147483648)\\n    {\\n        return -2147483648;\\n    }\\n    else if(divided >= 2147483647)\\n    {\\n        return 2147483647;\\n    }\\n\\n    return divided;\\n} "
                    },
                    {
                        "username": "dimitryku",
                        "content": "It is clearly stated, that we should not use \"multiplication, division, and mod operator\". And anyway, the most efficient submission (and the most popular too) made by using multiplication. Of cource, my solution is far from the best, I don\\'t pretending for that, but it feels unfair. "
                    },
                    {
                        "username": "andrew99154",
                        "content": "The corner cases suck. And when will a PRO engineer use these codes instead of **\" / \"**?"
                    },
                    {
                        "username": "shweta_raj",
                        "content": "my noob solution:\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        if dividend==-2147483648 and divisor==-1:\n            return 2147483647\n        if  dividend<0 and divisor<0: \n            return dividend//divisor\n        if dividend<0 or divisor<0:\n            if dividend<0 :\n                dividend=-1*dividend\n            if divisor<0:\n                divisor=-1*divisor\n            return -1*(dividend//divisor)\n        else:\n            return dividend//divisor         \n\n\n "
                    },
                    {
                        "username": "Andrew0000",
                        "content": "Does the time limit work on per case bases or the limit is set for all the cases together or both?"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend == -2147483648 && divisor == -1){\\n                return 2147483647;\\n       }\\n       else{\\n       int n = dividend/divisor;\\n       return n;\\n       }\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1794172,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1791787,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778332,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1764711,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1762923,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1761438,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1757201,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1754878,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1753143,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1752956,
                "content": [
                    {
                        "username": "shivamtherexpandey",
                        "content": "Lets Just look at the Test Case :\\nDividend: -2147483648\\nDivisor: -1\\n\\nUse a Calculator, It\\'s a tricky problem,\\n\\n\\n\\n\\n\\n\\n\\n\\nYour Result Would be....\\n2147483648 \\nCongratulations, Your a normal intelligent person like us.\\nBUT............\\nExpected Result:\\n2147483647\\nBy Leetcode.\\n\\nMessage to Leetcode:\\nKindly Verify this Test Case as this will create issues in the future."
                    },
                    {
                        "username": "Neptuuno",
                        "content": "very annoying\\n"
                    },
                    {
                        "username": "user9215S",
                        "content": "Input\\n-2147483648\\n-1\\nExpected\\n2147483647\\n\\nIt\\'s that wrong!"
                    },
                    {
                        "username": "gk779866",
                        "content": "What could i do if encounter error with input  -2147483648, -1 and ZeroSM in runtime??\\n "
                    },
                    {
                        "username": "DLH06",
                        "content": "Can anyone tell me how I pass this thing with python xD\ndividend = -2147483648\ndivisor = -1\nOutput\n2147483648\nExpected\n2147483647"
                    },
                    {
                        "username": "Apr26",
                        "content": "It\\'s given in the question itself if the answer is less than -2147483648 return -2147483648 and if the answer is greater than 2147483647 return 2147483647"
                    },
                    {
                        "username": "podopo34",
                        "content": "Most solutions disregard the requirements that can\\'t be checked. It\\'s a shame too because the whole point of this website is to practice."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": " public int divide(int dividend, int divisor) {\\n        if(dividend==0) return 0; // corner case \\n        if(divisor==0) return Integer.MAX_VALUE; // corner case\\n        int p = 0;\\n        if(divisor==-1) return Integer.MAX_VALUE;\\n        boolean sign = (dividend<0) ^ (divisor<0); // used turnery operator for true/false\\n       dividend = Math.abs(dividend); // find absolute value\\n       divisor  = Math.abs(divisor);// find absolute value \\n       if(divisor==1){\\n           return ((sign==false)?dividend:-dividend);// after comparing\\n       }\\n    //    Basic Idea : a/b = e ln(a) / e ln(b) = e( ln(a) \\u2013 ln(b) )\\n       int ans =(int) Math.exp(Math.log(dividend)-Math.log(divisor)+0.0000000001);//\\n       return ((sign==false)?ans:-ans);"
                    },
                    {
                        "username": "dewei",
                        "content": "My thoughts on a solution:\\n1. The original problem can be mapped to only positive situation + sign manipulation. (as many solution already suggested)\\n\\nThe solution to a positive positive problem:\\n1. use bit operation to re-define a multiplication function. for example, x * 6 = x*4 + x*2 =  x * (2**2) + x * 2**1 = x >> 2 + x >> 1\\n2. use power of 2\\'s to divide the dividen range into a few sub windows. (use bit operation, x/2**k = x >>k, we can quickly find those windows.)\\n3. find the window contains divisor\\'s results, we do this by comparing divisor with the window start 2**(k) and ends 2**(k+1)\\n4. apply binary search in that window. (using the multiplication function defined in 2)\\n\\nTime complexity: log(log(N))\\nSpace complexity: O(1)"
                    },
                    {
                        "username": "vik24k",
                        "content": "\\n        total = str(eval(f\"{dividend} / {divisor}\"))\\n\\n        if int(total[:total.index(\".\")]) > pow(2, 31) -1:\\n            return pow(2, 31) -1\\n        elif int(total[:total.index(\".\")]) < -pow(2, 31):\\n            return -pow(2, 31)\\n        else:\\n            return int(total[:total.index(\".\")]) \\n\\ndoes this count? lol\\n"
                    },
                    {
                        "username": "gajjarv2001",
                        "content": "993/994 testcases passed:\\n\\n```class Solution {\\n    public int divide(int dividend, int divisor) {\\n        int ans=dividend/divisor;\\n        return ans;\\n    }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1751661,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740547,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734768,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1731871,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729208,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1729170,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728779,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728067,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726065,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724578,
                "content": [
                    {
                        "username": "om_2209",
                        "content": "Same code is working in Java but not in CPP"
                    },
                    {
                        "username": "Konduru_sai",
                        "content": "  if divisor==0:\\n            return 0\\n        if divisor <0 and dividend<0:\\n            D=(dividend//divisor)\\n            if D>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return D\\n        elif (divisor<0 and dividend>0) or (divisor>0 and dividend<0):\\n            A=abs(divisor)\\n            E=abs(dividend)\\n            b=-(E//A)\\n            if b<=-2**31:\\n                return -2**31\\n            else:\\n                return b\\n            return -(dividend//A)\\n        else:\\n            c=int(dividend//divisor)\\n            if c>=2**31-1:\\n                return 2**31-1\\n            else:\\n                return c"
                    },
                    {
                        "username": "tarikin",
                        "content": "-2147483648 / -1 = 2147483647, yes Leet this makes a lot sense"
                    },
                    {
                        "username": "trantatxep",
                        "content": "Input\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n2147483648\\nExpected\\n2147483647\\n\\nWhat problems ? I have only case "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "wtf???\\n\\nTime Limit Exceeded\\nLast Executed Input\\n994 / 994 testcases passed\\ndividend =\\n\\nWhat is the input???"
                    },
                    {
                        "username": "Rohit_Singhal_0904",
                        "content": "Wrong Answer\\n\\nInput\\ndividend =\\n-2147483648\\ndivisor =\\n-1\\n993 / 994 testcases passed\\nOutput\\n-2147483648\\nExpected\\n2147483647"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/29_devide_2_int.cpp"
                    },
                    {
                        "username": "kSt_how",
                        "content": "why c++ example code is ruby ?"
                    },
                    {
                        "username": "Neo_09",
                        "content": "The test case\\n-2147483648\\n1\\nruns absolutely fine and shows the correct ans.\\nBut as soon as I submit it, the same test case shows time limit exceeded.\\nWhy?"
                    },
                    {
                        "username": "shivangshrivastavaprogramming",
                        "content": "class Solution {\\n    public int divide(int dividend, int divisor) {\\n        if(dividend==-2147483648 && divisor==-1){\\n            return 2147483647;\\n        }\\n        return dividend/divisor;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724023,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1722109,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1720936,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1719339,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709932,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1709351,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1707888,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1700876,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1699724,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1693543,
                "content": [
                    {
                        "username": "chopuryan",
                        "content": "I\\'m getting a `Time Limit Exceeded` error for this particular case\\n```\\ndividend =\\n2147483647\\ndivisor =\\n3\\n```\\nBut if I copy these into a custom test case and run, everything works! \\n\\nCan anyone help me understand what is the problem? I\\'m using simple `addition` algorithm written in JS"
                    },
                    {
                        "username": "jrespond00",
                        "content": "we can apply division by successive subtractions "
                    },
                    {
                        "username": "jrespond00",
                        "content": "It comes to my mind to make an algorithm that is done at a binary level, that is, the issue of converting a number to binary, there is an operation for this"
                    },
                    {
                        "username": "charonme",
                        "content": "in most languages numbers already are in binary and you can use binary operations to work with them without conversion: https://en.wikipedia.org/wiki/Bitwise_operation"
                    },
                    {
                        "username": "rahulseith",
                        "content": "Regarding Test case:\\nInput : dividend: -2147483648, divisor = -1, expected 2147483647\\nI see many people are justifying the expected as the resultant of max value of int....  but that shouldnt be the point... point should be what is the ans irrespective of approach... , u ask any 3rd grader  he would say 2147484648 only...  which is again overflow , can u please update test case."
                    },
                    {
                        "username": "charonme",
                        "content": "The justification is that that is what the problem description says. The overflow protection is part of the problem and reflects the reality that needs to be accounted for in practice when building a computer"
                    },
                    {
                        "username": "faisalprofessional1",
                        "content": "Why it is necessry to use abs(divident) and abs(divisor)"
                    },
                    {
                        "username": "fahimmakhanifm",
                        "content": "what does \"Time Limit Exceeded\" means while submitting "
                    },
                    {
                        "username": "LoopSkywalker",
                        "content": ">993 / 993 testcases passed\n>Time Limit Exceeded\n\nWhat are they trying to tell me?"
                    },
                    {
                        "username": "revathivalligatla",
                        "content": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if(dividend==1<<31&&divisor==-1) return Integer.MAX_VALUE;\n        boolean sign =(dividend>=0)==(divisor>=0)? true:false;\n        divisor=Math.abs(divisor);\n        dividend=Math.abs(dividend);\n        int result=0;\n        while(dividend-divisor>=0){\n            int count=0;\n        while(dividend-(divisor << 1 << count)>=0){\n             count++;\n        }\n        result+=1 << count;\n        }\n        return sign ? result:-result; \n    }\n}\nwith this im getting time limit exceeded,can any one help me out"
                    },
                    {
                        "username": "aniketdali",
                        "content": "the official solution on c++ has time limit exceeded error"
                    },
                    {
                        "username": "rohangautam219",
                        "content": "what is the time complexity of this code and how I will reduce its memory.\\n\\nif(dividend == Integer.MIN_VALUE && divisor==-1){\\n            return -(dividend-1 / divisor);\\n        } \\n        else {\\n            int ans = dividend/divisor;\\n            return ans;\\n        }\\n        \\n"
                    }
                ]
            },
            {
                "id": 1684081,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1678534,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1671289,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1666480,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1654024,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1649596,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1627800,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1570090,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1575027,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            },
            {
                "id": 1574713,
                "content": [
                    {
                        "username": "Luna-martinez",
                        "content": "Hey i used absolute functions, to return the value and then add a - sign, but there is some error when the input is -2^31"
                    },
                    {
                        "username": "zOrOjUrO_",
                        "content": "__The log based approach doesn\\'t work?__\\n\\n_Case 1:_\\nDividend = 2147483647\\nDivisor = 2\\nExpected = 1073741823\\n\\n_Case 2:_\\nDividend = -231\\nDivisor = 3\\nExpected = -77\\n\\nThe first case fails if taken as\\n`round(2**(log(dividend,2)-log(divisor,2)))`\\n\\nWhile second fails if taken as\\n`int(2**(log(dividend,2)-log(divisor,2)))`\\n\\nTried with different bases as well. Am I missing something? "
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html](https://www.gyangav.com/2022/11/leetocde-divide-two-integers-problem-solution.html)"
                    },
                    {
                        "username": "bonasero",
                        "content": "invalid test:\\nInput (dividend = -2147483648; divisor = -1)\\nExpected (2147483647)"
                    },
                    {
                        "username": "soumya00",
                        "content": "This is a very good problem based on Bit Manipulations, and can be done by several approaches. I don't know why there are so many dislikes! There are some of the edge cases like combinations of (+ve, -ve) dividend and (+ve, -ve) divisor, and that needs to be handled carefully. Also, when divisor == -1 or +1. Other than that, this is a nice problem."
                    },
                    {
                        "username": "oritzau",
                        "content": "I keep getting \"runtime exceeded\" despite my code working fine and fast when I run it on the terminal. Anyone else encounter something similar?"
                    },
                    {
                        "username": "Xylys",
                        "content": "i made this code for the solution but it says its wrong but when i tested it on my own computer it works\n\nheres what i did on here:\n\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        temp = dividend\n        run = True\n        while run:\n            if temp - divisor < 0:\n                run = False\n                return count\n            elif temp - divisor > 0:\n                temp = temp - divisor\n                count = count + 1\n\n                \n\nheres what i did on my own computer:\n dividend = 10\ndivisor = 3\n\ncount = 0\ntemp = dividend\nrun = True\nwhile run:\n    if temp - divisor < 0:\n        run = False\n        print(count)\n    elif temp - divisor > 0:\n        temp = temp - divisor\n        count = count + 1\n\ncan someone tell me whats wrong"
                    },
                    {
                        "username": "fgg192",
                        "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers.\\n\\nJust use Ian Kaplan\\'s 1996 binary solution, only using bitwise operators. Gotta check for negative values and overflow cases though.\\n\\nLink below:\\n\\nhttp://bearcave.com/software/divide.htm\\n"
                    },
                    {
                        "username": "manish47",
                        "content": "-2147483648\\n-1\\n\\nExpected Output is 2147483647\\nwhich is wrong.\\nif you multiply -1 with 2147483648, you will receive value = -2147483648."
                    },
                    {
                        "username": "TheBeliever",
                        "content": "Question has restriction to not use multiplication, division or mod operator.\\nDivison is obvious.\\nHow can you effectively solve the problem using multiplication or mod operator ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sum Root to Leaf Numbers",
        "question_content": "<p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>\n\n<p>Each root-to-leaf path in the tree represents a number.</p>\n\n<ul>\n\t<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>\n</ul>\n\n<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>A <strong>leaf</strong> node is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 25\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\nTherefore, sum = 12 + 13 = <code>25</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,9,0,5,1]\n<strong>Output:</strong> 1026\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.\nThe root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.\nThe root-to-leaf path <code>4-&gt;0</code> represents the number 40.\nTherefore, sum = 495 + 491 + 40 = <code>1026</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>The depth of the tree will not exceed <code>10</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 41363,
                "title": "short-java-solution-recursion",
                "content": "\\x01I use recursive solution to solve the problem.\\n\\n    public int sumNumbers(TreeNode root) {\\n\\t\\treturn sum(root, 0);\\n\\t}\\n\\t\\n\\tpublic int sum(TreeNode n, int s){\\n\\t\\tif (n == null) return 0;\\n\\t\\tif (n.right == null && n.left == null) return s*10 + n.val;\\n\\t\\treturn sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);\\n\\t}",
                "solutionTags": [],
                "code": "\\x01I use recursive solution to solve the problem.\\n\\n    public int sumNumbers(TreeNode root) {\\n\\t\\treturn sum(root, 0);\\n\\t}\\n\\t\\n\\tpublic int sum(TreeNode n, int s){\\n\\t\\tif (n == null) return 0;\\n\\t\\tif (n.right == null && n.left == null) return s*10 + n.val;\\n\\t\\treturn sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1556417,
                "title": "c-python-recursive-iterative-dfs-bfs-morris-traversal-o-1-beats-100",
                "content": "We are given a binary tree consisting of nodes with digit values. We need to consider every possible root-to-leaf path. Each of these path represent a number. We need to return the total sum of all the number represented by each of these paths.\\n\\n---\\n\\n\\u2714\\uFE0F **Solution - I (Recursive DFS - Preorder)**\\n\\nWe can intuitively see that a DFS solution will fit well here since we traverse from root to leaf in a DFS traversal and thus we can use it to form number represented by each root-to-leaf path. In DFS traversal -\\n* We start at the root with current number `cur = 0`. \\n* Every time, the current node\\'s digit will be appended to `cur` from root to leaf and we recurse for left and right child.\\n* If we reach a leaf node (a node not having any left or right child), we have formed the complete root-to-leaf number. We will then add this number `cur` to the overall sum.\\n\\nSum = 0, Cur = 4             |  Sum = 0, Cur = 49 | Sum = 495, Cur = 495 |  Sum = 986, Cur = 491 |  Sum = 1026, Cur = 40 |\\n:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:\\n<img src = \"https://assets.leetcode.com/users/images/a5b455fb-e770-4524-a184-74bf2706a4ea_1635906783.6132123.png\" width=\"250\"/>  |  <img src = \"https://assets.leetcode.com/users/images/0ee98d35-30fb-4861-9700-85570c479cee_1635906909.2482471.png\" width=\"250\"/>  | <img src = \"https://assets.leetcode.com/users/images/7561acf8-a3d6-4168-a053-962c1361b9e6_1635906994.7047894.png\" width=\"250\"/> | <img src = \"https://assets.leetcode.com/users/images/1e46e1e7-1b90-4d10-8d65-ab0a29c1a284_1635907048.6978989.png\" width=\"250\"/> | <img src = \"https://assets.leetcode.com/users/images/0eea2cdb-7d3b-4920-975b-26e027d96325_1635907121.5094054.png\" width=\"250\"/>\\n\\n<iframe src=\"https://leetcode.com/playground/AQ2Gx6hC/shared\" frameBorder=\"0\" width=100% height=380></iframe>\\n\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the tree. We are doing a standard DFS traversal which takes `O(N)` time\\n***Space Complexity :*** **`O(H)`**, where `H` is the maximum depth of tree. This space is required for implicit recursive stack space. In the worst case, the tree maybe skewed and `H = N` in which case space required is equal to `O(N)`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative DFS - preorder)***\\n\\nThe same as above but converted to iterative solution using an explicit stack. The working and complexities should be about the same for both the solutions. But, an interviewer may ocassionally ask to implement iterative version, so it\\'s good to know this as well.\\n\\n<iframe src=\"https://leetcode.com/playground/bv9YkhoL/shared\" frameBorder=\"0\" width=100% height=\"330\"></iframe>\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the tree. We are doing a standard DFS traversal which takes `O(N)` time\\n***Space Complexity :*** **`O(H)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BFS)***\\n\\nThe problem doesn\\'t intuitively fall under BFS but it can be solved using this traversal approach as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        while(q.size()) {\\n            auto [n, cur] = q.front(); q.pop();\\n            cur = cur * 10 + n -> val;\\n            if(n -> left) q.push({n -> left, cur});      \\n            if(n -> right) q.push({n -> right, cur});\\n            if(!n -> left && !n -> right) sum += cur;   // add to total sum if we are at leaf node\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**, standard time complexity of a BFS. Each node is only visited once.\\n***Space Complexity :*** **`O(N)`**, atmost `(N+1)/2` elements will be stored in queue in case of complete binary tree.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Morris Traversal - Preorder)***\\n\\nThis solution involves using the morris traversal technique to solve the problem. The advantage of this traversal is that we can traverse the tree in O(1) space complexity. The basic idea is to link predecessors to root nodes so we can trace it back once we have traversed a side without need of using a stack. It\\'s a bit hard to explain in words so I have attached an image of how it works below. You can also find some good explanation **[here](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)**.\\n\\n| Morris Traversal Steps           | \\n| :-------------------------: |\\n| <img src=\"https://assets.leetcode.com/users/images/0f71f814-93c8-4fdb-b240-f397b12201a1_1635917043.0594902.jpeg\" height=\"600\"/> |\\n\\n\\n\\n<iframe src=\"https://leetcode.com/playground/JfeqynTR/shared\" frameBorder=\"0\" width=100% height=550></iframe>\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        while(q.size()) {\\n            auto [n, cur] = q.front(); q.pop();\\n            cur = cur * 10 + n -> val;\\n            if(n -> left) q.push({n -> left, cur});      \\n            if(n -> right) q.push({n -> right, cur});\\n            if(!n -> left && !n -> right) sum += cur;   // add to total sum if we are at leaf node\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41383,
                "title": "python-solutions-dfs-stack-bfs-queue-dfs-recursively",
                "content": "```\\nclass Solution(object):\\n    def sumNumbers1(self, root): # DFS recursively \\n        self.res = 0\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if root:\\n            if not root.left and not root.right:\\n                path = path*10 + root.val\\n                self.res += path\\n            self.dfs(root.left, path*10+root.val)\\n            self.dfs(root.right, path*10+root.val)\\n            \\n    def sumNumbers2(self, root): # BFS with queue\\n        deque, res = collections.deque(), 0\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            node = deque.popleft()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.left:\\n                node.left.val += node.val*10\\n                deque.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                deque.append(node.right)\\n        return res\\n    \\n    def sumNumbers(self, root): # DFS with stack\\n        stack, res = [], 0\\n        if root:\\n            stack.append(root)\\n        while stack:\\n            node = stack.pop()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.right:\\n                node.right.val += node.val*10\\n                stack.append(node.right)\\n            if node.left:\\n                node.left.val += node.val*10\\n                stack.append(node.left)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumNumbers1(self, root): # DFS recursively \\n        self.res = 0\\n        self.dfs(root, 0)\\n        return self.res\\n    \\n    def dfs(self, root, path):\\n        if root:\\n            if not root.left and not root.right:\\n                path = path*10 + root.val\\n                self.res += path\\n            self.dfs(root.left, path*10+root.val)\\n            self.dfs(root.right, path*10+root.val)\\n            \\n    def sumNumbers2(self, root): # BFS with queue\\n        deque, res = collections.deque(), 0\\n        if root:\\n            deque.append(root)\\n        while deque:\\n            node = deque.popleft()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.left:\\n                node.left.val += node.val*10\\n                deque.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                deque.append(node.right)\\n        return res\\n    \\n    def sumNumbers(self, root): # DFS with stack\\n        stack, res = [], 0\\n        if root:\\n            stack.append(root)\\n        while stack:\\n            node = stack.pop()\\n            if not node.left and not node.right:\\n                res += node.val\\n            if node.right:\\n                node.right.val += node.val*10\\n                stack.append(node.right)\\n            if node.left:\\n                node.left.val += node.val*10\\n                stack.append(node.left)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41531,
                "title": "clean-java-dfs-solution-preorder-traversal",
                "content": "    public class Solution {\\n        int total;\\n        \\n        public int sumNumbers(TreeNode root) {\\n            total = 0;\\n            helper(root, 0);\\n            return total;\\n        }\\n        \\n        void helper(TreeNode root, int sum) {\\n            if (root == null) return;\\n            \\n            sum = sum * 10 + root.val;\\n            \\n            if (root.left == null && root.right == null) {\\n                total += sum;\\n                return;\\n            }\\n            \\n            helper(root.left, sum);\\n            helper(root.right, sum);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        int total;\\n        \\n        public int sumNumbers(TreeNode root) {\\n            total = 0;\\n            helper(root, 0);\\n            return total;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3294054,
                "title": "java-easy-recursion-with-explanation",
                "content": "**Basically we are just taking sum as a global variable. Then we are just traversing the tree using preorder traversal. What can be our base cases?? So one thing we can know that if we get node\\'s value as null then we will simply return it .The second base condition is if we find left and right of the node to be null then we simply add it to our global variable sum by converting the string to integer. If the node is not null and the left and right of that node is not null then we simply concatenate the node\\'s val to the string. This recursive process continues and atlast we get our sum.**\\n```\\nclass Solution {\\n    int sum=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String str){\\n        if(root==null){\\n            return;\\n        }\\n        str+=root.val;\\n        if(root.left==null && root.right==null){\\n            sum+=Integer.parseInt(str);\\n            return;\\n        }\\n        helper(root.left,str);\\n        helper(root.right,str);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/38d4b216-38c7-4a68-bd64-bf483ca0bdb8_1678756977.3545482.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int sum=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,\"\");\\n        return sum;\\n    }\\n    public void helper(TreeNode root,String str){\\n        if(root==null){\\n            return;\\n        }\\n        str+=root.val;\\n        if(root.left==null && root.right==null){\\n            sum+=Integer.parseInt(str);\\n            return;\\n        }\\n        helper(root.left,str);\\n        helper(root.right,str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555940,
                "title": "c-easy-clean-solution-fastest-0ms-1-liner-dfs-detailed-explanation-dry-run",
                "content": "##### Method: DFS [T(n) = O(n) and S(n) = O(H) [recursion stack space]]\\nIdea is to use DFS (Top Down) and generate number (starting with 0) going root to leaf. At each level, we have: `currNum = prevNum * 10 + root->val`. We compute this number for both left and right subtrees and finally return the sum of both subtree numbers.\\n*Base case:* `root->left == root->right` (only possbile for leaf node).\\n\\n##### Dry Run:\\n```\\nSuppose Binary Tree is:\\n\\t\\t1\\n\\t  /    \\\\\\n\\t2       3\\n\\t\\t  /\\n\\t\\t4\\nLet func. name be DFS (for explaination only).\\nDFS(1) = DFS(2, 1) + DFS(3, 1)\\nDFS(2, 1) = 10 + 2 = 12     // Base case\\nDFS(3, 1) = DFS(4, 10 + 3) + 0 = DFS(4, 13)\\nDFS(4, 13) = 130 + 4 = 134    // Base Case\\n=> DFS(1) = 12 + 134 = 146\\n```\\n\\n**NOTE:** \\n1. Below code (sumNumbers func. implementation) is actually 1 liner, Only for readability, I have presented it in 3 lines.\\n2. This problem is a perfect example of how we can use already known solution(s) to solve a new problem. The below solution is very similar to 4th Nov 2021 Daily LC Challenge [here](https://leetcode.com/problems/sum-of-left-leaves/discuss/1558669/c-easy-clean-solution-fastest-0ms-1-liner-dfs-detailed-explanation-dry-run) on leetcode.\\n\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int num=0) {\\n        return root->left == root->right ? num * 10 + root->val :\\n            ((root->left ? sumNumbers(root->left, num * 10 + root->val) : 0) + \\n            (root->right ? sumNumbers(root->right, num * 10 + root->val) : 0));\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nSuppose Binary Tree is:\\n\\t\\t1\\n\\t  /    \\\\\\n\\t2       3\\n\\t\\t  /\\n\\t\\t4\\nLet func. name be DFS (for explaination only).\\nDFS(1) = DFS(2, 1) + DFS(3, 1)\\nDFS(2, 1) = 10 + 2 = 12     // Base case\\nDFS(3, 1) = DFS(4, 10 + 3) + 0 = DFS(4, 13)\\nDFS(4, 13) = 130 + 4 = 134    // Base Case\\n=> DFS(1) = 12 + 134 = 146\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int num=0) {\\n        return root->left == root->right ? num * 10 + root->val :\\n            ((root->left ? sumNumbers(root->left, num * 10 + root->val) : 0) + \\n            (root->right ? sumNumbers(root->right, num * 10 + root->val) : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41400,
                "title": "can-you-improve-this-algorithm",
                "content": "    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            return sumR(root, 0);\\n        }\\n        public int sumR(TreeNode root, int x) {\\n            if (root.right == null && root.left == null)\\n                return 10 * x + root.val;\\n            int val = 0;\\n            if (root.left != null)\\n                val += sumR(root.left, 10 * x + root.val);\\n            if (root.right != null)\\n                val += sumR(root.right, 10 * x + root.val);\\n            return val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            return sumR(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3294304,
                "title": "image-explanation-3-methods-recursive-bfs-o-1-space-morris-traversal-preorder",
                "content": "# Video Solution\\nhttps://youtu.be/fkqobtlcF9A\\n\\n# Intuition & Approach\\nMethod1: Recursive Approach O(N) Space\\nMethod2: Iterative Approach-BFS O(N) Space\\nMethod3: Morris Traversal O(1) Space\\n\\n![image.png](https://assets.leetcode.com/users/images/791a0ae6-6dd4-49e1-8aa4-ab057b902480_1678764496.115488.png)\\n![image.png](https://assets.leetcode.com/users/images/07ad840f-5051-43a6-9d3a-3991320f9193_1678764507.0180266.png)\\n![image.png](https://assets.leetcode.com/users/images/468212b6-faa5-4b31-8724-5c946ffcac84_1678764518.7442815.png)\\n![image.png](https://assets.leetcode.com/users/images/7ca968bd-69d1-4851-b631-cc17ea7c612c_1678764529.2572453.png)\\n![image.png](https://assets.leetcode.com/users/images/3a21daec-db21-41c8-bab4-62dabec54e66_1678764537.1934292.png)\\n![image.png](https://assets.leetcode.com/users/images/8f9b9265-f935-4042-93d8-574865099acd_1678764556.4629147.png)\\n![image.png](https://assets.leetcode.com/users/images/7b79be39-a4b4-4f04-beb8-3d4406cc6ea4_1678764564.5119863.png)\\n![image.png](https://assets.leetcode.com/users/images/07fa78c3-8abd-4a6f-a47f-da73f2a0068a_1678764575.7467487.png)\\n![image.png](https://assets.leetcode.com/users/images/0a359d0f-6ec8-4bcf-9041-23e4176bb5c5_1678764600.991705.png)\\n![image.png](https://assets.leetcode.com/users/images/c61dc4c8-20c9-4ff9-b222-dbc90ea880e2_1678764614.2367642.png)\\n![image.png](https://assets.leetcode.com/users/images/8f51bc34-69f4-42d6-9cd9-601b9bc6799d_1678764646.0626986.png)\\n![image.png](https://assets.leetcode.com/users/images/f368550f-ff3a-4d7d-b6b7-2a0b933b83cb_1678764656.7012725.png)\\n![image.png](https://assets.leetcode.com/users/images/1d9d6cec-6793-43a1-8a64-a210aca83b6e_1678764664.9558482.png)\\n![image.png](https://assets.leetcode.com/users/images/ff894ab9-9cfa-4a76-9768-50a61e5e796c_1678764673.095142.png)\\n![image.png](https://assets.leetcode.com/users/images/fb8be609-c2b5-466d-ba22-2b76ec4a3e8c_1678764684.9639466.png)\\n![image.png](https://assets.leetcode.com/users/images/ecf6b892-28bc-44aa-9c9e-6a9651e00e51_1678766505.5274205.png)\\n\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int currentSum = 0;\\n        return sumNodes(root, currentSum);\\n    }\\n\\n    int sumNodes(TreeNode* root, int currentSum){\\n        if(root == NULL) return 0;\\n        currentSum = currentSum * 10 + root->val;\\n        if(root->left==NULL && root->right==NULL) return currentSum;\\n\\n        int leftSum = sumNodes(root->left, currentSum);\\n        int rightSum = sumNodes(root->right, currentSum);\\n        return leftSum + rightSum; \\n    }\\n};\\n```\\n\\n# Iterative Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum = 0;\\n        queue<pair<TreeNode*, int>> q; // <TreeNode*, sumSoFar>\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            auto [root, currentSum] = q.front(); q.pop();\\n            currentSum = currentSum*10 + root->val;\\n            if(root->left==NULL && root->right==NULL) totalSum += currentSum;\\n\\n            if(root->left) q.push({root->left, currentSum});\\n            if(root->right) q.push({root->right, currentSum});\\n        }\\n        return totalSum;\\n    }\\n};\\n```\\n\\n# Morris Traversal - Preorder Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        TreeNode *cur = root;\\n        int totalSum=0, currentSum=0, depth=0;\\n        while(cur != NULL){\\n            if(cur->left == NULL){ // left side is not there\\n                currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                if(cur->right == NULL) totalSum += currentSum;\\n                cur = cur->right;\\n            }else{ // left side is there (explore it) \\n                TreeNode *prev = cur->left;\\n                depth=1;\\n                while(prev->right && prev->right!=cur) prev = prev->right, depth++;\\n\\n                if(prev->right == NULL){ // Root\\'s Left\\'s Rightmost node has no attachments (means first time visit)\\n                    prev->right = cur;\\n                    currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                    cur = cur->left;\\n                }else{ // Root\\'s Left\\'s Rightmost node has threaded attachments (means Root\\'s Left Visited already)\\n                    prev->right = NULL;\\n                    if(prev->left == NULL) totalSum += currentSum; // that node is being visited last time\\n                    currentSum = currentSum/pow(10, depth);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int currentSum = 0;\\n        return sumNodes(root, currentSum);\\n    }\\n\\n    int sumNodes(TreeNode* root, int currentSum){\\n        if(root == NULL) return 0;\\n        currentSum = currentSum * 10 + root->val;\\n        if(root->left==NULL && root->right==NULL) return currentSum;\\n\\n        int leftSum = sumNodes(root->left, currentSum);\\n        int rightSum = sumNodes(root->right, currentSum);\\n        return leftSum + rightSum; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum = 0;\\n        queue<pair<TreeNode*, int>> q; // <TreeNode*, sumSoFar>\\n        q.push({root, 0});\\n\\n        while(!q.empty()){\\n            auto [root, currentSum] = q.front(); q.pop();\\n            currentSum = currentSum*10 + root->val;\\n            if(root->left==NULL && root->right==NULL) totalSum += currentSum;\\n\\n            if(root->left) q.push({root->left, currentSum});\\n            if(root->right) q.push({root->right, currentSum});\\n        }\\n        return totalSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        TreeNode *cur = root;\\n        int totalSum=0, currentSum=0, depth=0;\\n        while(cur != NULL){\\n            if(cur->left == NULL){ // left side is not there\\n                currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                if(cur->right == NULL) totalSum += currentSum;\\n                cur = cur->right;\\n            }else{ // left side is there (explore it) \\n                TreeNode *prev = cur->left;\\n                depth=1;\\n                while(prev->right && prev->right!=cur) prev = prev->right, depth++;\\n\\n                if(prev->right == NULL){ // Root\\'s Left\\'s Rightmost node has no attachments (means first time visit)\\n                    prev->right = cur;\\n                    currentSum = currentSum * 10 + cur->val; // preorder(cur->val)\\n                    cur = cur->left;\\n                }else{ // Root\\'s Left\\'s Rightmost node has threaded attachments (means Root\\'s Left Visited already)\\n                    prev->right = NULL;\\n                    if(prev->left == NULL) totalSum += currentSum; // that node is being visited last time\\n                    currentSum = currentSum/pow(10, depth);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306331,
                "title": "simple-and-easy-way",
                "content": "# Approach\\nThe problem can be solved using a recursive approach. We can traverse the binary tree using a pre-order traversal and concatenate the node values into a string. When we reach a leaf node, we can add the string as an integer to our running sum. We repeat this process for each root-to-leaf path in the tree.\\n\\n# Complexity\\n- *Time complexity:*\\nO(n), where n is the number of nodes in the binary tree. We visit each node once.\\n\\n- *Space complexity:*\\n O(h), where h is the height of the binary tree. This is the maximum depth of our recursive stack. In the worst case, where the tree is a linked list, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root, string str){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            str += to_string(root->val);\\n            sum += stoi(str);\\n            return;\\n        }\\n        str += to_string(root->val);\\n\\n        solve(root->left, str);\\n        solve(root->right, str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str = \"\";\\n        solve(root, str);\\n        return sum;\\n    }\\n};\\n```\\n- If you like my solution then don\\'t forget to upvote it :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    void solve(TreeNode* root, string str){\\n        if(!root) return;\\n        if(!root->left && !root->right){\\n            str += to_string(root->val);\\n            sum += stoi(str);\\n            return;\\n        }\\n        str += to_string(root->val);\\n\\n        solve(root->left, str);\\n        solve(root->right, str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str = \"\";\\n        solve(root, str);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555847,
                "title": "java-tc-o-n-sc-o-treeheight-3-simple-dfs-solutions-recursive-iterative",
                "content": "This is a classic DFS (Depth-First Search) problem. Here we have to explore all paths starting from Root Node to each Leaf Node.\\n\\n**Recursive DFS Solution**\\n```java\\n/**\\n * Recursive DFS Solution\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return sumNumbersHelper(root, 0);\\n    }\\n\\n    private int sumNumbersHelper(TreeNode node, int curVal) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        curVal = curVal * 10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return curVal;\\n        }\\n\\n        return sumNumbersHelper(node.left, curVal) + sumNumbersHelper(node.right, curVal);\\n    }\\n}\\n```\\n\\n---\\n**Iterative Post-Order Traversal**\\n```java\\n/**\\n * Iterative Post-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        int curVal = 0;\\n        int sum = 0;\\n\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                curVal = curVal * 10 + cur.val;\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n\\n            cur = stack.peek();\\n            if (cur.right != null && cur.right != pre) {\\n                cur = cur.right;\\n                continue;\\n            }\\n\\n            if (cur.right == null && cur.left == null) {\\n                sum += curVal;\\n            }\\n\\n            pre = stack.pop();\\n            curVal /= 10;\\n            cur = null;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n\\n---\\n**Iterative Pre-Order Traversal**\\n\\n```java\\n/**\\n * Iterative Pre-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\n/**\\n * Recursive DFS Solution\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return sumNumbersHelper(root, 0);\\n    }\\n\\n    private int sumNumbersHelper(TreeNode node, int curVal) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        curVal = curVal * 10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return curVal;\\n        }\\n\\n        return sumNumbersHelper(node.left, curVal) + sumNumbersHelper(node.right, curVal);\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Post-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        TreeNode pre = null;\\n        int curVal = 0;\\n        int sum = 0;\\n\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                curVal = curVal * 10 + cur.val;\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n\\n            cur = stack.peek();\\n            if (cur.right != null && cur.right != pre) {\\n                cur = cur.right;\\n                continue;\\n            }\\n\\n            if (cur.right == null && cur.left == null) {\\n                sum += curVal;\\n            }\\n\\n            pre = stack.pop();\\n            curVal /= 10;\\n            cur = null;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Pre-Order Traversal\\n *\\n * Time Complexity: O(N). Each node is visited once.\\n *\\n * Space Complexity: O(H). Stack space.\\n * In case of balanced tree (best case) it will be O(log N) and in case of Skewed Tree (worst case) it will be O(N)\\n *\\n * N = Total number of nodes in the tree. H = Height of the tree.\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555932,
                "title": "c-recursive-and-iterative-simple-explanation-100-faster-o-n",
                "content": "**Problem statement :** We have to find the sum of all the root to leaf number nodes.\\n\\n**Approach**\\n1.Recursive\\n2.Iterative\\n\\n**Time and space complexity**\\n1. Recursive :  Time complexity: O(N)  Auxiliary space: O(H)  H-> height of tree\\n2. Iterative : Time Complexity: O(N)  Space complexity: O(N) ->Stack\\n\\n**Recursive**\\n# Digramatical representation\\n![image](https://assets.leetcode.com/users/images/43858b45-c24a-499e-974e-f815b0156226_1635901771.7337537.png)\\n![image](https://assets.leetcode.com/users/images/39588670-34c9-43a2-b4de-f1adc7e47e69_1635901846.167564.png)\\n![image](https://assets.leetcode.com/users/images/1c0e94a7-d2b5-4aee-95e2-2cbb38edee1b_1635901895.8840768.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int temp ,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        temp=temp*10+root->val;\\n        //If reached the last node\\n        if(root->left==NULL and root->right==NULL){\\n            ans+=temp;\\n        }\\n        findSum(root->left,temp,ans);\\n        findSum(root->right,temp,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        //Output\\n        int ans=0;\\n        findSum(root,0,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Iterative**\\n# Diagramatical representation\\n![image](https://assets.leetcode.com/users/images/28a5ee8f-cb28-484c-918c-342bc99d6cf8_1635902017.2172806.png)\\n![image](https://assets.leetcode.com/users/images/d5da6674-a394-40c9-aaa5-e21041652e1a_1635902096.774102.png)\\n![image](https://assets.leetcode.com/users/images/fa5c6344-2628-4208-ad41-705ef2e5f013_1635902145.8339965.png)\\n![image](https://assets.leetcode.com/users/images/4e64de9d-5368-4d0a-b937-a92f8c5706cb_1635902183.3103824.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum=0;\\n        stack<pair<TreeNode*,int>> stck;\\n        stck.push({root,0});\\n        while(!stck.empty()){\\n            pair<TreeNode*,int> p=stck.top();\\n            stck.pop();\\n            TreeNode* cur_node=p.first;\\n            int cur_sum=p.second;\\n            if(cur_node!=NULL){\\n                cur_sum=cur_sum*10+cur_node->val;\\n                if(cur_node->left==NULL and cur_node->right==NULL){\\n                    totalSum+=cur_sum;\\n                }\\n                else{\\n                    if(cur_node->right){\\n                        stck.push({cur_node->right,cur_sum});\\n                    }\\n                    if(cur_node->left){\\n                        stck.push({cur_node->left,cur_sum});\\n                    }\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```\\n\\nThank you so much for reading my article, if you like then please like and share.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSum(TreeNode* root, int temp ,int &ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        temp=temp*10+root->val;\\n        //If reached the last node\\n        if(root->left==NULL and root->right==NULL){\\n            ans+=temp;\\n        }\\n        findSum(root->left,temp,ans);\\n        findSum(root->right,temp,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        //Output\\n        int ans=0;\\n        findSum(root,0,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int totalSum=0;\\n        stack<pair<TreeNode*,int>> stck;\\n        stck.push({root,0});\\n        while(!stck.empty()){\\n            pair<TreeNode*,int> p=stck.top();\\n            stck.pop();\\n            TreeNode* cur_node=p.first;\\n            int cur_sum=p.second;\\n            if(cur_node!=NULL){\\n                cur_sum=cur_sum*10+cur_node->val;\\n                if(cur_node->left==NULL and cur_node->right==NULL){\\n                    totalSum+=cur_sum;\\n                }\\n                else{\\n                    if(cur_node->right){\\n                        stck.push({cur_node->right,cur_sum});\\n                    }\\n                    if(cur_node->left){\\n                        stck.push({cur_node->left,cur_sum});\\n                    }\\n                }\\n            }\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293880,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the sum of all root-to-leaf paths in the binary tree, where each root-to-leaf path represents a number. To do this, we can traverse the tree in a depth-first manner, keeping track of the current number formed by the path from the root to the current node. When we reach a leaf node, we add the current number to our running sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a recursive approach to traverse the tree. We start with the root node and a current number of 0. At each node, we multiply the current number by 10 and add the node\\'s value to get the new current number. If the current node is a leaf node, we add the current number to our running sum. Otherwise, we recursively traverse the left and right subtrees, passing the new current number to each.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nWe visit each node exactly once, so the time complexity is $$O(n)$$, where n is the number of nodes in the tree.\\n- Space complexity:\\nThe space complexity is $$O(h)$$, where h is the height of the tree, due to the recursive calls on the function call stack. In the worst case, the tree is a skewed tree with a height of n, resulting in a space complexity of $$O(n)$$. However, in the best case, the tree is a balanced tree with a height of log n, resulting in a space complexity of O(log n).\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        return self.dfs(root, 0)\\n    \\n    def dfs(self, root, sum):\\n        if not root:\\n            return 0\\n        sum = sum * 10 + root.val\\n        if not root.left and not root.right:\\n            return sum\\n        return self.dfs(root.left, sum) + self.dfs(root.right, sum)\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41566,
                "title": "5-ms-c-code-using-dfs",
                "content": "    class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n            if(!root)\\n                return 0;\\n            sum=0;\\n            DFS(root, 0);\\n            return sum;\\n        }\\n        \\n        void DFS(TreeNode *&node, int currentSum)\\n        {\\n            currentSum=currentSum*10+node->val;\\n            if(!node->left&&!node->right)\\n                sum+=currentSum;\\n            if(node->left)\\n                DFS(node->left, currentSum);\\n            if(node->right)\\n                DFS(node->right, currentSum);\\n        }\\n    private:\\n        int sum;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n            if(!root)\\n                return 0;\\n            sum=0;\\n            DFS(root, 0);\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1508493,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nint sumNumbersHelper(TreeNode* root, int sum)\\n{\\n\\tif(!root)\\n\\t\\treturn 0;\\n\\n\\tsum = sum * 10 + root -> val;\\n\\n\\tif(!root -> left && !root -> right)\\n\\t\\treturn sum;\\n\\n\\treturn sumNumbersHelper(root -> left, sum) + sumNumbersHelper(root -> right, sum);\\n}\\n\\nint sumNumbers(TreeNode* root) {\\n\\treturn sumNumbersHelper(root, 0);\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint sumNumbersHelper(TreeNode* root, int sum)\\n{\\n\\tif(!root)\\n\\t\\treturn 0;\\n\\n\\tsum = sum * 10 + root -> val;\\n\\n\\tif(!root -> left && !root -> right)\\n\\t\\treturn sum;\\n\\n\\treturn sumNumbersHelper(root -> left, sum) + sumNumbersHelper(root -> right, sum);\\n}\\n\\nint sumNumbers(TreeNode* root) {\\n\\treturn sumNumbersHelper(root, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41367,
                "title": "non-recursive-preorder-traverse-java-solution",
                "content": "    \\n    public class Solution {\\n            public int sumNumbers(TreeNode root) {\\n                if(root==null){\\n                    return 0;\\n                }\\n                int sum = 0;\\n                TreeNode curr;\\n                Stack<TreeNode> ws = new Stack<TreeNode>();\\n                ws.push(root);\\n                \\n                while(!ws.empty()){\\n                    curr = ws.pop();\\n                    \\n                    if(curr.right!=null){\\n                        curr.right.val = curr.val*10+curr.right.val;\\n                        ws.push(curr.right);\\n                    }\\n                    \\n                    if(curr.left!=null){\\n                        curr.left.val = curr.val*10+curr.left.val;\\n                        ws.push(curr.left);\\n                    }\\n                    \\n                    if(curr.left==null && curr.right==null){ // leaf node\\n                        sum+=curr.val;\\n                    }\\n                }\\n                return sum;\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n            public int sumNumbers(TreeNode root) {\\n                if(root==null){\\n                    return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3294242,
                "title": "c-recursive-100-beat-easy-o-n",
                "content": "# Intuition\\nwe need to visit leaf node and creating number from the root to leaf node , we need search for a leaf node and creating a number their digits, and need to repeat for all root to leaf node , At last we need to add all root to leaf created number.\\n\\n# Approach\\nTo find out the leaf node , simply traverse in preoder way (root, left,right) and when ever we find root->left == NULL and root->right==NULL , we can say that it is our leaf node , by preoder traversal we will be getting from root node to left leaf node, same goes goes for right one , After  getting one root to leaf node we will add to our final answer. When recursion comes back we are not considering value of their initial time not the updated one.\\n\\nUPVOTE if you read it!!! \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(H) hight of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n\\n    void dfs(TreeNode *root, ll &ans , ll tmp){\\n        if(root->left== NULL && root->right==NULL){\\n            tmp = tmp*10 + root->val;\\n            ans+=tmp;\\n            return;\\n        }\\n        tmp = tmp*10 + root->val;\\n        if(root->left) dfs(root->left,ans,tmp);\\n        if(root->right) dfs(root->right,ans,tmp);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        ll ans =0;\\n        dfs(root,ans,0);\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n #define ll long long\\nclass Solution {\\npublic:\\n\\n    void dfs(TreeNode *root, ll &ans , ll tmp){\\n        if(root->left== NULL && root->right==NULL){\\n            tmp = tmp*10 + root->val;\\n            ans+=tmp;\\n            return;\\n        }\\n        tmp = tmp*10 + root->val;\\n        if(root->left) dfs(root->left,ans,tmp);\\n        if(root->right) dfs(root->right,ans,tmp);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        ll ans =0;\\n        dfs(root,ans,0);\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41603,
                "title": "one-of-the-easier-solution-using-preorder-traversal-recursion",
                "content": "**The idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be val. For every node, we update the val as val*10 plus node\\u2019s data.**\\n\\n\\n    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n           return  sumNumberUtil(root,0);\\n            \\n        }\\n        // preorder\\n        int sumNumberUtil(struct TreeNode* node, int val)\\n        {\\n            if(node==NULL)\\n            return 0;\\n            \\n            val= val*10+node->val;\\n            if(node->left==NULL && node->right==NULL)\\n            {\\n                return val;\\n            }\\n            \\n            return sumNumberUtil(node->left,val)+sumNumberUtil(node->right, val);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode *root) {\\n           return  sumNumberUtil(root,0);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 706982,
                "title": "c-4-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int sum = 0) {\\n        if(!root) return 0;\\n        sum = sum*10 + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumNumbers(root->left, sum) + sumNumbers(root->right, sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root, int sum = 0) {\\n        if(!root) return 0;\\n        sum = sum*10 + root->val;\\n        if(!root->left && !root->right) return sum;\\n        return sumNumbers(root->left, sum) + sumNumbers(root->right, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556690,
                "title": "c-short-explained-solution-dfs-100-faster",
                "content": "\\nI promise I did not read any other solutions when writing my code.\\nThe Idea:\\nThere is a function DFS, depth-first-search, and it does...\\n* If ```current == NULL``` return as you cannot do anything.\\n* If ```current->left == NULL && current->right == NULL``` there are no children. We will then do ```total += current->val```.\\n* Else, recurse ```DFS(current->left, value*10+current->val)``` and ```DFS(current->right, value*10+current->val)```.\\n\\nTime Complexity --> O(N), N is the number nodes in the tree.\\nSpace Complexity --> O(1).\\n\\n**Test Run:**\\n```\\nLets say the tree is:\\n\\t\\t\\t4\\n\\t\\t  /   \\\\\\n\\t\\t9      0\\n\\t             \\\\\\n\\t\\t\\t\\t  1\\nDFS(4, 0) runs DFS(9, 4) + DFS(0, 4).\\nDFS(9, 4) adds 49 to total.\\nDFS(0, 4) adds runs DFS(NULL, 40) + DFS(1, 40).\\nDFS(NULL, 40) doesn\\'t do anything.\\nDFS(1, 40) adds 401 to total.\\nIn the total == 450.\\n```\\n**Note:** DFS is a void function.\\n```\\nclass Solution {\\npublic:\\n    \\n    //This is the output.\\n    int total = 0;\\n    \\n    void DFS(TreeNode* current, int value){\\n        //If current == NULL, return.\\n        if (current == NULL){\\n            return;\\n        }\\n        \\n        //If current has no children add value*10+current->val to total. Then return.\\n        if (current->left == NULL && current->right == NULL){\\n            total += current->val;\\n            total += value*10;\\n            return\\n        }\\n        \\n        //If not run DFS(current->left&right, (value*10)+current->val)\\n        DFS(current->left, (value*10)+current->val);\\n        DFS(current->right, (value*10)+current->val);  \\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        //Run DFS to change total.\\n        DFS(root, 0);\\n        //Return total.\\n        return total;\\n    }\\n};\\n```\\n\\u263AThanks for reading this! \\u263B\\n\\u2705 Please Upvote! \\u2705",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```current == NULL```\n```current->left == NULL && current->right == NULL```\n```total += current->val```\n```DFS(current->left, value*10+current->val)```\n```DFS(current->right, value*10+current->val)```\n```\\nLets say the tree is:\\n\\t\\t\\t4\\n\\t\\t  /   \\\\\\n\\t\\t9      0\\n\\t             \\\\\\n\\t\\t\\t\\t  1\\nDFS(4, 0) runs DFS(9, 4) + DFS(0, 4).\\nDFS(9, 4) adds 49 to total.\\nDFS(0, 4) adds runs DFS(NULL, 40) + DFS(1, 40).\\nDFS(NULL, 40) doesn\\'t do anything.\\nDFS(1, 40) adds 401 to total.\\nIn the total == 450.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    //This is the output.\\n    int total = 0;\\n    \\n    void DFS(TreeNode* current, int value){\\n        //If current == NULL, return.\\n        if (current == NULL){\\n            return;\\n        }\\n        \\n        //If current has no children add value*10+current->val to total. Then return.\\n        if (current->left == NULL && current->right == NULL){\\n            total += current->val;\\n            total += value*10;\\n            return\\n        }\\n        \\n        //If not run DFS(current->left&right, (value*10)+current->val)\\n        DFS(current->left, (value*10)+current->val);\\n        DFS(current->right, (value*10)+current->val);  \\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        //Run DFS to change total.\\n        DFS(root, 0);\\n        //Return total.\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41513,
                "title": "super-simple-dfs-solution",
                "content": "    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbers(root, 0);\\n        }\\n        \\n        private int sumNumbers(TreeNode root, int sum){\\n            if(root == null) return 0;\\n            if(root.left == null && root.right == null)\\n                return sum + root.val;\\n            \\n            return sumNumbers(root.left, (sum + root.val) * 10) + sumNumbers(root.right, (sum + root.val) * 10);\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbers(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41474,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // dfs recursively\\n    public int sumNumbers1(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode node, int path) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        path = path*10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return path;\\n        }\\n        return dfs(node.left, path) + dfs(node.right, path);\\n    }\\n    \\n    // import javafx.util.Pair;\\n    //dfs iteratively \\n    public int sumNumbers2(TreeNode root) {\\n        int ret = 0;\\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\\n        stack.push(new Pair(root, 0));\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> p = stack.pop();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value*10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                stack.push(new Pair(node.right, value));\\n                stack.push(new Pair(node.left, value));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // bfs iteratively \\n    public int sumNumbers(TreeNode root) {\\n        int ret = 0;\\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, 0));\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, Integer> p = queue.poll();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value * 10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                queue.add(new Pair(node.left, value));\\n                queue.add(new Pair(node.right, value));\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs recursively\\n    public int sumNumbers1(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    private int dfs(TreeNode node, int path) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        path = path*10 + node.val;\\n        if (node.left == null && node.right == null) {\\n            return path;\\n        }\\n        return dfs(node.left, path) + dfs(node.right, path);\\n    }\\n    \\n    // import javafx.util.Pair;\\n    //dfs iteratively \\n    public int sumNumbers2(TreeNode root) {\\n        int ret = 0;\\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\\n        stack.push(new Pair(root, 0));\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> p = stack.pop();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value*10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                stack.push(new Pair(node.right, value));\\n                stack.push(new Pair(node.left, value));\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // bfs iteratively \\n    public int sumNumbers(TreeNode root) {\\n        int ret = 0;\\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\\n        queue.add(new Pair(root, 0));\\n        while (!queue.isEmpty()) {\\n            Pair<TreeNode, Integer> p = queue.poll();\\n            TreeNode node = p.getKey();\\n            int value = p.getValue();\\n            if (node != null) {\\n                value = value * 10 + node.val;\\n                if (node.left == null && node.right == null) {\\n                    ret += value;\\n                }\\n                queue.add(new Pair(node.left, value));\\n                queue.add(new Pair(node.right, value));\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 706148,
                "title": "java-short-easy-solution-100-faster",
                "content": "Do Upvote if this helps\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return cal(0, root);\\n    }\\n    int cal(int curr, TreeNode root){\\n        if(root == null) return 0;\\n        curr = (10*curr) + root.val;\\n        if(root.left == null && root.right == null)  return curr;\\n        return cal(curr, root.left) + cal(curr, root.right);        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return cal(0, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41468,
                "title": "clean-python-solution",
                "content": "    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(sum, root):\\n            if not root:\\n                return 0   \\n            sum = sum * 10 + root.val\\n            if not root.left and not root.right:\\n                return sum\\n            return helper(sum, root.left) + helper(sum, root.right)\\n         \\n        return helper(0, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def sumNumbers(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def helper(sum, root):\\n            if not root:\\n                return 0   \\n            sum = sum * 10 + root.val\\n            if not root.left and not root.right:\\n                return sum\\n            return helper(sum, root.left) + helper(sum, root.right)\\n         \\n        return helper(0, root)",
                "codeTag": "Python3"
            },
            {
                "id": 1556357,
                "title": "java-simple-and-readable-solution-dfs",
                "content": "**Problem statement at a glance:** Given, a tree. We need to find the sum of all root to leaf paths.\\n**Approach:**\\n1) We need to go from root to leaf, and whenever we are at leaf, form a number and add it to your result.\\n2) This can be done with DFS Traversal. Because in DFS we traverse child nodes and we go deep.\\n**Pictorial Representation:**\\n![image](https://assets.leetcode.com/users/images/4e9a516b-e912-4e64-8094-851adbab83f1_1635917131.9978747.png)\\n\\n**Time Complexity:** As we are traversing each node once, the time complexity will be O(N), where N is number of nodes.\\n**Space Complexity:** It takes stack space, as we are doing recursion. So space complexity is O(H), where H is the height of tree.\\n**Code:**\\n```\\n\\nclass Solution {\\n    // A helper function to perform DFS\\n    public int sumNumbersHelper(TreeNode root,int sum)\\n    {\\n        // Base case: If the root is null, then it doesnt have any value. So sum is 0\\n        if(root==null)\\n        {\\n            return 0; \\n        }\\n        // If tree has only one node, then the sum is value itself\\n        if(root.left==null && root.right==null)\\n        {\\n            int temp=sum*10+root.val;\\n            return temp;\\n        }\\n        // Else we take the previous sum and move it to left by one digit and root.val should be on unit digit. This can be done as sum*10+root.val\\n        int temp=sum*10+root.val;\\n        // Call the left subtree and right subtree and return the sum of them.\\n        return sumNumbersHelper(root.left,temp)+sumNumbersHelper(root.right,temp);\\n     }\\n    public int sumNumbers(TreeNode root) {\\n      // Calling helper function to perform DFS\\n      return sumNumbersHelper(root,0);\\n    }\\n}\\n```\\nThanks for reading! Please upvote and comment if you got a clear idea:)\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    // A helper function to perform DFS\\n    public int sumNumbersHelper(TreeNode root,int sum)\\n    {\\n        // Base case: If the root is null, then it doesnt have any value. So sum is 0\\n        if(root==null)\\n        {\\n            return 0; \\n        }\\n        // If tree has only one node, then the sum is value itself\\n        if(root.left==null && root.right==null)\\n        {\\n            int temp=sum*10+root.val;\\n            return temp;\\n        }\\n        // Else we take the previous sum and move it to left by one digit and root.val should be on unit digit. This can be done as sum*10+root.val\\n        int temp=sum*10+root.val;\\n        // Call the left subtree and right subtree and return the sum of them.\\n        return sumNumbersHelper(root.left,temp)+sumNumbersHelper(root.right,temp);\\n     }\\n    public int sumNumbers(TreeNode root) {\\n      // Calling helper function to perform DFS\\n      return sumNumbersHelper(root,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297708,
                "title": "simple-dfs-using-python-by-akash-sinha",
                "content": "**Coder: Akash Sinha**\\n\\n# Intuition\\nAs we have to calculate the path of each leaf node so we have to use **DFS**, the **base condition** must be if both the left and right child of the node are **None**.\\n\\n# Approach\\nOnce the base condition is decided just apply simple DFS and keep on adding the node value in a string. Also make a copy of this string because while applying DFS we will give a recursive call on both left child and right child, so we will require **2 copies of string** for these **2 recursive calls**. Once the base condition is reached, just **append the string into a global list**. Finally the list will contain all the paths from root to leaf nodes. Run a loop on it and add the numbers and return the sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        global l\\n        l=[]\\n        def f(root,s):\\n            if(root is None):\\n                pass\\n            elif(root.left is None and root.right is None):\\n                s+=str(root.val)\\n                l.append(s)\\n            else:\\n                s+=str(root.val)\\n                s1=s[::]\\n                f(root.left,s)\\n                f(root.right,s1)\\n        f(root,\"\")\\n        ans=0\\n        for i in l:\\n            ans+=int(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        global l\\n        l=[]\\n        def f(root,s):\\n            if(root is None):\\n                pass\\n            elif(root.left is None and root.right is None):\\n                s+=str(root.val)\\n                l.append(s)\\n            else:\\n                s+=str(root.val)\\n                s1=s[::]\\n                f(root.left,s)\\n                f(root.right,s1)\\n        f(root,\"\")\\n        ans=0\\n        for i in l:\\n            ans+=int(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706461,
                "title": "javascript-2-clean-code-dfs-solutions",
                "content": "### Approach - 1 \\n```javascript\\nvar sumNumbers = function(root) {\\n    \\n    function traverse(node, num) {\\n        if(!node) return null;\\n        num += node.val\\n        if(!node.left && !node.right) return +num;\\n        return traverse(node.left, num) + traverse(node.right, num);\\n    }\\n    return traverse(root, \\'\\');\\n};\\n```\\n\\n### Approach - 2\\n```javascript\\nvar sumNumbers = function(root) {\\n    if(!root) return null;\\n    let sum = 0;\\n    \\n    function traverse(node, num) {\\n        num += node.val\\n        if(!node.left && !node.right) sum += +num;\\n        if(node.left) traverse(node.left, num)\\n        if(node.right) traverse(node.right, num);\\n    }\\n    traverse(root, \\'\\');\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sumNumbers = function(root) {\\n    \\n    function traverse(node, num) {\\n        if(!node) return null;\\n        num += node.val\\n        if(!node.left && !node.right) return +num;\\n        return traverse(node.left, num) + traverse(node.right, num);\\n    }\\n    return traverse(root, \\'\\');\\n};\\n```\n```javascript\\nvar sumNumbers = function(root) {\\n    if(!root) return null;\\n    let sum = 0;\\n    \\n    function traverse(node, num) {\\n        num += node.val\\n        if(!node.left && !node.right) sum += +num;\\n        if(node.left) traverse(node.left, num)\\n        if(node.right) traverse(node.right, num);\\n    }\\n    traverse(root, \\'\\');\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935362,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return sumNumbers(root, sum: 0)\\n    }\\n    \\n\\n    private func sumNumbers(_ root: TreeNode?, sum: Int) -> Int {\\n        guard let root = root else { return 0 }\\n\\n        if root.left == nil, root.right == nil {\\n            return 10 * sum + root.val\\n        }\\n\\n        return sumNumbers(root.left, sum: 10 * sum + root.val) + sumNumbers(root.right, sum: 10 * sum + root.val)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        return sumNumbers(root, sum: 0)\\n    }\\n    \\n\\n    private func sumNumbers(_ root: TreeNode?, sum: Int) -> Int {\\n        guard let root = root else { return 0 }\\n\\n        if root.left == nil, root.right == nil {\\n            return 10 * sum + root.val\\n        }\\n\\n        return sumNumbers(root.left, sum: 10 * sum + root.val) + sumNumbers(root.right, sum: 10 * sum + root.val)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555854,
                "title": "c-simple-and-clean-recursive-solution-explained",
                "content": "**Explanation:**\\nWe are using typical preorder traversal on a tree.\\nIn each node we visit, first we concatenate the value to the current number.\\nIf we are in a leaf, we add `curr` to the result.\\nOtherwise, we continue recursion with `curr`.\\n\\n**Time Complexity:** O(n), we visit each node exactly once.\\n**Space Complexity:** O(1) if we don\\'t consider recursion stack. With recursion call stack it\\'s O(height-of-tree).\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void rec(TreeNode* node, int curr) {\\n        if (!node) return;\\n        \\n        curr = curr * 10 + node->val;\\n        \\n        if (!node->left && !node->right) {\\n            res += curr;\\n            return;\\n        }\\n        \\n        rec(node->left, curr);\\n        rec(node->right, curr);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void rec(TreeNode* node, int curr) {\\n        if (!node) return;\\n        \\n        curr = curr * 10 + node->val;\\n        \\n        if (!node->left && !node->right) {\\n            res += curr;\\n            return;\\n        }\\n        \\n        rec(node->left, curr);\\n        rec(node->right, curr);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        rec(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297233,
                "title": "day-73-dfs-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nThe intuition behind the problem is to traverse the binary tree using a depth-first search (DFS) approach and keep track of the sum of the numbers formed so far along each path from the root to the leaf nodes.\\n\\nAs we traverse each path from the root to a leaf node, we can calculate the sum of the numbers formed by concatenating the values of each node along the path. We can then add this sum to a running total.\\n\\nOnce we have traversed all possible paths from the root to the leaf nodes, we will have accumulated the sum of all root-to-leaf paths in the binary tree. Finally, we can return this sum as the solution to the problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a helper function that takes in the current node, the total sum, and the sum till the current node.\\n2. If the current node is null, return.\\n3. Calculate the sum till the current node by multiplying the sum till the previous node by 10 and adding the value of the current node.\\n4. If the current node is a leaf node, add the sum till the current node to the total sum.\\n5. Recursively call the helper function for the left and right child of the current node with updated parameters.\\n6. Define the main function that initializes the total sum to 0 and calls the helper function with the root node and the total sum.\\n7. Return the total sum.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code:\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper (TreeNode *root, int &totalSum, int sumTillCurrNode) {\\n        if (root == nullptr)\\n            return; \\n        sumTillCurrNode = sumTillCurrNode * 10 + root -> val;\\n        if (root -> left == nullptr && root -> right == nullptr)\\n            totalSum += sumTillCurrNode;\\n        helper(root -> left, totalSum, sumTillCurrNode);\\n        helper(root -> right, totalSum, sumTillCurrNode);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        helper (root, sum, 0);\\n        return sum;\\n    }\\n};\\n```\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int[] totalSum = new int[1];\\n        helper(root, totalSum, 0);\\n        return totalSum[0];\\n    }\\n\\n    private void helper(TreeNode root, int[] totalSum, int sumTillCurrNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            totalSum[0] += sumTillCurrNode;\\n        }\\n        helper(root.left, totalSum, sumTillCurrNode);\\n        helper(root.right, totalSum, sumTillCurrNode);\\n    }\\n}\\n\\n```\\n```Python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        totalSum = [0]\\n        self.helper(root, totalSum, 0)\\n        return totalSum[0]\\n\\n    def helper(self, root: TreeNode, totalSum: List[int], sumTillCurrNode: int) -> None:\\n        if root is None:\\n            return\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val\\n        if root.left is None and root.right is None:\\n            totalSum[0] += sumTillCurrNode\\n        self.helper(root.left, totalSum, sumTillCurrNode)\\n        self.helper(root.right, totalSum, sumTillCurrNode)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the number of nodes in the tree. We need to visit every node in the worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the tree. This is the space used by the call stack during recursion, which can go up to the height of the tree. Where O(h) equals O(n) in the worst case and O(log(n)) in the best case.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper (TreeNode *root, int &totalSum, int sumTillCurrNode) {\\n        if (root == nullptr)\\n            return; \\n        sumTillCurrNode = sumTillCurrNode * 10 + root -> val;\\n        if (root -> left == nullptr && root -> right == nullptr)\\n            totalSum += sumTillCurrNode;\\n        helper(root -> left, totalSum, sumTillCurrNode);\\n        helper(root -> right, totalSum, sumTillCurrNode);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0;\\n        helper (root, sum, 0);\\n        return sum;\\n    }\\n};\\n```\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int[] totalSum = new int[1];\\n        helper(root, totalSum, 0);\\n        return totalSum[0];\\n    }\\n\\n    private void helper(TreeNode root, int[] totalSum, int sumTillCurrNode) {\\n        if (root == null) {\\n            return;\\n        }\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            totalSum[0] += sumTillCurrNode;\\n        }\\n        helper(root.left, totalSum, sumTillCurrNode);\\n        helper(root.right, totalSum, sumTillCurrNode);\\n    }\\n}\\n\\n```\n```Python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        totalSum = [0]\\n        self.helper(root, totalSum, 0)\\n        return totalSum[0]\\n\\n    def helper(self, root: TreeNode, totalSum: List[int], sumTillCurrNode: int) -> None:\\n        if root is None:\\n            return\\n        sumTillCurrNode = sumTillCurrNode * 10 + root.val\\n        if root.left is None and root.right is None:\\n            totalSum[0] += sumTillCurrNode\\n        self.helper(root.left, totalSum, sumTillCurrNode)\\n        self.helper(root.right, totalSum, sumTillCurrNode)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799054,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        stack<pair<TreeNode*, int>> s;      // {node, cur}\\n        s.push({root, 0});\\n        int sum = 0;\\n        while(!s.empty()) {\\n            auto [root, cur] = s.top(); s.pop();\\n            cur = cur * 10 + root -> val;\\n            if(!root -> left && !root -> right) sum += cur;  // reached leaf node\\n            if(root -> right) s.push({root -> right, cur});\\n            if(root -> left) s.push({root -> left, cur});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        stack<pair<TreeNode*, int>> s;      // {node, cur}\\n        s.push({root, 0});\\n        int sum = 0;\\n        while(!s.empty()) {\\n            auto [root, cur] = s.top(); s.pop();\\n            cur = cur * 10 + root -> val;\\n            if(!root -> left && !root -> right) sum += cur;  // reached leaf node\\n            if(root -> right) s.push({root -> right, cur});\\n            if(root -> left) s.push({root -> left, cur});\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246702,
                "title": "dfs-solution-for-beginners-with-explanation-100-faster",
                "content": "Any DFS based solution follows one common structure:\\n```\\ngivenfun(TreeNode* root)\\n{\\n\\t//call helper class\\n\\thelper(root);\\n}\\n\\nvoid helper(TreeNode* root)\\n{\\n\\tif(!root) return;\\n\\t/*\\n\\tDo some necessary task here\\n\\t*/\\n\\t//call recursively to left node and right node\\n\\thelper(root->left);\\n\\thelper(root->right);\\n\\t//that\\'s it.\\n}\\n```\\n\\nHere, we need to find the sum of root-leaf path. So, we can think of storing node values in string which can be converted to integer while computing sum. \\nso here you go. \\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root, string s)\\n    {\\n        if(!root) return;\\n        if(!root->left && !root->right) \\n        {\\n            //cout<<s<<endl;\\n           sum+=stoi(s+to_string(root->val));\\n            return;\\n        }\\n        helper(root->left, s+to_string(root->val));\\n        helper(root->right, s+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root,\"\");\\n        return sum;\\n    }\\n};\\n```\\nBeats 100% runtime.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ngivenfun(TreeNode* root)\\n{\\n\\t//call helper class\\n\\thelper(root);\\n}\\n\\nvoid helper(TreeNode* root)\\n{\\n\\tif(!root) return;\\n\\t/*\\n\\tDo some necessary task here\\n\\t*/\\n\\t//call recursively to left node and right node\\n\\thelper(root->left);\\n\\thelper(root->right);\\n\\t//that\\'s it.\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void helper(TreeNode* root, string s)\\n    {\\n        if(!root) return;\\n        if(!root->left && !root->right) \\n        {\\n            //cout<<s<<endl;\\n           sum+=stoi(s+to_string(root->val));\\n            return;\\n        }\\n        helper(root->left, s+to_string(root->val));\\n        helper(root->right, s+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        helper(root,\"\");\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 328123,
                "title": "simple-python-solution-top-down-dfs",
                "content": "Please see and vote for my solutions for these similar problems.\\n\\n[257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/discuss/309004/Different-DFS-Python-solutions)\\n```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\\n\\n[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/discuss/328123/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/328033/Top-down-Python-DFS-Solution)\\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\\n\\n[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/discuss/328119/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\\n\\n[112. Path Sum](https://leetcode.com/problems/path-sum/discuss/328124/Simple-Python-Solution%3A-top-down-DFS)\\n\\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\\n\\n[113. Path Sum II](https://leetcode.com/problems/path-sum-ii/discuss/328125/Simple-Python-Solution%3A-top-down-DFS)\\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\\n\\n[437. Path Sum III](https://leetcode.com/problems/path-sum-iii/discuss/328128/Simple-Python-Solution%3A-top-down-DFS-%2B-DP) (Similar problem: 560. Subarray Sum Equals K)\\n\\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def binaryTreePaths(self, root: TreeNode) -> List[str]:\\n        def dfs(node, path, res):\\n            if node.left == None and node.right == None:\\n                res.append(path + str(node.val))\\n            if node.left:\\n                dfs(node.left, path + str(node.val) + \\'->\\', res)\\n            if node.right:\\n                dfs(node.right, path + str(node.val) + \\'->\\', res)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, \"\", res)\\n        return res\\n```\n```\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 10)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def sumRootToLeaf(self, root: TreeNode) -> int:\\n        def dfs(node, bits, res):\\n            if node.left == None and node.right == None:\\n                res[0] += int(bits + str(node.val), 2)\\n            if node.left:\\n                dfs(node.left, bits + str(node.val), res)\\n            if node.right:\\n                dfs(node.right, bits + str(node.val), res)\\n        \\n        if root == None:\\n            return 0\\n        bits, res = \\'\\', [0]\\n        dfs(root, bits, res)\\n        return res[0]\\n```\n```\\n    def smallestFromLeaf(self, root: TreeNode) -> str:\\n        def dfs(root, s):\\n            s = s + chr(ord(\\'a\\') + root.val)\\n            if not root.left and not root.right:\\n                if res[0] == None:\\n                    res[0] = s[::-1]\\n                else:\\n                    res[0] = min(res[0], s[::-1])\\n            if root.left:\\n                dfs(root.left, s)\\n            if root.right:\\n                dfs(root.right, s)\\n        \\n        if not root:\\n            return \\'\\'\\n        res = [None]\\n        dfs(root, \\'\\')\\n        return res[0]\\n```\n```\\n    def hasPathSum(self, root: TreeNode, s: int) -> bool:\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res[0] = True\\n                    return\\n            if not res[0] and root.left:\\n                dfs(root.left, curr_s)\\n            if not res[0] and root.right:\\n                dfs(root.right, curr_s)\\n        \\n        if not root:\\n            return False\\n        res = [False]\\n        dfs(root, 0)\\n        return res[0]\\n```\n```\\n    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:\\n        def dfs(root, lst, curr_s):\\n            curr_s += root.val\\n            if not root.left and not root.right:\\n                if curr_s == s:\\n                    res.append(lst + [root.val])\\n                    return\\n            if root.left:\\n                dfs(root.left, lst + [root.val], curr_s)\\n            if root.right:\\n                dfs(root.right, lst + [root.val], curr_s)\\n        \\n        if not root:\\n            return []\\n        res = []\\n        dfs(root, [], 0)\\n        return res\\n```\n```\\n    def pathSum(self, root, s):\\n        def dfs(root, curr_s):\\n            curr_s += root.val\\n            res[0] += pre_sums.get(curr_s - s, 0)\\n            pre_sums[curr_s] = pre_sums.get(curr_s, 0) + 1\\n            if root.left:\\n                dfs(root.left, curr_s)\\n            if root.right:\\n                dfs(root.right, curr_s)\\n            pre_sums[curr_s] -= 1\\n            if pre_sums[curr_s] == 0:\\n                del pre_sums[curr_s]\\n        \\n        res = [0]\\n        pre_sums = {0: 1}\\n        if not root:\\n            return res[0]\\n        dfs(root, 0)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3294635,
                "title": "day-42-recursive-solution-100-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove to every path from root to each leaf and while moving keep concatenating the number and when you reach the leaf add it to your answer.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)  (stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    void dfs(TreeNode* root,int& ans,int i){\\n        if(!root->left and !root->right){\\n            ans+=i;\\n            return;\\n        }\\n        if(root->left)dfs(root->left,ans,(i*10)+root->left->val);\\n        if(root->right)dfs(root->right,ans,(i*10)+root->right->val);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        dfs(root,ans,root->val);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n***DO SHARE YOUR SOLUTION IN THE COMMENTS. HAPPY CODING!***",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    void dfs(TreeNode* root,int& ans,int i){\\n        if(!root->left and !root->right){\\n            ans+=i;\\n            return;\\n        }\\n        if(root->left)dfs(root->left,ans,(i*10)+root->left->val);\\n        if(root->right)dfs(root->right,ans,(i*10)+root->right->val);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        dfs(root,ans,root->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293914,
                "title": "easy-to-understand-with-illustration",
                "content": "![image](https://assets.leetcode.com/users/images/3f30121c-1efe-456a-ae5d-f4429ec716d8_1678753582.6372776.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* curr, int& totalSum, int numTillParent)\\n    {\\n        if (curr == NULL) return;\\n        \\n        int numTillCurr = (numTillParent * 10) + (curr->val);\\n        if (curr->left == NULL && curr->right == NULL)  //leaf node\\n        {\\n            totalSum += numTillCurr;\\n            return; \\n        }\\n        solve(curr->left, totalSum, numTillCurr);\\n        solve(curr->right, totalSum, numTillCurr);\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int totalSum = 0;\\n        solve(root, totalSum, 0);\\n        return (totalSum); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* curr, int& totalSum, int numTillParent)\\n    {\\n        if (curr == NULL) return;\\n        \\n        int numTillCurr = (numTillParent * 10) + (curr->val);\\n        if (curr->left == NULL && curr->right == NULL)  //leaf node\\n        {\\n            totalSum += numTillCurr;\\n            return; \\n        }\\n        solve(curr->left, totalSum, numTillCurr);\\n        solve(curr->right, totalSum, numTillCurr);\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int totalSum = 0;\\n        solve(root, totalSum, 0);\\n        return (totalSum); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324261,
                "title": "c-100-beat-recursive-searching-o-n-speed-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mResult;\\n    \\n    int sumNumbers(TreeNode* root) {\\n        mResult = 0;\\n        if (root != NULL) {\\n            sumNumbers(root, 0);\\n        }\\n        return mResult;\\n    }\\n    \\n    void sumNumbers(TreeNode* root, int val) {\\n        \\n        val *= 10;\\n        val += root->val;\\n        \\n        if (!root->left && !root->right) {\\n            mResult += val;\\n        }\\n        \\n        if (root->left)  { sumNumbers(root->left , val); }\\n        if (root->right) { sumNumbers(root->right, val); }\\n    }\\n    \\n};\\n```\\n\\nAs you dive deeper into the number, you can multiply the parent\\'s number by 10 and add the current node.\\n\\nFor example.\\n   [5]\\n /       \\\\\\n[3]   [6]\\n\\n--We start with 0, multiply by 10 and add 5.\\n\\n----We start with 5, multiply by 10 and add 3.\\n----We start with 5, multiply by 10 and add 6.\\n\\nSo 53 + 56",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mResult;\\n    \\n    int sumNumbers(TreeNode* root) {\\n        mResult = 0;\\n        if (root != NULL) {\\n            sumNumbers(root, 0);\\n        }\\n        return mResult;\\n    }\\n    \\n    void sumNumbers(TreeNode* root, int val) {\\n        \\n        val *= 10;\\n        val += root->val;\\n        \\n        if (!root->left && !root->right) {\\n            mResult += val;\\n        }\\n        \\n        if (root->left)  { sumNumbers(root->left , val); }\\n        if (root->right) { sumNumbers(root->right, val); }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41541,
                "title": "3-line-c-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode* r, int b=0) {\\n            if (!r) return 0;\\n            if (r->left || r->right) return sumNumbers(r->left, 10*b + r->val) + sumNumbers(r->right, 10*b + r->val);\\n            else return 10*b + r->val;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode* r, int b=0) {\\n            if (!r) return 0;\\n            if (r->left || r->right) return sumNumbers(r->left, 10*b + r->val) + sumNumbers(r->right, 10*b + r->val);\\n            else return 10*b + r->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41585,
                "title": "c-only-3-line-and-8ms-for-my-code",
                "content": "class Solution {\\n\\npublic:\\n\\n    int sumNumbers(TreeNode *root) {\\n\\n        if (!root) return 0;\\n\\n        if (!root->left && !root->right) return root->val;\\n\\n        return (root->left ? root->left->val += root->val * 10, sumNumbers(root->left) : 0) + (root->right ? root->right->val += root->val * 10, sumNumbers(root->right) : 0);\\n\\n    } \\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int sumNumbers(TreeNode *root) {\\n\\n        if (!root) return 0;\\n\\n        if (!root->left && !root->right) return root->val;\\n\\n        return (root->left ? root->left->val += root->val * 10, sumNumbers(root->left) : 0) + (root->right ? root->right->val += root->val * 10, sumNumbers(root->right) : 0);\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3352371,
                "title": "easy-java-recusion-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The sumNumbers method is called with the root of the binary tree as an argument.\\n- The makeSumTrav method is called with the root of the tree and an initial sum of 0 as arguments.\\n- In the makeSumTrav method, if the current node is null, the method returns without doing anything.\\n- The current sum is updated by multiplying it by 10 and adding the value of the current node.\\n- If the current node is a leaf node (i.e., it has no left or right children), its value is added to the final result (ans) and the method returns.\\n- The makeSumTrav method is called recursively for the left and right children of the current node with the updated sum as an argument.\\n- This process continues until all root-to-leaf paths in the tree have been traversed and their values have been added to the final result (ans).\\n- The final result (ans) is returned by the sumNumbers method.\\n\\n# Complexity\\n- Time complexity: **Beats 100%**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is **O(n)**, where n is the number of nodes in the binary tree. This is because the algorithm needs to visit each node in the tree once to calculate the sum of all root-to-leaf numbers.\\n\\n- Space complexity: **Beats 72%**\\n\\nThe space complexity of this code is **O(h)**, where h is the height of the binary tree. This is because the recursive call stack can grow up to a maximum depth of h.\\n\\n# Code\\n```\\nclass Solution {\\n    public int ans=0;\\n    public int sumNumbers(TreeNode root) {\\n        makeSumTrav(root,0);\\n        return ans;\\n    }\\n    public void makeSumTrav(TreeNode curr,int sum)\\n    {\\n        \\n        if(curr==null)\\n            return;\\n        sum=sum*10+curr.val;\\n        if(curr.left==null&&curr.right==null)\\n        {\\n         ans+=sum;\\n         return;\\n        }\\n        makeSumTrav(curr.left,sum);\\n        makeSumTrav(curr.right,sum);\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int ans=0;\\n    public int sumNumbers(TreeNode root) {\\n        makeSumTrav(root,0);\\n        return ans;\\n    }\\n    public void makeSumTrav(TreeNode curr,int sum)\\n    {\\n        \\n        if(curr==null)\\n            return;\\n        sum=sum*10+curr.val;\\n        if(curr.left==null&&curr.right==null)\\n        {\\n         ans+=sum;\\n         return;\\n        }\\n        makeSumTrav(curr.left,sum);\\n        makeSumTrav(curr.right,sum);\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296649,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root, 0);\\n    }\\n    \\n    int dfs(TreeNode* root, int sum) {\\n        if (!root) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root->val;\\n        if (!root->left && !root->right) {\\n            return sum;\\n        }\\n        return dfs(root->left, sum) + dfs(root->right, sum);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295156,
                "title": "easiest-7-lines-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(curr,num):\\n            if curr is None:\\n                return 0\\n            num=num*10+curr.val\\n            if not curr.left  and not curr.right:\\n                return num\\n            return dfs(curr.left,num)+dfs(curr.right,num)\\n        return dfs(root,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(curr,num):\\n            if curr is None:\\n                return 0\\n            num=num*10+curr.val\\n            if not curr.left  and not curr.right:\\n                return num\\n            return dfs(curr.left,num)+dfs(curr.right,num)\\n        return dfs(root,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654589,
                "title": "python3-dfs-easy-understanding",
                "content": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        \\n        def dfs(cur_node: Optional[TreeNode], num: int):\\n            if not cur_node.left and not cur_node.right:\\n                self.ans += num * 10 + cur_node.val\\n                return\\n            \\n            if cur_node.left:\\n                dfs(cur_node.left, num * 10 + cur_node.val)\\n            \\n            if cur_node.right:\\n                dfs(cur_node.right, num * 10 + cur_node.val)\\n            \\n        dfs(root, 0)\\n        \\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n        \\n        def dfs(cur_node: Optional[TreeNode], num: int):\\n            if not cur_node.left and not cur_node.right:\\n                self.ans += num * 10 + cur_node.val\\n                return\\n            \\n            if cur_node.left:\\n                dfs(cur_node.left, num * 10 + cur_node.val)\\n            \\n            if cur_node.right:\\n                dfs(cur_node.right, num * 10 + cur_node.val)\\n            \\n        dfs(root, 0)\\n        \\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 706363,
                "title": "c-general-approach-for-similar-problems",
                "content": "Our goal is to find the sum of all the numbers that are formed by each root to leaf path. For example, consider the tree\\n<pre>\\n    4\\n   / \\\\ \\n  9   0\\n / \\\\\\n5   1\\n</pre>\\n\\nThe answer is 495 + 491 + 40 = 1026\\n\\nWe traverse through all the nodes and compute the number formed from root to the current node. Whenever we come across a leaf node, we add the number to our answer. The code for this logic is as follows.\\n\\n```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode *root, long num, long &ans)\\n    {\\n        if(!root)\\n            return;\\n        num = root->val + num * 10; // Calculate the number formed so far.\\n        if(root->left == NULL && root->right == NULL) // Leaf node condition\\n        {\\n            ans += num;\\n            return;\\n        }\\n\\t\\t\\n        traverse(root->left, num, ans);\\n        traverse(root->right, num, ans);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        \\n        long ans = 0;\\n        traverse(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nThe time complexity will O(n) where n is the number of nodes in the tree.\\n\\nThis problem is similar to the Problem 257: Binary Tree Paths (https://leetcode.com/problems/binary-tree-paths/), where we have to return all the root to leaf paths. Do give it a try as well, if you have not already solved it.",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode *root, long num, long &ans)\\n    {\\n        if(!root)\\n            return;\\n        num = root->val + num * 10; // Calculate the number formed so far.\\n        if(root->left == NULL && root->right == NULL) // Leaf node condition\\n        {\\n            ans += num;\\n            return;\\n        }\\n\\t\\t\\n        traverse(root->left, num, ans);\\n        traverse(root->right, num, ans);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        \\n        long ans = 0;\\n        traverse(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706028,
                "title": "c-two-solutions",
                "content": "This problem is quite simple. We will see the first space expensive appraoch to understand the problem.\\nThen I will show you the more optimized one.\\n\\nApproach 1:\\n```\\n\\n int sumNumbers(TreeNode *root)\\n    {\\n        if (!root)  // If there is no element return 0 as the sum\\n            return 0;\\n\\t\\t// This vector will contain all the numbers from root to all leaves\\n        vector<int> v;   // so for tree in the first example after dfs this vector will have numbers 12 and 13\\n        // This array contains all the digits we came across from root to the current node.\\n\\t\\tvector<int> d;  // So when we are at 2 the array will be [1,2] and when we are at 3 it will be [1,3].\\n        dfs(root, v, d); // Perform dfs on the tree\\n        int ans = 0;\\n        for (int x : v)  // Iterate over the array and add all the values\\n        {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// Dfs to iterate over the nodes\\n\\t// root : the current element, v & d : as mentioned above.\\t\\n    void dfs(TreeNode *root, vector<int> &v, vector<int> &digits)\\n    {\\n        digits.push_back(root->val); //  insert the current digit to digits array\\n        if (root->left == NULL && root->right == NULL){\\n\\t\\t\\t// If we are at the leaf node add the number we have to the v array\\n            int val = 0; // Initialize the number to  be added as 0;\\n            for (int x : digits)\\n            {\\n\\t\\t\\t\\tval *=10;  // shift the number to left   \\n\\t\\t\\t\\tval += x; // add the value \\n\\t\\t\\t\\t// for array [1,2] = >\\n\\t\\t\\t\\t// 0*10 + 1 = 1 ;  1*10 + 2 = 12;\\n            }\\n            v.push_back(val); // add the value to the array\\n            digits.pop_back();  // remove this number (i.e the leaf node) and return to parent.\\n            return;\\n        }\\n        if (root->left == NULL)   // If there is only right node.\\n        {\\n            dfs(root->right, v, digits);  // go to right node\\n            digits.pop_back();  // After completing the traversal remove this element and return to parent\\n            return;\\n        }\\n        if (root->right == NULL)  // Same as we did for right do for left\\n        {\\n            dfs(root->left, v, digits);\\n            digits.pop_back();\\n            return;\\n        }\\n\\t\\t// If it has both left and right children then traverse both and return after remove the digit from array.\\n        dfs(root->left, v, digits);\\n        dfs(root->right, v, digits);\\n        digits.pop_back();\\n    }\\n```\\n\\nThe second approach is better as it does not use both the array\\n\\nApproach 2:\\n\\n```\\nint sumNumbers(TreeNode *root){\\n        return dfs(root, 0); // The second value in this function is current sum which 0 as of now.\\n }\\n int dfs(TreeNode *root, int csum) {\\n        if (!root) return 0;  // return if there is no node the value should be zero\\n        int nsum = csum * 10 + root->val;  // Calculate the number we have uptil now (Same as we did in the above apporach)\\n\\t\\t// If we are the leaf node return the value\\n        if (!root->left && !root->right) return nsum;\\n\\t\\t// In all other cases add the sum from the left and the right\\n        return dfs(root->left, nsum) + dfs(root->right, nsum); // So when we return back to the root we have the final sum.\\n}\\n\\n```\\n\\nThe important fact here is that we only need the final sum, which makes the above approach efficient.\\nIf we were asked to get all the value till leaf nodes then in the first approach we can simpy return the v array.\\nThank you! Hope it helped you.",
                "solutionTags": [],
                "code": "```\\n\\n int sumNumbers(TreeNode *root)\\n    {\\n        if (!root)  // If there is no element return 0 as the sum\\n            return 0;\\n\\t\\t// This vector will contain all the numbers from root to all leaves\\n        vector<int> v;   // so for tree in the first example after dfs this vector will have numbers 12 and 13\\n        // This array contains all the digits we came across from root to the current node.\\n\\t\\tvector<int> d;  // So when we are at 2 the array will be [1,2] and when we are at 3 it will be [1,3].\\n        dfs(root, v, d); // Perform dfs on the tree\\n        int ans = 0;\\n        for (int x : v)  // Iterate over the array and add all the values\\n        {\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t// Dfs to iterate over the nodes\\n\\t// root : the current element, v & d : as mentioned above.\\t\\n    void dfs(TreeNode *root, vector<int> &v, vector<int> &digits)\\n    {\\n        digits.push_back(root->val); //  insert the current digit to digits array\\n        if (root->left == NULL && root->right == NULL){\\n\\t\\t\\t// If we are at the leaf node add the number we have to the v array\\n            int val = 0; // Initialize the number to  be added as 0;\\n            for (int x : digits)\\n            {\\n\\t\\t\\t\\tval *=10;  // shift the number to left   \\n\\t\\t\\t\\tval += x; // add the value \\n\\t\\t\\t\\t// for array [1,2] = >\\n\\t\\t\\t\\t// 0*10 + 1 = 1 ;  1*10 + 2 = 12;\\n            }\\n            v.push_back(val); // add the value to the array\\n            digits.pop_back();  // remove this number (i.e the leaf node) and return to parent.\\n            return;\\n        }\\n        if (root->left == NULL)   // If there is only right node.\\n        {\\n            dfs(root->right, v, digits);  // go to right node\\n            digits.pop_back();  // After completing the traversal remove this element and return to parent\\n            return;\\n        }\\n        if (root->right == NULL)  // Same as we did for right do for left\\n        {\\n            dfs(root->left, v, digits);\\n            digits.pop_back();\\n            return;\\n        }\\n\\t\\t// If it has both left and right children then traverse both and return after remove the digit from array.\\n        dfs(root->left, v, digits);\\n        dfs(root->right, v, digits);\\n        digits.pop_back();\\n    }\\n```\n```\\nint sumNumbers(TreeNode *root){\\n        return dfs(root, 0); // The second value in this function is current sum which 0 as of now.\\n }\\n int dfs(TreeNode *root, int csum) {\\n        if (!root) return 0;  // return if there is no node the value should be zero\\n        int nsum = csum * 10 + root->val;  // Calculate the number we have uptil now (Same as we did in the above apporach)\\n\\t\\t// If we are the leaf node return the value\\n        if (!root->left && !root->right) return nsum;\\n\\t\\t// In all other cases add the sum from the left and the right\\n        return dfs(root->left, nsum) + dfs(root->right, nsum); // So when we return back to the root we have the final sum.\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41492,
                "title": "very-simple-bfs-solution",
                "content": "Interviewers love to ask for an iterative solution these days. This solution uses BFS and compute level by level.\\n\\n\\tint sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n\\t\\tint res = 0;\\n\\t\\tQueue<NodeSum> q = new LinkedList<>();\\n\\t\\tq.add(new NodeSum(root, root.val));\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tNodeSum poll = q.poll(); \\n\\t\\t\\tTreeNode node = poll.node;\\n\\t\\t\\tint sum = poll.sum;\\n\\t\\t\\tif(node.left != null) q.add(new NodeSum(node.left, sum * 10 + node.left.val));\\n\\t\\t\\tif(node.right != null) q.add(new NodeSum(node.right, sum * 10 + node.right.val));\\n\\t\\t\\tif(node.left == null && node.right == null) res += sum;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tclass NodeSum {\\n\\t\\tTreeNode node;\\n\\t\\tint sum;\\n\\t\\tpublic NodeSum(TreeNode node, int sum) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t\\tthis.sum = sum;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "Interviewers love to ask for an iterative solution these days. This solution uses BFS and compute level by level.\\n\\n\\tint sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n\\t\\tint res = 0;\\n\\t\\tQueue<NodeSum> q = new LinkedList<>();\\n\\t\\tq.add(new NodeSum(root, root.val));\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tNodeSum poll = q.poll(); \\n\\t\\t\\tTreeNode node = poll.node;\\n\\t\\t\\tint sum = poll.sum;\\n\\t\\t\\tif(node.left != null) q.add(new NodeSum(node.left, sum * 10 + node.left.val));\\n\\t\\t\\tif(node.right != null) q.add(new NodeSum(node.right, sum * 10 + node.right.val));\\n\\t\\t\\tif(node.left == null && node.right == null) res += sum;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tclass NodeSum {\\n\\t\\tTreeNode node;\\n\\t\\tint sum;\\n\\t\\tpublic NodeSum(TreeNode node, int sum) {\\n\\t\\t\\tthis.node = node;\\n\\t\\t\\tthis.sum = sum;\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3480131,
                "title": "easy-o-n-c-intutive-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Auxillary Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint tsum=0;\\n\\n    void solve(TreeNode* root,int c){\\n        if(!root)\\n            return;\\n        c=c*10+root->val;\\n\\n        if(!root->left and !root->right)\\n        {\\n            tsum+=c;\\n            return;\\n        }\\n        if(root->left){\\n            solve(root->left,c);\\n        }\\n        if(root->right){\\n            solve(root->right,c);\\n        }\\n\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int s=0,i,j,k,c=0;\\n        if(!root)\\n        return 0;\\n\\n        solve(root,c);\\n        return tsum;\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint tsum=0;\\n\\n    void solve(TreeNode* root,int c){\\n        if(!root)\\n            return;\\n        c=c*10+root->val;\\n\\n        if(!root->left and !root->right)\\n        {\\n            tsum+=c;\\n            return;\\n        }\\n        if(root->left){\\n            solve(root->left,c);\\n        }\\n        if(root->right){\\n            solve(root->right,c);\\n        }\\n\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int s=0,i,j,k,c=0;\\n        if(!root)\\n        return 0;\\n\\n        solve(root,c);\\n        return tsum;\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297915,
                "title": "explained-with-images-think-and-code-like-a-pro-beats-100",
                "content": "# Intuition [Top down approach]\\n\\n![image.png](https://assets.leetcode.com/users/images/a22f0c55-5dfa-4b0f-817e-c1bf24627841_1678826538.8064666.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhen you are in a node, you have two things to think:\\n1. Is this a normal node?\\n2. Is this a leaf node?\\n\\nIf this is a normal node, we somehow need to tell it\\'s child about the value we got so far. So, we will update the value by doing: `val*10 + node.val` And pass them into both left and right children.\\n\\nIf this is a leaf node, we reached a base case. We can now update the globally stored variable `total`. But we need to consider our current nodes value. That\\'s why we will do `total+=val*10 + node.val`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\nAs we are iterating for every node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\nAs the recursive call will iterate for every node and the function stack will be created.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total = 0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    private void helper(TreeNode node, int val){\\n        // is this a leaf node..\\n        if(node.left == null && node.right == null){\\n            total+=val*10 + node.val;\\n            return;\\n        }\\n        if(node.left!=null){\\n            helper(node.left, val*10+node.val);\\n        }\\n        if(node.right!=null){\\n            helper(node.right, val*10+node.val);\\n        }\\n    }\\n}\\n```\\n``` C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int total = 0;\\n    int sumNumbers(TreeNode* root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode* node, int val) {\\n        // is this a leaf node\\n        if(!node->left && !node->right) {\\n            total += val*10+node->val;\\n            return;\\n        }\\n        if(node->left){\\n            helper(node->left, val*10+node->val);\\n        }\\n        if(node->right){\\n            helper(node->right, val*10+node->val);\\n        }\\n    }\\n};\\n```\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/92ad6871-d492-4e07-a21f-68711250cad5_1678826911.7306123.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree"
                ],
                "code": "``` Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total = 0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    private void helper(TreeNode node, int val){\\n        // is this a leaf node..\\n        if(node.left == null && node.right == null){\\n            total+=val*10 + node.val;\\n            return;\\n        }\\n        if(node.left!=null){\\n            helper(node.left, val*10+node.val);\\n        }\\n        if(node.right!=null){\\n            helper(node.right, val*10+node.val);\\n        }\\n    }\\n}\\n```\n``` C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int total = 0;\\n    int sumNumbers(TreeNode* root) {\\n        helper(root, 0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode* node, int val) {\\n        // is this a leaf node\\n        if(!node->left && !node->right) {\\n            total += val*10+node->val;\\n            return;\\n        }\\n        if(node->left){\\n            helper(node->left, val*10+node->val);\\n        }\\n        if(node->right){\\n            helper(node->right, val*10+node->val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200174,
                "title": "129-beats-96-72-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe define a recursive function dfs that takes in a node and a path sum as arguments. We initially call dfs on the root node with a path sum of 0.\\n\\nAt each node, we add the current node\\'s value to the path sum by multiplying the current path sum by 10 and adding the node\\'s value.\\n\\nIf the current node is a leaf node (i.e., it has no left or right children), we return the path sum. Otherwise, we recursively call dfs on the left and right subtrees and sum up the returned values.\\n\\nFinally, we call dfs on the root node and return the resulting sum.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n59.76%\\n\\n- Space complexity:\\nBeats\\n96.72%\\n\\n# Code\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        # Define a recursive function to traverse the tree and sum up the numbers\\n        def dfs(node, path_sum):\\n            if not node:\\n                return 0\\n            # Add the current node\\'s value to the path sum\\n            path_sum = path_sum * 10 + node.val\\n            # If this is a leaf node, return the path sum\\n            if not node.left and not node.right:\\n                return path_sum\\n            # Otherwise, recursively traverse the left and right subtrees\\n            return dfs(node.left, path_sum) + dfs(node.right, path_sum)\\n        \\n        # Call the recursive function on the root node with an initial path sum of 0\\n        return dfs(root, 0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        # Define a recursive function to traverse the tree and sum up the numbers\\n        def dfs(node, path_sum):\\n            if not node:\\n                return 0\\n            # Add the current node\\'s value to the path sum\\n            path_sum = path_sum * 10 + node.val\\n            # If this is a leaf node, return the path sum\\n            if not node.left and not node.right:\\n                return path_sum\\n            # Otherwise, recursively traverse the left and right subtrees\\n            return dfs(node.left, path_sum) + dfs(node.right, path_sum)\\n        \\n        # Call the recursive function on the root node with an initial path sum of 0\\n        return dfs(root, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519528,
                "title": "c-0ms-faster-than-100-easy-understanding-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int sum = 0;\\n    \\n    void f(TreeNode *root, string cur_sum){\\n        \\n        if(!root) return;\\n        \\n        if(!root->left and !root->right){\\n            sum+=stoi(cur_sum + to_string(root->val));\\n            return;\\n        }\\n        \\n        f(root->left, cur_sum + to_string(root->val));\\n        f(root->right, cur_sum + to_string(root->val));\\n                \\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        f(root, \"\");\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sum = 0;\\n    \\n    void f(TreeNode *root, string cur_sum){\\n        \\n        if(!root) return;\\n        \\n        if(!root->left and !root->right){\\n            sum+=stoi(cur_sum + to_string(root->val));\\n            return;\\n        }\\n        \\n        f(root->left, cur_sum + to_string(root->val));\\n        f(root->right, cur_sum + to_string(root->val));\\n                \\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        f(root, \"\");\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845290,
                "title": "c-easy-dfs-backtracking-solution",
                "content": "**Do** \\u2B06\\uFE0F **UPVOTE IF IT WAS HELPFUL**\\n\\n\\tclass Solution {\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *root,string &s){\\n\\t\\t\\tif(!root) return ;\\n\\t\\t\\ts.push_back(root->val+\\'0\\');\\n\\t\\t\\tif(root->left==root->right){\\n\\t\\t\\t\\tans+=stoi(s);\\n\\t\\t\\t}\\n\\t\\t\\thelper(root->left,s);\\n\\t\\t\\thelper(root->right,s);\\n\\t\\t\\ts.pop_back();\\n\\t\\t}\\n\\t\\tint sumNumbers(TreeNode* root) {\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\thelper(root,s);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tint ans=0;\\n\\tpublic:\\n\\t\\tvoid helper(TreeNode *root,string &s){\\n\\t\\t\\tif(!root) return ;\\n\\t\\t\\ts.push_back(root->val+\\'0\\');\\n\\t\\t\\tif(root->left==root->right){\\n\\t\\t\\t\\tans+=stoi(s);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1793789,
                "title": "solution-swift-sum-root-to-leaf-numbers",
                "content": "```swift\\nclass Solution {\\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var result = 0\\n        \\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 0))\\n        \\n        while !queue.isEmpty {\\n            let (node, val) = queue.removeFirst()\\n            let sum = ((10 * val) + node.val)\\n            \\n            let (left, right) = (node.left, node.right)\\n            if left == nil && right == nil { result += sum }\\n            \\n            if let left = left { queue.append((left, sum)) }\\n            if let right = right { queue.append((right, sum)) }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>TreeNode</b></summary>\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        \\n        var result = 0\\n        \\n        var queue: [(TreeNode, Int)] = []\\n        queue.append((root, 0))\\n        \\n        while !queue.isEmpty {\\n            let (node, val) = queue.removeFirst()\\n            let sum = ((10 * val) + node.val)\\n            \\n            let (left, right) = (node.left, node.right)\\n            if left == nil && right == nil { result += sum }\\n            \\n            if let left = left { queue.append((left, sum)) }\\n            if let right = right { queue.append((right, sum)) }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785393,
                "title": "0ms-100-solution-accepted",
                "content": "class Solution {\\npublic:\\n\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root , int num = 0) {\\n        if(!root)return 0;\\n        \\n        if(!root->left and !root->right){\\n            num = num * 10 + root -> val;\\n            sum += num;\\n            return sum;\\n        }\\n        \\n        num = num * 10 + root -> val;\\n        sumNumbers(root->left , num);\\n        sumNumbers(root->right , num);\\n        \\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root , int num = 0) {\\n        if(!root)return 0;\\n        \\n        if(!root->left and !root->right){\\n            num = num * 10 + root -> val;\\n            sum += num;\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1556108,
                "title": "c-100-faster-dfs-recursive-explained",
                "content": "In the question, it is mentioned that the number is formed from digits, i.e. number present in the path from the  root-to-leaf. So order here is important. \\n\\nMoreover, it is evident, that one has to implement Depth- First Search to solve this problem, as the we have to traverse till the dept of the tree and get the digits to form the number. \\n\\n## Some Basics\\n### Forming the number from digits.\\nTo make a number from digits, one has to do the following:\\n1. The left most part of a number is multiplied by an order of 10.\\n2. The right most part is left at it is.\\n\\nUsing the above approch, one can form a number from the fdigits.\\n\\n### Finding the digits\\nNow the next task is to find the digits. Since the digits has to be found out by traversing the depth of the tree.\\n\\nBelow is the implementation of the above approach:\\n```\\nclass Solution {\\npublic:\\n   // Function to traverse the depth of trr\\n   // and find the sum\\n    int dfs(TreeNode* root,int prev){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        if(root->left == root->right){\\n            return prev*10 + root->val;\\n        }\\n        \\n        return dfs(root->left,prev*10 + root->val) + dfs(root->right,prev*10 + root->val);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int answer = dfs(root,0);\\n        return answer;\\n    }\\n};\\n```\\n\\n**Explanation**\\n1. FIrst check if the current node is a valid one or not. If not, return.\\n2. Check if the current node is root, if yes then add the value at root with that of the previous sum.\\n3. Recursively call the function for the left and right sub part of the tree.\\n\\nThe `prev` is used to store the sum of the previous values. \\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // Function to traverse the depth of trr\\n   // and find the sum\\n    int dfs(TreeNode* root,int prev){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        if(root->left == root->right){\\n            return prev*10 + root->val;\\n        }\\n        \\n        return dfs(root->left,prev*10 + root->val) + dfs(root->right,prev*10 + root->val);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int answer = dfs(root,0);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481784,
                "title": "c-soln-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*10 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\nhttps://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/\\nhttps://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/discuss/1481832/Recursive-DFS-soln-c%2B%2B",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    \\n    void helper(TreeNode* root , int num = 0)\\n    {\\n        num = num*10 + root->val;\\n        if(root->left)helper(root->left , num);\\n        if(root->right)helper(root->right , num);\\n        \\n        if(!root->left && !root->right)\\n        {  sum += num;\\n           return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(!root)\\n            return 0;\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512898,
                "title": "python-o-n-sol-by-dfs-approach-90-with-explanation",
                "content": "Python O(n) sol. by DFS approach.\\n\\n---\\n**Hint**:\\n\\nThink of **DFS traversal** with leaf node judgement\\n\\nA node is **leaf node** <=> **node.left is None** and **node.right is None**\\n\\n---\\n**Algorithm**:\\n\\nStep_#1.\\n\\nStart **DFS traversal from root node** and initial tree number 0.\\n**Update tree number** with current node value **on each level**.\\n\\n\\nStep_#2.\\n\\nIf current node is  **leaf node**, **return tree number**.\\nIf current node is non-leaf node, **DFS down to next level** with **summation** (**+**).\\n\\n\\n---\\n\\n```\\n\\nclass Solution:\\n    \\n\\n    def sumNumbers(self, node: TreeNode, tree_num = 0) -> int:\\n\\n        if not node:\\n            # empty tree or empty node\\n            return 0\\n        \\n        else:\\n            # update tree_num with current node\\n            tree_num = 10 * tree_num + node.val\\n\\n            if not node.left and not node.right:\\n                # leaf is reached, return tree_num\\n                return tree_num\\n\\n            else:\\n                # DFS down to next level\\n                return self.sumNumbers( node.left, tree_num) + self.sumNumbers( node.right, tree_num) \\n```\\n\\n---\\n\\nShare another implementation with generator\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        \\n        def calc(node, val):\\n            \\n            ## base case aka stop condition:\\n            # generate decimal value on leaf node\\n            if not node.left and not node.right:\\n                yield (val * 10 + node.val)\\n                \\n            ## general cases:\\n            # visit each non-leaf nodes\\n            for child in (node.left, node.right):\\n                if child:\\n                    yield from calc(child, val * 10 + node.val)\\n            \\n        # -------------------------------------------------------------\\n        # sum of root-to-leaf numbers\\n        return sum( calc(root, 0) )\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n[Leetcode #1022 Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    \\n\\n    def sumNumbers(self, node: TreeNode, tree_num = 0) -> int:\\n\\n        if not node:\\n            # empty tree or empty node\\n            return 0\\n        \\n        else:\\n            # update tree_num with current node\\n            tree_num = 10 * tree_num + node.val\\n\\n            if not node.left and not node.right:\\n                # leaf is reached, return tree_num\\n                return tree_num\\n\\n            else:\\n                # DFS down to next level\\n                return self.sumNumbers( node.left, tree_num) + self.sumNumbers( node.right, tree_num) \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        \\n        def calc(node, val):\\n            \\n            ## base case aka stop condition:\\n            # generate decimal value on leaf node\\n            if not node.left and not node.right:\\n                yield (val * 10 + node.val)\\n                \\n            ## general cases:\\n            # visit each non-leaf nodes\\n            for child in (node.left, node.right):\\n                if child:\\n                    yield from calc(child, val * 10 + node.val)\\n            \\n        # -------------------------------------------------------------\\n        # sum of root-to-leaf numbers\\n        return sum( calc(root, 0) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41464,
                "title": "share-my-java-solution",
                "content": "    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);    \\n    }\\n    private int dfs(TreeNode root, int num){\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        num = num*10 + root.val;\\n        if(root.left == null && root.right == null) return num;\\n        \\n        return dfs(root.left, num) + dfs(root.right,num);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);    \\n    }\\n    private int dfs(TreeNode root, int num){\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        num = num*10 + root.val;\\n        if(root.left == null && root.right == null) return num;\\n        \\n        return dfs(root.left, num) + dfs(root.right,num);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41452,
                "title": "iterative-c-solution-using-stack-similar-to-postorder-traversal",
                "content": "Iterative C++ solution using postorder traversal to treat the nodes \\n\\n\\n\\n    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int sumNumbers(TreeNode* root) {\\n            \\n            stack<TreeNode*> nodes;\\n            if (!root)\\n             return 0;\\n             \\n            int total = 0;\\n            int current = 0;\\n            TreeNode* last = nullptr;\\n            while (root || !nodes.empty())\\n            {\\n                if (root)\\n                {\\n                    nodes.push(root);\\n                    current *= 10;\\n                    current += root->val;\\n                    root = root->left;\\n                }\\n                else \\n                {\\n                    root = nodes.top();\\n                    if (root->right && root->right != last)\\n                    {\\n                        root = root->right;\\n                    }\\n                    else \\n                    {\\n                         nodes.pop();\\n                         last = root;\\n                         // only add sum of leaf node\\n                         if (root->right == nullptr && root->left == nullptr)\\n                            total += current;\\n                         current /= 10;\\n                         root = nullptr;\\n                    }\\n                }\\n              }\\n            \\n             return total;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        int sumNumbers(TreeNode* root) {\\n            \\n            stack<TreeNode*> nodes;\\n            if (!root)\\n             return 0;\\n             \\n            int total = 0;\\n            int current = 0;\\n            TreeNode* last = nullptr;\\n            while (root || !nodes.empty())\\n            {\\n                if (root)\\n                {\\n                    nodes.push(root);\\n                    current *= 10;\\n                    current += root->val;\\n                    root = root->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3294691,
                "title": "beats-c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<string> &paths, string num){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            paths.push_back(num);\\n        }\\n        solve(root->left,paths,num+to_string(root->val));\\n        solve(root->right,paths,num+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        vector<string> paths;\\n        string num=\"\";\\n        solve(root,paths,num);\\n        int sum=0;\\n        for(auto x: paths){\\n            sum+=stoi(x);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nOR\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string num,int& sum){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            sum+=stoi(num);\\n        }\\n        solve(root->left,num+to_string(root->val),sum);\\n        solve(root->right,num+to_string(root->val),sum);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string num=\"\";\\n        int sum=0;\\n        solve(root,num,sum);\\n        return sum;\\n    }\\n};\\n```\\n\\nDO UPVOTE, IF THIS HELPED\\uD83D\\uDE01\\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<string> &paths, string num){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            paths.push_back(num);\\n        }\\n        solve(root->left,paths,num+to_string(root->val));\\n        solve(root->right,paths,num+to_string(root->val));\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        vector<string> paths;\\n        string num=\"\";\\n        solve(root,paths,num);\\n        int sum=0;\\n        for(auto x: paths){\\n            sum+=stoi(x);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, string num,int& sum){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            num+=to_string(root->val);\\n            sum+=stoi(num);\\n        }\\n        solve(root->left,num+to_string(root->val),sum);\\n        solve(root->right,num+to_string(root->val),sum);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string num=\"\";\\n        int sum=0;\\n        solve(root,num,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294261,
                "title": "python3-32ms-dfs-detailed-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using DFS**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we want sum all routes from root and return sum.\\n- for this appropriate method would be dfs.\\n- using dfs traverse till end of tree ie. leaf node.\\n- keep track of path from root till leaf-node, now when encountered leaf node, sum it in answer.\\n- do this till all path covered, return answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        def dfs(curr=None,path=\\'\\'):\\n            nonlocal ans\\n            if curr:\\n                path += str(curr.val)\\n                dfs(curr.left,path)\\n                dfs(curr.right,path)\\n                if curr.left == None and curr.right == None:ans += int(path)\\n            return\\n        dfs(root)\\n        return ans\\n```\\n# Please like and comment below ( \\u0361\\uD83D\\uDC41\\uFE0F\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDC41\\uFE0F)\\uD83D\\uDC4C",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0\\n        def dfs(curr=None,path=\\'\\'):\\n            nonlocal ans\\n            if curr:\\n                path += str(curr.val)\\n                dfs(curr.left,path)\\n                dfs(curr.right,path)\\n                if curr.left == None and curr.right == None:ans += int(path)\\n            return\\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180432,
                "title": "best-c-solution-dfs-stack-recursive-and-iterative-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using DFS + Binary Search Tree. (Recursive Approach).\\n2. Solved using Stack + Binary Search Tree. (Iterative Approach).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Even though we don\\'t explicitly use any additional memory, the call stack\\n    of our recursion could be as large as the number of nodes in the worst case.\\n\\n    Solved using DFS + Binary Search Tree. (Recursive Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int sumNumbersHelper(TreeNode* root, int currSum){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        currSum = currSum * 10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            return currSum;\\n        }\\n        return sumNumbersHelper(root->left, currSum) + sumNumbersHelper(root->right, currSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int currSum = 0;\\n        return sumNumbersHelper(root, currSum);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Stack space.\\n\\n    Solved using Stack + Binary Search Tree. (Iterative Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        stack<pair<TreeNode*, int>> store;\\n        store.push({root, 0});\\n        int sum = 0;\\n        while(!store.empty()){\\n            auto [root, currSum] = store.top(); \\n            store.pop();\\n            currSum = currSum * 10 + root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                sum += currSum;\\n            }\\n            if(root->right != NULL){\\n                store.push({root->right, currSum});\\n            }\\n            if(root->left != NULL){\\n                store.push({root->left, currSum});\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Even though we don\\'t explicitly use any additional memory, the call stack\\n    of our recursion could be as large as the number of nodes in the worst case.\\n\\n    Solved using DFS + Binary Search Tree. (Recursive Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int sumNumbersHelper(TreeNode* root, int currSum){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        currSum = currSum * 10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            return currSum;\\n        }\\n        return sumNumbersHelper(root->left, currSum) + sumNumbersHelper(root->right, currSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int currSum = 0;\\n        return sumNumbersHelper(root, currSum);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity: O(N), where N is the total number of nodes in the given tree. We visit each node\\n    at most once.\\n\\n    Space Complexity: O(N), Stack space.\\n\\n    Solved using Stack + Binary Search Tree. (Iterative Approach)\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        stack<pair<TreeNode*, int>> store;\\n        store.push({root, 0});\\n        int sum = 0;\\n        while(!store.empty()){\\n            auto [root, currSum] = store.top(); \\n            store.pop();\\n            currSum = currSum * 10 + root->val;\\n            if(root->left == NULL && root->right == NULL){\\n                sum += currSum;\\n            }\\n            if(root->right != NULL){\\n                store.push({root->right, currSum});\\n            }\\n            if(root->left != NULL){\\n                store.push({root->left, currSum});\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557186,
                "title": "sum-root-to-leaf-numbers-cpp-c-with-detail-explanation",
                "content": "**Explanation:**\\nBasic idea is to explore all the paths and then store the digits that you encounter on the way and then find the result. So, whenever there is an exploring all the path stuff then we should think of recursion. And, since it is a tree related question then there is a high chance of using recursion.\\n\\nNow, we will do pre-order traversal for this tree and when we hit any node we will convert that node val to string and concatenate to our string `s` and whenever we hit the leaf node we will store the string `s` in a vector name `paths`.\\n\\nBasically, `paths` is a vector which stores all the path from `root-to-leaf` in a string format.\\n\\nNow, after that we will traverse the vector and convert all the strings to digits one by one and add them and return the ans i.e. sum.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> paths;\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        findSumNumber(root, \"\");\\n        int sum = 0;\\n        for(auto path : paths){\\n            int n = stoi(path);\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, string s){\\n        if(!root) return;\\n        \\n        s += to_string(root->val);\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            paths.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, s);\\n        findSumNumber(root->right, s);\\n        s.pop_back();\\n    }\\n};\\n```\\n\\n**Discussion:**\\nNow, the problem with above approach is, we are using extra vector for storing all the paths So, we can do something to eliminate the vector. \\n\\nNow, the idea is to replicate the above solution but we will have one variable name `path` that will store the value from `root-to-leaf` in the form of number on the way i.e. as the recursion goes.\\n\\nWhen we hit the leaf node we will add that number i.e. `path` to our `sum` variable. Also, in order to exlore all paths we will remove the last digit from `path` variable.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int sum = 0;\\n        findSumNumber(root, 0, sum);\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, int path, int& sum){\\n        if(!root) return;\\n        \\n        path = path*10 + root->val;\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            sum += path;\\n            path = path/10;\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, path, sum);\\n        findSumNumber(root->right, path, sum);\\n        path = path/10;\\n    }\\n};\\n```\\n\\nPlease do let me know, if you have another solution.\\nI hope this helps. \\nThanks \\u270C\\uD83C\\uDFFB\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> paths;\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        findSumNumber(root, \"\");\\n        int sum = 0;\\n        for(auto path : paths){\\n            int n = stoi(path);\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, string s){\\n        if(!root) return;\\n        \\n        s += to_string(root->val);\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            paths.push_back(s);\\n            s.pop_back();\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, s);\\n        findSumNumber(root->right, s);\\n        s.pop_back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int sum = 0;\\n        findSumNumber(root, 0, sum);\\n        return sum;\\n    }\\n    \\n    void findSumNumber(TreeNode* root, int path, int& sum){\\n        if(!root) return;\\n        \\n        path = path*10 + root->val;\\n        \\n        //if the node is a leaf node\\n        if(root->left == NULL && root->right == NULL){\\n            sum += path;\\n            path = path/10;\\n            return;\\n        }\\n        \\n        findSumNumber(root->left, path, sum);\\n        findSumNumber(root->right, path, sum);\\n        path = path/10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556982,
                "title": "clean-java-dfs-100-faster",
                "content": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int component = 0;    // stores current_sum till leaf\\n\\t\\tint ans = 0;     // stores sum of every number generated from root to leaf path\\n        return dfs(root, component, ans);\\n    }\\n    \\n    public int dfs(TreeNode root, int comp, int ans){\\n        if(root == null) return 0;\\n        comp = comp * 10 + root.val;    // updating the comp \\n        if(root.left == null && root.right == null){\\n            ans += comp;    // updating the sum if the curr_node is a root\\n            return ans;\\n        }\\n        int call1 = dfs(root.left, comp, ans);    // sum of numbers to all leaf nodes on the left\\n        int call2 = dfs(root.right, comp, ans);  // // sum of numbers to all leaf nodes on the right\\n        return call1 + call2;\\n    }\\n}\\nTime Complexity : O(N)\\nSpace Complexity : O(LogN) average",
                "solutionTags": [],
                "code": "class Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int component = 0;    // stores current_sum till leaf\\n\\t\\tint ans = 0;     // stores sum of every number generated from root to leaf path\\n        return dfs(root, component, ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1556242,
                "title": "c-recursive-0-ms-code",
                "content": "Below is commented code - \\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root , int res=0) {\\n\\t// if no root the simply return 0\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n\\t\\t// if current node is leaf node\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            return(res*10+root->val);\\n        }\\n\\t\\t// otherwise go in both direction and add both the results \\n        return(sumNumbers(root->left,res*10+root->val) +sumNumbers(root->right,res*10+root->val)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root , int res=0) {\\n\\t// if no root the simply return 0\\n        if(!root)\\n        {\\n            return 0;\\n        }\\n\\t\\t// if current node is leaf node\\n        if(root->left==NULL and root->right==NULL)\\n        {\\n            return(res*10+root->val);\\n        }\\n\\t\\t// otherwise go in both direction and add both the results \\n        return(sumNumbers(root->left,res*10+root->val) +sumNumbers(root->right,res*10+root->val)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555911,
                "title": "faster-than-100-c-solutions-easy-intuitive-approach-dfs",
                "content": "Hello there my fellow reader, thanks for reading in advance!\\n\\n**Approach:** \\n\\n1. I will traverse the binary tree in a depth first search (DFS) fashion and computer the number formed so far.\\n\\n2. To compute the number: if number so far is 23 and current node value is 5 then the number will become 23*10 + 5 = 235.\\n\\n3. Then I\\'ll check for the leaf node and add the number formed so far to our result.\\n\\nBelow is the code for my approach mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n    int res{}; //result variable\\n    \\n    void dfs(TreeNode* root, int num){\\n        \\n        if(root == NULL) return;\\n        \\n        //num value at this node\\n        num = num*10 + root->val;\\n        \\n        //leaf Node\\n        if(root->left == NULL && root->right == NULL)\\n            res += num;\\n        \\n        dfs(root->left, num);\\n        dfs(root->right, num);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        dfs(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res{}; //result variable\\n    \\n    void dfs(TreeNode* root, int num){\\n        \\n        if(root == NULL) return;\\n        \\n        //num value at this node\\n        num = num*10 + root->val;\\n        \\n        //leaf Node\\n        if(root->left == NULL && root->right == NULL)\\n            res += num;\\n        \\n        dfs(root->left, num);\\n        dfs(root->right, num);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        dfs(root, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440005,
                "title": "0-ms-c-super-easy",
                "content": "**The value of sum at each point of recursive call is saved in inbuilt Stack and that sum is added to answer when both children of root becomes NULL.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\tint ans=0;  \\n\\tint sumNumbers(TreeNode* root,int sum=0)\\n    {\\n\\t\\n        if(root==NULL)\\n            return 0;\\n        \\n          sum=sum*10+root->val;\\n          sumNumbers(root->left,sum);\\n          sumNumbers(root->right,sum);\\n\\t\\t  \\n        if(root->left==root->right && root->left==NULL)\\n        {\\n            ans+=sum;\\n        }\\n        return ans;\\n    }\\n };\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint ans=0;  \\n\\tint sumNumbers(TreeNode* root,int sum=0)\\n    {\\n\\t\\n        if(root==NULL)\\n            return 0;\\n        \\n          sum=sum*10+root->val;\\n          sumNumbers(root->left,sum);\\n          sumNumbers(root->right,sum);\\n\\t\\t  \\n        if(root->left==root->right && root->left==NULL)\\n        {\\n            ans+=sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41497,
                "title": "share-my-c-code-using-0ms",
                "content": "int sumTreeNodes(struct TreeNode* root, int parent) {\\n\\n    if (root == NULL)\\n        return 0;\\n    if (root->left == NULL && root->right == NULL) \\n        return parent * 10 + root->val;\\n    \\n    return sumTreeNodes(root->left, parent * 10 + root->val) + \\n           sumTreeNodes(root->right, parent * 10 + root->val);\\n}\\n\\n\\nint sumNumbers(struct TreeNode* root) {\\n\\n    return (root == NULL) ? 0 : sumTreeNodes(root, 0);\\n}",
                "solutionTags": [],
                "code": "int sumTreeNodes(struct TreeNode* root, int parent) {\\n\\n    if (root == NULL)\\n        return 0;\\n    if (root->left == NULL && root->right == NULL) \\n        return parent * 10 + root->val;\\n    \\n    return sumTreeNodes(root->left, parent * 10 + root->val) + \\n           sumTreeNodes(root->right, parent * 10 + root->val);\\n}\\n\\n\\nint sumNumbers(struct TreeNode* root) {\\n\\n    return (root == NULL) ? 0 : sumTreeNodes(root, 0);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4076700,
                "title": "best-o-n-solution",
                "content": "# Approach\\nPreorder Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void path(TreeNode* root, int& sum, int& num) {\\n        if (!root) \\n            return;\\n        if (!root->left && !root->right) {\\n            sum += num * 10 + root->val;\\n            return;\\n        }\\n        num = num * 10 + root->val;\\n        path(root->left, sum, num);\\n        path(root->right, sum, num);\\n        num = num / 10;\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0, num = 0;\\n        path(root, sum, num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void path(TreeNode* root, int& sum, int& num) {\\n        if (!root) \\n            return;\\n        if (!root->left && !root->right) {\\n            sum += num * 10 + root->val;\\n            return;\\n        }\\n        num = num * 10 + root->val;\\n        path(root->left, sum, num);\\n        path(root->right, sum, num);\\n        num = num / 10;\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum = 0, num = 0;\\n        path(root, sum, num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310003,
                "title": "c-recursive-100-beat-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDCAFFirst reach to leaf nodes by traversing in dfs manner .\\nOnce you are in leaf node add it to global variable answer.\\uD83D\\uDCAF\\n\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(TreeNode* root, int val){\\n        if(root->left==NULL and root->right==NULL){\\n            val=val*10+(root->val);\\n            ans+=val;\\n            return ;\\n        }\\n        val=(val*10)+(root->val);\\n        cout<<val<<endl;\\n        if(root->left!=NULL)\\n        helper(root->left,val);\\n        if(root->right!=NULL)\\n        helper(root->right,val);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) {\\n        \\n        \\n        helper(root, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void helper(TreeNode* root, int val){\\n        if(root->left==NULL and root->right==NULL){\\n            val=val*10+(root->val);\\n            ans+=val;\\n            return ;\\n        }\\n        val=(val*10)+(root->val);\\n        cout<<val<<endl;\\n        if(root->left!=NULL)\\n        helper(root->left,val);\\n        if(root->right!=NULL)\\n        helper(root->right,val);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) {\\n        \\n        \\n        helper(root, 0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3295495,
                "title": "dfs-c-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int x){\\n        if(root == NULL){\\n            return;\\n        }\\n        x = x*10+root->val;\\n        solve(root->left,ans,x);\\n        solve(root->right,ans,x);\\n        if(root->left==NULL&&root->right==NULL){\\n            ans += x;\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans,0);\\n        return (ans);\\n    }\\n\\t\\t};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int x){\\n        if(root == NULL){\\n            return;\\n        }\\n        x = x*10+root->val;\\n        solve(root->left,ans,x);\\n        solve(root->right,ans,x);\\n        if(root->left==NULL&&root->right==NULL){\\n            ans += x;\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans = 0;\\n        solve(root,ans,0);\\n        return (ans);\\n    }\\n\\t\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294307,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static ArrayList<String> sum( TreeNode root , ArrayList<String> arr , String str )\\n    {\\n        if( root==null ) return arr;\\n        if( root.left ==null && root.right==null ){\\n            str+=Integer.toString(root.val) ;\\n            arr.add( str );\\n        }\\n        if( root.left!=null && root.right != null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str );\\n            sum( root.right , arr , str );\\n        }\\n        if( root.left!=null && root.right == null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str  );\\n        }\\n        if( root.left==null && root.right != null ) {\\n            str+=Integer.toString(root.val) ;\\n            sum( root.right , arr , str  );\\n        }\\n\\n        return arr ;\\n\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<>();\\n        int sum = 0;\\n        sum( root , arr , \"\"  );\\n        for( int i = 0 ; i<arr.size() ; i++ )\\n        {\\n            sum+= Integer.valueOf( arr.get(i) );\\n        }\\n        return sum  ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static ArrayList<String> sum( TreeNode root , ArrayList<String> arr , String str )\\n    {\\n        if( root==null ) return arr;\\n        if( root.left ==null && root.right==null ){\\n            str+=Integer.toString(root.val) ;\\n            arr.add( str );\\n        }\\n        if( root.left!=null && root.right != null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str );\\n            sum( root.right , arr , str );\\n        }\\n        if( root.left!=null && root.right == null ){\\n            str+=Integer.toString(root.val) ;\\n            sum( root.left , arr , str  );\\n        }\\n        if( root.left==null && root.right != null ) {\\n            str+=Integer.toString(root.val) ;\\n            sum( root.right , arr , str  );\\n        }\\n\\n        return arr ;\\n\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        ArrayList<String> arr = new ArrayList<>();\\n        int sum = 0;\\n        sum( root , arr , \"\"  );\\n        for( int i = 0 ; i<arr.size() ; i++ )\\n        {\\n            sum+= Integer.valueOf( arr.get(i) );\\n        }\\n        return sum  ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293870,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n            if (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root.left == null && root.right == null) {\\n            return root.val;\\n        }\\n\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        stack.push(new Pair<>(root, root.val));\\n\\n        int sum = 0;\\n\\n        while (!stack.isEmpty()) {\\n            Pair<TreeNode, Integer> cur = stack.pop();\\n            TreeNode node = cur.getKey();\\n            int num = cur.getValue();\\n\\n            if (node.left == null && node.right == null) {\\n                sum += num;\\n                continue;\\n            }\\n\\n            if (node.left != null) {\\n                stack.push(new Pair<>(node.left, num * 10 + node.left.val));\\n            }\\n            if (node.right != null) {\\n                stack.push(new Pair<>(node.right, num * 10 + node.right.val));\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044969,
                "title": "simple-and-easy-c-recursion",
                "content": "# Intuition\\ngenerate a number from moving root to leaf , once you reach the leaf node add it to the ans and return.\\n\\n# Approach\\ninitialise x as 0 then after visiting each node do \"x=10*x + node->val;\" this will keep on making your number. once you reach the the leaf node add that x to ans;\\n\\nafter recursion completes return ans;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) recursion stack space\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    void sum(TreeNode* t,int &ans,int x)\\n    {\\n        if(t==NULL)\\n            return;\\n        x=10*x+t->val;\\n        if(t->left==NULL&&t->right==NULL)\\n        {\\n            ans=ans+x;\\n            return;\\n        }\\n        sum(t->left,ans,x);\\n        sum(t->right,ans,x);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0,x=0;\\n        sum(root,ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    void sum(TreeNode* t,int &ans,int x)\\n    {\\n        if(t==NULL)\\n            return;\\n        x=10*x+t->val;\\n        if(t->left==NULL&&t->right==NULL)\\n        {\\n            ans=ans+x;\\n            return;\\n        }\\n        sum(t->left,ans,x);\\n        sum(t->right,ans,x);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0,x=0;\\n        sum(root,ans,x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648129,
                "title": "c-solution-sum-root-to-leaf-numbers",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root , int &ans, vector<int> path){\\n        //base case \\n        if(root == NULL)\\n            return;\\n\\t\\t\\t\\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int num = 0;\\n            for(int i = 0 ; i < path.size() ; i++){\\n                num = num*10 + path[i];\\n            }\\n            ans += num;\\n        } \\n        solve(root->left , ans, path);\\n        solve(root->right , ans, path);\\n        \\n        path.pop_back();\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int ans = 0; vector<int> path;\\n        solve(root, ans,path);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root , int &ans, vector<int> path){\\n        //base case \\n        if(root == NULL)\\n            return;\\n\\t\\t\\t\\n        path.push_back(root->val);\\n        \\n        if(root->left == NULL && root->right == NULL){\\n            int num = 0;\\n            for(int i = 0 ; i < path.size() ; i++){\\n                num = num*10 + path[i];\\n            }\\n            ans += num;\\n        } \\n        solve(root->left , ans, path);\\n        solve(root->right , ans, path);\\n        \\n        path.pop_back();\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int ans = 0; vector<int> path;\\n        solve(root, ans,path);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756021,
                "title": "easy-cpp-solution",
                "content": "The basic concept I applied here is, while traversing down (in fonc function) I just took root->val and multiplied it by 10 + its successor, this will make all numbers we want to add and stored the numbers in a vector.\\nIn sumNumbers function I just add all numbers present in vector ans.\\n\\n\\n\\n     vector<int> ans;\\n\\n     //Helper Function\\n    void fonc(TreeNode* root,int total){\\n        if(root==NULL){\\n            return;\\n        }\\n        total+= root->val;\\n        if(root->left ==NULL && root->right ==NULL){\\n            ans.push_back(total);\\n            return;\\n        }\\n        fonc(root->left, total * 10);\\n        fonc(root->right, total * 10);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int total=0;\\n        int s=0;\\n        fonc(root,total);\\n        for(int i=0;i<ans.size();i++){\\n            s+=ans[i]; \\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "Math",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "The basic concept I applied here is, while traversing down (in fonc function) I just took root->val and multiplied it by 10 + its successor, this will make all numbers we want to add and stored the numbers in a vector.\\nIn sumNumbers function I just add all numbers present in vector ans.\\n\\n\\n\\n     vector<int> ans;\\n\\n     //Helper Function\\n    void fonc(TreeNode* root,int total){\\n        if(root==NULL){\\n            return;\\n        }\\n        total+= root->val;\\n        if(root->left ==NULL && root->right ==NULL){\\n            ans.push_back(total);\\n            return;\\n        }\\n        fonc(root->left, total * 10);\\n        fonc(root->right, total * 10);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int total=0;\\n        int s=0;\\n        fonc(root,total);\\n        for(int i=0;i<ans.size();i++){\\n            s+=ans[i]; \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1708624,
                "title": "c-simple-solution-using-preorder-traversal-sum-root-to-leaf-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> answer;\\n    void preorder(TreeNode* root, string str){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> left == NULL and root -> right == NULL){\\n            str = str+to_string(root -> val);\\n            answer.push_back(str);\\n            return;\\n        }\\n        str = str+to_string(root -> val);\\n        preorder(root -> left,str);\\n        preorder(root -> right,str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        int sum = 0;\\n        for(int i = 0 ; i < answer.size(); i++){\\n            // reverse(answer[i].begin(), answer[i].end());\\n            int x = stoi(answer[i]);\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> answer;\\n    void preorder(TreeNode* root, string str){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root -> left == NULL and root -> right == NULL){\\n            str = str+to_string(root -> val);\\n            answer.push_back(str);\\n            return;\\n        }\\n        str = str+to_string(root -> val);\\n        preorder(root -> left,str);\\n        preorder(root -> right,str);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string str;\\n        preorder(root,str);\\n        int sum = 0;\\n        for(int i = 0 ; i < answer.size(); i++){\\n            // reverse(answer[i].begin(), answer[i].end());\\n            int x = stoi(answer[i]);\\n            sum+=x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662966,
                "title": "java-bfs-dfs",
                "content": "BFS: 2ms, 38.7 MB\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int res = 0;\\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        q.offer(new Pair<>(root,root.val));\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i = 0;i<s;i++){\\n                Pair<TreeNode,Integer> pair = q.poll();\\n                root = pair.getKey();\\n                int value = pair.getValue();\\n                if(root.left==null && root.right==null){\\n                    res += value;\\n                    continue;\\n                }\\n                if(root.left!=null){\\n                    q.offer(new Pair<>(root.left,value*10+root.left.val));\\n                }\\n                if(root.right!=null){\\n                    q.offer(new Pair<>(root.right,value*10+root.right.val));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nDFS: 0 ms, 38.3 MB\\n```\\nclass Solution {\\n    int res = 0;\\n    public int sumNumbers(TreeNode root) {\\n        dfs(root,root.val);\\n        return res;\\n    }\\n    public void dfs(TreeNode root, int total){\\n        if(root.left==null && root.right==null){\\n            res+=total;\\n            return;\\n        }\\n        if(root.left!=null){\\n            dfs(root.left, total*10 + root.left.val);\\n        }\\n        if(root.right!=null){\\n            dfs(root.right, total*10 + root.right.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int res = 0;\\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        q.offer(new Pair<>(root,root.val));\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i = 0;i<s;i++){\\n                Pair<TreeNode,Integer> pair = q.poll();\\n                root = pair.getKey();\\n                int value = pair.getValue();\\n                if(root.left==null && root.right==null){\\n                    res += value;\\n                    continue;\\n                }\\n                if(root.left!=null){\\n                    q.offer(new Pair<>(root.left,value*10+root.left.val));\\n                }\\n                if(root.right!=null){\\n                    q.offer(new Pair<>(root.right,value*10+root.right.val));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int res = 0;\\n    public int sumNumbers(TreeNode root) {\\n        dfs(root,root.val);\\n        return res;\\n    }\\n    public void dfs(TreeNode root, int total){\\n        if(root.left==null && root.right==null){\\n            res+=total;\\n            return;\\n        }\\n        if(root.left!=null){\\n            dfs(root.left, total*10 + root.left.val);\\n        }\\n        if(root.right!=null){\\n            dfs(root.right, total*10 + root.right.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557540,
                "title": "python-99-speed-99-memory",
                "content": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def helper(node, num):\\n            if node is None:\\n                return 0\\n            num = num * 10 + node.val\\n            if node.left is None and node.right is None:\\n                return num\\n            return helper(node.left, num) + helper(node.right, num)\\n        \\n        return helper(root, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def helper(node, num):\\n            if node is None:\\n                return 0\\n            num = num * 10 + node.val\\n            if node.left is None and node.right is None:\\n                return num\\n            return helper(node.left, num) + helper(node.right, num)\\n        \\n        return helper(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557343,
                "title": "rust-dfs-iterative",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        let mut stack = vec![(root, 0)];\\n\\n        while let Some(node_sum) = stack.pop() {\\n            if let Some(node) = node_sum.0 {\\n                let node = node.borrow();\\n                let cur_sum = 10 * node_sum.1 + node.val;\\n\\n                if node.left.is_none() && node.right.is_none() {\\n                    res += cur_sum;\\n                    continue;\\n                }\\n\\n                stack.push((node.left.clone(), cur_sum));\\n                stack.push((node.right.clone(), cur_sum));\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut res = 0;\\n        let mut stack = vec![(root, 0)];\\n\\n        while let Some(node_sum) = stack.pop() {\\n            if let Some(node) = node_sum.0 {\\n                let node = node.borrow();\\n                let cur_sum = 10 * node_sum.1 + node.val;\\n\\n                if node.left.is_none() && node.right.is_none() {\\n                    res += cur_sum;\\n                    continue;\\n                }\\n\\n                stack.push((node.left.clone(), cur_sum));\\n                stack.push((node.right.clone(), cur_sum));\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557135,
                "title": "python-simple-and-recursive-solution",
                "content": "```\\nclass Solution:\\n\\n    def dfs(self, val, node) -> int:\\n        if node is None:\\n            return 0\\n        # The node is leaf:\\n        elif node.left is None and node.right is None:\\n            return int(val+str(node.val))\\n        else:\\n            return self.dfs(val + str(node.val), node.right) + self.dfs(val + str(node.val), node.left)\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return self.dfs(\"\", root)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def dfs(self, val, node) -> int:\\n        if node is None:\\n            return 0\\n        # The node is leaf:\\n        elif node.left is None and node.right is None:\\n            return int(val+str(node.val))\\n        else:\\n            return self.dfs(val + str(node.val), node.right) + self.dfs(val + str(node.val), node.left)\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return self.dfs(\"\", root)",
                "codeTag": "Java"
            },
            {
                "id": 1556479,
                "title": "c-easy-to-understand-solution-using-recursion",
                "content": "```\\n//variable to store our answer\\nlong long sum = 0;\\n\\t\\n\\t//function for dfs\\n    void recur(TreeNode *root,long long num)\\n    {\\n\\t//base case\\n        if(!root) return;\\n\\t\\t\\n\\t\\t//update num as num*10 + root->val\\n        num *= 10;\\n        num += root->val;\\n\\t\\t\\n\\t\\t//if current node is leaf node, update sum and return\\n        if(!root->left and !root->right)\\n        {\\n            sum += num;\\n            return;\\n        }\\n        \\n\\t\\t//recur for left and right\\n        recur(root->left,num);\\n        recur(root->right,num);\\n    }\\n\\t\\n\\tint sumNumbers(TreeNode* root) {\\n        sum = 0;\\n\\t\\t//call dfs\\n        recur(root,0);\\n\\t\\t\\n\\t\\t//return answer\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//variable to store our answer\\nlong long sum = 0;\\n\\t\\n\\t//function for dfs\\n    void recur(TreeNode *root,long long num)\\n    {\\n\\t//base case\\n        if(!root) return;\\n\\t\\t\\n\\t\\t//update num as num*10 + root->val\\n        num *= 10;\\n        num += root->val;\\n\\t\\t\\n\\t\\t//if current node is leaf node, update sum and return\\n        if(!root->left and !root->right)\\n        {\\n            sum += num;\\n            return;\\n        }\\n        \\n\\t\\t//recur for left and right\\n        recur(root->left,num);\\n        recur(root->right,num);\\n    }\\n\\t\\n\\tint sumNumbers(TreeNode* root) {\\n        sum = 0;\\n\\t\\t//call dfs\\n        recur(root,0);\\n\\t\\t\\n\\t\\t//return answer\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555889,
                "title": "java-easy-solution-dfs-preorder-traversal-explanation-simplified",
                "content": "Hey Programmers,\\nI tried to solve this question using DFS with preorder traversal :\\n\\nLet\\'s Understand this with an example : \\n![image](https://assets.leetcode.com/users/images/9d953701-8857-4132-beb8-2368fde88872_1635899796.6375616.png)\\n\\nThe idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be sum. For every node, we update the sum as sum*10 plus node\\u2019s data.\\n\\n![image](https://assets.leetcode.com/users/images/293397a3-8b2a-4edf-90b7-dd0b2ac36a3e_1635899830.6428554.png)\\n\\n```\\nclass Solution {\\n    \\n    int total = 0; // Global variable which hold our sum;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        total = 0;\\n        helper(root, 0); // helper functions holds the root i.e. 4 & leaf node which is intially 0\\n        return total;\\n    }\\n    \\n    void helper(TreeNode root, int sum){\\n        // Base Condition\\n        if(root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if(root.left == null && root.right == null){\\n            total += sum;\\n            return;\\n        }\\n        \\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n}\\n```\\n\\nI hope this help\\'s you to understand. Thanks (:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int total = 0; // Global variable which hold our sum;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        total = 0;\\n        helper(root, 0); // helper functions holds the root i.e. 4 & leaf node which is intially 0\\n        return total;\\n    }\\n    \\n    void helper(TreeNode root, int sum){\\n        // Base Condition\\n        if(root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if(root.left == null && root.right == null){\\n            total += sum;\\n            return;\\n        }\\n        \\n        helper(root.left, sum);\\n        helper(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717793,
                "title": "c-2-solutions-bfs-and-dfs-preorder",
                "content": "**BFS**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<pair<TreeNode*, int>> bfs;\\n        bfs.push({root, root->val});\\n        \\n        pair<TreeNode*, int> curr;\\n        int total_sum = 0;\\n        \\n        while(!bfs.empty()){\\n            curr = bfs.front();\\n            bfs.pop();\\n            \\n            if(!curr.first->left && !curr.first->right)\\n                total_sum += curr.second;\\n            \\n            if(curr.first->left)\\n                bfs.push({curr.first->left, (curr.second * 10 + curr.first->left->val)});\\n            if(curr.first->right)\\n                bfs.push({curr.first->right, (curr.second * 10 + curr.first->right->val)});\\n        }\\n        \\n        return total_sum;\\n    }\\n};\\n```\\n**DFS**\\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int total_sum = 0;\\n        \\n        dfs(root, total_sum, 0);\\n        \\n        return total_sum;\\n    }\\n    \\n    void dfs(TreeNode* root, int& total_sum, int curr){\\n        if(root == NULL) return;\\n        \\n        curr = (curr * 10) + root->val;\\n        \\n        if(!root->right && !root->left) total_sum += curr;\\n        \\n        if(root->left) dfs(root->left, total_sum, curr);\\n        if(root->right) dfs(root->right, total_sum, curr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        \\n        queue<pair<TreeNode*, int>> bfs;\\n        bfs.push({root, root->val});\\n        \\n        pair<TreeNode*, int> curr;\\n        int total_sum = 0;\\n        \\n        while(!bfs.empty()){\\n            curr = bfs.front();\\n            bfs.pop();\\n            \\n            if(!curr.first->left && !curr.first->right)\\n                total_sum += curr.second;\\n            \\n            if(curr.first->left)\\n                bfs.push({curr.first->left, (curr.second * 10 + curr.first->left->val)});\\n            if(curr.first->right)\\n                bfs.push({curr.first->right, (curr.second * 10 + curr.first->right->val)});\\n        }\\n        \\n        return total_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int total_sum = 0;\\n        \\n        dfs(root, total_sum, 0);\\n        \\n        return total_sum;\\n    }\\n    \\n    void dfs(TreeNode* root, int& total_sum, int curr){\\n        if(root == NULL) return;\\n        \\n        curr = (curr * 10) + root->val;\\n        \\n        if(!root->right && !root->left) total_sum += curr;\\n        \\n        if(root->left) dfs(root->left, total_sum, curr);\\n        if(root->right) dfs(root->right, total_sum, curr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517515,
                "title": "python3-bfs-solution-faster-than-99-submissions",
                "content": "```\\nRuntime: 20 ms, faster than 99.42% of Python3 online submissions for Sum Root to Leaf Numbers.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Sum Root to Leaf Numbers.\\n```\\n\\n```\\n\\tfrom collections import deque\\n\\n    def sum_numbers_bfs(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        node_queue = deque([(root, root.val)])\\n        total_sum = 0\\n        while node_queue:\\n            cur_node, cur_sum = node_queue.popleft()\\n            if cur_node.left:\\n                node_queue.append((cur_node.left, cur_sum * 10 + cur_node.left.val))\\n\\n            if cur_node.right:\\n                node_queue.append((cur_node.right, cur_sum * 10 + cur_node.right.val))\\n\\n            if not cur_node.left and not cur_node.right:\\n                total_sum += cur_sum\\n\\n        return total_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime: 20 ms, faster than 99.42% of Python3 online submissions for Sum Root to Leaf Numbers.\\nMemory Usage: 12.9 MB, less than 100.00% of Python3 online submissions for Sum Root to Leaf Numbers.\\n```\n```\\n\\tfrom collections import deque\\n\\n    def sum_numbers_bfs(self, root: TreeNode) -> int:\\n        if not root: return 0\\n\\n        node_queue = deque([(root, root.val)])\\n        total_sum = 0\\n        while node_queue:\\n            cur_node, cur_sum = node_queue.popleft()\\n            if cur_node.left:\\n                node_queue.append((cur_node.left, cur_sum * 10 + cur_node.left.val))\\n\\n            if cur_node.right:\\n                node_queue.append((cur_node.right, cur_sum * 10 + cur_node.right.val))\\n\\n            if not cur_node.left and not cur_node.right:\\n                total_sum += cur_sum\\n\\n        return total_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 413263,
                "title": "python-solution-using-iterative-dfs-approach",
                "content": "Here\\'s my solution for Python.\\n\\nAny type of tree traversal problem you must decided to first either use recursion OR iterative.  The downside to recursion, aside from being challenging if you don\\'t know the patterns, is that is has the potential for Stackoverflow for very large trees.  I like the iterative approach better, since in order to solve the problem, I\\'ll need to traverse the tree in a DFS fashion.\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        summation = 0\\n        if root is None:\\n            return summation\\n        \\n        stack = [(root, root.val)]\\n        \\n        while len(stack) != 0:\\n            node, running_sum = stack.pop()\\n            \\n            if node.left is None and node.right is None:\\n                summation += running_sum\\n                continue\\n            \\n            if node.left:\\n                new_sum = int(str(running_sum) + str(node.left.val))\\n                stack.append((node.left, new_sum))\\n            if node.right:\\n                new_sum = int(str(running_sum) + str(node.right.val))\\n                stack.append((node.right, new_sum))                \\n                \\n        return summation\\n```\\n\\nAnalysis of time and space complexity is as follows:\\n\\nTime: O(N)\\n    Since I need to traverse through each node to figure out the summations.\\n\\t\\nSpace: O(log N) on average, O(N) worst case\\nExplanation:\\nIf you have unbalanced tree, then the stack reaches N nodes, so its worst case O(N).  To better understand this, imagine a tree that only has node.right branches, and no left branches.  Then DFS traverses through goes through all N nodes to figure out the summation.  \\nIf you have a balanced tree, then you only traverse the depth of the tree (or the height) and thus you only store those nodes in the stack.  To figure out the height of a balanced tree, I recommend google searching the math proof, but that evaluates to O(log N).  So assuming most trees we recieved are balanced, then on average its O(log N).  \\n\\nThe key to solving this problem is recognizing the code pattern used for DFS traversals.  If your not familiar, then I suggest studying the different ways to solve the isValidBST problem\\nhttps://leetcode.com/problems/validate-binary-search-tree/\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        summation = 0\\n        if root is None:\\n            return summation\\n        \\n        stack = [(root, root.val)]\\n        \\n        while len(stack) != 0:\\n            node, running_sum = stack.pop()\\n            \\n            if node.left is None and node.right is None:\\n                summation += running_sum\\n                continue\\n            \\n            if node.left:\\n                new_sum = int(str(running_sum) + str(node.left.val))\\n                stack.append((node.left, new_sum))\\n            if node.right:\\n                new_sum = int(str(running_sum) + str(node.right.val))\\n                stack.append((node.right, new_sum))                \\n                \\n        return summation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248949,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    var s = 0\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        var p = 0\\n        f(root, &p)\\n        \\n        return s\\n    }\\n    \\n    func f(_ root: TreeNode?, _ p: inout Int) {\\n        guard let r = root else { return }\\n        \\n        p = p * 10 + r.val\\n        if r.left == nil && r.right == nil {\\n            s += p\\n        }\\n        \\n        f(r.left, &p)\\n        f(r.right, &p)\\n        p -= r.val\\n        p /= 10\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    var s = 0\\n    \\n    func sumNumbers(_ root: TreeNode?) -> Int {\\n        var p = 0\\n        f(root, &p)\\n        \\n        return s\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41480,
                "title": "very-simple-recursion-solution-using-c",
                "content": "    int helper(TreeNode* root, int prev)\\n    {\\n        if(!root)\\n            return 0;\\n        int num = prev * 10 + (root->val);\\n        if(!root->left && !root->right)//if node is leaf\\n            return num;\\n        else\\n            return helper(root->left, num) + helper(root->right, num);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        return helper(root, 0);\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    int helper(TreeNode* root, int prev)\\n    {\\n        if(!root)\\n            return 0;\\n        int num = prev * 10 + (root->val);\\n        if(!root->left && !root->right)//if node is leaf\\n            return num;\\n        else\\n            return helper(root->left, num) + helper(root->right, num);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        return helper(root, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41527,
                "title": "clean-java-solution-preorder-traversal",
                "content": "    public class Q129 {\\n        int result=0;\\n        public int sumNumbers(TreeNode root) {\\n            if (root==null) return 0;\\n            addValues(root, root.val);\\n            return result;\\n        }\\n    \\n        public void addValues(TreeNode node, int value){\\n            if (node.left==null && node.right==null) result+=value;\\n            if (node.left!=null) addValues(node.left, value*10+node.left.val);\\n            if (node.right!=null) addValues(node.right, value*10+node.right.val);\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class Q129 {\\n        int result=0;\\n        public int sumNumbers(TreeNode root) {\\n            if (root==null) return 0;\\n            addValues(root, root.val);\\n            return result;\\n        }\\n    \\n        public void addValues(TreeNode node, int value){\\n            if (node.left==null && node.right==null) result+=value;\\n            if (node.left!=null) addValues(node.left, value*10+node.left.val);\\n            if (node.right!=null) addValues(node.right, value*10+node.right.val);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41530,
                "title": "simple-and-clean-java-solution-based-on-pre-order-traversal",
                "content": "     public int sumNumbers(TreeNode root) {\\n        return sumNumbers(root, 0);\\n     }\\n\\n\\tprivate int sumNumbers(TreeNode root, int sum) {\\n\\t\\tif (root == null) return 0;\\n\\t\\tsum = sum * 10 + root.val;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\treturn sumNumbers(root.left, sum) + sumNumbers(root.right, sum);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "     public int sumNumbers(TreeNode root) {\\n        return sumNumbers(root, 0);\\n     }\\n\\n\\tprivate int sumNumbers(TreeNode root, int sum) {\\n\\t\\tif (root == null) return 0;\\n\\t\\tsum = sum * 10 + root.val;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t\\treturn sumNumbers(root.left, sum) + sumNumbers(root.right, sum);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 41544,
                "title": "my-c-solution-with-2-parameters",
                "content": "    class Solution {\\n    public:\\n        int sum(TreeNode*root, int subsum) {\\n            if(!root)   return 0;\\n            if(!root->left && !root->right) return subsum*10+root->val;\\n            return sum(root->left, subsum*10+root->val)+sum(root->right, subsum*10+root->val);\\n        }\\n        int sumNumbers(TreeNode* root) {\\n            return sum(root, 0);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sum(TreeNode*root, int subsum) {\\n            if(!root)   return 0;\\n            if(!root->left && !root->right) return subsum*10+root->val;\\n            return sum(root->left, subsum*10+root->val)+sum(root->right, subsum*10+root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 41575,
                "title": "simple-no-recursive-using-queue-java",
                "content": "     public static int sumNumbers(TreeNode root) {\\n        if(root==null)\\n        \\treturn 0;\\n        Queue<TreeNode> node=new LinkedList<TreeNode>();\\n        Queue<Integer> sum=new LinkedList<Integer>();\\n        node.add(root);\\n        sum.add(root.val);\\n        int res=0;\\n        while(!node.isEmpty()){\\n        \\tTreeNode cur=node.poll();\\n        \\tInteger num=sum.poll();\\n        \\n        \\tif(cur.left!=null){\\n        \\t\\tnode.offer(cur.left);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.left.val));\\n        \\t}\\n        \\tif(cur.right!=null){\\n        \\t\\tnode.offer(cur.right);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.right.val));\\n        \\t}     \\n        \\tif(cur.left==null&&cur.right==null){\\n        \\t\\tres=(int)num+res;\\n        \\t}\\n        \\n        } \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "     public static int sumNumbers(TreeNode root) {\\n        if(root==null)\\n        \\treturn 0;\\n        Queue<TreeNode> node=new LinkedList<TreeNode>();\\n        Queue<Integer> sum=new LinkedList<Integer>();\\n        node.add(root);\\n        sum.add(root.val);\\n        int res=0;\\n        while(!node.isEmpty()){\\n        \\tTreeNode cur=node.poll();\\n        \\tInteger num=sum.poll();\\n        \\n        \\tif(cur.left!=null){\\n        \\t\\tnode.offer(cur.left);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.left.val));\\n        \\t}\\n        \\tif(cur.right!=null){\\n        \\t\\tnode.offer(cur.right);\\n        \\t\\tsum.offer((Integer)((int)(num)*10+cur.right.val));\\n        \\t}     \\n        \\tif(cur.left==null&&cur.right==null){\\n        \\t\\tres=(int)num+res;\\n        \\t}\\n        \\n        } \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41577,
                "title": "c-5ms-dfs-code-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int sumNumbers(TreeNode *root) {\\n        return traverse(0, root);\\n    }\\n    \\n    int traverse(int fathers, TreeNode *root) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        \\n        int cur = fathers * 10 + root->val;\\n        \\n        int sum = traverse(cur, root->left) + traverse(cur, root->right);\\n        \\n        return (sum != 0) ? sum : cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int sumNumbers(TreeNode *root) {\\n        return traverse(0, root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41578,
                "title": "simple-java-solution-accepted",
                "content": "    public class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbersUtil(root, 0);\\n        }\\n        \\n        public int sumNumbersUtil(TreeNode root, int path) {\\n            if (root == null) {\\n                return 0;\\n            }\\n            \\n            path = path*10 + root.val;\\n    \\n            if (root.left == null && root.right == null) {\\n                return path;\\n            }\\n    \\n            return sumNumbersUtil(root.left, path) + sumNumbersUtil(root.right, path);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int sumNumbers(TreeNode root) {\\n            return sumNumbersUtil(root, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3524388,
                "title": "java-beats-100-oms-recursion-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n    private int dfs(TreeNode root, int sum) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        sum = sum * 10 + root.val;\\n        if (root.left == null && root.right == null) {\\n            return sum;\\n        }\\n        return dfs(root.left, sum) + dfs(root.right, sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298158,
                "title": "awesome-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def sumroot(root,s):\\n            if not root: return 0\\n            s=s*10+root.val\\n            if not root.left and not root.right: return s\\n            return sumroot(root.left,s) + sumroot(root.right,s)\\n        return sumroot(root,0)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def sumroot(root,s):\\n            if not root: return 0\\n            s=s*10+root.val\\n            if not root.left and not root.right: return s\\n            return sumroot(root.left,s) + sumroot(root.right,s)\\n        return sumroot(root,0)\\n    #please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297822,
                "title": "php-beats-100-javascript-93-2-different-approaches",
                "content": "##### Here you can get acquainted with **2 different solutions**. Solutions implemented in **PHP** and **JavaScript**\\n\\n### SOLUTION #1\\nThe approach used in this solution is to traverse the tree using a breadth-first search, and for each node add the values of its children to the sum of its own value. We also use a queue to keep track of the nodes that need to be visited. We start with the root node, and for each node check if it is a leaf node (if it has no children). If it is, add the value of the node to the total sum. If it is not a leaf node, add its children to the queue, and add the node value to the children\\'s values. When the queue is empty, all the nodes have been visited and the sum is returned.\\n*Time complexity*: O(n), as we visit every node in the tree once.\\n*Space complexity*: O(n), as we use a queue to store up to n nodes at any given time.\\n\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int {\\n        if ($root === null || $root->val === null) return 0;\\n        $totalSum = 0;\\n        $queue = [$root];\\n        while (count($queue) > 0) {\\n            $node = array_shift($queue);\\n            if ($node->left === null && $node->right === null) {\\n                $totalSum += $node->val;\\n            }\\n\\n            if ($node->left) {\\n                $node->left->val = $node->val * 10 + $node->left->val;\\n                $queue[] = $node->left;\\n            }\\n            if ($node->right) {\\n                $node->right->val = $node->val * 10 + $node->right->val;\\n                $queue[] = $node->right;\\n            }\\n        }\\n        return $totalSum;\\n    }\\n}\\n```\\n```javascript []\\nvar sumNumbers = function (root) {\\n    let totalSum = 0;\\n    if (root === null || root.val === undefined) return 0;\\n    if (root.left === undefined && root.right === undefined) return root.val;\\n    let queue = [root];\\n\\n    while (queue.length > 0) {\\n        node = queue.shift();\\n        if (node.left === null && node.right == null) {\\n            totalSum += node.val;\\n        }\\n        if (node.left && node.left.val !== undefined) {\\n            node.left.val = node.val * 10 + node.left.val;\\n            queue.push(node.left);\\n        }\\n        if (node.right && node.right.val !== undefined) {\\n            node.right.val = node.val * 10 + node.right.val;\\n            queue.push(node.right);\\n        }\\n    }\\n    return totalSum;\\n};\\n```\\n\\n\\n### SOLUTION #2\\nThis solution uses a Depth-First Search (DFS) approach to traverse the binary tree and calculate the sum of all root-to-leaf path numbers. The DFS function takes in a node and the sum of the existing path up to the node. If the node is null, then it returns 0. If the node is a leaf node, it returns the total sum of the path from the root to the leaf node. If the node has children, then it calls the same DFS function on both of the children, passing in the sum of the existing path up to that node. The sum of all the DFS calls is then returned.\\n*Time Complexity*: O(n) as we have to traverse each node in the binary tree once.\\n*Space Complexity*: O(n) as the maximum depth of the recursive stack can be n for a binary tree with n nodes.\\n\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int\\n    {\\n        return $this->dfs($root, 0);\\n    }\\n\\n    private function dfs(?TreeNode $node, int $sum): int\\n    {\\n        if ($node === null) {\\n            return 0;\\n        }\\n        if ($node->left === null && $node->right == null) {\\n            return $sum * 10 + $node->val;\\n        }\\n        return $this->dfs($node->left, $sum * 10 + $node->val) +\\n            $this->dfs($node->right, $sum * 10 + $node->val);\\n    }\\n}\\n```\\n```javascript []\\nvar sumNumbers = function (root) {\\n    const dfs = function (node, sum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left === null && node.right == null) {\\n            return sum * 10 + node.val;\\n        }\\n        return dfs(node.left, sum * 10 + node.val) +\\n               dfs(node.right, sum * 10 + node.val);\\n    }\\n    return dfs(root, 0);\\n}\\n```\\n\\n### If my work was useful for you, please upvote\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP"
                ],
                "code": "```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int {\\n        if ($root === null || $root->val === null) return 0;\\n        $totalSum = 0;\\n        $queue = [$root];\\n        while (count($queue) > 0) {\\n            $node = array_shift($queue);\\n            if ($node->left === null && $node->right === null) {\\n                $totalSum += $node->val;\\n            }\\n\\n            if ($node->left) {\\n                $node->left->val = $node->val * 10 + $node->left->val;\\n                $queue[] = $node->left;\\n            }\\n            if ($node->right) {\\n                $node->right->val = $node->val * 10 + $node->right->val;\\n                $queue[] = $node->right;\\n            }\\n        }\\n        return $totalSum;\\n    }\\n}\\n```\n```javascript []\\nvar sumNumbers = function (root) {\\n    let totalSum = 0;\\n    if (root === null || root.val === undefined) return 0;\\n    if (root.left === undefined && root.right === undefined) return root.val;\\n    let queue = [root];\\n\\n    while (queue.length > 0) {\\n        node = queue.shift();\\n        if (node.left === null && node.right == null) {\\n            totalSum += node.val;\\n        }\\n        if (node.left && node.left.val !== undefined) {\\n            node.left.val = node.val * 10 + node.left.val;\\n            queue.push(node.left);\\n        }\\n        if (node.right && node.right.val !== undefined) {\\n            node.right.val = node.val * 10 + node.right.val;\\n            queue.push(node.right);\\n        }\\n    }\\n    return totalSum;\\n};\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Integer\\n     */\\n    function sumNumbers(TreeNode $root): int\\n    {\\n        return $this->dfs($root, 0);\\n    }\\n\\n    private function dfs(?TreeNode $node, int $sum): int\\n    {\\n        if ($node === null) {\\n            return 0;\\n        }\\n        if ($node->left === null && $node->right == null) {\\n            return $sum * 10 + $node->val;\\n        }\\n        return $this->dfs($node->left, $sum * 10 + $node->val) +\\n            $this->dfs($node->right, $sum * 10 + $node->val);\\n    }\\n}\\n```\n```javascript []\\nvar sumNumbers = function (root) {\\n    const dfs = function (node, sum) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left === null && node.right == null) {\\n            return sum * 10 + node.val;\\n        }\\n        return dfs(node.left, sum * 10 + node.val) +\\n               dfs(node.right, sum * 10 + node.val);\\n    }\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297440,
                "title": "simple-java-solution-using-recursion-100-faster",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        // takes root and initial sum (which is 0 at the start)\\n        return inorder(root, 0);\\n    }\\n    private int inorder(TreeNode root, int num) {\\n        // we reached to root of tree\\n        if (root.left == null && root.right == null) return num * 10 + root.val;\\n        \\n        num = num * 10 + root.val;\\n        int left = 0;\\n        int right = 0;\\n        // computing left sub tree\\n        if (root.left != null) {\\n            left += inorder(root.left, num);\\n        }\\n        // computing right sub tree\\n        if (root.right != null) {\\n            right += inorder(root.right, num);\\n        }\\n        // adding values of both sub trees\\n        return left + right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        // takes root and initial sum (which is 0 at the start)\\n        return inorder(root, 0);\\n    }\\n    private int inorder(TreeNode root, int num) {\\n        // we reached to root of tree\\n        if (root.left == null && root.right == null) return num * 10 + root.val;\\n        \\n        num = num * 10 + root.val;\\n        int left = 0;\\n        int right = 0;\\n        // computing left sub tree\\n        if (root.left != null) {\\n            left += inorder(root.left, num);\\n        }\\n        // computing right sub tree\\n        if (root.right != null) {\\n            right += inorder(root.right, num);\\n        }\\n        // adding values of both sub trees\\n        return left + right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296503,
                "title": "simple-c-solution-using-path-sum-i",
                "content": "# Intuition\\nPath Sum I\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,string &s,int &ans){\\n        if(root && !root->left && !root->right)\\n        {\\n            s+=to_string(root->val);\\n            ans+=stoi(s);\\n            s.pop_back();\\n        }\\n        if(root){\\n            s+=to_string(root->val);\\n            solve(root->left,s,ans);\\n            solve(root->right,s,ans);\\n            s.pop_back();\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        solve(root,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,string &s,int &ans){\\n        if(root && !root->left && !root->right)\\n        {\\n            s+=to_string(root->val);\\n            ans+=stoi(s);\\n            s.pop_back();\\n        }\\n        if(root){\\n            s+=to_string(root->val);\\n            solve(root->left,s,ans);\\n            solve(root->right,s,ans);\\n            s.pop_back();\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        string s=\"\";\\n        int ans=0;\\n        solve(root,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296139,
                "title": "python3-simple-dfs-27-ms-faster-than-92-24",
                "content": "https://leetcode.com/submissions/detail/914997379/\\nRuntime: **27 ms, faster than 92.24%** of Python3 online submissions for Sum Root to Leaf Numbers.  \\nMemory Usage: 13.8 MB, less than 95.89% of Python3 online submissions for Sum Root to Leaf Numbers.  \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        nsum = 0\\n        if not root: return nsum\\n        l = [(str(root.val), root)]\\n        while l: ## dfs\\n            s, n = l.pop() ## string, node\\n            if not n.left and not n.right:\\n                nsum += int(s); continue\\n            if n.right:\\n                l.append((s+str(n.right.val), n.right))\\n            if n.left:\\n                l.append((s+str(n.left.val), n.left))\\n        return nsum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        nsum = 0\\n        if not root: return nsum\\n        l = [(str(root.val), root)]\\n        while l: ## dfs\\n            s, n = l.pop() ## string, node\\n            if not n.left and not n.right:\\n                nsum += int(s); continue\\n            if n.right:\\n                l.append((s+str(n.right.val), n.right))\\n            if n.left:\\n                l.append((s+str(n.left.val), n.left))\\n        return nsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296020,
                "title": "very-simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Recursion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First traverse left subtree using node.left, node.right\\n2. On each rucursive call add left node value to existing value multiplying by 10. (On each level - value goes to new point 1->10->100)\\n3. Traverse right subtree.\\n4. Add value to result if left and right subtree is null means it is a leaf node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h), where h is the height of the tree.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    \\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n        sumNumbersHelper(root.left, root.right, root.val);\\n\\t\\treturn result;\\n    }\\n\\t\\n\\tpublic void sumNumbersHelper(TreeNode l, TreeNode r, int val) {\\n\\t\\tif(l==null && r == null) {\\n\\t\\t\\tresult += val;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(l!= null) {\\n\\t\\t\\tsumNumbersHelper(l.left, l.right, val*10 + l.val);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(r != null) {\\n\\t\\t\\tsumNumbersHelper(r.left, r.right, val*10 + r.val);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int result = 0;\\n    \\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\tif(root == null) return 0;\\n        sumNumbersHelper(root.left, root.right, root.val);\\n\\t\\treturn result;\\n    }\\n\\t\\n\\tpublic void sumNumbersHelper(TreeNode l, TreeNode r, int val) {\\n\\t\\tif(l==null && r == null) {\\n\\t\\t\\tresult += val;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(l!= null) {\\n\\t\\t\\tsumNumbersHelper(l.left, l.right, val*10 + l.val);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(r != null) {\\n\\t\\t\\tsumNumbersHelper(r.left, r.right, val*10 + r.val);\\n\\t\\t}\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295776,
                "title": "easy-o-n-c-solution",
                "content": "# Approach\\nAdding to total sum only when reaching leaf node\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int totalsum=0;\\n    int sumNumbers(TreeNode* root,int sum=0) {\\n        if(root){\\n            int sum1 = sum;\\n            sum1 = sum1*10+root->val;\\n            sumNumbers(root->left,sum1);\\n            sumNumbers(root->right,sum1);\\n            if(!root->left && !root->right){\\n                totalsum+=sum1;\\n            }\\n            return totalsum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int totalsum=0;\\n    int sumNumbers(TreeNode* root,int sum=0) {\\n        if(root){\\n            int sum1 = sum;\\n            sum1 = sum1*10+root->val;\\n            sumNumbers(root->left,sum1);\\n            sumNumbers(root->right,sum1);\\n            if(!root->left && !root->right){\\n                totalsum+=sum1;\\n            }\\n            return totalsum;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295408,
                "title": "python-elegant-short-dsf-generators-97-5-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(h)\\n    \"\"\"\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return sum(self._get_paths(root, path=0))\\n\\n    @classmethod\\n    def _get_paths(cls, root: Optional[TreeNode], path: int) -> Iterable[int]:\\n        if root is None:\\n            return\\n\\n        path = path * 10 + root.val\\n        if root.left is None and root.right is None:\\n            yield path\\n        else:\\n            yield from cls._get_paths(root.left, path)\\n            yield from cls._get_paths(root.right, path)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(h)\\n    \"\"\"\\n\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        return sum(self._get_paths(root, path=0))\\n\\n    @classmethod\\n    def _get_paths(cls, root: Optional[TreeNode], path: int) -> Iterable[int]:\\n        if root is None:\\n            return\\n\\n        path = path * 10 + root.val\\n        if root.left is None and root.right is None:\\n            yield path\\n        else:\\n            yield from cls._get_paths(root.left, path)\\n            yield from cls._get_paths(root.right, path)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295189,
                "title": "javascript-rust-go-short-recursive-solution",
                "content": "## JavaScript Solution\\n\\n```\\nconst sumNumbers = function (root, num = 0) {\\n  if (!root) return 0;\\n  num = num * 10 + root.val;\\n  if (!root.left && !root.right) return num;\\n\\n  return sumNumbers(root.left, num) + sumNumbers(root.right, num);\\n};\\n\\n```\\n\\n## Rust Solution\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::sum_nodes(root, 0)\\n    }\\n\\n    pub fn sum_nodes(node: Option<Rc<RefCell<TreeNode>>>, num: i32) -> i32 {\\n        if node.is_none() { return 0; }\\n        let node = node.unwrap();\\n        let node = node.borrow();\\n        let num = num * 10 + node.val;\\n\\n        if node.left.is_none() && node.right.is_none() { return num; }\\n\\n        Solution::sum_nodes(node.left.clone(), num.clone()) \\n            + Solution::sum_nodes(node.right.clone(), num.clone())\\n    }\\n}\\n```\\n\\n## Go Solution\\n\\n```go\\nfunc sumNumbers(root *TreeNode) int {\\n\\treturn sumNodes(root, 0)\\n}\\n\\nfunc sumNodes(node *TreeNode, num int) int {\\n\\tif node == nil { return 0 }\\n\\n\\tnum = num * 10 + node.Val\\n\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\treturn num\\n\\t}\\n\\n\\treturn sumNodes(node.Left, num) + sumNodes(node.Right, num)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst sumNumbers = function (root, num = 0) {\\n  if (!root) return 0;\\n  num = num * 10 + root.val;\\n  if (!root.left && !root.right) return num;\\n\\n  return sumNumbers(root.left, num) + sumNumbers(root.right, num);\\n};\\n\\n```\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        Solution::sum_nodes(root, 0)\\n    }\\n\\n    pub fn sum_nodes(node: Option<Rc<RefCell<TreeNode>>>, num: i32) -> i32 {\\n        if node.is_none() { return 0; }\\n        let node = node.unwrap();\\n        let node = node.borrow();\\n        let num = num * 10 + node.val;\\n\\n        if node.left.is_none() && node.right.is_none() { return num; }\\n\\n        Solution::sum_nodes(node.left.clone(), num.clone()) \\n            + Solution::sum_nodes(node.right.clone(), num.clone())\\n    }\\n}\\n```\n```go\\nfunc sumNumbers(root *TreeNode) int {\\n\\treturn sumNodes(root, 0)\\n}\\n\\nfunc sumNodes(node *TreeNode, num int) int {\\n\\tif node == nil { return 0 }\\n\\n\\tnum = num * 10 + node.Val\\n\\n\\tif node.Left == nil && node.Right == nil {\\n\\t\\treturn num\\n\\t}\\n\\n\\treturn sumNodes(node.Left, num) + sumNodes(node.Right, num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295157,
                "title": "easy-to-understand-c-solution-using-dfs-and-string",
                "content": "# Intuition\\nFor finding the paths we have to traverse the tree and store path into appropriate data structure and add those at the leaf node\\n\\n# Approach\\nWe need paths from root to leaf, so we will take a string which will keep the record of values from root to leaf and when we reach the leaf node then we will convert the string value to integer value and add it to our ans variable this is the number obtained from path one. Now remove the last inserted value as we have to traverse the right subtree and follow the same process for second path\\n\\n# Complexity\\n- Time complexity:\\nO(n) As we have visited ever node only once\\n\\n- Space complexity:\\nO(1) Ignoring the recursion stack space and auxillary space\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    long long int ans=0;\\n    void in(TreeNode* node){\\n\\n        if(node==NULL) return; \\n        s+=(to_string(node->val));\\n\\n        in(node->left);\\n        in(node->right);\\n        \\n        if(node->left==NULL && node->right==NULL) ans+=stoi(s);\\n        \\n        s.pop_back();\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        in(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string s=\"\";\\n    long long int ans=0;\\n    void in(TreeNode* node){\\n\\n        if(node==NULL) return; \\n        s+=(to_string(node->val));\\n\\n        in(node->left);\\n        in(node->right);\\n        \\n        if(node->left==NULL && node->right==NULL) ans+=stoi(s);\\n        \\n        s.pop_back();\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        in(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294792,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void help(TreeNode* root, long long tempSum, int& totalSum)\\n    {\\n        if(root==NULL) return;\\n      \\n        if(root->left==NULL && root->right==NULL)\\n       \\n        {\\n           tempSum = tempSum*10+root->val;\\n            totalSum+=tempSum;\\n        }\\n        tempSum = tempSum*10+root->val;\\n\\n        help(root->left, tempSum, totalSum);\\n\\n        help(root->right, tempSum, totalSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root)\\n     {\\n        int ans=0;\\n        help(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    void help(TreeNode* root, long long tempSum, int& totalSum)\\n    {\\n        if(root==NULL) return;\\n      \\n        if(root->left==NULL && root->right==NULL)\\n       \\n        {\\n           tempSum = tempSum*10+root->val;\\n            totalSum+=tempSum;\\n        }\\n        tempSum = tempSum*10+root->val;\\n\\n        help(root->left, tempSum, totalSum);\\n\\n        help(root->right, tempSum, totalSum);\\n    }\\npublic:\\n    int sumNumbers(TreeNode* root)\\n     {\\n        int ans=0;\\n        help(root, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294204,
                "title": "java-dfs-no-strings-beats-100-7-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private int dfs(TreeNode node, int val) {\\n    var a = val * 10 + node.val;\\n    if (node.left == null && node.right == null) return a;\\n\\n    var sum = 0;\\n    if (node.left != null) sum += dfs(node.left, a);\\n    if (node.right != null) sum += dfs(node.right, a);\\n\\n    return sum;\\n  }\\n\\n  public int sumNumbers(TreeNode root) {\\n    return dfs(root, 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  private int dfs(TreeNode node, int val) {\\n    var a = val * 10 + node.val;\\n    if (node.left == null && node.right == null) return a;\\n\\n    var sum = 0;\\n    if (node.left != null) sum += dfs(node.left, a);\\n    if (node.right != null) sum += dfs(node.right, a);\\n\\n    return sum;\\n  }\\n\\n  public int sumNumbers(TreeNode root) {\\n    return dfs(root, 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294182,
                "title": "c-4-lines-recursive-100-faster",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* r, int prev = 0) {\\n        if (!r) return 0;\\n        auto val = prev + r->val;\\n        if (!r->left && !r->right) return val;\\n        return sumNumbers(r->left, val * 10) + sumNumbers(r->right, val * 10);\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* r, int prev = 0) {\\n        if (!r) return 0;\\n        auto val = prev + r->val;\\n        if (!r->left && !r->right) return val;\\n        return sumNumbers(r->left, val * 10) + sumNumbers(r->right, val * 10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294065,
                "title": "daily-leetcode-solution-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int num,int& ans){\\n        if(!root) return;\\n        if(root->left==NULL and root->right==NULL){\\n            num*=10;\\n            num+=root->val;\\n            ans+=num;\\n            return;\\n        }\\n        num*=10;\\n        num+=root->val;\\n        solve(root->left,num,ans);\\n        solve(root->right,num,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int num,int& ans){\\n        if(!root) return;\\n        if(root->left==NULL and root->right==NULL){\\n            num*=10;\\n            num+=root->val;\\n            ans+=num;\\n            return;\\n        }\\n        num*=10;\\n        num+=root->val;\\n        solve(root->left,num,ans);\\n        solve(root->right,num,ans);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        int ans=0;\\n        solve(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293992,
                "title": "beats-100-c-simple-recursion",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(LOGN)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void add(TreeNode* root,int numtillnow)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        numtillnow*=10;\\n        numtillnow+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans+=numtillnow;\\n            return;\\n        }\\n        add(root->left,numtillnow);\\n        add(root->right,numtillnow);\\n        return;\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        add(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void add(TreeNode* root,int numtillnow)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        numtillnow*=10;\\n        numtillnow+=root->val;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans+=numtillnow;\\n            return;\\n        }\\n        add(root->left,numtillnow);\\n        add(root->right,numtillnow);\\n        return;\\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        add(root,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293925,
                "title": "dfs-with-a-minor-change-standard-path-problem",
                "content": "# Intuition\\nTraversing from root to leaf node along every path will give a number. The sum of all those numbers has to be returned. \\nWe can follow a standard pre-order traversal, keeping track of the number we have tracked so far along our path, and once we arrive at a leaf node, add it to our result.\\n\\n# Approach\\nIn a standard pre-order traversal code, maintain a variable- $$currNum$$ which will represent the number we have built by following a path.\\n$$currNum$$ will be calculated by the formula:\\n```\\ncurrNum = Number made before reaching current Node*10 + Node.val\\n```\\nEx:\\n![image.png](https://assets.leetcode.com/users/images/eff9dd3c-6ca0-4f8b-81c3-9620a84906a4_1678753155.4871728.png)\\n\\nThe above image represents the value of $$currNum$$ for nodes $$4$$ and $$9$$. All we have to do is add the $$currNum$$ values whenever we reach a leaf node.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(h)$$\\n$$h$$ -> height of tree\\n\\n# Code\\n```Java []\\nclass Solution {\\n    int sum=0; \\n    public int sumNumbers(TreeNode root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    public void f(TreeNode root,int currNum){\\n        if(root==null ) return ; \\n        if(root.left==null && root.right==null ) {\\n            //adding currNum values\\n            sum+=(currNum*10+root.val);\\n            return;\\n        }\\n        f(root.left,currNum*10+root.val);\\n        f(root.right,currNum*10+root.val);\\n// currNum*10+root.val passes the value of 49(4*10+9) to the node\\n//with value 5 in the picture. \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    \\n    void f(TreeNode* root, int currNum) {\\n        if (root == NULL) return;\\n        if (root->left == NULL && root->right == NULL) {\\n            sum += (currNum*10 + root->val);\\n            return;\\n        }\\n        f(root->left, currNum*10 + root->val);\\n        f(root->right, currNum*10 + root->val);\\n    }\\n};\\n\\n```\\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n        \\n    def sumNumbers(self, root: TreeNode) -> int:\\n        self.f(root, 0)\\n        return self.sum\\n    \\n    def f(self, root: TreeNode, currNum: int) -> None:\\n        if not root: return\\n        if not root.left and not root.right:\\n            self.sum += (currNum*10 + root.val)\\n            return\\n        self.f(root.left, currNum*10 + root.val)\\n        self.f(root.right, currNum*10 + root.val)\\n\\n```\\n\\n---\\n\\nWe can do without the global variable by a simplification:\\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return f(root,0);\\n    }\\n    public int f(TreeNode root,int currNum){\\n        if(root==null ) return 0; \\n        if(root.left==null && root.right==null ) {\\n            return (currNum*10+root.val);\\n            \\n        }\\n        return f(root.left,currNum*10+root.val)+ f(root.right,currNum*10+root.val);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ncurrNum = Number made before reaching current Node*10 + Node.val\\n```\n```Java []\\nclass Solution {\\n    int sum=0; \\n    public int sumNumbers(TreeNode root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    public void f(TreeNode root,int currNum){\\n        if(root==null ) return ; \\n        if(root.left==null && root.right==null ) {\\n            //adding currNum values\\n            sum+=(currNum*10+root.val);\\n            return;\\n        }\\n        f(root.left,currNum*10+root.val);\\n        f(root.right,currNum*10+root.val);\\n// currNum*10+root.val passes the value of 49(4*10+9) to the node\\n//with value 5 in the picture. \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int sum = 0;\\n    int sumNumbers(TreeNode* root) {\\n        f(root,0);\\n        return sum;\\n    }\\n    \\n    void f(TreeNode* root, int currNum) {\\n        if (root == NULL) return;\\n        if (root->left == NULL && root->right == NULL) {\\n            sum += (currNum*10 + root->val);\\n            return;\\n        }\\n        f(root->left, currNum*10 + root->val);\\n        f(root->right, currNum*10 + root->val);\\n    }\\n};\\n\\n```\n```python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.sum = 0\\n        \\n    def sumNumbers(self, root: TreeNode) -> int:\\n        self.f(root, 0)\\n        return self.sum\\n    \\n    def f(self, root: TreeNode, currNum: int) -> None:\\n        if not root: return\\n        if not root.left and not root.right:\\n            self.sum += (currNum*10 + root.val)\\n            return\\n        self.f(root.left, currNum*10 + root.val)\\n        self.f(root.right, currNum*10 + root.val)\\n\\n```\n```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return f(root,0);\\n    }\\n    public int f(TreeNode root,int currNum){\\n        if(root==null ) return 0; \\n        if(root.left==null && root.right==null ) {\\n            return (currNum*10+root.val);\\n            \\n        }\\n        return f(root.left,currNum*10+root.val)+ f(root.right,currNum*10+root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228396,
                "title": "c-solution-dfs",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    private int sum  = 0;\\n\\n    public int SumNumbers(TreeNode root) {\\n        DFS(root, 0);\\n        return sum;\\n    }\\n\\n    private void DFS(TreeNode root, int currentNumber){\\n        if(root == null){\\n            return;\\n        }\\n\\n        currentNumber = currentNumber*10 + root.val;\\n\\n        if(root.left == null && root.right == null){\\n            sum += currentNumber;\\n            return;\\n        }\\n\\n        DFS(root.left, currentNumber);\\n        DFS(root.right, currentNumber);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    private int sum  = 0;\\n\\n    public int SumNumbers(TreeNode root) {\\n        DFS(root, 0);\\n        return sum;\\n    }\\n\\n    private void DFS(TreeNode root, int currentNumber){\\n        if(root == null){\\n            return;\\n        }\\n\\n        currentNumber = currentNumber*10 + root.val;\\n\\n        if(root.left == null && root.right == null){\\n            sum += currentNumber;\\n            return;\\n        }\\n\\n        DFS(root.left, currentNumber);\\n        DFS(root.right, currentNumber);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132830,
                "title": "python3-3-solutions",
                "content": "# Intuition\\n    please upvote if its useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [root]\\n        sum = 0\\n        while(q):\\n            node  = q.pop()\\n            if not node.left and not node.right:\\n                sum+=node.val\\n            \\n            if node.left:\\n                node.left.val += node.val*10\\n                q.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                q.append(node.right)\\n        return sum\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [(root , str(root.val))]\\n        sum = 0\\n        while(q):\\n            node ,val = q.pop()\\n            if not node.left and not node.right:\\n                sum+=int(val)\\n            if node.left:\\n                q.append((node.left , val + str(node.left.val)))\\n            if node.right:\\n                q.append((node.right , val + str(node.right.val)))\\n        return sum\\n\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        val = 10 * val + root.val\\n        if not root.left and not root.right:\\n            return val\\n\\n        return self.sumNumbers(root.left , val) + self.sumNumbers(root.right , val)",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# Intuition\\n    please upvote if its useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [root]\\n        sum = 0\\n        while(q):\\n            node  = q.pop()\\n            if not node.left and not node.right:\\n                sum+=node.val\\n            \\n            if node.left:\\n                node.left.val += node.val*10\\n                q.append(node.left)\\n            if node.right:\\n                node.right.val += node.val*10\\n                q.append(node.right)\\n        return sum\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        q = [(root , str(root.val))]\\n        sum = 0\\n        while(q):\\n            node ,val = q.pop()\\n            if not node.left and not node.right:\\n                sum+=int(val)\\n            if node.left:\\n                q.append((node.left , val + str(node.left.val)))\\n            if node.right:\\n                q.append((node.right , val + str(node.right.val)))\\n        return sum\\n\\n\\n\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode] , val = 0) -> int:\\n        if not root:\\n            return 0\\n        val = 10 * val + root.val\\n        if not root.left and not root.right:\\n            return val\\n\\n        return self.sumNumbers(root.left , val) + self.sumNumbers(root.right , val)",
                "codeTag": "Java"
            },
            {
                "id": 3069161,
                "title": "simple-recursive-solution",
                "content": "# Complexity\\n- *Time complexity:*\\n**O(N)** #Where N is number of Nodes\\n\\n- *Space complexity:*\\n**O(h)** #where h is height of Tree\\n\\n# Code\\n```\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        self.ans = 0\\n        def dfs(root, sum_):\\n            if not root: return\\n            if not root.left and not root.right:\\n                self.ans += (sum_ * 10) + root.val\\n            dfs(root.left, (sum_ * 10) + root.val)\\n            dfs(root.right, (sum_ * 10) + root.val)\\n        dfs(root, 0)\\n        return self.ans\\n```\\nIf you have any *doubt* ask me in comment & **UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumNumbers(self, root):\\n        self.ans = 0\\n        def dfs(root, sum_):\\n            if not root: return\\n            if not root.left and not root.right:\\n                self.ans += (sum_ * 10) + root.val\\n            dfs(root.left, (sum_ * 10) + root.val)\\n            dfs(root.right, (sum_ * 10) + root.val)\\n        dfs(root, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917583,
                "title": "simplest-c-code",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int x=countnodes(root,0);\\n        return x;\\n    }\\n    int countnodes(TreeNode*root,int sum){\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL&& root->right==NULL){ \\n        return sum*10+root->val;\\n        }\\n        else\\n         return countnodes(root->left,sum*10+root->val)+countnodes(root->right,sum*10+root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        int x=countnodes(root,0);\\n        return x;\\n    }\\n    int countnodes(TreeNode*root,int sum){\\n        if(root==NULL)\\n        return 0;\\n        if(root->left==NULL&& root->right==NULL){ \\n        return sum*10+root->val;\\n        }\\n        else\\n         return countnodes(root->left,sum*10+root->val)+countnodes(root->right,sum*10+root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658995,
                "title": "easy-implementation-with-explanation-java",
                "content": "```\\n\\n\\nclass Solution {\\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\treturn helper(root, 0);\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root, int num) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\tnum = (num * 10) + root.val;        // num = (1*10) + 1; => num = 12;\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t\\tnum = (num * 10) + root.val;  // num = (0 * 10)+ 1; => num = 1\\n\\t\\tint a = helper(root.left, num); // a = num (12)\\n\\t\\tint b = helper(root.right, num); // Similarly, b = num(13)\\n        return (a+b);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n\\tpublic int sumNumbers(TreeNode root) {\\n\\t\\treturn helper(root, 0);\\n\\t}\\n\\n\\tpublic static int helper(TreeNode root, int num) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n\\t\\tif (root.left == null && root.right == null) {\\n\\t\\t\\tnum = (num * 10) + root.val;        // num = (1*10) + 1; => num = 12;\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t\\tnum = (num * 10) + root.val;  // num = (0 * 10)+ 1; => num = 1\\n\\t\\tint a = helper(root.left, num); // a = num (12)\\n\\t\\tint b = helper(root.right, num); // Similarly, b = num(13)\\n        return (a+b);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657840,
                "title": "simple-o-n-recursive-solution-explained",
                "content": "**O(N) Recursive Solution**\\n```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n\\tself.ans = 0 #answer\\n\\n\\tdef dfs(node,amt): #depth-first search helper method\\n\\t\\tif node: #we only care if there is a node\\n\\t\\t\\tamt = amt*10+node.val #update the corresponding amount for this root-to-leaf path\\n\\t\\t\\tif not node.left and not node.right: #if it is a leaf\\n\\t\\t\\t\\tself.ans += amt #then add the path to our answer\\n\\t\\t\\telse: #if it isn\\'t a leaf\\n\\t\\t\\t\\tdfs(node.left,amt) #search to the left\\n\\t\\t\\t\\tdfs(node.right,amt) #search to the right\\n\\n\\tdfs(root,0) #perform dfs on the root\\n\\n\\treturn self.ans #return answer\\n```\\n\\nIn this solution, we search through the tree using depth-first search. We keep track of the ```node``` we are looking at and the value of the root-to-node path up to that point using ```amt```. We update ```amt``` by multiplying it by 10 and adding the value of the current node we are looking at. If the node is a leaf, then we add the value of its root-to-leaf path to our answer. Otherwise, we continue searching to the left and to the right to find more leaves.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef sumNumbers(self, root: Optional[TreeNode]) -> int:\\n\\tself.ans = 0 #answer\\n\\n\\tdef dfs(node,amt): #depth-first search helper method\\n\\t\\tif node: #we only care if there is a node\\n\\t\\t\\tamt = amt*10+node.val #update the corresponding amount for this root-to-leaf path\\n\\t\\t\\tif not node.left and not node.right: #if it is a leaf\\n\\t\\t\\t\\tself.ans += amt #then add the path to our answer\\n\\t\\t\\telse: #if it isn\\'t a leaf\\n\\t\\t\\t\\tdfs(node.left,amt) #search to the left\\n\\t\\t\\t\\tdfs(node.right,amt) #search to the right\\n\\n\\tdfs(root,0) #perform dfs on the root\\n\\n\\treturn self.ans #return answer\\n```\n```node```\n```amt```\n```amt```",
                "codeTag": "Python3"
            },
            {
                "id": 2631147,
                "title": "c-recursion-without-storing-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void rec(int no,TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        no = no*10 + root->val;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=no;\\n            return;\\n        }\\n        rec(no,root->left);\\n        rec(no,root->right);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        ans = 0;\\n        rec(0,root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void rec(int no,TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        no = no*10 + root->val;\\n        if(root->left==NULL&&root->right==NULL)\\n        {\\n            ans+=no;\\n            return;\\n        }\\n        rec(no,root->left);\\n        rec(no,root->right);\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        ans = 0;\\n        rec(0,root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440960,
                "title": "concept-of-path-to-leaf-node-c-easy-and-naive",
                "content": "Here, We have used the PATH TO LEAF NODE approach to solve it.\\nAt first we will find the path for each leaf node and store in any data structure ( vector )\\nAt last we will add the values of vector;\\n\\n///\\n\\nclass Solution {\\npublic:\\n\\n\\n    void helper(TreeNode* root, vector<int> &ans,string asf)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ans.push_back(stoi(asf)); // converting string path to integer number\\n            return;\\n        }\\n        \\n        if(root->left)\\n            helper(root->left,ans,asf + to_string(root->left->val));\\n        if(root->right)\\n            helper(root->right,ans,asf + to_string(root->right->val));\\n    }\\n    \\n    \\n    int sumNumbers(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans,to_string(root->val));\\n        \\n        int sum = 0;\\n        for(auto it : ans)\\n            sum += it;\\n        return sum;\\n    }\\n};\\n\\nHOPE YOU GET IT",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    void helper(TreeNode* root, vector<int> &ans,string asf)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(!root->left && !root->right)\\n        {\\n            ans.push_back(stoi(asf)); // converting string path to integer number\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2108407,
                "title": "c-dfs-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int& sum,int temp){\\n      if(!root)return;\\n      \\n      if(!root->left && !root->right){\\n        temp = 10* temp + root->val;\\n        sum+=temp;\\n        temp=0;\\n      }\\n      \\n      temp = 10* temp + root->val;\\n      \\n      solve(root->left,sum,temp);\\n      solve(root->right,sum,temp);\\n      \\n      return;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n      int sum=0;\\n      int temp=0;\\n      solve(root,sum,temp);\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int& sum,int temp){\\n      if(!root)return;\\n      \\n      if(!root->left && !root->right){\\n        temp = 10* temp + root->val;\\n        sum+=temp;\\n        temp=0;\\n      }\\n      \\n      temp = 10* temp + root->val;\\n      \\n      solve(root->left,sum,temp);\\n      solve(root->right,sum,temp);\\n      \\n      return;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n      int sum=0;\\n      int temp=0;\\n      solve(root,sum,temp);\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557822,
                "title": "recursive-solution-simple-and-effective",
                "content": "`# All numbers are added to the array by recursion, and finally the array amount is returned (in the main function)`\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        array_number = np.array(self.rec(root, [], \"\"))\\n        for number in array_number:\\n            res += int(number)\\n        return res\\n\\n    def rec(self, root: Optional[TreeNode], string_number, my_string):\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return string_number + [my_string + str(root.val)]\\n        if root.left is None:\\n            my_string += str(root.val)\\n            return self.rec(root.right, string_number, my_string)\\n        if root.right is None:\\n            my_string += str(root.val)\\n            return self.rec(root.left, string_number, my_string)\\n        my_string += str(root.val)\\n        return self.rec(root.right, string_number, my_string) + self.rec(root.left, string_number, my_string)\\n\\n",
                "solutionTags": [],
                "code": "`# All numbers are added to the array by recursion, and finally the array amount is returned (in the main function)`\\nimport numpy as np\\n\\n\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        array_number = np.array(self.rec(root, [], \"\"))\\n        for number in array_number:\\n            res += int(number)\\n        return res\\n\\n    def rec(self, root: Optional[TreeNode], string_number, my_string):\\n        if root is None:\\n            return []\\n        if root.left is None and root.right is None:\\n            return string_number + [my_string + str(root.val)]\\n        if root.left is None:\\n            my_string += str(root.val)\\n            return self.rec(root.right, string_number, my_string)\\n        if root.right is None:\\n            my_string += str(root.val)\\n            return self.rec(root.left, string_number, my_string)\\n        my_string += str(root.val)\\n        return self.rec(root.right, string_number, my_string) + self.rec(root.left, string_number, my_string)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1557815,
                "title": "c-simple-solution-recursive",
                "content": "```\\n\\nint f(struct TreeNode* r,int x){\\n    \\n    if(!r)\\n        return 0;\\n    \\n    if(!r->right&&!r->left)\\n        return (x*10)+r->val;\\n    \\n    return f(r->right,(x*10)+r->val)+f(r->left,(x*10)+r->val);\\n\\n}\\n\\nint sumNumbers(struct TreeNode* root){\\n    \\n    return f(root,0);\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nint f(struct TreeNode* r,int x){\\n    \\n    if(!r)\\n        return 0;\\n    \\n    if(!r->right&&!r->left)\\n        return (x*10)+r->val;\\n    \\n    return f(r->right,(x*10)+r->val)+f(r->left,(x*10)+r->val);\\n\\n}\\n\\nint sumNumbers(struct TreeNode* root){\\n    \\n    return f(root,0);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557659,
                "title": "c-simple-depth-first-search-solution-0-ms",
                "content": "Algorithm:\\n\\t1. From a root, we add the root->val to the end of a string, which records the numbers we have gone from.\\n\\t2. We repeat step 1. on the left child of the root then the right one. (note: you do not have to go to the left before the right, that is a personal preference. You can go to the right before the left.)\\n\\t3. If the root has no children, we stop and add the number we got to a total sum.\\n\\nWikipedia:\\n\"Depth-first search (DFS) is **an algorithm for traversing or searching tree or graph data structures.** The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.\"\\n```\\n/*\\nSecond example:\\n\\t\\t\\t\\t\\t\\t 4\\n\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t  9    0\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   5    1\\n\\nOur code will take the path:\\n\\t4 --> 9 --> 5\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 495 to the sum\\n\\t\\t\\t --> 1\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 491 to the sum\\n\\t  --> 0\\n\\t\\t\\t no non-null children so stops\\n\\t\\t\\t adds 40 to the sum\\n*/\\n```\\n\\nImplementation\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        // LeetCode annoying and likes to add these testcases\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        // dfs the root and an empty string\\n        dfs(root, \"\");\\n        \\n        return sum;\\n    }\\n    \\nprivate:\\n    int sum = 0;\\n    \\n    void dfs(TreeNode*& root, string s){\\n        // add root->val to the end of the string\\n        // + \\'0\\', this turns a digit to its ASCII value\\n        s += root->val + \\'0\\';\\n        \\n        if(root->left == nullptr && root->right == nullptr){\\n            // convert a string to integer\\n            sum += stoi(s);\\n            \\n            // this node has no children, so we stop\\n            return;\\n        }\\n        \\n        if(root->left != nullptr){\\n            dfs(root->left,s);\\n        }\\n        \\n        if(root->right != nullptr){\\n            dfs(root->right,s);\\n        }\\n    }\\n};\\n```\\nHope you liked this solution. Please like :))",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nSecond example:\\n\\t\\t\\t\\t\\t\\t 4\\n\\t\\t\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t\\t\\t  9    0\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   5    1\\n\\nOur code will take the path:\\n\\t4 --> 9 --> 5\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 495 to the sum\\n\\t\\t\\t --> 1\\n\\t\\t\\t\\t\\t\\tno non-null children so stops\\n\\t\\t\\t\\t\\t\\tadds 491 to the sum\\n\\t  --> 0\\n\\t\\t\\t no non-null children so stops\\n\\t\\t\\t adds 40 to the sum\\n*/\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root) {\\n        // LeetCode annoying and likes to add these testcases\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        \\n        // dfs the root and an empty string\\n        dfs(root, \"\");\\n        \\n        return sum;\\n    }\\n    \\nprivate:\\n    int sum = 0;\\n    \\n    void dfs(TreeNode*& root, string s){\\n        // add root->val to the end of the string\\n        // + \\'0\\', this turns a digit to its ASCII value\\n        s += root->val + \\'0\\';\\n        \\n        if(root->left == nullptr && root->right == nullptr){\\n            // convert a string to integer\\n            sum += stoi(s);\\n            \\n            // this node has no children, so we stop\\n            return;\\n        }\\n        \\n        if(root->left != nullptr){\\n            dfs(root->left,s);\\n        }\\n        \\n        if(root->right != nullptr){\\n            dfs(root->right,s);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557547,
                "title": "javascript-100-super-simple-multiple-solutions",
                "content": "![image](https://assets.leetcode.com/users/images/1e97f12a-6a43-475e-9da0-8a75bc47f4b6_1636010606.2161295.png)\\n\\n\\n\\nNov 3rd LC Challenge.\\n\\nEDIT:  (Upon further testing and working with the problem, I have decided I like this solution best - The top one.  \\n\\nImportant note - Top solution below uses strings as an argument for curPath.  In that version, we just add root.val and then send the variable away in the recursive calls.  After that, we add what is returned to the sum, then return that sum.  This works great because strings in JS are assign-by-value.  If we send one string to a recursive call, it only effects that call and lower recursive calls - not higher ones.  Alternatively, below that solution we have curPath stored as an array.  In those functions, you\\'ll notice a .push() at the very start, and then a .pop() after the recursive calls.  This is because arrays are assign-by-reference.  When you pass an array (or anything else assign-by-reference), it effects all recursive calls in which it is involved - All can change it on their recursive levels, and it will be reflected in higher recursive levels.  Hence, we need the .pop() as clean up after we have explored that node.  Both assign-by-value and assign-by-reference have their advantages and disadvantages in recursive functions.  You\\'ll also notice we use sum = [0] in some of the other functions.  This is because arrays are pass by reference.  Hence, in lower recursive calls, we can do sum[0] += curPath.join(\\'\\') - 0, and it changes the value with the sum array on All recursive levels and we can just return it at the top level.  In the non-assign-by-reference code examples, you\\'ll notice we have to do sum += \\'whatever we return from recursive call\\' because that call can\\'t change the sum itself.  Hence, if you change the code to sum = 0 within the arguments, and change the logic within the function to match an integer, you\\'ll find it no longer works - This is because integers are assign-by-value.  If you knew all of this already, I apologize for the tangeant.  It\\'s a subject that I struggled with in my coding for a while, so I wanted to add a short aside to address it and maybe help others.\\n\\nTL:DR; You have to code a bit differently in recursive calls when using assign-by-reference vs assign-by-value arguments.  In the below assign-by-reference versions - We add to the variable (curPath), run our recursive calls with it as an argument, and then we remove what we added afterwards (I.E. - Recursion has reached the basecase and popped back up.  In the case of the example in the description - Initial function call pushes 1 to curPath, recursion runs on root.left.  We push 2 to curPath.  We have reached the base case since 2 has no .left or .right.  12 is added to the sum ([1,2].join(\\'\\') - 0 OR +[1,2].join(\\'\\') - both are ways to coerce strings to numbers where possible in JS).  The two is popped off.  We return to the initial function call level.  Function again called on root.right.  On this level, our curPath is again back to [1].  3 is pushed to curPath.  Base case is reached.  [1,3] joined to form 13 and added to sum.  On initial level, we pop the one from curPath.  curPath = [] at the end.  But sum has been changed by lower recursive calls.  We return sum[0].)  In the assign-by-value versions, we add to the variable, send it away in the recursive calls, Do Something With What Is Returned (Add to a total, hashmap, etc), and return the effected variable.)\\n\\n\\ncurPath and sum both assign-by-value:\\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = 0) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) sum += +curPath;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  return sum;\\n};\\n```\\n\\ncurPath and sum both assign-by-reference:\\n```\\nconst sumNumbers = (root, curPath = [], sum = [0]) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum[0] += curPath.join(\\'\\') - 0;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  curPath.pop();\\n  return sum[0];\\n};\\n```\\n\\n\\nAlternate version with helper function instead of all-recursion (This one\\'s likely easier for most to write on the spot in an interview.  Tracking variables through assign-by-reference data structures is sometimes tough without practice.  This is the \\'play it safe\\' and get it right the first time version.  This version is easiest imo because within the recursive function, we only really have to worry about reaching our base case and then changing sum accordingly - We don\\'t have to worry about what we return from the recursive function at all.  Our function itself changes the sum in the parent scope for us and we don\\'t have to worry about passing sum down, what happens on each level, etc...  Only how sum changes when base case is reached.):\\n\\nsum within initial function scope, traverse has access to this function scope and can change it accordingly.  This lets us use sum as an integer (assign-by-value), but still only change it when the base case is reached.\\n```\\nconst sumNumbers = root => {\\n  let sum = 0;\\n  const traverse = (node, curPath = []) => {\\n    curPath.push(node.val);\\n    if (!node.left && !node.right) sum += curPath.join(\\'\\') - 0;\\n    node.left && traverse(node.left, curPath);\\n    node.right && traverse(node.right, curPath);\\n    curPath.pop();\\n  }\\n  traverse(root);\\n  return sum;\\n}\\n```\\n\\n\\nFinal version.  This one works the same as the second, but does not use array to track total using assign-by-reference.\\n\\nHybrid: curPath is assign-by-reference, sum is assign-by-value:\\n```\\nconst sumNumbers = (root, curPath = [], sum = 0) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum += curPath.join(\\'\\') - 0;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  curPath.pop();\\n  return sum;\\n};\\n```\\n\\n\\nI lied!  Last version showing objects are assign-by-reference as well.  We track curPath as a string (We add on every level, but don\\'t worry about clean-up because adding on a lower level doesn\\'t effect higher levels.)  We track sum as an object.  I.E. - We can change the value within the object at All recursive levels when base case is reached and the top level will be reflected appropriately - Only reaching our base case changes the total that is returned in assign-by-reference versions.  In assign-by-value, what is returned from function changes our total, and is then returned.).\\n\\nHybrid: curPath is assign-by-value and sum is assign-by-reference.  This one is particularly cool because we can add to curPath on each level without having to worry about clean up, we can also effect the answer only when the base case is reached, and we also don\\'t have to worry about what we return from any call other than the initial one.  This combination of factors leads me to use assign-by-value and assign-by-reference in this fashion as often as possible, because I find it the easiest to code personally.  Using an object here is somewhat pointless though. lol... I just did it to show it\\'s also assign-by-reference.  Normally I\\'d use an array, both work though. (arrays are just objects in js anyway) \\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = { answer: 0 }) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) return sum.answer += +curPath;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  return sum.answer;\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sumNumbers = (root, curPath = \\'\\', sum = 0) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) sum += +curPath;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  return sum;\\n};\\n```\n```\\nconst sumNumbers = (root, curPath = [], sum = [0]) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum[0] += curPath.join(\\'\\') - 0;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  curPath.pop();\\n  return sum[0];\\n};\\n```\n```\\nconst sumNumbers = root => {\\n  let sum = 0;\\n  const traverse = (node, curPath = []) => {\\n    curPath.push(node.val);\\n    if (!node.left && !node.right) sum += curPath.join(\\'\\') - 0;\\n    node.left && traverse(node.left, curPath);\\n    node.right && traverse(node.right, curPath);\\n    curPath.pop();\\n  }\\n  traverse(root);\\n  return sum;\\n}\\n```\n```\\nconst sumNumbers = (root, curPath = [], sum = 0) => {\\n  curPath.push(root.val);\\n  if (!root.left && !root.right) sum += curPath.join(\\'\\') - 0;\\n  root.left && (sum += sumNumbers(root.left, curPath));\\n  root.right && (sum += sumNumbers(root.right, curPath));\\n  curPath.pop();\\n  return sum;\\n};\\n```\n```\\nconst sumNumbers = (root, curPath = \\'\\', sum = { answer: 0 }) => {\\n  curPath += root.val;\\n  if (!root.left && !root.right) return sum.answer += +curPath;\\n  root.left && sumNumbers(root.left, curPath, sum);\\n  root.right && sumNumbers(root.right, curPath, sum);\\n  return sum.answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556855,
                "title": "c-0ms-optimal-solution-using-simple-recursion",
                "content": "\\n**Optimal Solution** *(Runtime : 0ms and Memory : 91.89%)*\\n```\\nclass Solution {\\npublic:\\n    int res=0;//variable to have sum\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        sum(root,0); //calling sum with initial num as 0\\n        \\n        return res; // return result;\\n    }\\n    \\n    void sum(TreeNode*root, int num){\\n        \\n        if(!root)return;\\n        \\n        int temp = num*10+root->val; //when we tranveral down a tree, num has to mul by 10 and current node val becomes its ones digit position \\n               \\n        if(!root->left&&!root->right){//leaf root -> add temp value to res\\n            \\n            sum += temp;\\n            return;\\n        }\\n        //recursive for its children nodes\\n        sum(root->left,temp);\\n        sum(root->right,temp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;//variable to have sum\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        sum(root,0); //calling sum with initial num as 0\\n        \\n        return res; // return result;\\n    }\\n    \\n    void sum(TreeNode*root, int num){\\n        \\n        if(!root)return;\\n        \\n        int temp = num*10+root->val; //when we tranveral down a tree, num has to mul by 10 and current node val becomes its ones digit position \\n               \\n        if(!root->left&&!root->right){//leaf root -> add temp value to res\\n            \\n            sum += temp;\\n            return;\\n        }\\n        //recursive for its children nodes\\n        sum(root->left,temp);\\n        sum(root->right,temp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556202,
                "title": "python-96-99-faster-24-ms-with-a-diagram",
                "content": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        if root is None: return 0\\n        \\n        def rec(node=root, prev=0):\\n            if node.left is None and node.right is None:\\n                return prev + node.val            \\n            \\n            prev = (prev + node.val)*10\\n            \\n            left = right = 0\\n            if node.left:\\n                left = rec(node.left, prev)\\n            if node.right:\\n                right = rec(node.right, prev)\\n            \\n            return left + right\\n        \\n        return rec()\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ebf72c68-d3e6-460a-acfe-5a817d2be31b_1635912885.932716.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        if root is None: return 0\\n        \\n        def rec(node=root, prev=0):\\n            if node.left is None and node.right is None:\\n                return prev + node.val            \\n            \\n            prev = (prev + node.val)*10\\n            \\n            left = right = 0\\n            if node.left:\\n                left = rec(node.left, prev)\\n            if node.right:\\n                right = rec(node.right, prev)\\n            \\n            return left + right\\n        \\n        return rec()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555994,
                "title": "idea-explained-faster-than-100-simple-clean-c-solution",
                "content": "**Intuition:**\\n\\n* Idea is keep adding digits to our path value. \\n* And when we reach the leaf node, add this path value to overall `pathSum`\\n\\n\\t\\tEx:          4 \\n                   /   \\\\   \\n\\t\\t\\t\\t    9     0 \\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t 5     1\\n\\t\\t\\t\\t \\n\\t\\t\\tSo, here we start from root -> 4. We recursively move down exploring all possible paths.\\n\\t\\t\\tLet\\'s see how each paths will look , initially pathSum = 0: \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\ta. 4 -> \\n\\t\\t\\t\\t\\t 9 -> \\n\\t\\t\\t\\t\\t\\t  5 -| : Path Value = 495 , Path Sum = 495\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t 9 -> \\n\\t\\t\\t\\t\\t\\t  1 -| : Path Value = 491 , Path Sum = 495 + 491 = 986\\n\\t\\t\\t\\n\\t\\t\\tb. 4 -> \\n\\t\\t\\t\\t\\t 0 -| : Path Value = 40 , Path Sum = 986 + 50 = 1026\\n# Code: \\n```\\nclass Solution {\\npublic:\\n    int pathSum = 0;\\n    \\n    void solve(TreeNode* root, int val)\\n    {\\n        if(!root->left && !root->right)\\n        {\\n            pathSum += (10*val + root->val);\\n            return;\\n        }\\n        \\n        val = (10*val + root->val);\\n        \\n        if(root->left) solve(root->left, val);\\n        if(root->right) solve(root->right, val);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        solve(root, 0);\\n        return pathSum;\\n    }\\n};\\n```\\n\\n**Complexity Analysis :** \\n\\n* Time : `O(n)`, we visit all nodes in preorder traversal.\\n* Space : `O(1)` and if we take recursion call stack into account, then `O(logn)`.\\n\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pathSum = 0;\\n    \\n    void solve(TreeNode* root, int val)\\n    {\\n        if(!root->left && !root->right)\\n        {\\n            pathSum += (10*val + root->val);\\n            return;\\n        }\\n        \\n        val = (10*val + root->val);\\n        \\n        if(root->left) solve(root->left, val);\\n        if(root->right) solve(root->right, val);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        \\n        solve(root, 0);\\n        return pathSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393923,
                "title": "easy-to-understand-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    void treeHelper(TreeNode*root, int &sum, int num)\\n    {\\n        if(root==NULL)\\n            return;\\n        num=num*10+root->val;\\n        if(root->left==0 && root->right==0)\\n            sum+=num;\\n        treeHelper(root->left,sum,num);\\n        treeHelper(root->right,sum,num);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int sum=0,num=0;\\n        treeHelper(root, sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void treeHelper(TreeNode*root, int &sum, int num)\\n    {\\n        if(root==NULL)\\n            return;\\n        num=num*10+root->val;\\n        if(root->left==0 && root->right==0)\\n            sum+=num;\\n        treeHelper(root->left,sum,num);\\n        treeHelper(root->right,sum,num);\\n        \\n    }\\n    int sumNumbers(TreeNode* root) \\n    {\\n        int sum=0,num=0;\\n        treeHelper(root, sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301027,
                "title": "clean-recursive-solution-0ms-java",
                "content": "```\\nclass Solution {\\n    \\n    int number = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        \\n        number = number*10 + root.val;\\n        \\n        int ans = 0;\\n        \\n        if (root.left != null)\\n            ans += sumNumbers(root.left);\\n        \\n        if (root.right != null)\\n            ans += sumNumbers(root.right);\\n        \\n        if (root.left == null && root.right == null)\\n            ans = number;\\n        \\n        number /= 10;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int number = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        \\n        number = number*10 + root.val;\\n        \\n        int ans = 0;\\n        \\n        if (root.left != null)\\n            ans += sumNumbers(root.left);\\n        \\n        if (root.right != null)\\n            ans += sumNumbers(root.right);\\n        \\n        if (root.left == null && root.right == null)\\n            ans = number;\\n        \\n        number /= 10;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198403,
                "title": "c-dfs-pre-order-stack-iterative-beats-100",
                "content": "Feel Free to ask if you have any question and if you liked it click on **UPVOTE** icon.\\n```\\n int sum = 0;\\n    void calculateScore (stack<int> s){ // calculating the score of the values in the stack\\n        int i=0;\\n       while(!s.empty()){\\n           sum = sum + s.top() * pow(10, i);\\n            s.pop(); i++;\\n        }\\n    }\\n    int traverseTree(TreeNode* root , stack<int> q){\\n        if(root == NULL) return 0;\\n        q.push(root -> val);\\n        if(!root -> left  && !root -> right){\\n            calculateScore(q);\\n            q.pop();\\n        }\\n        if(root -> left != NULL)\\n            traverseTree(root -> left , q);\\n        if(root -> right != NULL)\\n            traverseTree(root -> right , q);\\n        q.pop();\\n        return sum;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        stack<int> q;\\n        if(root == NULL) return 0;\\n        traverseTree(root , q);\\n        return sum;\\n    }",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "Feel Free to ask if you have any question and if you liked it click on **UPVOTE** icon.\\n```\\n int sum = 0;\\n    void calculateScore (stack<int> s){ // calculating the score of the values in the stack\\n        int i=0;\\n       while(!s.empty()){\\n           sum = sum + s.top() * pow(10, i);\\n            s.pop(); i++;\\n        }\\n    }\\n    int traverseTree(TreeNode* root , stack<int> q){\\n        if(root == NULL) return 0;\\n        q.push(root -> val);\\n        if(!root -> left  && !root -> right){\\n            calculateScore(q);\\n            q.pop();\\n        }\\n        if(root -> left != NULL)\\n            traverseTree(root -> left , q);\\n        if(root -> right != NULL)\\n            traverseTree(root -> right , q);\\n        q.pop();\\n        return sum;\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        stack<int> q;\\n        if(root == NULL) return 0;\\n        traverseTree(root , q);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1122658,
                "title": "100-faster-short-n-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root,int mysum=0) {\\n        mysum = mysum*10 + root->val;\\n        if(!root->left && !root->right) return mysum;\\n        if(!root->left) return sumNumbers(root->right,mysum);\\n        if(!root->right) return sumNumbers(root->left,mysum);\\n        return sumNumbers(root->left, mysum) + sumNumbers(root->right,mysum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumNumbers(TreeNode* root,int mysum=0) {\\n        mysum = mysum*10 + root->val;\\n        if(!root->left && !root->right) return mysum;\\n        if(!root->left) return sumNumbers(root->right,mysum);\\n        if(!root->right) return sumNumbers(root->left,mysum);\\n        return sumNumbers(root->left, mysum) + sumNumbers(root->right,mysum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984555,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sumNumbers(root *TreeNode) int {\\n    sum := 0\\n    \\n    var s func(*TreeNode, int)\\n    \\n    s = func(root *TreeNode, total int) {\\n        if root == nil {return}\\n        \\n        if root.Left == nil && root.Right == nil {\\n            sum += (total * 10) + root.Val       \\n            return\\n        }\\n        \\n        total = ((total * 10) + root.Val)\\n        \\n        s(root.Left, total)\\n        s(root.Right, total)        \\n    }\\n    \\n    s(root, 0)\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sumNumbers(root *TreeNode) int {\\n    sum := 0\\n    \\n    var s func(*TreeNode, int)\\n    \\n    s = func(root *TreeNode, total int) {\\n        if root == nil {return}\\n        \\n        if root.Left == nil && root.Right == nil {\\n            sum += (total * 10) + root.Val       \\n            return\\n        }\\n        \\n        total = ((total * 10) + root.Val)\\n        \\n        s(root.Left, total)\\n        s(root.Right, total)        \\n    }\\n    \\n    s(root, 0)\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703693,
                "title": "python3-iterative-recursive-dfs",
                "content": "\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 10*val + node.val \\n            if not node.left and not node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        \\n        def fn(node, val):\\n            \"\"\"Return sum of node-to-leaf numbers\"\"\"\\n            if not node: return 0\\n            val = 10*val + node.val\\n            if not node.left and not node.right: return val \\n            return fn(node.left, val) + fn(node.right, val)\\n            \\n        return fn(root, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        ans = 0 \\n        stack = [(root, 0)]\\n        while stack: \\n            node, val = stack.pop()\\n            val = 10*val + node.val \\n            if not node.left and not node.right: ans += val \\n            if node.left: stack.append((node.left, val))\\n            if node.right: stack.append((node.right, val))\\n        return ans \\n```\n```\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        \\n        def fn(node, val):\\n            \"\"\"Return sum of node-to-leaf numbers\"\"\"\\n            if not node: return 0\\n            val = 10*val + node.val\\n            if not node.left and not node.right: return val \\n            return fn(node.left, val) + fn(node.right, val)\\n            \\n        return fn(root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589655,
                "title": "0ms-morris-preorder-traversal-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int root2leaf = 0, number = 0, steps=0;\\n        TreeNode predecessor;\\n        if(root == null){\\n            return 0;\\n        }\\n        while(root!=null){\\n            if(root.left!=null){\\n                predecessor = root.left;\\n                steps = 1;\\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    steps++;\\n                }\\n                if(predecessor.right == null){\\n                    predecessor.right = root;\\n                    //explore left subtree\\n                    number = number*10 + root.val;\\n                    root =root.left;\\n                }else{\\n                    predecessor.right = null;\\n                    if (predecessor.left == null) {\\n                        root2leaf += number;\\n                    }\\n                    for(int i = 0; i < steps; ++i) {\\n                        number /= 10;\\n                    }\\n                    root = root.right;\\n                }\\n                \\n            }else{\\n                //no left child\\n                number = number*10 + root.val;\\n                if(root.right == null){\\n                    root2leaf += number;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        \\n        return root2leaf;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        int root2leaf = 0, number = 0, steps=0;\\n        TreeNode predecessor;\\n        if(root == null){\\n            return 0;\\n        }\\n        while(root!=null){\\n            if(root.left!=null){\\n                predecessor = root.left;\\n                steps = 1;\\n                while(predecessor.right != null && predecessor.right != root){\\n                    predecessor = predecessor.right;\\n                    steps++;\\n                }\\n                if(predecessor.right == null){\\n                    predecessor.right = root;\\n                    //explore left subtree\\n                    number = number*10 + root.val;\\n                    root =root.left;\\n                }else{\\n                    predecessor.right = null;\\n                    if (predecessor.left == null) {\\n                        root2leaf += number;\\n                    }\\n                    for(int i = 0; i < steps; ++i) {\\n                        number /= 10;\\n                    }\\n                    root = root.right;\\n                }\\n                \\n            }else{\\n                //no left child\\n                number = number*10 + root.val;\\n                if(root.right == null){\\n                    root2leaf += number;\\n                }\\n                root = root.right;\\n            }\\n        }\\n        \\n        return root2leaf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313638,
                "title": "smple-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sum2=0;\\n    public int sumNumbers(TreeNode root) {\\n        mySolve(root,0);\\n        return sum2;\\n    }\\n    public void mySolve(TreeNode root,int sum )\\n    {\\n        if(root == null) return;\\n        if(root.left == null && root.right==null) {\\n            sum2+=sum*10+root.val;\\n            return;\\n        }\\n        mySolve(root.left,sum*10+root.val);\\n        mySolve(root.right,sum*10+root.val);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int sum2=0;\\n    public int sumNumbers(TreeNode root) {\\n        mySolve(root,0);\\n        return sum2;\\n    }\\n    public void mySolve(TreeNode root,int sum )\\n    {\\n        if(root == null) return;\\n        if(root.left == null && root.right==null) {\\n            sum2+=sum*10+root.val;\\n            return;\\n        }\\n        mySolve(root.left,sum*10+root.val);\\n        mySolve(root.right,sum*10+root.val);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287264,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public int SumNumbers(TreeNode root) {\\n        return DFS(root, 0);\\n    }\\n\\n    private int DFS(TreeNode root, int num) {\\n        if (root == null) return 0;\\n\\n        var curResult = num * 10 + root.val;\\n        if (root.left == null && root.right == null) return curResult;\\n\\n        return DFS(root.left, curResult) + DFS(root.right, curResult);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SumNumbers(TreeNode root) {\\n        return DFS(root, 0);\\n    }\\n\\n    private int DFS(TreeNode root, int num) {\\n        if (root == null) return 0;\\n\\n        var curResult = num * 10 + root.val;\\n        if (root.left == null && root.right == null) return curResult;\\n\\n        return DFS(root.left, curResult) + DFS(root.right, curResult);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41484,
                "title": "even-neater-and-easy-to-understand-java-solution",
                "content": "    int totalSum = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        sum(root, 0);\\n        return totalSum;\\n    }\\n    \\n    public void sum(TreeNode root, int sum) {\\n        if (root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            totalSum += sum;\\n            return;\\n        }\\n        \\n        sum(root.left, sum);\\n        sum(root.right, sum);\\n    }",
                "solutionTags": [],
                "code": "    int totalSum = 0;\\n    \\n    public int sumNumbers(TreeNode root) {\\n        sum(root, 0);\\n        return totalSum;\\n    }\\n    \\n    public void sum(TreeNode root, int sum) {\\n        if (root == null) return;\\n        \\n        sum = sum * 10 + root.val;\\n        \\n        if (root.left == null && root.right == null) {\\n            totalSum += sum;\\n            return;\\n        }\\n        \\n        sum(root.left, sum);\\n        sum(root.right, sum);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41521,
                "title": "short-python-solution",
                "content": "    class Solution(object):\\n    def sumNumbers(self, root):\\n        if not root: return 0\\n        self.res=0\\n        self.cal(root, '')\\n        return self.res\\n    \\n    def cal(self, root, temp):\\n        if not root: return\\n        if not root.left and not root.right: self.res+=int(temp+str(root.val))\\n        for node in [root.left, root.right]: self.cal(node, temp+str(root.val))",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def sumNumbers(self, root):\\n        if not root: return 0\\n        self.res=0\\n        self.cal(root, '')\\n        return self.res\\n    \\n    def cal(self, root, temp):\\n        if not root: return\\n        if not root.left and not root.right: self.res+=int(temp+str(root.val))\\n        for node in [root.left, root.right]: self.cal(node, temp+str(root.val))",
                "codeTag": "Java"
            },
            {
                "id": 41522,
                "title": "solution-with-iterative-preorder-traversal",
                "content": "During a previous interview, they don\\'t like my answer to a tree problem with a recursive solution. Stack overflow is a common problem in the real work environment. So I think we should prefer iterative solution to recursive ones. Or we should at least practice both. \\n\\n    public class Solution {        \\n        public int sumNumbers(TreeNode root) {\\n            int sum = 0, val = 0;\\n            if(root == null) {\\n                return 0;\\n            }\\n            \\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            Stack<Integer> valStack = new Stack<Integer>();\\n            stack.push(root);\\n            valStack.push(root.val);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                val = valStack.pop();\\n                if(node.right == null && node.left == null){\\n                    sum += val;\\n                }\\n                if(node.right != null){\\n                    stack.push(node.right);\\n                    valStack.push(val*10+node.right.val);\\n                }\\n                if(node.left != null){\\n                    stack.push(node.left);\\n                    valStack.push(val*10+node.left.val);\\n                }\\n            }\\n            \\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "class Solution {        \\n        public int sumNumbers(TreeNode root) {\\n            int sum = 0, val = 0;\\n            if(root == null) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41552,
                "title": "my-c-solution-2-ms",
                "content": "    int dfs(struct TreeNode* root, int num) {\\n        if (root == NULL) return 0; // if only one child node is NULL, do not count it\\n        if (root->left == NULL && root->right == NULL) return num * 10 + root->val; // if the node is leaf node, return the sum value\\n        return dfs(root->left, num * 10 + root->val) + dfs(root->right, num * 10 + root->val);\\n    }\\n    \\n    int sumNumbers(struct TreeNode* root) {\\n        return dfs(root, 0);\\n    }",
                "solutionTags": [],
                "code": "    int dfs(struct TreeNode* root, int num) {\\n        if (root == NULL) return 0; // if only one child node is NULL, do not count it\\n        if (root->left == NULL && root->right == NULL) return num * 10 + root->val; // if the node is leaf node, return the sum value\\n        return dfs(root->left, num * 10 + root->val) + dfs(root->right, num * 10 + root->val);\\n    }\\n    \\n    int sumNumbers(struct TreeNode* root) {\\n        return dfs(root, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 41565,
                "title": "share-my-neat-java-solution",
                "content": "    public class Solution {\\n        private int sum;\\n        \\n        public Solution() {\\n            sum = 0;\\n        }\\n        public void sumNumbersHelper(TreeNode root, int current) {\\n            if (root == null) return;\\n            current = current * 10 + root.val;\\n            if (root.left == null && root.right == null) {\\n                sum += current;\\n            } else {\\n                sumNumbersHelper(root.left, current);\\n                sumNumbersHelper(root.right, current);\\n            }\\n        }\\n        \\n        public int sumNumbers(TreeNode root) {\\n            if (root == null) return sum;\\n            int current = 0;\\n            sumNumbersHelper(root, current);\\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private int sum;\\n        \\n        public Solution() {\\n            sum = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3908640,
                "title": "easy-to-understrand-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int sum = 0; // Initialize a global variable to store the sum of root-to-leaf numbers.\\n    \\n    public int sumNumbers(TreeNode root) {\\n        number(root, 0); // Call the helper function with the root and initial sum as 0.\\n        return sum; // Return the calculated sum.\\n    }\\n    \\n    public void number(TreeNode root, int data) {\\n        if (root == null) {\\n            return; // Base case: if the node is null, return.\\n        }\\n        data = data * 10 + root.val; // Calculate the new value by appending the current node\\'s value.\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += data; // If it\\'s a leaf node, add the value to the sum.\\n        }\\n        \\n        number(root.left, data); // Recurse on the left subtree with the updated value.\\n        number(root.right, data); // Recurse on the right subtree with the updated value.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int sum = 0; // Initialize a global variable to store the sum of root-to-leaf numbers.\\n    \\n    public int sumNumbers(TreeNode root) {\\n        number(root, 0); // Call the helper function with the root and initial sum as 0.\\n        return sum; // Return the calculated sum.\\n    }\\n    \\n    public void number(TreeNode root, int data) {\\n        if (root == null) {\\n            return; // Base case: if the node is null, return.\\n        }\\n        data = data * 10 + root.val; // Calculate the new value by appending the current node\\'s value.\\n        \\n        if (root.left == null && root.right == null) {\\n            sum += data; // If it\\'s a leaf node, add the value to the sum.\\n        }\\n        \\n        number(root.left, data); // Recurse on the left subtree with the updated value.\\n        number(root.right, data); // Recurse on the right subtree with the updated value.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767834,
                "title": "java-100-fast-solution-using-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n     return sum(root, 0);   \\n    }\\n    public int sum(TreeNode n, int s) {\\n        if(n == null) return 0;\\n        if(n.right == null && n.left == null) return s * 10 + n.val;\\n        return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n     return sum(root, 0);   \\n    }\\n    public int sum(TreeNode n, int s) {\\n        if(n == null) return 0;\\n        if(n.right == null && n.left == null) return s * 10 + n.val;\\n        return sum(n.left, s * 10 + n.val) + sum(n.right, s * 10 + n.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688079,
                "title": "c-beats-100-t-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int>& res, int sum){\\n        if(root->left==NULL && root->right==NULL){\\n            sum = sum*10 + root->val;\\n            res.push_back(sum);\\n            return;\\n        }\\n        if(root->left!=NULL && root->right ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->left, res, sum);\\n            return; \\n        }\\n        if(root->right!=NULL && root->left ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->right, res, sum);\\n            return; \\n        }\\n        sum = sum*10 + root->val;\\n        helper(root->right, res, sum);\\n        helper(root->left, res, sum);\\n        return; \\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        vector<int> res;\\n        helper(root, res, 0);\\n        int sum =0;\\n        for(int i=0; i<res.size(); i++){\\n            sum+= res[i];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void helper(TreeNode* root, vector<int>& res, int sum){\\n        if(root->left==NULL && root->right==NULL){\\n            sum = sum*10 + root->val;\\n            res.push_back(sum);\\n            return;\\n        }\\n        if(root->left!=NULL && root->right ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->left, res, sum);\\n            return; \\n        }\\n        if(root->right!=NULL && root->left ==NULL){\\n            sum = sum*10 + root->val;\\n            helper(root->right, res, sum);\\n            return; \\n        }\\n        sum = sum*10 + root->val;\\n        helper(root->right, res, sum);\\n        helper(root->left, res, sum);\\n        return; \\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        vector<int> res;\\n        helper(root, res, 0);\\n        int sum =0;\\n        for(int i=0; i<res.size(); i++){\\n            sum+= res[i];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685494,
                "title": "java-ultimate-solution-beats-100",
                "content": "# Intuition\\n\\nAt each step just make a new path until you encounter a leaf node.\\n\\n# Approach\\n\\nExample Tree -  \\n\\n           6                               \\n         /   \\\\                          \\n        3     5                      \\n      /   \\\\     \\\\\\n     2    5      4             \\n        /  \\\\                        \\n       7    4  \\n\\n    0*10 + 6 = 6\\n    6*10 + 3 = 63\\n    63*10 + 2 = 632\\n\\n    -- this makes one of the path ( from root  6 to leaf = 2)\\n\\n\\n    similarly make the left and right call to achieve all paths\\n    and calculate\\n\\n# Complexity\\n- Time complexity:  O(N) \\n\\n- Space complexity: O(Height of Tree)\\n  \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        \\n\\n        return helper(root , 0);\\n    }\\n\\n    static int helper(TreeNode root , int currentSum){\\n\\n\\n        if(root == null) return 0;\\n\\n        int newSum = currentSum * 10 + root.val;\\n\\n\\n        if(root.left == null && root.right == null) return newSum;\\n\\n\\n\\n\\n        int leftSum = helper(root.left , newSum);\\n        int rightSum = helper(root.right , newSum);\\n\\n        return leftSum +  rightSum;\\n\\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        \\n\\n        return helper(root , 0);\\n    }\\n\\n    static int helper(TreeNode root , int currentSum){\\n\\n\\n        if(root == null) return 0;\\n\\n        int newSum = currentSum * 10 + root.val;\\n\\n\\n        if(root.left == null && root.right == null) return newSum;\\n\\n\\n\\n\\n        int leftSum = helper(root.left , newSum);\\n        int rightSum = helper(root.right , newSum);\\n\\n        return leftSum +  rightSum;\\n\\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654837,
                "title": "simple-c-solution-using-dfs",
                "content": "Please upvote if you liked it!\\n\\n```\\n    int dfs(TreeNode* root,int sum){\\n        if(!root){return 0;}\\n        sum*=10;\\n        sum+=root->val;\\n        if(!root->left && !root->right){return sum;}\\n        return dfs(root->left,sum) + dfs(root->right,sum);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root,0);\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "Please upvote if you liked it!\\n\\n```\\n    int dfs(TreeNode* root,int sum){\\n        if(!root){return 0;}\\n        sum*=10;\\n        sum+=root->val;\\n        if(!root->left && !root->right){return sum;}\\n        return dfs(root->left,sum) + dfs(root->right,sum);\\n    }\\n    \\n    int sumNumbers(TreeNode* root) {\\n        return dfs(root,0);\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3644689,
                "title": "100-fast-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder traversal\\n    void solve(TreeNode* root, int &sum, int num){\\n        if(!root)  return;\\n         if(!root->left && !root->right){\\n             sum+=num*10+root->val;\\n         }\\n         solve(root->left,sum,num*10+root->val);\\n         solve(root->right,sum,num*10+root->val);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum=0,num=0;\\n        solve(root,sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder traversal\\n    void solve(TreeNode* root, int &sum, int num){\\n        if(!root)  return;\\n         if(!root->left && !root->right){\\n             sum+=num*10+root->val;\\n         }\\n         solve(root->left,sum,num*10+root->val);\\n         solve(root->right,sum,num*10+root->val);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n        int sum=0,num=0;\\n        solve(root,sum,num);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643563,
                "title": "c-efficient",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int sumNumbers(TreeNode* root) {\\n        int ans(0);\\n        int sum(0);\\n        dfs(root, sum);\\n        for(auto it:nums){\\n            cout<<it<<\" \";\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int &sum){\\n        if(root == NULL){\\n            return;\\n        }\\n        sum = sum*10 + root->val;\\n        if(isLeaf(root))\\n            nums.PB(sum);\\n        dfs(root->left,sum);\\n        dfs(root->right,sum);\\n        sum = (sum - root->val)/10;\\n    }\\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define PB push_back\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int sumNumbers(TreeNode* root) {\\n        int ans(0);\\n        int sum(0);\\n        dfs(root, sum);\\n        for(auto it:nums){\\n            cout<<it<<\" \";\\n            ans += it;\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root, int &sum){\\n        if(root == NULL){\\n            return;\\n        }\\n        sum = sum*10 + root->val;\\n        if(isLeaf(root))\\n            nums.PB(sum);\\n        dfs(root->left,sum);\\n        dfs(root->right,sum);\\n        sum = (sum - root->val)/10;\\n    }\\n    bool isLeaf(TreeNode* root){\\n        if(!root->left && !root->right)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3509242,
                "title": "easy-c-code-beginner-friendly-with-100-beats",
                "content": "# Intuition\\nEasyPeasy C++ code\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void sumNumberHelper(TreeNode* root,int val,int &ans){\\n        int curr=val*10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            ans += curr;\\n        }\\n        if(root->left){\\n            sumNumberHelper(root->left,curr,ans);\\n        }\\n        if(root->right) {\\n            sumNumberHelper(root->right,curr,ans);\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int ans = 0;\\n        sumNumberHelper(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void sumNumberHelper(TreeNode* root,int val,int &ans){\\n        int curr=val*10 + root->val;\\n        if(root->left == NULL && root->right == NULL){\\n            ans += curr;\\n        }\\n        if(root->left){\\n            sumNumberHelper(root->left,curr,ans);\\n        }\\n        if(root->right) {\\n            sumNumberHelper(root->right,curr,ans);\\n        }\\n    }\\n    int sumNumbers(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int ans = 0;\\n        sumNumberHelper(root,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486171,
                "title": "beats-100-recursive-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode root,int sum)\\n    {\\n        if(root==null)\\n            return;\\n        sum=sum*10+root.val;\\n\\n        if(root.left==null && root.right==null)\\n        {\\n            total+=sum;\\n            return;\\n        }\\n\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int total=0;\\n    public int sumNumbers(TreeNode root) {\\n        helper(root,0);\\n        return total;\\n    }\\n\\n    void helper(TreeNode root,int sum)\\n    {\\n        if(root==null)\\n            return;\\n        sum=sum*10+root.val;\\n\\n        if(root.left==null && root.right==null)\\n        {\\n            total+=sum;\\n            return;\\n        }\\n\\n        helper(root.left,sum);\\n        helper(root.right,sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300947,
                "title": "preorder-dfs-java-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDFS - PreOrder\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode root, int sum)\\n    {\\n        if(root == null)\\n            return 0;\\n\\n        sum = (sum * 10) + root.val;\\n\\n        int left = dfs(root.left, sum);\\n        int right = dfs(root.right, sum);\\n\\n        return (left+right) == 0 ? sum : left+right;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        return dfs(root, 0);\\n    }\\n\\n    int dfs(TreeNode root, int sum)\\n    {\\n        if(root == null)\\n            return 0;\\n\\n        sum = (sum * 10) + root.val;\\n\\n        int left = dfs(root.left, sum);\\n        int right = dfs(root.right, sum);\\n\\n        return (left+right) == 0 ? sum : left+right;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297738,
                "title": "simplest-python-solution-using-preorder-traversal",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(cur,num):\\n            if not cur:\\n                return 0\\n            num=num*10+cur.val\\n            if not cur.left and not cur.right:\\n                return num\\n            else:\\n                return dfs(cur.left,num) + dfs(cur.right,num)\\n        return dfs(root,0)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\\n        def dfs(cur,num):\\n            if not cur:\\n                return 0\\n            num=num*10+cur.val\\n            if not cur.left and not cur.right:\\n                return num\\n            else:\\n                return dfs(cur.left,num) + dfs(cur.right,num)\\n        return dfs(root,0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297560,
                "title": "0-ms-beats-100-simple-and-concise-recursive-solution",
                "content": "# Intuition\\n0-> Return the total sum of all root-to-leaf numbers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n0-> use a recursive approach to traverse the tree.\\n\\n1->  We start with the root node and a current number of 0.\\n\\n2-> At each node, we multiply the current number by 10 and add the node\\'s value to get the new current number.\\n\\n3-> If the current node is a leaf node, we add the current number to our running sum. \\n\\n4-> we recursively traverse the left and right subtrees, passing the new current number to each.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height of Tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sumNumbersHelper(TreeNode root, int curr){\\n        if(root == null) return 0;\\n\\n        curr = curr * 10 + root.val;\\n\\n        if(root.left == null && root.right == null) return curr;\\n\\n        int leftSum = sumNumbersHelper(root.left, curr);\\n        int rightSum = sumNumbersHelper(root.right, curr);\\n\\n        return leftSum + rightSum;\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        return sumNumbersHelper(root, 0);\\n    }\\n}\\n```\\n\\n\\n![Upvote Dis.jpeg](https://assets.leetcode.com/users/images/32c2a3e0-b7bb-4f05-a80d-75e0b33f88e7_1678818862.3224769.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private int sumNumbersHelper(TreeNode root, int curr){\\n        if(root == null) return 0;\\n\\n        curr = curr * 10 + root.val;\\n\\n        if(root.left == null && root.right == null) return curr;\\n\\n        int leftSum = sumNumbersHelper(root.left, curr);\\n        int rightSum = sumNumbersHelper(root.right, curr);\\n\\n        return leftSum + rightSum;\\n    }\\n    public int sumNumbers(TreeNode root) {\\n        return sumNumbersHelper(root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564972,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831719,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831810,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832010,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831954,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832215,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831834,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831813,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831804,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1564972,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831719,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831810,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832010,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831954,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1832215,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831834,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831813,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831804,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sum-root-to-leaf-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Iterative Preorder Traversal.\n\n  \n**Approach 2:** Recursive Preorder Traversal.\n\n  \n**Approach 3:** Morris Preorder Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Very good question which can be solved in many approaches. Great suggestion, LeetCode!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yesterday's daily (symmetric tree, rated easy) was at least as hard as this one imho"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@mint_](/mint_) No need for string conversion. Just do sum * 10 to shift it over by 1 place "
                    },
                    {
                        "username": "knotri",
                        "content": "[@mint_](/mint_) u dont need to do string to int conversion, just sum =* 10"
                    },
                    {
                        "username": "mint_",
                        "content": "\n\nhonestly yesterday's \"easy\" was harder than this IMO, this is just basic DFS (with a little string to int conversion in the end if you want to make it easier)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**so i guess this week topic is BINARY TREE**"
                    },
                    {
                        "username": "Msey",
                        "content": "[@aeroabrar_31](/aeroabrar_31) we used std::ceil :)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "No, only 3 days."
                    },
                    {
                        "username": "AmpiroMax",
                        "content": "This task should be considered as an easy one, not a medium one because of the simplicity of the solution"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "March 12th is Arbor Day, so i guess this is a week for tree!"
                    },
                    {
                        "username": "underdogsourav",
                        "content": "great 2 see new random question in daily challenge\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Basic DFS..."
                    },
                    {
                        "username": "zah7131",
                        "content": "but the challenge is not there for solving it not only DFS. it requires some more attention if it is asked to solve in o(1) space."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "mint_",
                        "content": "some of them probably solved this question before (I solved this one a while back for other prep)"
                    },
                    {
                        "username": "imprayas12",
                        "content": "It's been a while since I saw a randomly new question on daily challenge."
                    }
                ]
            },
            {
                "id": 1831789,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571276,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1679672,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1572527,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571277,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1571278,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 2058609,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 2003736,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1948682,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1933355,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Should be marked as easy, joke question"
                    },
                    {
                        "username": "BryanBoCao",
                        "content": "In terms of [#129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\nMy output for running the same code was different to that on the submit solution, which was \"1\" and \"10\" respectively, why?\\n![0_1467851352336_Screenshot from 2016-07-06 18:27:39.png](/uploads/files/1467851353053-screenshot-from-2016-07-06-18-27-39.png) \\n\\n[My submission](https://leetcode.com/submissions/detail/66362641/)"
                    },
                    {
                        "username": "wjeevika",
                        "content": "This is a good question."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@wjeevika](/wjeevika) lmao why u reply to urself"
                    },
                    {
                        "username": "wjeevika",
                        "content": "I like it. "
                    },
                    {
                        "username": "ben_huang",
                        "content": "![image](https://assets.leetcode.com/users/ben_huang/image_1552672771.png)\\n"
                    },
                    {
                        "username": "sweetiemelody",
                        "content": "who can explain the 0-ms solution? Thank you a lot."
                    },
                    {
                        "username": "bboczeng",
                        "content": "What does this mean in terms of a binary tree?"
                    },
                    {
                        "username": "manodupont",
                        "content": "Why is this working correctly in VSCode, but not in here ?\n**Use Case**\nroot =\n[4,9,0,5,1]\n\n**Code**\n```\nlet sum = 0\nfunction dfs(node, path) {\n    if (node !== null) {\n        path += `${node.val}`\n\n        if (node.left == null && node.right == null) {// Its a leaf\n            console.log(path)\n            sum += parseInt(path)\n        }\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n    }\n}\n\nfunction sumNumbers(root) {\n    dfs(root, '')\n    return sum\n};\n```\n"
                    },
                    {
                        "username": "garvit_17",
                        "content": "terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\n"
                    },
                    {
                        "username": "souravishere1996",
                        "content": "What to say about this easy approach??\\n\\nclass Solution {\\npublic:\\n\\n    int func(TreeNode* root,int sum)\\n    {\\n        if(!root){\\n          //  sum=sum*10+root->val;\\n            return 0;\\n        }\\n        if(!root->left && !root->right)\\n        {\\n            sum=sum*10+root->val;\\n            return sum;\\n        }\\n\\n        sum=sum*10+root->val;\\n        return func(root->left,sum) + func(root->right,sum);\\n    }\\n\\n    int sumNumbers(TreeNode* root) {\\n\\n        int sum=0;\\n        return func(root,sum);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I would say - lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I like this question. Its similar to path sum I and II, so if you solved those then this should be easy too \\n\\nI found other \"easy\" tree questions to be harder than this one "
                    }
                ]
            },
            {
                "id": 1876676,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1840700,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1833310,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832548,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832524,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832381,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832375,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832357,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832243,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832242,
                "content": [
                    {
                        "username": "Aditya_Prajapati",
                        "content": "What are the other approaches other than recursion possible for this question ?"
                    },
                    {
                        "username": "Kinszs",
                        "content": "When I type my solution, I am having a error that I cant solve. \\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        enum State{Unvisited, Visited, Visiting; }\\n         boolean search(Graph grade, Node start, Node end){\\n             if(start == end) return true;\\n\\n             LinkedList<Node> queue = new LinkedList<Node>();\\n             for(Node u : grade.getNodes()){\\n                 u.state = State.Unvisited;\\n             }\\n             start.state = State.Visiting;\\n             queue.add(start);\\n             Node u;\\n             while(!queue.isEmpty()){\\n                 u = queue.removeFirst();\\n                 if(u != null){\\n                     for(Node v : u.getAdjacent()){\\n                         if(v.state == State.Unvisited){\\n                             if(v == end){\\n                                 return true;\\n                             }else{\\n                                 v.state = State.Visiting;\\n                                 queue.add(v);\\n                             }\\n                         }\\n                     }\\n                     u.state = State.Visited;\\n                 }\\n             }\\n         }\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Kinszs",
                        "content": "IMO the best approach to solving this would be to use DFS. What do you guys think?"
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem can be solved as DFS or BFS!"
                    },
                    {
                        "username": "theAchiever",
                        "content": "Can anyone please explain to me why this code won\\'t work?\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null)\\n            return 0;\\n        else if(root.left==null&&root.right==null)\\n            return root.val;\\n        else{\\n            int sum1=root.val*10+sumNumbers(root.left);\\n            int sum2=root.val*10+sumNumbers(root.right);\\n            return sum1+sum2;\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "nayeemfifa_14",
                        "content": "why is it that when I\\'m running my code on my vs code its giving the right output but here it somehow gives the wrong output ?"
                    },
                    {
                        "username": "Msey",
                        "content": "Tree week :)"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "We are given a binary tree and we need to traverse from root to leaf and then form a number.Likewise, repeat the path traversals and form all possible numbers from root to leaf.Finally, find the sum of all these numbers formed and return as answer.From the below code you can see how we can solve this problem using recursion or dfs (depth first search).\\nWe have declare ans as global variable to use it in both the method and store the final ans.\\n\\nCode : \\n\\nclass Solution {\\n    int ans = 0;\\n    public int sumNumbers(TreeNode root) {\\n        if(root==null) return 0;\\n        dfs(root,0);\\n        return ans;\\n    }\\n    public void dfs(TreeNode root, int val){\\n        if(root==null) return ;\\n        val*=10;\\n        val += root.val;\\n        if(root.left==null && root.right==null){\\n            ans+=val;\\n            return;\\n        }\\n        dfs(root.left,val);\\n        dfs(root.right,val);\\n    }\\n\\n}"
                    },
                    {
                        "username": "shaikirfan2349",
                        "content": "pls help me.....My code giving output as \\'0\\'\\n\\n\\nclass Solution {\\n    public int sumNumbers(TreeNode root) {\\n        Pair<TreeNode,Integer> pair=new Pair(root,0);\\n        Queue<Pair<TreeNode,Integer>> q=new LinkedList();\\n        ArrayList<Integer> leaf = new ArrayList<Integer>();\\n\\n        q.add(pair);\\n        \\n        int totalSum=0;\\n        while(!q.isEmpty()){\\n            int currSum=0;\\n            Pair<TreeNode,Integer> p=q.remove();\\n            currSum=(currSum*10)+p.getKey().val;\\n            if(root.left==null && root.right==null){\\n                leaf.add(currSum);\\n                \\n            }\\n\\n            if(p.getKey().left!=null){\\n                q.add(new Pair(p.getKey().left,p.getValue()+currSum));\\n            }\\n            if(p.getKey().right!=null){\\n                q.add(new Pair(p.getKey().right,p.getValue()+currSum));\\n            }\\n        }\\n        for(int i:leaf){\\n            totalSum+=i;\\n        }\\n\\n        return totalSum;\\n    }\\n}"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is a Simple Approach (BFS):-\\n\\n1. Initialize a queue and add the root of the binary tree to it.\\n2. Initialize a variable to keep track of the sum of root-to-leaf numbers to 0.\\n3. While the queue is not empty, remove the first element from the queue and assign it to a node variable.\\n4. If the node is a leaf node (i.e., it has no left or right child), add its value to the sum variable.\\n5. If the node has a left child, update its value to be the value of the parent node multiplied by 10 and then added to its own value. Add the left child to the queue.\\n6. If the node has a right child, update its value in the same way and add the right child to the queue.\\n7. Repeat steps 3-6 until the queue is empty.\\n8. Return the sum variable."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "here is the code link for reference:-\\nhttps://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3296514/bfs-easy-to-understand-with-steps/"
                    }
                ]
            },
            {
                "id": 1832078,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831993,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831918,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831872,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831794,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831786,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831777,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831733,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1831720,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            },
            {
                "id": 1635469,
                "content": [
                    {
                        "username": "upscchap",
                        "content": "Hey, I tried to code the solution for this problem.\\nCould you please rate my approach to solving this problem?\\nhttps://youtu.be/0vSQRnU-PXo\\nThanks in advance!!"
                    },
                    {
                        "username": "zbr_98",
                        "content": "Started learning tree this week and the best thing is that getting daily questions of tree \\uD83C\\uDF34.\\nProbably the first medium question of tree I\\'ve done without taking any hint."
                    },
                    {
                        "username": "stutitiwari161",
                        "content": "Hey! Even I started Tree this week.....where are you learning from?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just a normal dfs just additional parameter current sum when u reach at a leaf just add it into the res and at each node multiply running sum with and add current nodes value"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "is it just me or are we getting a lot of repeated daily challenge questions these days? Everyday I login and see that I have already submitted the solution"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Using preorder traversal recursion can be done."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Here are, the different approaches we should keep in mind after understanding the problem......\\nApproach 1: Recursive Depth-First Search.\\nApproach 2: Iterative Depth-First Search.\\nApproach 3: Breadth-First Search."
                    },
                    {
                        "username": "meow_power",
                        "content": "Sometimes Leetcode tries us to motivate us,so that we won\\'t go into depression:) Thank You Leetcode!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Im confused on this sentence in the question:\n\n*For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.\n\n        1\n      /    \\\n   2         3\n\nFor the tree shown, that's not a valid path. What is the meaning of this sentence? \nThe rest of the examples show proper tree paths. Usually when discussing trees we assume they are directed, but they arent necessarily. It MIGHT be valid to claim there is a path from 1 to 3 like so:  1 -> 2 -> 1 -> 3, but that is very different from what they are claiming. What am I missing? \n\n\nEDIT: The path in the sentence is for a theoretical tree NOT depicted here. This is a pretty poor choice, given that almost immediately below this the first image corresponds with a similarly labeled tree. The sentance and image are unrelated. Reading comprehension isnt my strong suit I guess, but really they should just change the sentence to use different numbers \n\n(I dont need a hint on the solution, this one should probably be an easy, its a pretty trivial tree problem)"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "The 1 -> 2 -> 3 example is not related to the tree below. It's just an explanation on how the root-to-path idea works. "
                    },
                    {
                        "username": "user8228j",
                        "content": "not the most efficient solution by far, but imo way easier to implement.\\nkeep track of the number as a string, and just convert to an int when at a leaf node."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "hint : try some sort of traversal with extra variables to store sum and sum till the root ."
                    }
                ]
            }
        ]
    }
]