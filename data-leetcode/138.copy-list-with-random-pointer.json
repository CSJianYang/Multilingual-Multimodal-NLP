[
    {
        "title": "Count and Say",
        "question_content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n\tcountAndSay(1) = \"1\"\n\tcountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\nGiven a positive integer n, return the nth term of the count-and-say sequence.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n\nExample 2:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 30",
        "solutions": [
            {
                "id": 15995,
                "title": "examples-of-nth-sequence",
                "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I'm going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n     1.     1\\n     2.     11\\n     3.     21\\n     4.     1211\\n     5.     111221 \\n     6.     312211\\n     7.     13112221\\n     8.     1113213211\\n     9.     31131211131221\\n     10.   13211311123113112211\\n\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!",
                "solutionTags": [],
                "code": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I'm going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n     1.     1\\n     2.     11\\n     3.     21\\n     4.     1211\\n     5.     111221 \\n     6.     312211\\n     7.     13112221\\n     8.     1113213211\\n     9.     31131211131221\\n     10.   13211311123113112211\\n\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 15999,
                "title": "4-5-lines-python-solutions",
                "content": "**Solution 1** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s\\n\\n---\\n\\n**Solution 2** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(group)) + digit\\n                        for group, digit in re.findall(r'((.)\\\\2*)', s))\\n        return s\\n\\n---\\n\\n**Solution 3** ... using `groupby`\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(list(group))) + digit\\n                        for digit, group in itertools.groupby(s))\\n        return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s\\n\\n---\\n\\n**Solution 2** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(group)) + digit\\n                        for group, digit in re.findall(r'((.)\\\\2*)', s))\\n        return s\\n\\n---\\n\\n**Solution 3** ... using `groupby`\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(list(group))) + digit\\n                        for digit, group in itertools.groupby(s))\\n        return s",
                "codeTag": "Python3"
            },
            {
                "id": 16040,
                "title": "straightforward-java-solution",
                "content": "     public class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for(int i = 1; i < n; i++){\\n                s = countIdx(s);\\n            }\\n            return s;\\n        }\\n        \\n        public String countIdx(String s){\\n            StringBuilder sb = new StringBuilder();\\n            char c = s.charAt(0);\\n            int count = 1;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s.charAt(i) == c){\\n                    count++;\\n                }\\n                else\\n                {\\n                    sb.append(count);\\n                    sb.append(c);\\n                    c = s.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(c);\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for(int i = 1; i < n; i++){\\n                s = countIdx(s);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 16043,
                "title": "c-solution-easy-understand",
                "content": "    string countAndSay(int n) {\\n        if (n == 0) return \"\";\\n        string res = \"1\";\\n        while (--n) {\\n            string cur = \"\";\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                 while ((i + 1 < res.size()) && (res[i] == res[i + 1])){\\n                    count++;    \\n                    i++;\\n                }\\n                cur += to_string(count) + res[i];\\n            }\\n            res = cur;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    string countAndSay(int n) {\\n        if (n == 0) return \"\";\\n        string res = \"1\";\\n        while (--n) {\\n            string cur = \"\";\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                 while ((i + 1 < res.size()) && (res[i] == res[i + 1])){\\n                    count++;    \\n                    i++;\\n                }\\n                cur += to_string(count) + res[i];\\n            }\\n            res = cur;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16044,
                "title": "simple-python-solution",
                "content": "Idea here is keep track of the first letter in the sequence and count consecutive occurances.  Once you encounter a new letter you add the previous count and letter to the chain.  Repeat n-1 times (since we seeded the initial '1' case).  We always update temp after the inner loop since we will never have already added the last sequence.\\n\\n         def countAndSay(self, n):\\n            s = '1'\\n            for _ in range(n-1):\\n                let, temp, count = s[0], '', 0\\n                for l in s:\\n                    if let == l:\\n                        count += 1\\n                    else:\\n                        temp += str(count)+let\\n                        let = l\\n                        count = 1\\n                temp += str(count)+let\\n                s = temp\\n            return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "Idea here is keep track of the first letter in the sequence and count consecutive occurances.  Once you encounter a new letter you add the previous count and letter to the chain.  Repeat n-1 times (since we seeded the initial '1' case).  We always update temp after the inner loop since we will never have already added the last sequence.\\n\\n         def countAndSay(self, n):\\n            s = '1'\\n            for _ in range(n-1):\\n                let, temp, count = s[0], '', 0\\n                for l in s:\\n                    if let == l:\\n                        count += 1\\n                    else:\\n                        temp += str(count)+let\\n                        let = l\\n                        count = 1\\n                temp += str(count)+let\\n                s = temp\\n            return s",
                "codeTag": "Python3"
            },
            {
                "id": 16000,
                "title": "show-an-answer-in-java",
                "content": "I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard.\\n\\nMaybe many other people had some trouble too. So I put my answer here.\\n\\n\\n\\n    public class Solution {\\n        public String countAndSay(int n) {\\n    \\t    \\tStringBuilder curr=new StringBuilder(\"1\");\\n    \\t    \\tStringBuilder prev;\\n    \\t    \\tint count;\\n    \\t    \\tchar say;\\n    \\t        for (int i=1;i<n;i++){\\n    \\t        \\tprev=curr;\\n    \\t \\t        curr=new StringBuilder();       \\n    \\t \\t        count=1;\\n    \\t \\t        say=prev.charAt(0);\\n    \\t \\t        \\n    \\t \\t        for (int j=1,len=prev.length();j<len;j++){\\n    \\t \\t        \\tif (prev.charAt(j)!=say){\\n    \\t \\t        \\t\\tcurr.append(count).append(say);\\n    \\t \\t        \\t\\tcount=1;\\n    \\t \\t        \\t\\tsay=prev.charAt(j);\\n    \\t \\t        \\t}\\n    \\t \\t        \\telse count++;\\n    \\t \\t        }\\n    \\t \\t        curr.append(count).append(say);\\n    \\t        }\\t       \\t        \\n    \\t        return curr.toString();\\n            \\n        }\\n    }\\n\\n@code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly.\\n\\nAny comment is welcomed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n    \\t    \\tStringBuilder curr=new StringBuilder(\"1\");\\n    \\t    \\tStringBuilder prev;\\n    \\t    \\tint count;\\n    \\t    \\tchar say;\\n    \\t        for (int i=1;i<n;i++){\\n    \\t        \\tprev=curr;\\n    \\t \\t        curr=new StringBuilder();       \\n    \\t \\t        count=1;\\n    \\t \\t        say=prev.charAt(0);\\n    \\t \\t        \\n    \\t \\t        for (int j=1,len=prev.length();j<len;j++){\\n    \\t \\t        \\tif (prev.charAt(j)!=say){\\n    \\t \\t        \\t\\tcurr.append(count).append(say);\\n    \\t \\t        \\t\\tcount=1;\\n    \\t \\t        \\t\\tsay=prev.charAt(j);\\n    \\t \\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2716207,
                "title": "c-easy-detailed-explaination-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition :**\\n```\\nn = 1: return 1 is the base case\\nn = 2: return count of last entry i.e. 1 1\\nn = 3: return count of last entry i.e. two 1\\'s so 21\\nn = 4: we have one 2 and one 1 so 1211\\nn = 5: , we have one 1 and one 2 and two 1\\'s so -> 111221\\nn = 6: we have three 1\\'s, two 2\\'s and one 1 so -> 312211\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> 13112221\\n...\\nn = i: return counts in front of the number for entry of i-1 case\\n```\\n\\n**The following are sequence from n=1 to n=10:**\\n```\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\n```\\ncredits for sequences @xin15\\n\\n**Ques)** What does `s=s+\"&\"` means, why do we add \"&\" at the end?\\n**Ans =>** Whenever we get a character that is unequal to the previous character,we add the previous add our answer for the previous number to the string temp. So for the last number in the string we wont get any inequality and hence it wont get added to string temp. This is why we added a random character at the end so that random character becomes unequal to the last character of the actual string and we could get the desired answer.\\n\\nTake example \"1211\".\\nHere you can not count the last \\'1\\'.\\n\\nBut you can in this example \"1211$\"\\nif(s[j]==s[j-1]){\\n      cnt++;\\n}\\nto count the last one you\\'ve to include an ending character.\\n\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        // base case\\n        if(n==1)\\n            return \"1\";\\n        if(n==2)\\n            return \"11\";\\n        \\n        // take a string equals 11\\n        string str = \"11\";\\n        \\n        // now we need the value of nth term so we loop from 3 -> n\\n        for(int i=3; i<=n ; i++)\\n        {\\n            // temp will have the ans of the next iteration i.e value of the next ith data\\n            string temp = \"\";\\n            str = str+\"&\"; // add a delimeter at the end\\n            int cnt = 1; // counter \\n            \\n            // now loop from 1st value to last value\\n            for(int j = 1; j<str.length(); j++)\\n            {\\n                // this condition should be satisfied, if not that means new number has started occurring\\n                if(str[j]!=str[j-1])\\n                {\\n                    temp = temp + to_string(cnt); // add the counter to temp\\n                    temp = temp + str[j-1]; // add the data of the counter\\n                    cnt = 1; // reset the counter to 1\\n                }\\n                else\\n                    cnt++; // just count the freq of that number\\n            }\\n            \\n            // after one complete traversal, make str equal to temp;\\n            str = temp;\\n        }\\n        \\n    return str;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/cda3b0c2-39b5-43e1-99dd-0f8086af8ee6_1666055856.180599.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nn = 1: return 1 is the base case\\nn = 2: return count of last entry i.e. 1 1\\nn = 3: return count of last entry i.e. two 1\\'s so 21\\nn = 4: we have one 2 and one 1 so 1211\\nn = 5: , we have one 1 and one 2 and two 1\\'s so -> 111221\\nn = 6: we have three 1\\'s, two 2\\'s and one 1 so -> 312211\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> 13112221\\n...\\nn = i: return counts in front of the number for entry of i-1 case\\n```\n```\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\n```\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        // base case\\n        if(n==1)\\n            return \"1\";\\n        if(n==2)\\n            return \"11\";\\n        \\n        // take a string equals 11\\n        string str = \"11\";\\n        \\n        // now we need the value of nth term so we loop from 3 -> n\\n        for(int i=3; i<=n ; i++)\\n        {\\n            // temp will have the ans of the next iteration i.e value of the next ith data\\n            string temp = \"\";\\n            str = str+\"&\"; // add a delimeter at the end\\n            int cnt = 1; // counter \\n            \\n            // now loop from 1st value to last value\\n            for(int j = 1; j<str.length(); j++)\\n            {\\n                // this condition should be satisfied, if not that means new number has started occurring\\n                if(str[j]!=str[j-1])\\n                {\\n                    temp = temp + to_string(cnt); // add the counter to temp\\n                    temp = temp + str[j-1]; // add the data of the counter\\n                    cnt = 1; // reset the counter to 1\\n                }\\n                else\\n                    cnt++; // just count the freq of that number\\n            }\\n            \\n            // after one complete traversal, make str equal to temp;\\n            str = temp;\\n        }\\n        \\n    return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201832,
                "title": "it-s-a-good-question-let-me-explain-it",
                "content": "When I first read the question, I don\\'t really understand what is this question meaning. Actually it is very simple.\\nEverthing start 1, 1 is 1, nothing else.\\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\\n....\\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let\\'s count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\\n\\n\\tclass Solution:\\n\\t\\tdef countAndSay(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn \"1\"\\n\\t\\t\\treturn self.count(self.countAndSay(n - 1))\\n\\t\\t\\t\\n\\t\\tdef count(self , s):\\n\\t\\t\\tc = s[0]\\n\\t\\t\\tcount = 1\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor char in s[1 : ]:\\n\\t\\t\\t\\tif char == c:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres  = res + str(count) + c\\n\\t\\t\\t\\t\\tc = char\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\tres = res + str(count) + c\\n\\t\\t\\treturn res\\neasy question , but good, just need to understand it",
                "solutionTags": [],
                "code": "When I first read the question, I don\\'t really understand what is this question meaning. Actually it is very simple.\\nEverthing start 1, 1 is 1, nothing else.\\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\\n....\\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let\\'s count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\\n\\n\\tclass Solution:\\n\\t\\tdef countAndSay(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn \"1\"\\n\\t\\t\\treturn self.count(self.countAndSay(n - 1))\\n\\t\\t\\t\\n\\t\\tdef count(self , s):\\n\\t\\t\\tc = s[0]\\n\\t\\t\\tcount = 1\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor char in s[1 : ]:\\n\\t\\t\\t\\tif char == c:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres  = res + str(count) + c\\n\\t\\t\\t\\t\\tc = char\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\tres = res + str(count) + c\\n\\t\\t\\treturn res\\neasy question , but good, just need to understand it",
                "codeTag": "Java"
            },
            {
                "id": 2716134,
                "title": "easy-java-superfast-solution",
                "content": "# Upote if you like the solution\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```\\n\\n\\n# IF THE SOLUTION WORKED FOR YOU PLEASE UPVOTE IT............",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525671,
                "title": "simple-c-recursive-solution",
                "content": "This function makes `n` recursive calls, since we start from `n` and end at `1` (base case)\\n\\n```\\nstring countAndSay(int n, string s = \"1\") { // initial value of the string is \"1\"\\n    if(n==1) return s; // base case, when n recursive calls are finished\\n\\t\\n    int i=0, j, len = s.size(); // \\'len\\' is the length of the string \\'s\\'\\n    string res = \"\"; // result after we \\'say\\' the string \\'s\\'\\n\\t\\n\\t// \\'i\\' starts from index 0\\n    while(i<len) {\\n        j=i; // fix \\'j\\' as the current position (i)\\n\\t\\t\\n\\t\\t// increment the value of \\'i\\' till valid position\\n        while(i<len && s[i]==s[j]) i++;\\n\\t\\t\\n\\t\\t// substring with same values as s[j] is [j,i-1] & \"i-j\" is the count of that value\\n\\t\\t// add the concatenation of (count + s[j]) to the result \\n        res += to_string(i-j) + s[j];\\n    }\\n\\t\\n\\t// recursively, call the same function by decrementing the count\\n\\t// and update the result \\'res\\', which will be the next string \\'s\\'\\n    return countAndSay(n-1, res);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstring countAndSay(int n, string s = \"1\") { // initial value of the string is \"1\"\\n    if(n==1) return s; // base case, when n recursive calls are finished\\n\\t\\n    int i=0, j, len = s.size(); // \\'len\\' is the length of the string \\'s\\'\\n    string res = \"\"; // result after we \\'say\\' the string \\'s\\'\\n\\t\\n\\t// \\'i\\' starts from index 0\\n    while(i<len) {\\n        j=i; // fix \\'j\\' as the current position (i)\\n\\t\\t\\n\\t\\t// increment the value of \\'i\\' till valid position\\n        while(i<len && s[i]==s[j]) i++;\\n\\t\\t\\n\\t\\t// substring with same values as s[j] is [j,i-1] & \"i-j\" is the count of that value\\n\\t\\t// add the concatenation of (count + s[j]) to the result \\n        res += to_string(i-j) + s[j];\\n    }\\n\\t\\n\\t// recursively, call the same function by decrementing the count\\n\\t// and update the result \\'res\\', which will be the next string \\'s\\'\\n    return countAndSay(n-1, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16382,
                "title": "python-easy-to-understand-iterative-and-recursive-solutions",
                "content": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        ret = \"1\"\\n        for _ in range(n-1):\\n            ret = self.nextStep(ret)\\n        return ret\\n    \\n    def nextStep(self, s):\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n    \\n    def countAndSay1(self, n):\\n        if n == 1:\\n            return \"1\"\\n        s = self.countAndSay(n-1)\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        ret = \"1\"\\n        for _ in range(n-1):\\n            ret = self.nextStep(ret)\\n        return ret\\n    \\n    def nextStep(self, s):\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n    \\n    def countAndSay1(self, n):\\n        if n == 1:\\n            return \"1\"\\n        s = self.countAndSay(n-1)\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391236,
                "title": "javascript-97-25-not-clever",
                "content": "When you only have 30 options\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\narr = [ \"\",\\'1\\',\\n  \\'11\\',\\n  \\'21\\',\\n  \\'1211\\',\\n  \\'111221\\',\\n  \\'312211\\',\\n  \\'13112221\\',\\n  \\'1113213211\\',\\n  \\'31131211131221\\',\\n  \\'13211311123113112211\\',\\n  \\'11131221133112132113212221\\',\\n  \\'3113112221232112111312211312113211\\',\\n  \\'1321132132111213122112311311222113111221131221\\',\\n  \\'11131221131211131231121113112221121321132132211331222113112211\\',\\n  \\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n  \\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n  \\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n  \\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n  \\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\' ]\\n    return arr[n]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\narr = [ \"\",\\'1\\',\\n  \\'11\\',\\n  \\'21\\',\\n  \\'1211\\',\\n  \\'111221\\',\\n  \\'312211\\',\\n  \\'13112221\\',\\n  \\'1113213211\\',\\n  \\'31131211131221\\',\\n  \\'13211311123113112211\\',\\n  \\'11131221133112132113212221\\',\\n  \\'3113112221232112111312211312113211\\',\\n  \\'1321132132111213122112311311222113111221131221\\',\\n  \\'11131221131211131231121113112221121321132132211331222113112211\\',\\n  \\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n  \\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n  \\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n  \\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n  \\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\' ]\\n    return arr[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351839,
                "title": "swift-count-and-say-test-cases",
                "content": "```swift\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 && n <= 30 else { return \"1\" }\\n        \\n        let prev = countAndSay(n - 1)\\n        var curr = prev.first!, count = 0, result = \"\"\\n        \\n        prev.forEach {\\n            if $0 != curr {\\n                result += \"\\\\(count)\\\\(curr)\"\\n                count = 1\\n                curr = $0\\n            } else {\\n                count += 1\\n            }\\n        }\\n        result += \"\\\\(count)\\\\(curr)\"\\n        return result\\n        \\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.countAndSay(1), \"1\")\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.countAndSay(4), \"1211\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 && n <= 30 else { return \"1\" }\\n        \\n        let prev = countAndSay(n - 1)\\n        var curr = prev.first!, count = 0, result = \"\"\\n        \\n        prev.forEach {\\n            if $0 != curr {\\n                result += \"\\\\(count)\\\\(curr)\"\\n                count = 1\\n                curr = $0\\n            } else {\\n                count += 1\\n            }\\n        }\\n        result += \"\\\\(count)\\\\(curr)\"\\n        return result\\n        \\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.countAndSay(1), \"1\")\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.countAndSay(4), \"1211\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16325,
                "title": "super-simple-javascript-solution-if-anyone-is-interested",
                "content": "    var countAndSay = function(n) {\\n        var str = '1';\\n        for (var i=1; i < n; i++) {\\n            var strArray = str.split('');\\n            str ='';\\n            var count = 1;\\n            // Loop through current nth level line\\n            for (var j=0; j < strArray.length; j++) {\\n                // Next digit is different\\n                if (strArray[j] !== strArray[j+1]) {\\n                    // Go to next non-matching digit\\n                    str += count + strArray[j];\\n                    count = 1;\\n                }\\n                else {\\n                    count++;\\n                }\\n            }\\n        }\\n        return str;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var countAndSay = function(n) {\\n        var str = '1';\\n        for (var i=1; i < n; i++) {\\n            var strArray = str.split('');\\n            str ='';\\n            var count = 1;\\n            // Loop through current nth level line\\n            for (var j=0; j < strArray.length; j++) {\\n                // Next digit is different\\n                if (strArray[j] !== strArray[j+1]) {\\n                    // Go to next non-matching digit\\n                    str += count + strArray[j];\\n                    count = 1;\\n                }\\n                else {\\n                    count++;\\n                }\\n            }\\n        }\\n        return str;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1239584,
                "title": "c-easy-to-understand-0ms-100-faster",
                "content": "```\\n string countAndSay(int n) \\n    {\\n        if(n == 1)\\n          return \"1\";\\n        if(n == 2)\\n          return \"11\";\\n          \\n        string str = \"11\";\\n        \\n        for(int i = 3; i <= n; i++)\\n         {\\n             str += \\'$\\';\\n             int len = str.length();\\n             \\n             int cnt = 1;\\n             string tmp = \"\";\\n             \\n             for(int j = 1; j < len; j++)\\n              {\\n                  if(str[j] != str[j - 1])\\n                    {\\n                        tmp += cnt + \\'0\\';\\n                        tmp += str[j - 1];\\n                        cnt = 1;\\n                    }\\n                   else\\n                     cnt++;\\n              }\\n            str = tmp;  \\n         }\\n         \\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n string countAndSay(int n) \\n    {\\n        if(n == 1)\\n          return \"1\";\\n        if(n == 2)\\n          return \"11\";\\n          \\n        string str = \"11\";\\n        \\n        for(int i = 3; i <= n; i++)\\n         {\\n             str += \\'$\\';\\n             int len = str.length();\\n             \\n             int cnt = 1;\\n             string tmp = \"\";\\n             \\n             for(int j = 1; j < len; j++)\\n              {\\n                  if(str[j] != str[j - 1])\\n                    {\\n                        tmp += cnt + \\'0\\';\\n                        tmp += str[j - 1];\\n                        cnt = 1;\\n                    }\\n                   else\\n                     cnt++;\\n              }\\n            str = tmp;  \\n         }\\n         \\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16446,
                "title": "c-iterative-solution-with-explanation-easy-to-understand",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe key point here is to find the maximum consecutive identical numbers, which means, for example:\\n\\nSay there is a array like this `[1, 1, 2, 3, 4, 4, 5, 5, 5]`, we will need to divide the array into different segments like this, `[1, 1]`, `[2]`, `[3]`, `[4, 4]`, `[5, 5, 5]`. Only in this way, can we count the occurrence of each consecutive segments and convert them into `\"21 12 13 24 35\"`. \\n\\nThe description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number `n` has nothing to do with the algorithm directly, but but only control the number of iteration.\\n\\nThe problem can be solved by using iterative algorithm.\\n\\n<h2>Code</h2>\\n\\n    string countAndSay(int n)\\n    {\\n        string curr_str;\\n\\n\\t\\t// The initial case, when n = 1\\n\\t\\tcurr_str += '1';\\n\\n\\t\\t// The iterative case, when n > 1\\n\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tstring buffer;\\n\\n\\t\\t\\t// Handle the current string\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (int index = 0; index < curr_str.size(); ++index)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Count the occurance of each digit\\n\\t\\t\\t\\tint cnt = 1; // At least one occurance\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile (index + 1 < curr_str.size() and curr_str[index + 1] == curr_str[index]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffer.push_back(cnt + '0');\\n\\t\\t\\t\\tbuffer.push_back(curr_str[index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update the current string\\n\\t\\t\\tcurr_str = buffer;\\n\\t\\t}\\n\\n\\t\\treturn curr_str;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe key point here is to find the maximum consecutive identical numbers, which means, for example:\\n\\nSay there is a array like this `[1, 1, 2, 3, 4, 4, 5, 5, 5]`, we will need to divide the array into different segments like this, `[1, 1]`, `[2]`, `[3]`, `[4, 4]`, `[5, 5, 5]`. Only in this way, can we count the occurrence of each consecutive segments and convert them into `\"21 12 13 24 35\"`. \\n\\nThe description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number `n` has nothing to do with the algorithm directly, but but only control the number of iteration.\\n\\nThe problem can be solved by using iterative algorithm.\\n\\n<h2>Code</h2>\\n\\n    string countAndSay(int n)\\n    {\\n        string curr_str;\\n\\n\\t\\t// The initial case, when n = 1\\n\\t\\tcurr_str += '1';\\n\\n\\t\\t// The iterative case, when n > 1\\n\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tstring buffer;\\n\\n\\t\\t\\t// Handle the current string\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (int index = 0; index < curr_str.size(); ++index)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Count the occurance of each digit\\n\\t\\t\\t\\tint cnt = 1; // At least one occurance\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile (index + 1 < curr_str.size() and curr_str[index + 1] == curr_str[index]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffer.push_back(cnt + '0');\\n\\t\\t\\t\\tbuffer.push_back(curr_str[index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update the current string\\n\\t\\t\\tcurr_str = buffer;\\n\\t\\t}\\n\\n\\t\\treturn curr_str;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2717257,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0)\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n, string prevs = \"1\") {\\n    if(n==1) return prevs;\\n    int i=0, j, len = prevs.size();\\n    string currs = \"\";\\n    while(i<len) {\\n        j=i;\\n        while(i<len && prevs[i]==prevs[j]) i++;\\n        currs += to_string(i-j) + prevs[j];\\n    }\\n    return countAndSay(n-1, currs);\\n}\\n}; \\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n, string prevs = \"1\") {\\n    if(n==1) return prevs;\\n    int i=0, j, len = prevs.size();\\n    string currs = \"\";\\n    while(i<len) {\\n        j=i;\\n        while(i<len && prevs[i]==prevs[j]) i++;\\n        currs += to_string(i-j) + prevs[j];\\n    }\\n    return countAndSay(n-1, currs);\\n}\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716459,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16413,
                "title": "16-line-clean-recursion-c-solution",
                "content": "    class Solution {\\n    public:\\n        string countAndSay(int n) {\\n            if(n==1) return \"1\"; // base case\\n            string res,tmp = countAndSay(n-1); // recursion\\n            char c= tmp[0];\\n            int count=1;\\n            for(int i=1;i<tmp.size();i++)\\n                if(tmp[i]==c)\\n                    count++;\\n                else {\\n                    res+=to_string(count);\\n                    res.push_back(c);\\n                    c=tmp[i];\\n                    count=1;\\n                }\\n            res+=to_string(count);\\n            res.push_back(c);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string countAndSay(int n) {\\n            if(n==1) return \"1\"; // base case\\n            string res,tmp = countAndSay(n-1); // recursion\\n            char c= tmp[0];\\n            int count=1;\\n            for(int i=1;i<tmp.size();i++)\\n                if(tmp[i]==c)\\n                    count++;\\n                else {\\n                    res+=to_string(count);\\n                    res.push_back(c);\\n                    c=tmp[i];\\n                    count=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2716528,
                "title": "easiest-way-to-solve-this-problem-13-line-of-code-only",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if(n==1):\\n            return(\"1\")\\n        x=self.countAndSay(n-1)\\n        i=0\\n        s=\"\"\\n        while(i<len(x)):\\n            ch=x[i]\\n            ns=0\\n            while(i<len(x) and x[i]==ch):\\n                ns+=1\\n                i+=1\\n            s+=str(ns)\\n            s+=ch\\n        return(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if(n==1):\\n            return(\"1\")\\n        x=self.countAndSay(n-1)\\n        i=0\\n        s=\"\"\\n        while(i<len(x)):\\n            ch=x[i]\\n            ns=0\\n            while(i<len(x) and x[i]==ch):\\n                ns+=1\\n                i+=1\\n            s+=str(ns)\\n            s+=ch\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716511,
                "title": "easy-python-solution-recursive-approach",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1:\\n            return \"1\"\\n        x=self.countAndSay(n-1)\\n        s=\"\"\\n        y=x[0]\\n        ct=1\\n        for i in range(1,len(x)):\\n            if x[i]==y:\\n                ct+=1\\n            else:\\n                s+=str(ct)\\n                s+=str(y)\\n                y=x[i]\\n                ct=1\\n        s+=str(ct)\\n        s+=str(y)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1:\\n            return \"1\"\\n        x=self.countAndSay(n-1)\\n        s=\"\"\\n        y=x[0]\\n        ct=1\\n        for i in range(1,len(x)):\\n            if x[i]==y:\\n                ct+=1\\n            else:\\n                s+=str(ct)\\n                s+=str(y)\\n                y=x[i]\\n                ct=1\\n        s+=str(ct)\\n        s+=str(y)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379255,
                "title": "javascript-regex-solution-with-explainative-comments",
                "content": "```\\nvar countAndSay = function(n) {\\n    let res = \\'1\\';\\n    for (let i = 1; i < n; i++) {\\n\\t\\t// let say at the beginning of the loop we have \\'11222333\\' (two 1s three 2s three 3s)\\n\\t\\t\\n        res = res.replace(/((\\\\d)\\\\2*)/g, \\'$1-\\')                        \\n\\t\\t\\t\\t // after the replacement we have: \\'11-222-333-\\'\\n                 .split(\\'-\\')                                                        \\n\\t\\t\\t\\t // we have: [ \\'11\\', \\'222\\', \\'333\\', \\'\\' ]\\n                 .map(str => str ? `${str.length}${str[0]}` : \\'\\') \\n\\t\\t\\t\\t // [ \\'21\\', \\'32\\', \\'33\\', \\'\\' ]\\n                 .join(\\'\\');                                                       \\n\\t\\t\\t\\t // \\'213232\\' (what we want)\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    let res = \\'1\\';\\n    for (let i = 1; i < n; i++) {\\n\\t\\t// let say at the beginning of the loop we have \\'11222333\\' (two 1s three 2s three 3s)\\n\\t\\t\\n        res = res.replace(/((\\\\d)\\\\2*)/g, \\'$1-\\')                        \\n\\t\\t\\t\\t // after the replacement we have: \\'11-222-333-\\'\\n                 .split(\\'-\\')                                                        \\n\\t\\t\\t\\t // we have: [ \\'11\\', \\'222\\', \\'333\\', \\'\\' ]\\n                 .map(str => str ? `${str.length}${str[0]}` : \\'\\') \\n\\t\\t\\t\\t // [ \\'21\\', \\'32\\', \\'33\\', \\'\\' ]\\n                 .join(\\'\\');                                                       \\n\\t\\t\\t\\t // \\'213232\\' (what we want)\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254369,
                "title": "clean-short-java-solution",
                "content": "```java\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```\\n\\n \\n .\\n .\\n .\\n .\\n \\n \\n\\nWith comments:\\n\\n```java\\n// for the nth number, you just need to count characters of the (n-1)th number,\\n// for the (n-1)th number, you just need to count characters of  the (n-2)th number,\\n// ...\\n\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// recursively call for (n-1) th number, \"0\" is only for the edge case at the end of the loop with `s.charAt(i+1)`\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\t// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```\n```java\\n// for the nth number, you just need to count characters of the (n-1)th number,\\n// for the (n-1)th number, you just need to count characters of  the (n-2)th number,\\n// ...\\n\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// recursively call for (n-1) th number, \"0\" is only for the edge case at the end of the loop with `s.charAt(i+1)`\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\t// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 642001,
                "title": "javascript-100-runtime-super-easy-recursive",
                "content": "```\\nvar countAndSay = function(n) {\\n    if (n === 1) return \\'1\\';\\n    \\n    return countAndSay(n-1)\\n        .match(/1+|2+|3+/g)\\n        .reduce((acc, nums) => acc += `${nums.length}${nums[0]}`, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    if (n === 1) return \\'1\\';\\n    \\n    return countAndSay(n-1)\\n        .match(/1+|2+|3+/g)\\n        .reduce((acc, nums) => acc += `${nums.length}${nums[0]}`, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16113,
                "title": "how-to-proof-the-count-is-always-less-than-10",
                "content": "At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:`curString +=count+'0';`, since it is more than one digit. And I solved it using `itoa`. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ.\\n\\nCan you guys help me proof it?\\nMy code:\\n\\n    class Solution {\\n    public:\\n        string countAndSay(int n) {\\n    \\t\\tstring prevString;\\n    \\t\\tstring curString = \"1\";\\n    \\t\\tfor (int i = 1; i<n; ++i){\\n    \\t\\t\\tprevString = curString;\\n    \\t\\t\\tcurString = \"\";\\n    \\t\\t\\tint count = 1;\\n    \\t\\t\\tchar digit = prevString[0];\\n    \\t\\t\\tfor (int j = 1; j<prevString.length(); ++j){\\n    \\t\\t\\t\\tif (prevString[j] == digit){\\n    \\t\\t\\t\\t\\t++count;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tcurString +=count+'0'; //myItoa(count);\\n    \\t\\t\\t\\t\\tcurString += digit;\\n    \\t\\t\\t\\t\\tdigit = prevString[j];\\n    \\t\\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tcurString += count+'0';//myItoa(count);\\n    \\t\\t\\tcurString += digit;\\n    \\t\\t}\\n    \\t\\treturn curString;\\n        }\\n    /*private:\\n    \\tstring myItoa(int i){\\n    \\t\\tstring str;\\n    \\t\\twhile (i){\\n    \\t\\t\\tstr += i%10+'0';\\n    \\t\\t\\ti /=10;\\n    \\t\\t}\\n    \\t\\treverse(str.begin(), str.end());\\n    \\t\\treturn str;\\n    \\t}*/\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string countAndSay(int n) {\\n    \\t\\tstring prevString;\\n    \\t\\tstring curString = \"1\";\\n    \\t\\tfor (int i = 1; i<n; ++i){\\n    \\t\\t\\tprevString = curString;\\n    \\t\\t\\tcurString = \"\";\\n    \\t\\t\\tint count = 1;\\n    \\t\\t\\tchar digit = prevString[0];\\n    \\t\\t\\tfor (int j = 1; j<prevString.length(); ++j){\\n    \\t\\t\\t\\tif (prevString[j] == digit){\\n    \\t\\t\\t\\t\\t++count;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 172315,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"1\"\\n        prev = \"1\"\\n        res = \"\"\\n        for i in range(1, n):\\n            count = 1\\n            for j in range(len(prev)-1):\\n                if prev[j] == prev[j+1]:\\n                    count += 1\\n                else:\\n                    res += str(count)+prev[j]\\n                    count = 1\\n            res += str(count)+prev[-1]\\n            prev = res\\n            res = \"\"\\n        return prev\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"1\"\\n        prev = \"1\"\\n        res = \"\"\\n        for i in range(1, n):\\n            count = 1\\n            for j in range(len(prev)-1):\\n                if prev[j] == prev[j+1]:\\n                    count += 1\\n                else:\\n                    res += str(count)+prev[j]\\n                    count = 1\\n            res += str(count)+prev[-1]\\n            prev = res\\n            res = \"\"\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716712,
                "title": "java-4-solutions",
                "content": "# 4.regulation\\n```\\n    //4.regulation\\n    //Runtime: 26 ms, faster than 35.45% of Java online submissions for Count and Say.\\n    //Memory Usage: 42.9 MB, less than 44.11% of Java online submissions for Count and Say.\\n    public String countAndSay(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n        Pattern pattern = Pattern.compile(\"(.)\\\\\\\\1*\");\\n        for (int i = 1; i < n; ++i) {\\n            Matcher m = pattern.matcher(currStr);\\n            StringBuilder sb = new StringBuilder();\\n            while (m.find())\\n                sb.append(m.group().length() + String.valueOf(m.group().charAt(0)));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\\n# 3.iteration\\n```\\n    //3.iteration\\n    //Runtime: 9 ms, faster than 56.22% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.3 MB, less than 86.39% of Java online submissions for Count and Say.\\n    public String countAndSay_3(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n\\n        for (int k = 0; k < n - 1; k++) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int i = 1; i < currStr.length(); i++) {\\n                if (currStr.charAt(i) == currStr.charAt(i - 1)) count++;\\n                else{\\n                    sb.append(count).append(currStr.charAt(i - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count).append(currStr.charAt(currStr.length()-1));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\\n# 2.recursion\\n```\\n    //2.recursion\\n    //Runtime: 3 ms, faster than 93.92% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.4 MB, less than 83.82% of Java online submissions for Count and Say.\\n    public String countAndSay_2(int n) {\\n        if (n == 1) return \"1\";\\n        String s = countAndSay_2(n - 1);\\n\\n        //say\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                sb.append(count).append(s.charAt(i - 1));\\n                count = 1;\\n            }\\n        }\\n        sb.append(count).append(s.charAt(s.length() - 1));\\n        return sb.toString();\\n    }\\n```\\n# 1.two helpers\\n```\\n    //1.two helpers\\n    //Runtime: 11 ms, faster than 51.50% of Java online submissions for Count and Say.\\n    //Memory Usage: 46.9 MB, less than 30.84% of Java online submissions for Count and Say.\\n    // Time: O(4^(n/3))\\n    public String countAndSay_1(int n) {\\n        if (n == 1) return \"1\";\\n        String x = \"1\";\\n        for (int i = 0; i < n - 1; i++)\\n            x = helper_say(helper_count(x));\\n        return x;\\n    }\\n\\n    private List<String[]> helper_count(String s){\\n        List<String[]> list = new ArrayList<>();\\n\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                list.add(new String[]{String.valueOf(s.charAt(i - 1)), String.valueOf(count)});\\n                count = 1;\\n            }\\n        }\\n        list.add(new String[]{String.valueOf(s.charAt(s.length() - 1)), String.valueOf(count)});\\n        return list;\\n    }\\n\\n    private String helper_say(List<String[]> list){\\n        StringBuilder sb = new StringBuilder();\\n        for (String[] node: list)\\n            sb.append(node[1]).append(node[0]);\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //4.regulation\\n    //Runtime: 26 ms, faster than 35.45% of Java online submissions for Count and Say.\\n    //Memory Usage: 42.9 MB, less than 44.11% of Java online submissions for Count and Say.\\n    public String countAndSay(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n        Pattern pattern = Pattern.compile(\"(.)\\\\\\\\1*\");\\n        for (int i = 1; i < n; ++i) {\\n            Matcher m = pattern.matcher(currStr);\\n            StringBuilder sb = new StringBuilder();\\n            while (m.find())\\n                sb.append(m.group().length() + String.valueOf(m.group().charAt(0)));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\n```\\n    //3.iteration\\n    //Runtime: 9 ms, faster than 56.22% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.3 MB, less than 86.39% of Java online submissions for Count and Say.\\n    public String countAndSay_3(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n\\n        for (int k = 0; k < n - 1; k++) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int i = 1; i < currStr.length(); i++) {\\n                if (currStr.charAt(i) == currStr.charAt(i - 1)) count++;\\n                else{\\n                    sb.append(count).append(currStr.charAt(i - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count).append(currStr.charAt(currStr.length()-1));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\n```\\n    //2.recursion\\n    //Runtime: 3 ms, faster than 93.92% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.4 MB, less than 83.82% of Java online submissions for Count and Say.\\n    public String countAndSay_2(int n) {\\n        if (n == 1) return \"1\";\\n        String s = countAndSay_2(n - 1);\\n\\n        //say\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                sb.append(count).append(s.charAt(i - 1));\\n                count = 1;\\n            }\\n        }\\n        sb.append(count).append(s.charAt(s.length() - 1));\\n        return sb.toString();\\n    }\\n```\n```\\n    //1.two helpers\\n    //Runtime: 11 ms, faster than 51.50% of Java online submissions for Count and Say.\\n    //Memory Usage: 46.9 MB, less than 30.84% of Java online submissions for Count and Say.\\n    // Time: O(4^(n/3))\\n    public String countAndSay_1(int n) {\\n        if (n == 1) return \"1\";\\n        String x = \"1\";\\n        for (int i = 0; i < n - 1; i++)\\n            x = helper_say(helper_count(x));\\n        return x;\\n    }\\n\\n    private List<String[]> helper_count(String s){\\n        List<String[]> list = new ArrayList<>();\\n\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                list.add(new String[]{String.valueOf(s.charAt(i - 1)), String.valueOf(count)});\\n                count = 1;\\n            }\\n        }\\n        list.add(new String[]{String.valueOf(s.charAt(s.length() - 1)), String.valueOf(count)});\\n        return list;\\n    }\\n\\n    private String helper_say(List<String[]> list){\\n        StringBuilder sb = new StringBuilder();\\n        for (String[] node: list)\\n            sb.append(node[1]).append(node[0]);\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716472,
                "title": "count-and-say-question-explanation-easy-simple-code",
                "content": "If you are not able to crack the question statement, let\\'s understand the pattern through the sequence from n=1 to n=10.\\n```\\n n      val\\n 1.     1                                                  (0 times 1) = 0\\n 2.     11                                                 (1 times 1) = 1\\n 3.     21                                                 (2 times 1) = 2\\n 4.     1211                                                and so on\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.    13211311123113112211\\n```\\nFrom here, we can see that the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nNow let\\'s write the recursive code for this.\\n```\\nstring countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        string s = countAndSay(n - 1);\\n        string ans = \"\";\\n        for(int i = 0; i<s.size(); i++){\\n            int count = 1;\\n            while(i < (s.size() - 1) and (s[i] == s[i + 1])){\\n                i++;\\n                count++;\\n            }\\n            ans.append(to_string(count) + s[i]);\\n        }\\n        return ans;\\n    }\\n```\\nEasy, right?",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n n      val\\n 1.     1                                                  (0 times 1) = 0\\n 2.     11                                                 (1 times 1) = 1\\n 3.     21                                                 (2 times 1) = 2\\n 4.     1211                                                and so on\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.    13211311123113112211\\n```\n```\\nstring countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        string s = countAndSay(n - 1);\\n        string ans = \"\";\\n        for(int i = 0; i<s.size(); i++){\\n            int count = 1;\\n            while(i < (s.size() - 1) and (s[i] == s[i + 1])){\\n                i++;\\n                count++;\\n            }\\n            ans.append(to_string(count) + s[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16354,
                "title": "c-solution-runtime-o-n-space-o-n",
                "content": "Please see the comments in the code. \\nThe solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.\\nWe use string-helper to save temporary result, \\nI'm sure there is a way for in-place solution also.\\n\\n    class Solution {\\n    public:\\n    \\n        std::string countAndSay(int n) {\\n        \\n        \\tif (0 == n) return \"\";  \\n        \\tif (1 == n) return \"1\";\\n        \\t\\n        \\tstd::string res=\"1\";\\n        \\tstd::string s;\\n        \\n        \\tfor (int i = 1; i < n; i++){    // run from starting to generate second string\\n        \\n        \\t\\tint len = res.size();\\n                \\n                //cheack all digits in the string\\n        \\t\\tfor (int j = 0; j < len; j++){  \\n        \\t\\t    \\n        \\t\\t    int count=1; // we have at least 1 occourence of each digit\\n        \\n                    // get the number of times same digit occurred (be carefull with the end of the string)\\n    \\t\\t\\t\\twhile ((j + 1 < len) && (res[j] == res[j + 1])){\\n    \\t\\t\\t\\t\\tcount++;    \\n    \\t\\t\\t\\t\\tj++;        // we need to keep increasing the index inside of the string\\n    \\t\\t\\t\\t}\\n                    \\n                    // add to new string \"count\"+\"digit itself\"\\n        \\t\\t\\ts += std::to_string(count) + res[j];\\n        \\t\\t}\\n        \\n                // save temporary result\\n        \\t\\tres = s;\\n        \\t\\t\\n        \\t\\t// clean our string-helper\\n        \\t\\ts.clear();\\n        \\n        \\t}\\n        \\n        \\treturn res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        std::string countAndSay(int n) {\\n        \\n        \\tif (0 == n) return \"\";  \\n        \\tif (1 == n) return \"1\";\\n        \\t\\n        \\tstd::string res=\"1\";\\n        \\tstd::string s;\\n        \\n        \\tfor (int i = 1; i < n; i++){    // run from starting to generate second string\\n        \\n        \\t\\tint len = res.size();\\n                \\n                //cheack all digits in the string\\n        \\t\\tfor (int j = 0; j < len; j++){  \\n        \\t\\t    \\n        \\t\\t    int count=1; // we have at least 1 occourence of each digit\\n        \\n                    // get the number of times same digit occurred (be carefull with the end of the string)\\n    \\t\\t\\t\\twhile ((j + 1 < len) && (res[j] == res[j + 1])){\\n    \\t\\t\\t\\t\\tcount++;    \\n    \\t\\t\\t\\t\\tj++;        // we need to keep increasing the index inside of the string\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1312932,
                "title": "java-recursive-easy-solution-with-explaination",
                "content": "class Solution {\\n\\n\\t\\tpublic String countAndSay(int n){ \\n\\t\\t\\tif(n == 1) return \"1\";  //if n==1 simply return \"1\"\\n\\t\\t\\t\\n\\t\\t\\tString s = countAndSay(n-1);  // else make recursive calls until n==1\\n\\t\\t\\t\\n\\t\\t\\tStringBuilder str = new StringBuilder(); // create string builder or string buffer object for easy mutations\\n\\t\\t\\t\\n\\t\\t\\tint count = 1 , i = 0; // count of every character is atleast 1 so take count as 1\\n\\t\\t\\t\\n\\t\\t\\twhile(i < s.length()){ // main loop\\n\\t\\t\\t\\n\\t\\t\\t\\tchar ch = s.charAt(i++); // store charcter at i and increment i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i < s.length() && s.charAt(i) == ch){ // create a loop to count the number of adjacent characters in string\\n\\t\\t\\t\\t\\ti++;    count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tstr.append(count).append(ch); // add count and current character to str\\n\\t\\t\\t\\tcount = 1; // reset count to 1\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\treturn str.toString(); // return str as string\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic String countAndSay(int n){ \\n\\t\\t\\tif(n == 1) return \"1\";  //if n==1 simply return \"1\"\\n\\t\\t\\t\\n\\t\\t\\tString s = countAndSay(n-1);  // else make recursive calls until n==1\\n\\t\\t\\t\\n\\t\\t\\tStringBuilder str = new StringBuilder(); // create string builder or string buffer object for easy mutations\\n\\t\\t\\t\\n\\t\\t\\tint count = 1 , i = 0; // count of every character is atleast 1 so take count as 1\\n\\t\\t\\t\\n\\t\\t\\twhile(i < s.length()){ // main loop\\n\\t\\t\\t\\n\\t\\t\\t\\tchar ch = s.charAt(i++); // store charcter at i and increment i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i < s.length() && s.charAt(i) == ch){ // create a loop to count the number of adjacent characters in string\\n\\t\\t\\t\\t\\ti++;    count++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1546382,
                "title": "java-simple-iterative-solution-generating-all-states-from-1-to-n",
                "content": "```java\\n/**\\n * Find each state starting from 1st to nth.\\n * \\n * Time Complexity: O(L(1) + L(2) + L(3) + ... + L(N-1) + L(N))\\n *\\n * Space Complexity: O(L(N-1) + L(N))\\n *\\n * N = Input number. L(N) = Length of Nth state\\n */\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```java\\n/**\\n * Find each state starting from 1st to nth.\\n * \\n * Time Complexity: O(L(1) + L(2) + L(3) + ... + L(N-1) + L(N))\\n *\\n * Space Complexity: O(L(N-1) + L(N))\\n *\\n * N = Input number. L(N) = Length of Nth state\\n */\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565435,
                "title": "easy-to-understand-javascript",
                "content": "Recursive:\\n```\\nconst countAndSay = (n, str = \\'1\\') => {\\n  if (n === 1) {\\n    return str;\\n  }\\n  let newStr = \\'\\',\\n    count = 0,\\n    say = str[0];\\n  for (let i = 0; i < str.length; i += 1) {\\n    if (str[i] === say) {\\n      count += 1;\\n    } else {\\n      newStr += count + say;\\n      count = 1;\\n      say = str[i];\\n    }\\n  }\\n  return countAndSay(n - 1, newStr + count + say);\\n};\\n```\\nIterative:\\n```\\nconst countAndSay = n => {\\n  let str = \\'1\\';\\n  while (n > 1) {\\n    let newStr = \\'\\',\\n      count = 0,\\n      say = str[0];\\n    for (let i = 0; i < str.length; i += 1) {\\n      if (str[i] === say) {\\n        count += 1;\\n      } else {\\n        newStr += count + say;\\n        count = 1;\\n        say = str[i];\\n      }\\n    }\\n    str = newStr + count + say;\\n    n -= 1;\\n  }\\n  return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nconst countAndSay = (n, str = \\'1\\') => {\\n  if (n === 1) {\\n    return str;\\n  }\\n  let newStr = \\'\\',\\n    count = 0,\\n    say = str[0];\\n  for (let i = 0; i < str.length; i += 1) {\\n    if (str[i] === say) {\\n      count += 1;\\n    } else {\\n      newStr += count + say;\\n      count = 1;\\n      say = str[i];\\n    }\\n  }\\n  return countAndSay(n - 1, newStr + count + say);\\n};\\n```\n```\\nconst countAndSay = n => {\\n  let str = \\'1\\';\\n  while (n > 1) {\\n    let newStr = \\'\\',\\n      count = 0,\\n      say = str[0];\\n    for (let i = 0; i < str.length; i += 1) {\\n      if (str[i] === say) {\\n        count += 1;\\n      } else {\\n        newStr += count + say;\\n        count = 1;\\n        say = str[i];\\n      }\\n    }\\n    str = newStr + count + say;\\n    n -= 1;\\n  }\\n  return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406880,
                "title": "super-fast-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\n\\nvar list = {\\n  \"0\": \"1\",\\n  \"1\": \"1\",\\n  \"2\": \"11\",\\n  \"3\": \"21\",\\n  \"4\": \"1211\",\\n  \"5\": \"111221\",\\n  \"6\": \"312211\",\\n  \"7\": \"13112221\",\\n  \"8\": \"1113213211\",\\n  \"9\": \"31131211131221\",\\n  \"10\": \"13211311123113112211\",\\n  \"11\": \"11131221133112132113212221\",\\n  \"12\": \"3113112221232112111312211312113211\",\\n  \"13\": \"1321132132111213122112311311222113111221131221\",\\n  \"14\": \"11131221131211131231121113112221121321132132211331222113112211\",\\n  \"15\": \"311311222113111231131112132112311321322112111312211312111322212311322113212221\",\\n  \"16\": \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\",\\n  \"17\": \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\",\\n  \"18\": \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\",\\n  \"19\": \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\",\\n  \"20\": \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\",\\n  \"21\": \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"22\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"23\": \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"24\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"25\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"26\": \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"27\": \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"28\": \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"29\": \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"30\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n}\\n\\nvar countAndSay = function(n) {\\n  return list[n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\n\\nvar list = {\\n  \"0\": \"1\",\\n  \"1\": \"1\",\\n  \"2\": \"11\",\\n  \"3\": \"21\",\\n  \"4\": \"1211\",\\n  \"5\": \"111221\",\\n  \"6\": \"312211\",\\n  \"7\": \"13112221\",\\n  \"8\": \"1113213211\",\\n  \"9\": \"31131211131221\",\\n  \"10\": \"13211311123113112211\",\\n  \"11\": \"11131221133112132113212221\",\\n  \"12\": \"3113112221232112111312211312113211\",\\n  \"13\": \"1321132132111213122112311311222113111221131221\",\\n  \"14\": \"11131221131211131231121113112221121321132132211331222113112211\",\\n  \"15\": \"311311222113111231131112132112311321322112111312211312111322212311322113212221\",\\n  \"16\": \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\",\\n  \"17\": \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\",\\n  \"18\": \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\",\\n  \"19\": \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\",\\n  \"20\": \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\",\\n  \"21\": \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"22\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"23\": \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"24\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"25\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"26\": \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"27\": \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"28\": \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"29\": \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"30\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n}\\n\\nvar countAndSay = function(n) {\\n  return list[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716238,
                "title": "java-100-0ms-4-different-solutions-w-video-explanation",
                "content": "*Please **Upvote** if you find the Explanation helpful*\\n\\n**Video Explanation**\\n[Count and Say | YouTube](https://www.youtube.com/watch?v=7ZvswJFUl5M&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//3ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n        for(int i=2;i<=n;i++){\\n            s = countIndex(s);\\n        }\\n        return s;\\n    }\\n    \\n    public String countIndex(String s){\\n        StringBuilder sb = new StringBuilder();\\n        char c = s.charAt(0);\\n        int count = 1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i) == c)\\n                count++;\\n            else{\\n                sb.append(count);\\n                sb.append(c);\\n                c = s.charAt(i);\\n                count=1;\\n            }\\n        }\\n        sb.append(count);\\n        sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n*Using Recursion*\\n```\\n//2ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String s = countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'!\\';\\n        int num = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                if(num>0){\\n                    sb.append(num);\\n                    sb.append(ch);\\n                }        \\n                num = 0;\\n                ch = s.charAt(i);\\n            }\\n            num++;\\n            i++;\\n        }\\n        sb.append(num);\\n        sb.append(ch);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n*Using HashMap*\\n```\\n//1ms\\nclass Solution {\\n     private static final Map<Integer, String> resultsCache = new HashMap<>();\\n\\n        public String countAndSay(int n) {\\n            if(resultsCache.containsKey(n)) {\\n                return resultsCache.get(n);\\n            }\\n\\n            if (n == 1) {\\n                return \"1\";\\n            }\\n\\n            String result = say(countAndSay(n - 1));\\n            resultsCache.put(n, result);\\n            return  result;\\n        }\\n\\n        private String say(String number) {\\n            int currentIndex = 0;\\n            StringBuilder result = new StringBuilder();\\n            while (currentIndex <= number.length() - 1) {\\n                int nextIndex = findNextDifferentIndex(number, currentIndex);\\n\\n                result.append(nextIndex - currentIndex);\\n                result.append(number.charAt(currentIndex));\\n\\n                currentIndex = nextIndex;\\n            }\\n\\n            return result.toString();\\n        }\\n\\n        private int findNextDifferentIndex(String number, int index) {\\n            char currentDigit = number.charAt(index);\\n            int currentIndex = index;\\n            while (currentIndex <= number.length() -1) {\\n                currentIndex = currentIndex + 1;\\n                if (currentIndex == number.length() || currentDigit != number.charAt(currentIndex)) {\\n                    return currentIndex;\\n                }\\n            }\\n\\n            return number.length() - 1;\\n        }\\n}\\n```\\n\\n\\n*Kind of the worst approach*\\n```\\n//0ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//3ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n        for(int i=2;i<=n;i++){\\n            s = countIndex(s);\\n        }\\n        return s;\\n    }\\n    \\n    public String countIndex(String s){\\n        StringBuilder sb = new StringBuilder();\\n        char c = s.charAt(0);\\n        int count = 1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i) == c)\\n                count++;\\n            else{\\n                sb.append(count);\\n                sb.append(c);\\n                c = s.charAt(i);\\n                count=1;\\n            }\\n        }\\n        sb.append(count);\\n        sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n//2ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String s = countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'!\\';\\n        int num = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                if(num>0){\\n                    sb.append(num);\\n                    sb.append(ch);\\n                }        \\n                num = 0;\\n                ch = s.charAt(i);\\n            }\\n            num++;\\n            i++;\\n        }\\n        sb.append(num);\\n        sb.append(ch);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n//1ms\\nclass Solution {\\n     private static final Map<Integer, String> resultsCache = new HashMap<>();\\n\\n        public String countAndSay(int n) {\\n            if(resultsCache.containsKey(n)) {\\n                return resultsCache.get(n);\\n            }\\n\\n            if (n == 1) {\\n                return \"1\";\\n            }\\n\\n            String result = say(countAndSay(n - 1));\\n            resultsCache.put(n, result);\\n            return  result;\\n        }\\n\\n        private String say(String number) {\\n            int currentIndex = 0;\\n            StringBuilder result = new StringBuilder();\\n            while (currentIndex <= number.length() - 1) {\\n                int nextIndex = findNextDifferentIndex(number, currentIndex);\\n\\n                result.append(nextIndex - currentIndex);\\n                result.append(number.charAt(currentIndex));\\n\\n                currentIndex = nextIndex;\\n            }\\n\\n            return result.toString();\\n        }\\n\\n        private int findNextDifferentIndex(String number, int index) {\\n            char currentDigit = number.charAt(index);\\n            int currentIndex = index;\\n            while (currentIndex <= number.length() -1) {\\n                currentIndex = currentIndex + 1;\\n                if (currentIndex == number.length() || currentDigit != number.charAt(currentIndex)) {\\n                    return currentIndex;\\n                }\\n            }\\n\\n            return number.length() - 1;\\n        }\\n}\\n```\n```\\n//0ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716132,
                "title": "java-0ms-solution",
                "content": "# Upote if you like the solution\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```\\n\\n\\n# IF THE SOLUTION WORKED FOR YOU PLEASE UPVOTE IT............",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905788,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        func helper(_ s: String, _ n: Int) -> String {\\n            guard n > 1 else { return s }\\n            var string = \"\"\\n            var prev: Character?\\n            var count: Int = 1\\n\\n            for c in s {\\n                if let prev = prev {\\n                    if c == prev {\\n                        count += 1\\n                    } else {\\n                        string += \"\\\\(count)\\\\(prev)\"\\n                        count = 1\\n                    }\\n                }\\n                prev = c\\n            }\\n            string += \"\\\\(count)\\\\(prev!)\"\\n            return helper(string, n - 1)\\n        }\\n\\n        return helper(\"1\", n)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        func helper(_ s: String, _ n: Int) -> String {\\n            guard n > 1 else { return s }\\n            var string = \"\"\\n            var prev: Character?\\n            var count: Int = 1\\n\\n            for c in s {\\n                if let prev = prev {\\n                    if c == prev {\\n                        count += 1\\n                    } else {\\n                        string += \"\\\\(count)\\\\(prev)\"\\n                        count = 1\\n                    }\\n                }\\n                prev = c\\n            }\\n            string += \"\\\\(count)\\\\(prev!)\"\\n            return helper(string, n - 1)\\n        }\\n\\n        return helper(\"1\", n)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367155,
                "title": "c-simple-clean-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string res = \"1\", tmp;\\n        n--;\\n        \\n        while (n) {\\n            tmp = \"\";\\n            \\n\\t\\t\\t// Count the number of contiguous same character in previous string to build current string\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                \\n                while (i + 1 < res.size() && res[i] == res[i+1]) {\\n                    count++; i++;\\n                }\\n                \\n                tmp += to_string(count) + res[i];\\n            }\\n            \\n            res = tmp;\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string res = \"1\", tmp;\\n        n--;\\n        \\n        while (n) {\\n            tmp = \"\";\\n            \\n\\t\\t\\t// Count the number of contiguous same character in previous string to build current string\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                \\n                while (i + 1 < res.size() && res[i] == res[i+1]) {\\n                    count++; i++;\\n                }\\n                \\n                tmp += to_string(count) + res[i];\\n            }\\n            \\n            res = tmp;\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16184,
                "title": "java-easy-to-read-also-fast",
                "content": "    public String countAndSay(int n) {\\n        String ret = \"\"+1;\\n        \\n        while(--n  > 0)\\n            ret = apply(ret);\\n        \\n        return ret;\\n    }\\n    \\n    String apply(String s){\\n        StringBuilder ret = new StringBuilder();\\n        \\n        for(int i = 0, count =0; i  < s.length() ; ){\\n            while(i + count < s.length() && s.charAt(i) == s.charAt(i + count))\\n                count ++;\\n                    \\n            ret.append(count).append(s.charAt(i));\\n            i += count; \\n            count = 0;\\n        }\\n        \\n        return ret.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String countAndSay(int n) {\\n        String ret = \"\"+1;\\n        \\n        while(--n  > 0)\\n            ret = apply(ret);\\n        \\n        return ret;\\n    }\\n    \\n    String apply(String s){\\n        StringBuilder ret = new StringBuilder();\\n        \\n        for(int i = 0, count =0; i  < s.length() ; ){\\n            while(i + count < s.length() && s.charAt(i) == s.charAt(i + count))\\n                count ++;\\n                    \\n            ret.append(count).append(s.charAt(i));\\n            i += count; \\n            count = 0;\\n        }\\n        \\n        return ret.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3780964,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n+k)$$ where k is the variable length of the strings formed.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1)\\n        {\\n            return \"1\";\\n        }\\n        if(n==2)\\n        {\\n            return \"11\";\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        nm.append(\"11\");\\n        for(int i=3;i<=n;i++)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            task(nm.toString(),kk);\\n            nm.setLength(0);\\n            nm.append(kk);\\n        }\\n        return nm.toString();\\n    }\\n    public void task(String s, StringBuilder nm)\\n    {\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i) == s.charAt(i+1))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                nm.append(count);\\n                nm.append(s.charAt(i));\\n                count=1;\\n            }\\n        }\\n        nm.append(count);\\n        nm.append(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1)\\n        {\\n            return \"1\";\\n        }\\n        if(n==2)\\n        {\\n            return \"11\";\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        nm.append(\"11\");\\n        for(int i=3;i<=n;i++)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            task(nm.toString(),kk);\\n            nm.setLength(0);\\n            nm.append(kk);\\n        }\\n        return nm.toString();\\n    }\\n    public void task(String s, StringBuilder nm)\\n    {\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i) == s.charAt(i+1))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                nm.append(count);\\n                nm.append(s.charAt(i));\\n                count=1;\\n            }\\n        }\\n        nm.append(count);\\n        nm.append(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654250,
                "title": "easy-c-solution-faster-than-80",
                "content": "```class Solution {\\npublic:\\n    string say(string s){\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++){\\n            int count = 1;\\n            while(i+1 < s.size() && s[i] == s[i+1]){\\n                i++;\\n                count++;\\n            }\\n            ans+=(to_string(count)+s[i]);\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        return say(countAndSay(n-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic:\\n    string say(string s){\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++){\\n            int count = 1;\\n            while(i+1 < s.size() && s[i] == s[i+1]){\\n                i++;\\n                count++;\\n            }\\n            ans+=(to_string(count)+s[i]);\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        return say(countAndSay(n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725764,
                "title": "c-naive-approach-easy-to-understand",
                "content": "***Runtime: 4 ms, faster than 86.31% of C++ online submissions for Count and Say.\\nMemory Usage: 6.1 MB, less than 98.62% of C++ online submissions for Count and Say.***\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string result = \"1\",current;\\n        while(--n){\\n            current = \"\";\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;\\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;\\n                }\\n                current +=  to_string(count) + result[i] ;\\n            }\\n            result = current;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string result = \"1\",current;\\n        while(--n){\\n            current = \"\";\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;\\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;\\n                }\\n                current +=  to_string(count) + result[i] ;\\n            }\\n            result = current;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462775,
                "title": "python-4-lines-recursive-beat-99",
                "content": "Use groupby to group the output string, then replace the output with the count-and-say logic (numbers of instances followed by the key).\\n\\n```\\nfrom itertools import groupby\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        for i in range(n-1):\\n            output = \\'\\'.join([str(len(list(g))) + k for k, g in groupby(output)])\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import groupby\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        for i in range(n-1):\\n            output = \\'\\'.join([str(len(list(g))) + k for k, g in groupby(output)])\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16359,
                "title": "the-fastest-js-solution-116ms",
                "content": "    var countAndSay = function(n) {\\n      var start = '1';\\n      var result = '';\\n      var tmp = 1;\\n      for (i=0; i<n-1; i++){\\n        //tmp will count all repeats\\n        for (var j=0; j<start.length; j++){\\n          if(start[j] !== start[j+1] || j == start.length - 1){\\n            result += tmp + start[j];\\n            tmp = 1;\\n          } else {\\n            tmp +=1;\\n          }\\n        }\\n        start = result;\\n        result = '';\\n      }\\n      return start;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var countAndSay = function(n) {\\n      var start = '1';\\n      var result = '';\\n      var tmp = 1;\\n      for (i=0; i<n-1; i++){\\n        //tmp will count all repeats\\n        for (var j=0; j<start.length; j++){\\n          if(start[j] !== start[j+1] || j == start.length - 1){\\n            result += tmp + start[j];\\n            tmp = 1;\\n          } else {\\n            tmp +=1;\\n          }\\n        }\\n        start = result;\\n        result = '';\\n      }\\n      return start;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3749690,
                "title": "explanation-of-question-with-example-and-proper-explanation-of-code",
                "content": "# Explanation of question\\nn==1 --> 1(base case) --> one(count) 1 so next  will be 1 1\\nn==2 --> 1 1 --> two(count) 1\\'s--> 2 1\\nn==3 --> 2 1 --> one(count) 2 one(count) --->1 2 1 1\\nn==4 --> 1 2 1 1\\nwe are given n,we have to give the corresponding sequence(string).\\nHere count is contiguous occrenece i.e. if there 1 1 2 1 then there two contigous 1, one 2 and one 1. \\n\\n# Approach\\n- We will start the recursion with base case i.e. we pass string=\"1\" in the recusrsive function(solve).\\n- Then in the string we will count the number of contiguous occurences and convert that count into string and append it to the string ans along with the character whose occurences we counted.\\n- Then traverse for the contiguous count of other character until the end of string. \\n- Then we will pass the resulting string i.e. ans(containing the sequence) to the next recursive call and will perform the above operations again on this string in next recursion call until we encounter the base case. \\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\nRecursive O(N) calls * for loop counting the contiguous occurences O(N).\\n\\n- Space complexity:\\nO(N)-Recursive stack (Auxilary space).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string solve(string s,int n)\\n    {\\n        if(n==1)//base case\\n        {\\n            return s;\\n        }\\n        //count contiguous occurences of characters\\n        int freq=1;\\n        char ch=s[0];\\n        string ans=\"\";\\n        s+=\"#\";//append because occurence of last element is pushed in else statement\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                //freq+1 till same character is coming\\n                freq++;\\n            }\\n            else\\n            {\\n                //different character encountered\\n                // push the occurence of last character along with last character\\n                ans+=to_string(freq)+ch;\\n                freq=1;//restart the count to count the other character\\n                ch=s[i];\\n            }\\n        }\\n        return solve(ans,n-1);//recursive call\\n    }\\n    string countAndSay(int n) {\\n        return solve(\"1\",n);//start sequence with base case\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(string s,int n)\\n    {\\n        if(n==1)//base case\\n        {\\n            return s;\\n        }\\n        //count contiguous occurences of characters\\n        int freq=1;\\n        char ch=s[0];\\n        string ans=\"\";\\n        s+=\"#\";//append because occurence of last element is pushed in else statement\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                //freq+1 till same character is coming\\n                freq++;\\n            }\\n            else\\n            {\\n                //different character encountered\\n                // push the occurence of last character along with last character\\n                ans+=to_string(freq)+ch;\\n                freq=1;//restart the count to count the other character\\n                ch=s[i];\\n            }\\n        }\\n        return solve(ans,n-1);//recursive call\\n    }\\n    string countAndSay(int n) {\\n        return solve(\"1\",n);//start sequence with base case\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717433,
                "title": "python-elegant-short-recursive-iterative",
                "content": "## Recursive version:\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.make_count(self.countAndSay(n - 1))\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\\n\\n## Iterative version:\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        string = \\'1\\'\\n        \\n        for _ in range(n - 1):\\n            string = self.make_count(string)\\n\\n        return string\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.make_count(self.countAndSay(n - 1))\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        string = \\'1\\'\\n        \\n        for _ in range(n - 1):\\n            string = self.make_count(string)\\n\\n        return string\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668741,
                "title": "python-99-faster-not-recursive",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        \\n        for i in range(2, n+1):\\n            res = \\'\\'\\n            cur = output[0]\\n            count = 1\\n            for x in output[1:]:\\n                if x == cur:\\n                    count += 1\\n                else:\\n                    res += str(count) + cur\\n                    count = 1\\n                    cur = x\\n                \\n            res += str(count) + cur\\n            output = \\'\\'.join(res)\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        \\n        for i in range(2, n+1):\\n            res = \\'\\'\\n            cur = output[0]\\n            count = 1\\n            for x in output[1:]:\\n                if x == cur:\\n                    count += 1\\n                else:\\n                    res += str(count) + cur\\n                    count = 1\\n                    cur = x\\n                \\n            res += str(count) + cur\\n            output = \\'\\'.join(res)\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235906,
                "title": "simple-javascript-and-regex",
                "content": "**Javascript**\\n\\nNot the fastest, but a pretty short solution.\\n\\n```\\nvar countAndSay = function(n) {\\n  for (z = 0, returnString = \"1\"; z < n - 1; z++) {\\n    returnString = returnString.match(/(.)\\\\1*/g).reduce((acc, val) => acc + `${val.length}${val[0]}`, \"\");\\n  }\\n  return returnString;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar countAndSay = function(n) {\\n  for (z = 0, returnString = \"1\"; z < n - 1; z++) {\\n    returnString = returnString.match(/(.)\\\\1*/g).reduce((acc, val) => acc + `${val.length}${val[0]}`, \"\");\\n  }\\n  return returnString;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16342,
                "title": "simple-java-recursion-with-no-extra-function",
                "content": "Since the function itself accepting an integer and return a String, internally we can call this function with n-1 recursively. Therefore, no extra function is required. Also we just need to keep a counter to track how many times a character appears without adding a variable to track 'previous char'\\n\\n    public String countAndSay(int n) {\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n\\n        String prevStr = countAndSay(n - 1);\\n\\n        StringBuffer sb = new StringBuffer();\\n\\n        int count = 0;\\n        int ptr = 0;\\n        while (ptr < prevStr.length()) {\\n            count++;\\n\\n            char curChar = prevStr.charAt(ptr);\\n            if (ptr + 1 >= prevStr.length() || curChar != prevStr.charAt(ptr + 1)) {\\n                sb.append(count).append(curChar);\\n\\n                count = 0;\\n            }\\n\\n            ptr++;\\n        }\\n\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Since the function itself accepting an integer and return a String, internally we can call this function with n-1 recursively. Therefore, no extra function is required. Also we just need to keep a counter to track how many times a character appears without adding a variable to track 'previous char'\\n\\n    public String countAndSay(int n) {\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n\\n        String prevStr = countAndSay(n - 1);\\n\\n        StringBuffer sb = new StringBuffer();\\n\\n        int count = 0;\\n        int ptr = 0;\\n        while (ptr < prevStr.length()) {\\n            count++;\\n\\n            char curChar = prevStr.charAt(ptr);\\n            if (ptr + 1 >= prevStr.length() || curChar != prevStr.charAt(ptr + 1)) {\\n                sb.append(count).append(curChar);\\n\\n                count = 0;\\n            }\\n\\n            ptr++;\\n        }\\n\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3409791,
                "title": "easy-code-java-solution",
                "content": "Please **UPVOTE** if you like my solution!\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String st = \"11\";\\n        int j = 0;\\n        for(int i = 0;i<n-2;i++){\\n            int count = 1;\\n            String s = \"\";\\n            for( j = 0;j<st.length()-1;j++){\\n                if(st.charAt(j) == st.charAt(j+1)){\\n                    count++;\\n                }\\n                else{\\n                    s += Integer.toString(count);\\n                    s += st.charAt(j);\\n                    count = 1;\\n                }\\n            }\\n            s += Integer.toString(count);\\n            s += st.charAt(j);\\n            st = s;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String st = \"11\";\\n        int j = 0;\\n        for(int i = 0;i<n-2;i++){\\n            int count = 1;\\n            String s = \"\";\\n            for( j = 0;j<st.length()-1;j++){\\n                if(st.charAt(j) == st.charAt(j+1)){\\n                    count++;\\n                }\\n                else{\\n                    s += Integer.toString(count);\\n                    s += st.charAt(j);\\n                    count = 1;\\n                }\\n            }\\n            s += Integer.toString(count);\\n            s += st.charAt(j);\\n            st = s;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259802,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        # Initial condition for output\\n        output = \\'1\\'\\n        \\n        while n > 1:\\n            # Use two pointers to count identical elements in the string\\n            # Start from first element in the string\\n            i = j = 0\\n\\t\\t\\t\\n            # Make copy of output string\\n            temp_str = output\\n\\t\\t\\t\\n            # Restart output string\\n            output = \\'\\'\\n\\t\\t\\t\\n            # While end sequence pointer (j) is less than length of the string\\n            while j < len(temp_str):\\n\\t\\t\\t\\n                # If elements are the same at start (i) and end (j) of sequence\\n                if temp_str[i] == temp_str[j]:\\n\\t\\t\\t\\t\\n                    # We increment j\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\n                    # If elements are different we count how many elements are between i and j and add it to the output string\\n                    # Sequence is [\\'count\\' + \\'element\\'] : example: \\'21\\',  count = 1, element = \\'2\\' and count = 1, element = \\'1\\',  makes it 1211\\n                    output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\t\\t\\n                    # Restart the sequence \\n                    i = j\\n\\t\\t\\t\\t\\t\\n            # Once we reach the end of the list we add the count and element to the output string\\n            output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\n\\t\\t\\t# The output string will go back to the top of the loop if n > 1 and then script will run again with new output string\\n            n -= 1\\n\\n        return output\\n```\\nTime complexity is O(n2^n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        # Initial condition for output\\n        output = \\'1\\'\\n        \\n        while n > 1:\\n            # Use two pointers to count identical elements in the string\\n            # Start from first element in the string\\n            i = j = 0\\n\\t\\t\\t\\n            # Make copy of output string\\n            temp_str = output\\n\\t\\t\\t\\n            # Restart output string\\n            output = \\'\\'\\n\\t\\t\\t\\n            # While end sequence pointer (j) is less than length of the string\\n            while j < len(temp_str):\\n\\t\\t\\t\\n                # If elements are the same at start (i) and end (j) of sequence\\n                if temp_str[i] == temp_str[j]:\\n\\t\\t\\t\\t\\n                    # We increment j\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\n                    # If elements are different we count how many elements are between i and j and add it to the output string\\n                    # Sequence is [\\'count\\' + \\'element\\'] : example: \\'21\\',  count = 1, element = \\'2\\' and count = 1, element = \\'1\\',  makes it 1211\\n                    output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\t\\t\\n                    # Restart the sequence \\n                    i = j\\n\\t\\t\\t\\t\\t\\n            # Once we reach the end of the list we add the count and element to the output string\\n            output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\n\\t\\t\\t# The output string will go back to the top of the loop if n > 1 and then script will run again with new output string\\n            n -= 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916951,
                "title": "short",
                "content": "```\\nstring countAndSay(int n) \\n{\\n\\tif(n==1) return \"1\";\\n\\tauto s = countAndSay(n-1) + \\' \\';\\n\\tstring out;\\n\\tfor(auto i{0}, j{0}; i<size(s); ++i)\\n\\t\\tif(s[i]!=s[j]) out += to_string(i-j)+s[i-1], j=i;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring countAndSay(int n) \\n{\\n\\tif(n==1) return \"1\";\\n\\tauto s = countAndSay(n-1) + \\' \\';\\n\\tstring out;\\n\\tfor(auto i{0}, j{0}; i<size(s); ++i)\\n\\t\\tif(s[i]!=s[j]) out += to_string(i-j)+s[i-1], j=i;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422076,
                "title": "go-solution-using-string-builder-0ms-beats-100-speed-memory",
                "content": "Go strings are immutable, so whenever we attempt to update a string within a loop we are actually creating a new string on every iteration.\\nFor this problem we only require to _append_/_write_ to the string while we are working with it, so there\\'s a helper from the Go standard library that comes handy: `strings.Builder`. \\nYou can take a look at its code at https://golang.org/src/strings/builder.go\\n\\n```go\\nimport (\\n    \"strconv\"\\n    \"strings\"\\n)\\n\\nfunc countAndSay(n int) string {\\n    seq := \"\"\\n    for i:=0; i<n; i++ {\\n        seq = countAndSayHelper(seq)\\n    }\\n    return seq\\n}\\n\\nfunc countAndSayHelper(prev string) string {\\n    if prev == \"\" {\\n        return \"1\"\\n    }\\n    var result strings.Builder\\n    count := 1\\n    for i:=1; i < len(prev); i++ {\\n        if prev[i] == prev[i-1] {\\n            count++\\n        } else {\\n            result.WriteString(strconv.Itoa(count)) \\n            result.WriteByte(prev[i-1])\\n            count = 1\\n        }\\n    }\\n    result.WriteString(strconv.Itoa(count)) \\n    result.WriteByte(prev[len(prev)-1])\\n    return result.String()\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```go\\nimport (\\n    \"strconv\"\\n    \"strings\"\\n)\\n\\nfunc countAndSay(n int) string {\\n    seq := \"\"\\n    for i:=0; i<n; i++ {\\n        seq = countAndSayHelper(seq)\\n    }\\n    return seq\\n}\\n\\nfunc countAndSayHelper(prev string) string {\\n    if prev == \"\" {\\n        return \"1\"\\n    }\\n    var result strings.Builder\\n    count := 1\\n    for i:=1; i < len(prev); i++ {\\n        if prev[i] == prev[i-1] {\\n            count++\\n        } else {\\n            result.WriteString(strconv.Itoa(count)) \\n            result.WriteByte(prev[i-1])\\n            count = 1\\n        }\\n    }\\n    result.WriteString(strconv.Itoa(count)) \\n    result.WriteByte(prev[len(prev)-1])\\n    return result.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 233913,
                "title": "java-solution-beats-96-70",
                "content": "```\\npublic String countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        \\n        String value = countAndSay(n - 1);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < value.length(); i++) {\\n            int count = 1;\\n            while(i < value.length() - 1 && value.charAt(i) == value.charAt(i + 1)) {\\n                count++;\\n                i++;\\n            }\\n            sb.append(count);\\n            sb.append(value.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        \\n        String value = countAndSay(n - 1);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < value.length(); i++) {\\n            int count = 1;\\n            while(i < value.length() - 1 && value.charAt(i) == value.charAt(i + 1)) {\\n                count++;\\n                i++;\\n            }\\n            sb.append(count);\\n            sb.append(value.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16019,
                "title": "easy-readable-6ms-recursive-code",
                "content": "The current result are always read and count the previous result, so...\\n\\n----------\\n\\n\\n\\t    string res, tmp;\\n    \\tif (n == 1)  return \"1\";\\n    \\twhile (n>0){\\n    \\t\\tint count = 1;\\n    \\t\\tres = countAndSay(--n);\\n    \\t\\ttmp = \"\";\\n    \\t\\tfor (int i = 0; i<res.size(); i++){\\n    \\t\\t\\tif (res[i] == res[i + 1])\\tcount++;\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\ttmp += to_string(count) + res[i];\\n    \\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn tmp;\\n    \\t}\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "The current result are always read and count the previous result, so...\\n\\n----------\\n\\n\\n\\t    string res, tmp;\\n    \\tif (n == 1)  return \"1\";\\n    \\twhile (n>0){\\n    \\t\\tint count = 1;\\n    \\t\\tres = countAndSay(--n);\\n    \\t\\ttmp = \"\";\\n    \\t\\tfor (int i = 0; i<res.size(); i++){\\n    \\t\\t\\tif (res[i] == res[i + 1])\\tcount++;\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\ttmp += to_string(count) + res[i];\\n    \\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn tmp;\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3412863,
                "title": "java-recursion-good-to-go",
                "content": "![photo_2023-04-13_18-38-05.jpg](https://assets.leetcode.com/users/images/f569c4b0-aaf7-4aa2-8efc-fce17ed7a43d_1681391306.9197733.jpeg)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) call stack space and a string builder is used\\n\\n# Code\\n```\\nclass Solution {\\n    int counter; \\n    public String countAndSay(int n) {\\n        if(n==1) return \"1\" ;\\n        String s= countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n        counter ++;\\n        if(i==s.length()-1 ||s.charAt(i)!=s.charAt(i+1)){\\n            sb.append(counter).append(s.charAt(i));\\n            counter=0;\\n        }\\n        }\\n    return sb.toString();    \\n    }\\n}\\n\\n![471ac8c9-5c1b-4052-a76c-b8019c47bb11_1679937665.6666765.png](https://assets.leetcode.com/users/images/55b6e259-0aa1-43f8-b07c-1fa12cf13b01_1681391180.1980383.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int counter; \\n    public String countAndSay(int n) {\\n        if(n==1) return \"1\" ;\\n        String s= countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n        counter ++;\\n        if(i==s.length()-1 ||s.charAt(i)!=s.charAt(i+1)){\\n            sb.append(counter).append(s.charAt(i));\\n            counter=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2718001,
                "title": "python-rust-c-smart-concise-solution-using-separators-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Comment.** There are many somewhat similar solutions to this problem here on LeetCode. For the sake of diversity, I provide a different solution using separators. Given that the maximal size of the problem is *n=30*, it turns out that the **run-time** is not bad at all, while the **write-time** (and ease of perception) is awesome. \\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/825127932/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **37 ms runtime (99.10%)** and used **14.1 MB memory (16.06%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        # [1] only 3 repetitiotns of any digit is possible, thus,\\n        #     we can list all possible boundaries between blocks\\n        sep = { \"12\" : \"1|2\", \"21\" : \"2|1\", \"13\" : \"1|3\", \\n                \"31\" : \"3|1\", \"23\" : \"2|3\", \"32\" : \"3|2\"}\\n        \\n        say = \"1\"\\n        \\n        # [2] at each iteration:\\n        #     - first, place separators between blocks\\n        #     - second, split using separators and build new saying\\n        for _ in range(n-1):\\n            for w, r in sep.items(): say = say.replace(w, r)\\n            say = \"\".join([f\"{len(b)}{b[0]}\" for b in say.split(\"|\")])\\n            \\n        return say\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/825130109/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **2 ms runtime (72.92%)** and used **2.3 MB memory (20.83%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nimpl Solution \\n{\\n    pub fn count_and_say(n: i32) -> String \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        let sep = [(\"12\", \"1|2\"), (\"21\", \"2|1\"), (\"13\", \"1|3\"),\\n                   (\"31\", \"3|1\"), (\"23\", \"2|3\"), (\"32\", \"3|2\")];\\n        \\n        let mut say = String::from(\"1\");\\n        \\n        // [2] at each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for _ in 0..n-1\\n        {\\n            say = sep.iter()\\n                     .fold(say, |s, &r| s.replace(r.0, r.1));\\n\\n            say = say.split(\"|\")\\n                     .map(|s| format!(\"{}{}\", s.len(), s.chars().nth(0).unwrap()))\\n                     .fold(String::with_capacity(4500), |s, add| s + &add);\\n        }\\n\\n        return say;\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/825141001/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **108 ms runtime (14.61%)** and used **30.2 MB memory (21.61%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nclass Solution \\n{\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        map<string,string> sep = {{\"12\", \"1|2\"}, {\"21\", \"2|1\"}, {\"13\", \"1|3\"},\\n                                  {\"31\", \"3|1\"}, {\"23\", \"2|3\"}, {\"32\", \"3|2\"}};\\n        \\n        string say = \"1\";\\n        string block;\\n        \\n        // [2] on each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for (int i = 0; i < n-1; ++i)\\n        {\\n            for(auto [src, dst]: sep) \\n                say = regex_replace(say, regex(src), dst);\\n            \\n            istringstream ss(say);\\n            string new_say = \"\";\\n            new_say.reserve(4500);\\n            while(getline(ss, block, \\'|\\')) \\n                new_say += to_string(block.size()) + block[0];\\n            say = new_say;\\n        }\\n        \\n        return say;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        # [1] only 3 repetitiotns of any digit is possible, thus,\\n        #     we can list all possible boundaries between blocks\\n        sep = { \"12\" : \"1|2\", \"21\" : \"2|1\", \"13\" : \"1|3\", \\n                \"31\" : \"3|1\", \"23\" : \"2|3\", \"32\" : \"3|2\"}\\n        \\n        say = \"1\"\\n        \\n        # [2] at each iteration:\\n        #     - first, place separators between blocks\\n        #     - second, split using separators and build new saying\\n        for _ in range(n-1):\\n            for w, r in sep.items(): say = say.replace(w, r)\\n            say = \"\".join([f\"{len(b)}{b[0]}\" for b in say.split(\"|\")])\\n            \\n        return say\\n```\n```\\nimpl Solution \\n{\\n    pub fn count_and_say(n: i32) -> String \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        let sep = [(\"12\", \"1|2\"), (\"21\", \"2|1\"), (\"13\", \"1|3\"),\\n                   (\"31\", \"3|1\"), (\"23\", \"2|3\"), (\"32\", \"3|2\")];\\n        \\n        let mut say = String::from(\"1\");\\n        \\n        // [2] at each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for _ in 0..n-1\\n        {\\n            say = sep.iter()\\n                     .fold(say, |s, &r| s.replace(r.0, r.1));\\n\\n            say = say.split(\"|\")\\n                     .map(|s| format!(\"{}{}\", s.len(), s.chars().nth(0).unwrap()))\\n                     .fold(String::with_capacity(4500), |s, add| s + &add);\\n        }\\n\\n        return say;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        map<string,string> sep = {{\"12\", \"1|2\"}, {\"21\", \"2|1\"}, {\"13\", \"1|3\"},\\n                                  {\"31\", \"3|1\"}, {\"23\", \"2|3\"}, {\"32\", \"3|2\"}};\\n        \\n        string say = \"1\";\\n        string block;\\n        \\n        // [2] on each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for (int i = 0; i < n-1; ++i)\\n        {\\n            for(auto [src, dst]: sep) \\n                say = regex_replace(say, regex(src), dst);\\n            \\n            istringstream ss(say);\\n            string new_say = \"\";\\n            new_say.reserve(4500);\\n            while(getline(ss, block, \\'|\\')) \\n                new_say += to_string(block.size()) + block[0];\\n            say = new_say;\\n        }\\n        \\n        return say;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716733,
                "title": "recursive-iterative-c-soln",
                "content": "# Complexity\\n- Time complexity: O(2^n)\\n Let\\'s say that every string has no duplicate numbers together , therefore lets asssume size for n=1 is 1 , 2 is 2, 3 is 4, 4 is 8 , 5 is 16 i.e. 2^(n-1) in worst case.  So overall complexity is a G.P. from 2^(1-1),2^(2-1),....,2^(n-1) which sums up to \\n  **g.p. sum = a(r^n - 1)/r-1** \\nwhere a = 1,r = 2.\\n  **So complexity becomes 2^n - 1.**\\n\\n **However ,it works for n=30 because all levels don\\'t necessarily doubles.**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Recursive Solution\\n```\\n    string countAndSay(int n) {\\n         if(n==1)return \"1\";\\n         string small = countAndSay(n-1);\\n         small+=\\'#\\';\\n         string ans = \"\";\\n         int cnt = 0;\\n         char k = small[0];\\n         for(char c:small){\\n            if(c!=k){\\n                ans+= (cnt+\\'0\\');\\n                ans+= k;\\n                cnt = 0; }\\n            k = c;\\n            cnt++; }\\n        return ans; }\\n```\\n \\n\\n# Iterative Solution \\n```\\n    string countAndSay(int n) {\\n        string start = \"1\";\\n        while(n-- >1){\\n           vector<int> num;\\n           int cnt = 0,ele = -1;\\n           for(int i =0;i<start.size();i++){\\n              if(ele==-1){\\n                  ele = start[i]-\\'0\\';\\n                  cnt++;\\n                  continue;\\n              }\\n              if(ele!=start[i]-\\'0\\'){\\n                  num.push_back(cnt);\\n                  num.push_back(ele);\\n                  ele = start[i]-\\'0\\',cnt=1;\\n              }\\n              else{\\n                  cnt++; }\\n           }\\n           if(ele!=-1){\\n               num.push_back(cnt);\\n               num.push_back(ele);\\n           }\\n            start = \"\";\\n           for(int a:num){\\n               start += (a+\\'0\\');\\n           } }\\n        return start ;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n         if(n==1)return \"1\";\\n         string small = countAndSay(n-1);\\n         small+=\\'#\\';\\n         string ans = \"\";\\n         int cnt = 0;\\n         char k = small[0];\\n         for(char c:small){\\n            if(c!=k){\\n                ans+= (cnt+\\'0\\');\\n                ans+= k;\\n                cnt = 0; }\\n            k = c;\\n            cnt++; }\\n        return ans; }\\n```\n```\\n    string countAndSay(int n) {\\n        string start = \"1\";\\n        while(n-- >1){\\n           vector<int> num;\\n           int cnt = 0,ele = -1;\\n           for(int i =0;i<start.size();i++){\\n              if(ele==-1){\\n                  ele = start[i]-\\'0\\';\\n                  cnt++;\\n                  continue;\\n              }\\n              if(ele!=start[i]-\\'0\\'){\\n                  num.push_back(cnt);\\n                  num.push_back(ele);\\n                  ele = start[i]-\\'0\\',cnt=1;\\n              }\\n              else{\\n                  cnt++; }\\n           }\\n           if(ele!=-1){\\n               num.push_back(cnt);\\n               num.push_back(ele);\\n           }\\n            start = \"\";\\n           for(int a:num){\\n               start += (a+\\'0\\');\\n           } }\\n        return start ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716650,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n**Problem Statement**\\n\\n\\t n      val\\n\\t 1.     1                                                  Base Case\\n\\t 2.     11                                                 (1 times 1) = 1\\n\\t 3.     21                                                 (2 times 1) = 2\\n\\t 4.     1211                                                and so on\\n\\n----------------------------------------------\\t\\n\\t\\n\\tstring countAndSay(int n) {\\n        \\n        if(n==1) return \"1\";                       //if n==1, return \"1\"\\n        if(n==2) return \"11\";                      //if n==2, return \"11\"\\n        \\n        string s=\"11\";                             //initialise s = \"11\"\\n        \\n        for(int i=3;i<=n;i++){\\n            \\n            string temp=\"\";                        //empty string, temp\\n            s+= \\'$\\';                               //append a random character, therefore, s = \"11$\"\\n            int count=1;                           //initially count = 1\\n            \\n            for(int j=1;j<s.size();j++){           //traverse string s from idx 1 to s.size()\\n                \\n                if(s[j]!=s[j-1]){                  //if curr_character and prev_character doesn\\'t match\\n                    \\n                    temp+= to_string(count);       //First,  add count to temp string\\n                    temp+= s[j-1];                 //Second, add the character (prev_character)\\n                    count=1;                       //Third,  reset the count\\n                }\\n                else count++;                      //if curr_character and prev_character match, increment count\\n                \\n            }\\n            \\n            s=temp;                                //Update string s wuth temp\\n        }\\n        \\n        return s;                                  //return s\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n**Problem Statement**\\n\\n\\t n      val\\n\\t 1.     1                                                  Base Case\\n\\t 2.     11                                                 (1 times 1) = 1\\n\\t 3.     21                                                 (2 times 1) = 2\\n\\t 4.     1211                                                and so on\\n\\n----------------------------------------------\\t\\n\\t\\n\\tstring countAndSay(int n) {\\n        \\n        if(n==1) return \"1\";                       //if n==1, return \"1\"\\n        if(n==2) return \"11\";                      //if n==2, return \"11\"\\n        \\n        string s=\"11\";                             //initialise s = \"11\"\\n        \\n        for(int i=3;i<=n;i++){\\n            \\n            string temp=\"\";                        //empty string, temp\\n            s+= \\'$\\';                               //append a random character, therefore, s = \"11$\"\\n            int count=1;                           //initially count = 1\\n            \\n            for(int j=1;j<s.size();j++){           //traverse string s from idx 1 to s.size()\\n                \\n                if(s[j]!=s[j-1]){                  //if curr_character and prev_character doesn\\'t match\\n                    \\n                    temp+= to_string(count);       //First,  add count to temp string\\n                    temp+= s[j-1];                 //Second, add the character (prev_character)\\n                    count=1;                       //Third,  reset the count\\n                }\\n                else count++;                      //if curr_character and prev_character match, increment count\\n                \\n            }\\n            \\n            s=temp;                                //Update string s wuth temp\\n        }\\n        \\n        return s;                                  //return s\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2716284,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = \"\"\\n        ct = 1\\n        if n == 1:\\n            return \"1\"\\n        prev =  self.countAndSay(n - 1)\\n        for i in range(len(prev)):\\n            if  i == len(prev) - 1 or prev[i] != prev[i + 1]   :\\n                res += str(ct) + prev[i]\\n                ct = 1\\n            else :\\n                ct +=1\\n        return res\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = \"\"\\n        ct = 1\\n        if n == 1:\\n            return \"1\"\\n        prev =  self.countAndSay(n - 1)\\n        for i in range(len(prev)):\\n            if  i == len(prev) - 1 or prev[i] != prev[i + 1]   :\\n                res += str(ct) + prev[i]\\n                ct = 1\\n            else :\\n                ct +=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470058,
                "title": "100-java-intuitive-recursion-method",
                "content": "Intuitive Java Recursion approach\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String res = countAndSay(n-1);\\n        StringBuilder ans = new StringBuilder();\\n        int left = 0, right = 0;\\n        while(right < res.length()){\\n            int counter = 0;\\n            while(right<res.length() && res.charAt(left) == res.charAt(right)){\\n                counter++;\\n                right++;\\n            }\\n            ans.append(counter);\\n            ans.append(res.charAt(left));\\n            left = right;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String res = countAndSay(n-1);\\n        StringBuilder ans = new StringBuilder();\\n        int left = 0, right = 0;\\n        while(right < res.length()){\\n            int counter = 0;\\n            while(right<res.length() && res.charAt(left) == res.charAt(right)){\\n                counter++;\\n                right++;\\n            }\\n            ans.append(counter);\\n            ans.append(res.charAt(left));\\n            left = right;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268267,
                "title": "python-1-line",
                "content": "This is a real python 1-liner, no tricks, no `;` for grouping multiple statements on a single line. The core of it is using `itertools.groupby` to help us count the number of chars easily and then doing that `n-1` times.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        return reduce(lambda s, _: \\'\\'.join(str(sum(1 for _ in g))+k for k, g in groupby(s)), range(n-1), \\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        return reduce(lambda s, _: \\'\\'.join(str(sum(1 for _ in g))+k for k, g in groupby(s)), range(n-1), \\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343305,
                "title": "100-runtime-python-code-o-1-runtime-unbeatable-easy-to-understand",
                "content": "Don\\'t worry, i created a program to provide this whole code, i didn\\'t calculate each count-and-say sequence part on my own ^^\\n\\nThis is of course a joke, don\\'t take that solution serious. But it\\'s a different way tho\\n\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n == 1: return \"1\"\\n        if n == 2: return \"11\"\\n        if n == 3: return \"21\"\\n        if n == 4: return \"1211\"\\n        if n == 5: return \"111221\"\\n        if n == 6: return \"312211\"\\n        if n == 7: return \"13112221\"\\n        if n == 8: return \"1113213211\"\\n        if n == 9: return \"31131211131221\"\\n        if n == 10: return \"13211311123113112211\"\\n        if n == 11: return \"11131221133112132113212221\"\\n        if n == 12: return \"3113112221232112111312211312113211\"\\n        if n == 13: return \"1321132132111213122112311311222113111221131221\"\\n        if n == 14: return \"11131221131211131231121113112221121321132132211331222113112211\"\\n        if n == 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n        if n == 16: return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n        if n == 17: return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n        if n == 18: return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n        if n == 19: return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n        if n == 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 21: return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 22: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 23: return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 24: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 26: return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 27: return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 28: return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 29: return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n == 1: return \"1\"\\n        if n == 2: return \"11\"\\n        if n == 3: return \"21\"\\n        if n == 4: return \"1211\"\\n        if n == 5: return \"111221\"\\n        if n == 6: return \"312211\"\\n        if n == 7: return \"13112221\"\\n        if n == 8: return \"1113213211\"\\n        if n == 9: return \"31131211131221\"\\n        if n == 10: return \"13211311123113112211\"\\n        if n == 11: return \"11131221133112132113212221\"\\n        if n == 12: return \"3113112221232112111312211312113211\"\\n        if n == 13: return \"1321132132111213122112311311222113111221131221\"\\n        if n == 14: return \"11131221131211131231121113112221121321132132211331222113112211\"\\n        if n == 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n        if n == 16: return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n        if n == 17: return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n        if n == 18: return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n        if n == 19: return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n        if n == 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 21: return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 22: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 23: return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 24: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 26: return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 27: return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 28: return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 29: return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16314,
                "title": "very-short-fast-6ms-and-concise-java-solution-easy-to-understand-and-implement",
                "content": "    public class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for (int i = 1; i < n; i++) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 1, count = 1; j <= s.length(); j++) {\\n                    if (j == s.length() || s.charAt(j - 1) != s.charAt(j)) {\\n                        sb.append(count);\\n                        sb.append(s.charAt(j - 1));\\n                        count = 1;\\n                    } else count++;\\n                }\\n                s = sb.toString();\\n            }\\n            return s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for (int i = 1; i < n; i++) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 1, count = 1; j <= s.length(); j++) {\\n                    if (j == s.length() || s.charAt(j - 1) != s.charAt(j)) {\\n                        sb.append(count);\\n                        sb.append(s.charAt(j - 1));\\n                        count = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 16214,
                "title": "0ms-c-language-solution",
                "content": "    char* countAndSay(int n) {\\n        if( n == 1 ) return \"1\";\\n    \\tchar *cur = malloc(2), *tmp;\\n    \\tcur[0] = '1';\\n    \\tcur[1] = 0;\\n    \\t\\n    \\tint len, idx, j, count;\\n    \\tfor(int i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tlen = strlen(cur);\\n    \\t\\ttmp = malloc(len * 3);\\n    \\t\\tmemset(tmp, 0, len * 3);\\n    \\t\\tcount = 1;\\n    \\t\\tfor(idx = 1, j = 0; idx < len; ++idx)\\n    \\t\\t{\\n    \\t\\t\\tif(cur[idx] == cur[idx-1])\\n            \\t{\\n                \\t++count;\\n            \\t}\\n    \\t\\t\\telse\\n            \\t{\\n                \\ttmp[j++] = '0' + count;\\n                \\ttmp[j++] = cur[idx-1];\\n                \\tcount = 1;\\n            \\t}\\n    \\t\\t}//end of for\\n    \\t\\ttmp[j++] = '0' + count;\\n        \\ttmp[j++] = cur[len-1];\\n    \\t\\tfree(cur);\\n    \\t\\tcur = tmp;\\n    \\t}\\t\\n    \\treturn cur;\\n    }",
                "solutionTags": [],
                "code": "    char* countAndSay(int n) {\\n        if( n == 1 ) return \"1\";\\n    \\tchar *cur = malloc(2), *tmp;\\n    \\tcur[0] = '1';\\n    \\tcur[1] = 0;\\n    \\t\\n    \\tint len, idx, j, count;\\n    \\tfor(int i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tlen = strlen(cur);\\n    \\t\\ttmp = malloc(len * 3);\\n    \\t\\tmemset(tmp, 0, len * 3);\\n    \\t\\tcount = 1;\\n    \\t\\tfor(idx = 1, j = 0; idx < len; ++idx)\\n    \\t\\t{\\n    \\t\\t\\tif(cur[idx] == cur[idx-1])\\n            \\t{\\n                \\t++count;\\n            \\t}\\n    \\t\\t\\telse\\n            \\t{\\n                \\ttmp[j++] = '0' + count;\\n                \\ttmp[j++] = cur[idx-1];\\n                \\tcount = 1;\\n            \\t}\\n    \\t\\t}//end of for\\n    \\t\\ttmp[j++] = '0' + count;\\n        \\ttmp[j++] = cur[len-1];\\n    \\t\\tfree(cur);\\n    \\t\\tcur = tmp;\\n    \\t}\\t\\n    \\treturn cur;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4067885,
                "title": "best-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string ans = \"1\";\\n        int i = 1;\\n        while (i < n) {\\n            string cur = \"\";\\n            for (int j = 0; j < ans.size(); j++) {\\n                int count = 1;\\n                while (j + 1 < ans.size() && ans[j] == ans[j + 1]) {\\n                    count++;\\n                    j++;\\n                }    \\n                cur += to_string(count) + ans[j];    \\n            } \\n            ans = cur; \\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string ans = \"1\";\\n        int i = 1;\\n        while (i < n) {\\n            string cur = \"\";\\n            for (int j = 0; j < ans.size(); j++) {\\n                int count = 1;\\n                while (j + 1 < ans.size() && ans[j] == ans[j + 1]) {\\n                    count++;\\n                    j++;\\n                }    \\n                cur += to_string(count) + ans[j];    \\n            } \\n            ans = cur; \\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088073,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/k9DpVGXO7H8\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    if(n == 1) return \"1\"\\n    let str = countAndSay(n-1)\\n\\n    let res = \"\"\\n    let j = 0;\\n    for(let i =0; i<str.length;i++){\\n        while(str[i] == str[j]) j++\\n\\n        res += j-i +str[i]\\n        i = j-1\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    if(n == 1) return \"1\"\\n    let str = countAndSay(n-1)\\n\\n    let res = \"\"\\n    let j = 0;\\n    for(let i =0; i<str.length;i++){\\n        while(str[i] == str[j]) j++\\n\\n        res += j-i +str[i]\\n        i = j-1\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716464,
                "title": "c-recursive-solution-with-explanation",
                "content": "# Recursive Approch:\\n**BASE CASE**\\n* First Base Case : - if(n == 1) then return \"1\";\\n* Second Base Case :- if(n == 2)then return \"11\";\\n\\n**RECURSIVE CALL**\\n* Call the fun(n-1) until it didn\\'t reached Base Case;\\n* When function hit the base case,then move procesing part of code;\\n\\n**PROCESSING**\\n* Store the resultant string into string x;\\n* if x[i] == x[i+1]the increase the counter;\\n* when if the case where x[i] != x[i+1] , then simply store the counter and then store the value of string;\\n\\n**CODE :-**\\n\\n```\\n    string countAndSay(int n) {\\n        int count = 1;string ans = \"\";\\n        if(n == 1)return \"1\";\\n        if(n == 2)return \"11\";\\n        string x = countAndSay(n-1);\\n        for(int i = 0;i<x.size();i++){\\n            if(x[i] == x[i+1]){\\n                count++;\\n            }\\n            else{\\n                ans+=to_string(count);\\n                ans+=x[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n        int count = 1;string ans = \"\";\\n        if(n == 1)return \"1\";\\n        if(n == 2)return \"11\";\\n        string x = countAndSay(n-1);\\n        for(int i = 0;i<x.size();i++){\\n            if(x[i] == x[i+1]){\\n                count++;\\n            }\\n            else{\\n                ans+=to_string(count);\\n                ans+=x[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716104,
                "title": "daily-leetcoding-challenge-october-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-and-say/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-and-say/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2689768,
                "title": "c-easy-fast-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        \\n        string str = countAndSay(n-1);\\n        \\n        string res = \"\";\\n        int s = str.size();\\n        int i = 0;\\n        while(i<s)\\n        {\\n            char c = str[i];\\n            int count = 0;\\n            while(i<s and str[i]==c)\\n            {\\n                count++;\\n                i++;\\n            }\\n            res+=\\'0\\'+count;\\n            res+=c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        \\n        string str = countAndSay(n-1);\\n        \\n        string res = \"\";\\n        int s = str.size();\\n        int i = 0;\\n        while(i<s)\\n        {\\n            char c = str[i];\\n            int count = 0;\\n            while(i<s and str[i]==c)\\n            {\\n                count++;\\n                i++;\\n            }\\n            res+=\\'0\\'+count;\\n            res+=c;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327540,
                "title": "2-solutions-recursion-iterative",
                "content": "\\n\\n**\\u2705 Recursive approach!**\\n\\n> Thanks for [fx19316\\'s post](https://leetcode.com/problems/count-and-say/discuss/201832/It\\'s-a-good-question-let-me-explain-it.) I understood it, So here I am sharing it in my way.\\n\\n1. What do we know and how can we use it.\\n    -   Let\\'s stat with example, suppose we have 4\\'th term \"1211\", how can we find 5\\'th term, then 6\\'th and so on.\\n        -   **4\\'th** - \"1211\"\\n        -   **5\\'th** - \"1-1 1-2 2-1s\" = \"111221\"\\n        -   **6\\'th** - \"3-1s 2-2s 1-1\" = \"312211\"\\n        -   **7\\'th** - \"<ins>1-3</ins> <ins>1-1</ins> <ins>2-2s</ins> <ins>2-1s</ins>\" = \"13 11 22 21\" = \"13112221\"\\n    - So from \"n-1\\'th\" term, we can find \"n\\'th\" term.\\n    - We just need to **count the number** and **say the number.**\\n\\n2. Algorithm.\\n    - **Base case:** for n = 1, we just return \"1\"\\n    - Get \"n-1\\'th\" term.\\n    - count the numbers of \"n-1\\'th\" term and get *count-say* string.\\n    - return final result as *count-say* string.\\n\\n\\n**C++ Code**\\n```cpp\\nclass Solution {\\n    // Simple function which return \\'count-say` string.\\n    // Just read it once, you will get the idea.\\n    string countSayStrFun(string s)\\n    {\\n        int count = 1;\\n        string res = \"\";\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[i - 1]) {\\n                count++;\\n            } else {\\n                res += to_string(count) + s[i - 1];\\n                count = 1;\\n            }\\n        }\\n        res += to_string(count) + s[s.size() - 1];\\n        return res;\\n    }\\n\\npublic:\\n    string countAndSay(int n)\\n    {\\n        if (n == 1) return \"1\"; // base case - first term is \"1\"\\n\\n        // believe that it will return n-1\\'th term\\n        string prevTerm = countAndSay(n - 1); \\n\\n        // Now just count the numbers and say the number.\\n        string countSayStr = countSayStrFun(prevTerm);\\n        \\n        return countSayStr;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\u2705 Iterative approach!**\\n- Same as recursive if you observe.\\n\\n**C++ Code**\\n```cpp\\nclass Solution {\\npublic:\\n    string countAndSay(int n)\\n    {\\n        string s = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            string t = \"\";\\n            int cnt = 1;\\n            for (int j = 1; j < s.size(); j++) {\\n                if (s[j] == s[j - 1])\\n                    cnt++;\\n                else {\\n                    t += to_string(cnt) + s[j - 1];\\n                    cnt = 1;\\n                }\\n            }\\n            t += to_string(cnt) + s[s.size() - 1];\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n**Please upvote if you find it useful.**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\n    // Simple function which return \\'count-say` string.\\n    // Just read it once, you will get the idea.\\n    string countSayStrFun(string s)\\n    {\\n        int count = 1;\\n        string res = \"\";\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[i - 1]) {\\n                count++;\\n            } else {\\n                res += to_string(count) + s[i - 1];\\n                count = 1;\\n            }\\n        }\\n        res += to_string(count) + s[s.size() - 1];\\n        return res;\\n    }\\n\\npublic:\\n    string countAndSay(int n)\\n    {\\n        if (n == 1) return \"1\"; // base case - first term is \"1\"\\n\\n        // believe that it will return n-1\\'th term\\n        string prevTerm = countAndSay(n - 1); \\n\\n        // Now just count the numbers and say the number.\\n        string countSayStr = countSayStrFun(prevTerm);\\n        \\n        return countSayStr;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string countAndSay(int n)\\n    {\\n        string s = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            string t = \"\";\\n            int cnt = 1;\\n            for (int j = 1; j < s.size(); j++) {\\n                if (s[j] == s[j - 1])\\n                    cnt++;\\n                else {\\n                    t += to_string(cnt) + s[j - 1];\\n                    cnt = 1;\\n                }\\n            }\\n            t += to_string(cnt) + s[s.size() - 1];\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456688,
                "title": "c-easy-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // base case\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n        // recursive case\\n        else {\\n            // store result of n - 1\\n            string s = countAndSay(n - 1);\\n            // stores result for n\\n            string result = \"\";\\n            // variables for adding the values\\n            char ch = s[0];\\n            int t = 0;\\n            \\n            //iterate over the string\\n            for (int i = 0; i < s.length(); i++) {\\n                // if char is same, increment\\n                if (ch == s[i]) {\\n                    t++;\\n                }\\n                // if char is differnet,\\n                else {\\n                    // add the values to result\\n                    result += to_string(t) + ch;\\n                    // reset variables\\n                    ch = s[i];\\n                    t = 1;\\n                }\\n            }\\n            // add the case when string contains only 1 character\\n            result += to_string(t) + ch;\\n            // return final result\\n            return result;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // base case\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n        // recursive case\\n        else {\\n            // store result of n - 1\\n            string s = countAndSay(n - 1);\\n            // stores result for n\\n            string result = \"\";\\n            // variables for adding the values\\n            char ch = s[0];\\n            int t = 0;\\n            \\n            //iterate over the string\\n            for (int i = 0; i < s.length(); i++) {\\n                // if char is same, increment\\n                if (ch == s[i]) {\\n                    t++;\\n                }\\n                // if char is differnet,\\n                else {\\n                    // add the values to result\\n                    result += to_string(t) + ch;\\n                    // reset variables\\n                    ch = s[i];\\n                    t = 1;\\n                }\\n            }\\n            // add the case when string contains only 1 character\\n            result += to_string(t) + ch;\\n            // return final result\\n            return result;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372052,
                "title": "iterative-java-solution-used-string-builder",
                "content": "\\tclass Solution {\\n    public String countAndSay(int n) {\\n        if(n<=0) return \"\";\\n        \\n        String res = \"1\";\\n        for(int i=1; i<=n-1; i++){\\n            StringBuilder cur = new StringBuilder();\\n            for(int j=0; j<res.length(); j++){\\n                int count = 1;\\n                while(j+1 < res.length() && res.charAt(j) == res.charAt(j+1)){\\n                    count++;\\n                    j++;\\n                }\\n                \\n                cur.append(count).append(res.charAt(j));\\n            }\\n            res = cur.toString();\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n<=0) return \"\";\\n        \\n        String res = \"1\";\\n        for(int i=1; i<=n-1; i++){\\n            StringBuilder cur = new StringBuilder();\\n            for(int j=0; j<res.length(); j++){\\n                int count = 1;\\n                while(j+1 < res.length() && res.charAt(j) == res.charAt(j+1)){\\n                    count++;\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1190634,
                "title": "c-easy-and-clean-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        string s = countAndSay(n-1), res=\"\";\\n        int sz = s.size(), cnt = 1;\\n        for(int i=1; i<sz; i++) {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else {\\n                res += to_string(cnt)+s[i-1];\\n                cnt = 1;\\n            }\\n        }\\n        res += to_string(cnt)+s[sz-1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        string s = countAndSay(n-1), res=\"\";\\n        int sz = s.size(), cnt = 1;\\n        for(int i=1; i<sz; i++) {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else {\\n                res += to_string(cnt)+s[i-1];\\n                cnt = 1;\\n            }\\n        }\\n        res += to_string(cnt)+s[sz-1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835293,
                "title": "kotlin-using-sequences",
                "content": "Kotlin sequences really showing their beauty on this task :)\\nWe just need to give the sequence:\\n* a place to begin - the string \"1\"\\n* a rule to generate the next element, given the previous one\\n\\nFor our successor function (`::next`), given an input string `s`, we can loop over `s`, counting up until the character changes, then adding the `count` and current character to our result `res`, repeating until we reach the end of the string. We then simply return `res`. Job done!\\n```\\n    fun countAndSay(n: Int): String {\\n        // our function to generate the next term of the sequence\\n        fun next(s: String): String {\\n\\n            var res = \"\"\\n            var count: Int\\n            var i = 0\\n            while (i<s.length) {\\n                count = 1\\n                while (i+1<s.length && s[i]==s[i+1]) {\\n                    i++\\n                    count++\\n                }\\n                res += \"$count${s[i++]}\"\\n            }\\n            return res\\n        }\\n        // create the sequence, starting with \"1\", return the nth element\\n        return generateSequence(\"1\", ::next).take(n).last()\\n        \\n    }",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "Kotlin sequences really showing their beauty on this task :)\\nWe just need to give the sequence:\\n* a place to begin - the string \"1\"\\n* a rule to generate the next element, given the previous one\\n\\nFor our successor function (`::next`), given an input string `s`, we can loop over `s`, counting up until the character changes, then adding the `count` and current character to our result `res`, repeating until we reach the end of the string. We then simply return `res`. Job done!\\n```\\n    fun countAndSay(n: Int): String {\\n        // our function to generate the next term of the sequence\\n        fun next(s: String): String {\\n\\n            var res = \"\"\\n            var count: Int\\n            var i = 0\\n            while (i<s.length) {\\n                count = 1\\n                while (i+1<s.length && s[i]==s[i+1]) {\\n                    i++\\n                    count++\\n                }\\n                res += \"$count${s[i++]}\"\\n            }\\n            return res\\n        }\\n        // create the sequence, starting with \"1\", return the nth element\\n        return generateSequence(\"1\", ::next).take(n).last()\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 441559,
                "title": "fastest-smallest-space-java-solution-100-runtime-100-memory",
                "content": "BEHOLD!\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            case 11: s = \"11131221133112132113212221\"; break;\\n            case 12: s = \"3113112221232112111312211312113211\"; break;\\n            case 13: s = \"1321132132111213122112311311222113111221131221\"; break;\\n            case 14: s = \"11131221131211131231121113112221121321132132211331222113112211\"; break;\\n            case 15: s = \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"; break;\\n            case 16: s = \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"; break;\\n            case 17: s = \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"; break;\\n            case 18: s = \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"; break;\\n            case 19: s = \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"; break;\\n            case 20: s = \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 21: s = \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 22: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 23: s = \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 24: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 25: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 26: s = \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 27: s = \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 28: s = \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 29: s = \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 30: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            default: break;\\n         }\\n        return s;\\n    }\\n}\\n```\\nBy the way, I got the numbers by making a different (less God-like) solution first. Just in case anyone thought I cheated wholesale; here it is:\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            default: break;\\n         }\\n        \\n        if (n > 10) {\\n            s = \"13211311123113112211\";\\n            String ans;\\n            for (int i = 10; i < n; i++) {\\n               ans = \"\";\\n               int count = 0;\\n               char num = s.charAt(0);\\n               for (int j = 0; j < s.length(); ++j) {\\n                  char thisNum = s.charAt(j);\\n                  if (thisNum == num) {\\n                     count++;\\n                  }\\n                  else {\\n                     ans += count; ans += num;\\n                     num = thisNum;\\n                     count = 1;\\n                  }\\n\\n                  if (j == s.length() - 1) {\\n                     ans += count; ans += num;\\n                  }\\n               }\\n               s = ans;\\n            }\\n         }\\n        return s;\\n    }\\n}\\n```\\nThanks for reading (and withholding your jealousy of my 1337 programming skills).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            case 11: s = \"11131221133112132113212221\"; break;\\n            case 12: s = \"3113112221232112111312211312113211\"; break;\\n            case 13: s = \"1321132132111213122112311311222113111221131221\"; break;\\n            case 14: s = \"11131221131211131231121113112221121321132132211331222113112211\"; break;\\n            case 15: s = \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"; break;\\n            case 16: s = \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"; break;\\n            case 17: s = \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"; break;\\n            case 18: s = \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"; break;\\n            case 19: s = \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"; break;\\n            case 20: s = \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 21: s = \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 22: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 23: s = \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 24: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 25: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 26: s = \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 27: s = \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 28: s = \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 29: s = \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 30: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            default: break;\\n         }\\n        return s;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            default: break;\\n         }\\n        \\n        if (n > 10) {\\n            s = \"13211311123113112211\";\\n            String ans;\\n            for (int i = 10; i < n; i++) {\\n               ans = \"\";\\n               int count = 0;\\n               char num = s.charAt(0);\\n               for (int j = 0; j < s.length(); ++j) {\\n                  char thisNum = s.charAt(j);\\n                  if (thisNum == num) {\\n                     count++;\\n                  }\\n                  else {\\n                     ans += count; ans += num;\\n                     num = thisNum;\\n                     count = 1;\\n                  }\\n\\n                  if (j == s.length() - 1) {\\n                     ans += count; ans += num;\\n                  }\\n               }\\n               s = ans;\\n            }\\n         }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373414,
                "title": "python-92-faster-simple-solution",
                "content": "I honestly hated this problem. Took me an hour to understand this one. [Explantation Here](https://www.geeksforgeeks.org/look-and-say-sequence/)\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 0: return \\'\\'\\n        if n == 1: return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for _ in range(n-1):\\n            prev, count = s[0], 0\\n            newS = \\'\\'\\n\\t\\t\\t\\n            for l in s:\\n                if prev != l:\\n                    newS += str(count) + prev\\n                    prev, count = l, 1\\n                else: count += 1\\n\\t\\t\\t\\t\\t\\n            newS += str(count) + prev\\n            s = newS\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 0: return \\'\\'\\n        if n == 1: return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for _ in range(n-1):\\n            prev, count = s[0], 0\\n            newS = \\'\\'\\n\\t\\t\\t\\n            for l in s:\\n                if prev != l:\\n                    newS += str(count) + prev\\n                    prev, count = l, 1\\n                else: count += 1\\n\\t\\t\\t\\t\\t\\n            newS += str(count) + prev\\n            s = newS\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188519,
                "title": "the-most-dodgy-solution-on-earth",
                "content": "class Solution {\n    public String countAndSay(int n) {\n        if (n==1) return \"1\";\n        if (n==2) return \"11\";\n        if (n==3) return \"21\";\n        if (n==4) return \"1211\";\n        if (n==5) return \"111221\";\n        if (n==6) return \"312211\";\n        if (n==7) return \"13112221\";\n        if (n==8) return \"1113213211\";\n        if (n==9) return \"31131211131221\";\n        if (n==10) return \"13211311123113112211\";\n        if (n==11) return \"11131221133112132113212221\";\n        if (n==12) return \"3113112221232112111312211312113211\";\n        if (n==13) return \"1321132132111213122112311311222113111221131221\";\n        if (n==14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n==15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        //if (n==16) return \"1\";\n        //if (n==17) return \"1\";\n        //if (n==18) return \"1\";\n        //if (n==19) return \"1\";\n        if (n==20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        //if (n==21) return \"1\";\n        //if (n==22) return \"1\";\n        //if (n==23) return \"1\";\n        //if (n==24) return \"1\";\n        if (n==25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        //if (n==26) return \"1\";\n        //if (n==27) return \"1\";\n        //if (n==28) return \"1\";\n        //if (n==29) return \"1\";\n        if (n==30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"\";\n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    public String countAndSay(int n) {\n        if (n==1) return \"1\";\n        if (n==2) return \"11\";\n        if (n==3) return \"21\";\n        if (n==4) return \"1211\";\n        if (n==5) return \"111221\";\n        if (n==6) return \"312211\";\n        if (n==7) return \"13112221\";\n        if (n==8) return \"1113213211\";\n        if (n==9) return \"31131211131221\";\n        if (n==10) return \"13211311123113112211\";\n        if (n==11) return \"11131221133112132113212221\";\n        if (n==12) return \"3113112221232112111312211312113211\";\n        if (n==13) return \"1321132132111213122112311311222113111221131221\";\n        if (n==14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n==15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        //if (n==16) return \"1\";\n        //if (n==17) return \"1\";\n        //if (n==18) return \"1\";\n        //if (n==19) return \"1\";\n        if (n==20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        //if (n==21) return \"1\";\n        //if (n==22) return \"1\";\n        //if (n==23) return \"1\";\n        //if (n==24) return \"1\";\n        if (n==25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        //if (n==26) return \"1\";\n        //if (n==27) return \"1\";\n        //if (n==28) return \"1\";\n        //if (n==29) return \"1\";\n        if (n==30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"\";\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3525420,
                "title": "awesome-logic-in-python3",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        first=\"1\"\\n        for i in range(n-1):\\n            new=\"\"\\n            count=1\\n            current=first[0]\\n            for c in first[1:]:\\n                if current==c:\\n                    count+=1\\n                else:\\n                    new+=str(count)+current\\n                    current=c\\n                    count=1\\n            new+=str(count)+current\\n            first=new\\n        return first\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        first=\"1\"\\n        for i in range(n-1):\\n            new=\"\"\\n            count=1\\n            current=first[0]\\n            for c in first[1:]:\\n                if current==c:\\n                    count+=1\\n                else:\\n                    new+=str(count)+current\\n                    current=c\\n                    count=1\\n            new+=str(count)+current\\n            first=new\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518596,
                "title": "java-solution-for-count-and-say-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe \"Count and Say\" sequence describes a pattern where each term is obtained by reading the previous term and counting the number of consecutive occurrences of each digit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Handle the edge case where n is less than or equal to 0 by returning null.\\n2. Initialize a variable result with the initial term of the sequence, which is \"1\".\\n3. Use a loop to generate the next term in the sequence n times:\\n- Inside the loop, create a StringBuilder named sb to build the next term.\\n- Initialize a counter count to 1 to keep track of the consecutive occurrences of a digit.\\n- Iterate through the characters of the result string starting from the second character.\\n- Compare each character with the previous character. If they are the same, increment the count.\\n- If the characters are different, append the count followed by the previous character to sb, reset the count to 1, and continue to the next character.\\n- After the inner loop completes, append the final count and the last character of the result string to sb.\\n- Update the result to the generated string in sb.\\n4. Return the final result string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n * k), where n is the given input and k is the length of the longest term in the \"Count and Say\" sequence up to the nth term. In each iteration of the loop, the code iterates through the characters of the result string to build the next term. Therefore, the time complexity is proportional to the length of the longest term, which is k.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(k), where k is the length of the longest term in the \"Count and Say\" sequence up to the nth term. It is due to the use of the StringBuilder to build the next term. The space required for the result string and the temporary variables is negligible compared to the length of the longest term, making the space complexity O(k).\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0)\\n            return null;\\n        String result = \"1\";\\n        int i = 1;\\n        while (i < n) \\n        {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int j = 1; j < result.length(); j++) \\n            {\\n                if (result.charAt(j) == result.charAt(j - 1)) \\n                {\\n                    count++;\\n                }\\n                else \\n                {\\n                    sb.append(count);\\n                    sb.append(result.charAt(j - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(result.charAt(result.length() - 1));\\n            result = sb.toString();\\n            i++;\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0)\\n            return null;\\n        String result = \"1\";\\n        int i = 1;\\n        while (i < n) \\n        {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int j = 1; j < result.length(); j++) \\n            {\\n                if (result.charAt(j) == result.charAt(j - 1)) \\n                {\\n                    count++;\\n                }\\n                else \\n                {\\n                    sb.append(count);\\n                    sb.append(result.charAt(j - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(result.charAt(result.length() - 1));\\n            result = sb.toString();\\n            i++;\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222117,
                "title": "count-and-say-sequence-generating-digit-strings-with-a-recursive-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires us to generate a sequence of strings that follows a specific pattern. The pattern for each string in the sequence is determined by applying a count-and-say algorithm to the previous string in the sequence. To generate the nth string in the sequence, we need to apply the count-and-say algorithm recursively on the (n-1)th string in the sequence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a recursive approach to generate the sequence of strings. If n is equal to 1, we simply return the string \"1\" as it is the first string in the sequence. Otherwise, we recursively call the countAndSay function with n-1 to get the previous string in the sequence. We then iterate through the previous string and apply the count-and-say algorithm to generate the current string in the sequence.\\n\\nTo apply the count-and-say algorithm, we iterate through the previous string from left to right, keeping track of the current digit and a count of how many times we have seen this digit consecutively. When we encounter a different digit, we append the count and the digit to our result string and reset the count to 1. We continue this process until we reach the end of the string.\\n# Complexity\\n- Time complexity: The algorithm iterates through each character in the input string once to generate the output string. Hence, the time complexity is $$O(N*M)$$, where N is the input integer and M is the length of the longest string in the sequence. In practice, since the length of the strings in the sequence grows exponentially with N, the actual time complexity of the algorithm is closer to $$O(2^N)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is $$O(M)$$, where M is the length of the longest string in the sequence. In practice, since the length of the strings in the sequence grows exponentially with N, the actual space complexity of the algorithm is closer to $$O(2^N)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        prev = self.countAndSay(n-1)\\n        result = \"\"\\n        count = 1\\n        digit = prev[0]\\n        for i in range(1, len(prev)):\\n            if prev[i] == digit:\\n                count += 1\\n            else:\\n                result += str(count) + digit\\n                count = 1\\n                digit = prev[i]\\n        result += str(count) + digit\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        prev = self.countAndSay(n-1)\\n        result = \"\"\\n        count = 1\\n        digit = prev[0]\\n        for i in range(1, len(prev)):\\n            if prev[i] == digit:\\n                count += 1\\n            else:\\n                result += str(count) + digit\\n                count = 1\\n                digit = prev[i]\\n        result += str(count) + digit\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103174,
                "title": "easy-100-in-runtime-beginners-simple-loop-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only have to call the function n times and update the string every time and pass that string as the input\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a string pass it to a function  count which is called n times.\\nIn function count we count the no of occurence and add that no with the no which is occuring to the string\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) with 100% \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string count(string p)\\n    {\\n        int k=0;\\n        string l=\"\";\\n        // we take m as \\'k\\' so we can check first character of string\\n        char m=\\'k\\';\\n        for(int i=0;i<p.length();i++)\\n        {\\n            //if new type of char is there then we will insert\\n            //k and that no in our string and reset value of k and m\\n            if(m!=p[i])\\n            {\\n                if(m!=\\'k\\')\\n                {\\n                   l+=(char)k+48;\\n                   l+=m;\\n                }\\n                k=0;\\n                m=p[i];\\n            }\\n            k++;\\n        }\\n        // for inserting last character\\n        l+=(char)k+48;\\n        l+=m;\\n        cout<<l<<endl;\\n        return l;\\n    }\\n    string countAndSay(int n) {\\n        string p=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            p=count(p);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string count(string p)\\n    {\\n        int k=0;\\n        string l=\"\";\\n        // we take m as \\'k\\' so we can check first character of string\\n        char m=\\'k\\';\\n        for(int i=0;i<p.length();i++)\\n        {\\n            //if new type of char is there then we will insert\\n            //k and that no in our string and reset value of k and m\\n            if(m!=p[i])\\n            {\\n                if(m!=\\'k\\')\\n                {\\n                   l+=(char)k+48;\\n                   l+=m;\\n                }\\n                k=0;\\n                m=p[i];\\n            }\\n            k++;\\n        }\\n        // for inserting last character\\n        l+=(char)k+48;\\n        l+=m;\\n        cout<<l<<endl;\\n        return l;\\n    }\\n    string countAndSay(int n) {\\n        string p=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            p=count(p);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2718543,
                "title": "c-using-map-easy-and-simple-code",
                "content": "class Solution {\\n    \\nprivate:\\n    vector<vector<int>> make_map(string &arr){\\n        int n = arr.size();\\n        vector<vector<int>> map;\\n        \\n        int temp = 1, mx = 0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]==arr[i+1]) temp++;\\n            \\n            else {\\n                map.push_back( {arr[i]-\\'0\\',temp});\\n                temp = 1;\\n            }\\n        }\\n        if(arr[n-1]!=arr[n-2]) map.push_back({arr[n-1]-\\'0\\',1});\\n        else if(arr[n-1]==arr[n-2]) map.push_back({arr[n-1]-\\'0\\',temp});\\n        \\n\\n        return map;\\n    } \\n    \\n    string make_string(vector<vector<int>> &map){\\n        string ans = \"\";\\n        for(auto&i:map) {\\n            ans+= (i[1]) +\\'0\\';\\n            ans+= (i[0]) +\\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        if(n==3) return \"21\";\\n        \\n        string ans = \"1211\";\\n        if(n==4) return ans;\\n        \\n        for(int i= 4;i<n;i++){\\n           vector<vector<int>> temp = make_map(ans);\\n           ans = make_string(temp);\\n          //  cout<<ans<<endl;\\n        }\\n        \\n        \\n        //Test\\n//         string fuck = \"1211\";\\n//         vector<vector<int>> temp = make_map(fuck);\\n//         ans = make_string(temp);\\n        \\n//         for(auto&i:temp) cout<<i[0]<<\" \"<<i[1]<<endl;\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\nprivate:\\n    vector<vector<int>> make_map(string &arr){\\n        int n = arr.size();\\n        vector<vector<int>> map;\\n        \\n        int temp = 1, mx = 0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]==arr[i+1]) temp++;\\n            \\n            else {\\n                map.push_back( {arr[i]-\\'0\\',temp}",
                "codeTag": "Java"
            },
            {
                "id": 2717850,
                "title": "easy-to-understand-c",
                "content": "If you find help from this code for good understanding, please Upvote.\\n```\\nclass Solution {\\npublic:\\n    string solve(int n){\\n        int cnt = 1;\\n        string s = \"1\";\\n        for(int i=2; i<=n; i++){\\n            int l = 0, r = 0;\\n            string ans = \"\";\\n            while(r < s.size()){\\n                int cnt = 0;\\n                while(r < s.size() and s[l] == s[r]){ // check similar character \\n                    cnt++;\\n                    r++;\\n                }\\n                ans += cnt+\\'0\\';\\n                ans += s[l];\\n                l = r;\\n            }\\n           s = ans; \\n        }\\n        return s;\\n    }\\n    string countAndSay(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(int n){\\n        int cnt = 1;\\n        string s = \"1\";\\n        for(int i=2; i<=n; i++){\\n            int l = 0, r = 0;\\n            string ans = \"\";\\n            while(r < s.size()){\\n                int cnt = 0;\\n                while(r < s.size() and s[l] == s[r]){ // check similar character \\n                    cnt++;\\n                    r++;\\n                }\\n                ans += cnt+\\'0\\';\\n                ans += s[l];\\n                l = r;\\n            }\\n           s = ans; \\n        }\\n        return s;\\n    }\\n    string countAndSay(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717340,
                "title": "rust-four-solutions-with-comments",
                "content": "We solve this by simulation. Starting with the base case, iteratively or recursively compute the next entry by grouping the digits, and appending the length of the group and the common group digit to the result.\\n\\nImplementation notes:\\n* I\\'d rather not muck around with using strings for computing the intermediate result. Using a vector with an integer element type is so much simpler and more efficient. We reformat to a string for the return value.\\n* I prefer an iterative approach here to keep things concise and efficient. If we use recursion, we should take care to implement it to allow for tail recursion, so that we are efficient with the stack. I included such a solution as well.\\n* If `group_by` wasn\\'t a nightly feature, we could have used that to make an even more concise and more functional solution. But we can\\'t use that here, so I went for a two-pointer approach to group the digits.\\n* `extend` and `once` make for a concise way to add elements to `next`.\\n\\n**Iterative (More Imperative)**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        let mut curr = vec![1];\\n        for _ in 1..n {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            curr = next;\\n        }\\n        curr.into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**Iterative (More Functional)**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        (1..n).fold(vec![1], |curr, _| {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            next\\n        }).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**Recursive with Tail Recursion**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    fn recurse(curr: &[u8], left: i32) -> Vec<u8> {\\n        if left == 1 {\\n            curr.to_vec()\\n        } else {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            Self::recurse(&next, left - 1)\\n        }\\n    }\\n\\n    pub fn count_and_say(n: i32) -> String {\\n        Self::recurse(&[1], n).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**I Just Had To :P**\\n\\n```\\nconst ANSWERS: [&str; 30] =\\n[\"1\"\\n,\"11\"      \\n,\"21\"      \\n,\"1211\"    \\n,\"111221\"  \\n,\"312211\"  \\n,\"13112221\"\\n,\"1113213211\"\\n,\"31131211131221\"\\n,\"13211311123113112211\"\\n,\"11131221133112132113212221\"\\n,\"3113112221232112111312211312113211\"\\n,\"1321132132111213122112311311222113111221131221\"\\n,\"11131221131211131231121113112221121321132132211331222113112211\"\\n,\"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n,\"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n,\"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n,\"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n,\"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n,\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"];\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        ANSWERS[(n - 1) as usize].to_string()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        let mut curr = vec![1];\\n        for _ in 1..n {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            curr = next;\\n        }\\n        curr.into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        (1..n).fold(vec![1], |curr, _| {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            next\\n        }).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    fn recurse(curr: &[u8], left: i32) -> Vec<u8> {\\n        if left == 1 {\\n            curr.to_vec()\\n        } else {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            Self::recurse(&next, left - 1)\\n        }\\n    }\\n\\n    pub fn count_and_say(n: i32) -> String {\\n        Self::recurse(&[1], n).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nconst ANSWERS: [&str; 30] =\\n[\"1\"\\n,\"11\"      \\n,\"21\"      \\n,\"1211\"    \\n,\"111221\"  \\n,\"312211\"  \\n,\"13112221\"\\n,\"1113213211\"\\n,\"31131211131221\"\\n,\"13211311123113112211\"\\n,\"11131221133112132113212221\"\\n,\"3113112221232112111312211312113211\"\\n,\"1321132132111213122112311311222113111221131221\"\\n,\"11131221131211131231121113112221121321132132211331222113112211\"\\n,\"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n,\"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n,\"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n,\"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n,\"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n,\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"];\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        ANSWERS[(n - 1) as usize].to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717054,
                "title": "python-iterative-solution-o-nm-time-o-m-space",
                "content": "```\\n# * Iterative Solution | O(nm) Time | O(m) Space\\n# * n -> The given input | m -> The length of string\\n\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = [\"1\"]\\n        n -= 1\\n        while n:\\n            cur_val = []\\n            i = 0\\n            while i < len(res):\\n                cur_count = 1\\n                while i + 1 < len(res) and res[i] == res[i + 1]:\\n                    cur_count += 1\\n                    i += 1\\n\\n                cur_val.extend([str(cur_count), res[i]])\\n                i += 1\\n\\n            res = cur_val\\n            n -= 1\\n\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n# * Iterative Solution | O(nm) Time | O(m) Space\\n# * n -> The given input | m -> The length of string\\n\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = [\"1\"]\\n        n -= 1\\n        while n:\\n            cur_val = []\\n            i = 0\\n            while i < len(res):\\n                cur_count = 1\\n                while i + 1 < len(res) and res[i] == res[i + 1]:\\n                    cur_count += 1\\n                    i += 1\\n\\n                cur_val.extend([str(cur_count), res[i]])\\n                i += 1\\n\\n            res = cur_val\\n            n -= 1\\n\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717007,
                "title": "simple-and-short-solution-easy-understandable",
                "content": "```\\n    string countAndSay(int n) {\\n        if(n==1)\\n            return \"1\";\\n        string prev=\"1\";\\n        for(int i=2;i<=n;i++){\\n            string cur=\"\";\\n            int cnt=0;\\n            char ch=prev[0];\\n            for(char j:prev){\\n                if(ch==j){\\n                    cnt++;\\n                }\\n                else{\\n                    cur+=to_string(cnt)+ch;\\n                    cnt=1;\\n                    ch=j;\\n                }\\n            }\\n            cur+=to_string(cnt)+ch;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n        if(n==1)\\n            return \"1\";\\n        string prev=\"1\";\\n        for(int i=2;i<=n;i++){\\n            string cur=\"\";\\n            int cnt=0;\\n            char ch=prev[0];\\n            for(char j:prev){\\n                if(ch==j){\\n                    cnt++;\\n                }\\n                else{\\n                    cur+=to_string(cnt)+ch;\\n                    cnt=1;\\n                    ch=j;\\n                }\\n            }\\n            cur+=to_string(cnt)+ch;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2716587,
                "title": "easy-to-understand-simple-solution",
                "content": "```\\nclass Solution\\n{\\n    string getCurrentSequence(string &previous)\\n    {\\n        string current;\\n        int counter = 1;\\n\\n        for (int idx = 1; idx < previous.length(); idx++)\\n        {\\n            if (previous[idx - 1] == previous[idx])\\n            {\\n                counter += 1;\\n            }\\n            else\\n            {\\n                current += to_string(counter);\\n                current.push_back(previous[idx - 1]);\\n                counter = 1;\\n            }\\n        }\\n\\n        current += to_string(counter);\\n        current.push_back(previous.back());\\n\\n        return current;\\n    }\\n\\n    public:\\n        string countAndSay(int n)\\n        {\\n            if (n == 1)\\n                return \"1\";\\n\\n            string previous = countAndSay(n - 1);\\n            return getCurrentSequence(previous);\\n        }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    string getCurrentSequence(string &previous)\\n    {\\n        string current;\\n        int counter = 1;\\n\\n        for (int idx = 1; idx < previous.length(); idx++)\\n        {\\n            if (previous[idx - 1] == previous[idx])\\n            {\\n                counter += 1;\\n            }\\n            else\\n            {\\n                current += to_string(counter);\\n                current.push_back(previous[idx - 1]);\\n                counter = 1;\\n            }\\n        }\\n\\n        current += to_string(counter);\\n        current.push_back(previous.back());\\n\\n        return current;\\n    }\\n\\n    public:\\n        string countAndSay(int n)\\n        {\\n            if (n == 1)\\n                return \"1\";\\n\\n            string previous = countAndSay(n - 1);\\n            return getCurrentSequence(previous);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707034,
                "title": "c-java-0-ms-100-00-faster-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        vector<string> v;\\n        string s=\"\";\\n        v.push_back(s);\\n        for(int i=1;i<=n;i++){\\n            s=v[i-1];\\n            if(s==\"\") v.push_back(\"1\");\\n            else{\\n                string ans=\"\";\\n                int count=1,flag=1;\\n                for(int i=0;i<s.size()-1;++i){\\n                    if(s[i+1]==s[i]){\\n                        count++;\\n                    }\\n                    else{\\n                        ans+=(count+\\'0\\');\\n                        ans+=s[i];\\n                        count=1;\\n                    }  \\n                }\\n                if(flag==1){\\n                    ans+=(count+\\'0\\');\\n                    ans+=s[s.size()-1];\\n                }\\n                v.push_back(ans);\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String",
                    "Recursion",
                    "Iterator"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        vector<string> v;\\n        string s=\"\";\\n        v.push_back(s);\\n        for(int i=1;i<=n;i++){\\n            s=v[i-1];\\n            if(s==\"\") v.push_back(\"1\");\\n            else{\\n                string ans=\"\";\\n                int count=1,flag=1;\\n                for(int i=0;i<s.size()-1;++i){\\n                    if(s[i+1]==s[i]){\\n                        count++;\\n                    }\\n                    else{\\n                        ans+=(count+\\'0\\');\\n                        ans+=s[i];\\n                        count=1;\\n                    }  \\n                }\\n                if(flag==1){\\n                    ans+=(count+\\'0\\');\\n                    ans+=s[s.size()-1];\\n                }\\n                v.push_back(ans);\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348106,
                "title": "c-solution-comments-easy-n-simple-faster-than-73-and-97",
                "content": "Here I tried to use the memoized approach in case of multiple test cases, so we have the precomputed table upto n=30. \\n(For a faster result, see below)\\n```\\n// initialized a vector of strings for each n==1 to n==30\\nvector<string> s{31, \"\"};\\n\\n// function to calculate the requires string\\nvoid calc(){\\n\\t// initialized the n=1, n=2 pos for s as \"1\", and \"11\" respectively.\\n\\ts[1] = \"1\", s[2] = \"11\";\\n\\t\\n\\t// initialized a count variable to keep track of consecutive same digits.\\n\\tint count=0;\\n\\n\\t// since we already have till 2, we start from 3.\\n\\tfor(int j=3; j<31; j++){\\n\\t\\tint pos=0;\\n\\t\\t// for each loop, we traverse through the previous string\\n\\t\\twhile(i<s[j-1].length()){\\n\\t\\t\\tcount =1;\\n\\t\\t\\t// here char c to keep track of the current character I\\'m checking\\n\\t\\t\\tchar c = s[j-1][pos];\\n\\t\\t\\t\\n\\t\\t\\t// whenever I encounter a same string, I increase count and the pos by 1\\n\\t\\t\\twhile(pos+1<s[j-1].length() && s[j-1][pos]==s[j-1][pos+1])\\n\\t\\t\\t\\tpos++, count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// when I don\\'t see consecutive digits same, I break out of loop and add it to string\\n\\t\\t\\ts[j] = s[j] + to_string(count) + (c);\\n\\t\\t\\tpos++;\\n\\t\\t}\\n\\t}\\n}\\n\\nstring countAndSay(int n) {\\n\\tcalc();\\n\\treturn s[n];\\n}\\n```\\n\\nFor a faster runtime: you can pass an argument to calc, so that the calc function only runs for that many times, decreasing the space and time usage, which gives you faster than other methods.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Memoization"
                ],
                "code": "```\\n// initialized a vector of strings for each n==1 to n==30\\nvector<string> s{31, \"\"};\\n\\n// function to calculate the requires string\\nvoid calc(){\\n\\t// initialized the n=1, n=2 pos for s as \"1\", and \"11\" respectively.\\n\\ts[1] = \"1\", s[2] = \"11\";\\n\\t\\n\\t// initialized a count variable to keep track of consecutive same digits.\\n\\tint count=0;\\n\\n\\t// since we already have till 2, we start from 3.\\n\\tfor(int j=3; j<31; j++){\\n\\t\\tint pos=0;\\n\\t\\t// for each loop, we traverse through the previous string\\n\\t\\twhile(i<s[j-1].length()){\\n\\t\\t\\tcount =1;\\n\\t\\t\\t// here char c to keep track of the current character I\\'m checking\\n\\t\\t\\tchar c = s[j-1][pos];\\n\\t\\t\\t\\n\\t\\t\\t// whenever I encounter a same string, I increase count and the pos by 1\\n\\t\\t\\twhile(pos+1<s[j-1].length() && s[j-1][pos]==s[j-1][pos+1])\\n\\t\\t\\t\\tpos++, count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// when I don\\'t see consecutive digits same, I break out of loop and add it to string\\n\\t\\t\\ts[j] = s[j] + to_string(count) + (c);\\n\\t\\t\\tpos++;\\n\\t\\t}\\n\\t}\\n}\\n\\nstring countAndSay(int n) {\\n\\tcalc();\\n\\treturn s[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2097846,
                "title": "easy-java-solution-using-recursion",
                "content": "```\\npublic String countAndSay(int n) {\\n        String fRes = \"\";\\n        if(n == 1) return \"1\";\\n        else{\\n            String res = countAndSay(n-1);\\n            int count = 1;\\n            int i;\\n            for(i=0; i<res.length()-1; i++){\\n                if(res.charAt(i) == res.charAt(i+1)) count++;\\n                else{\\n                    fRes+= Integer.toString(count)+res.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            fRes+= Integer.toString(count)+res.charAt(i);\\n        }\\n        return fRes;\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        String fRes = \"\";\\n        if(n == 1) return \"1\";\\n        else{\\n            String res = countAndSay(n-1);\\n            int count = 1;\\n            int i;\\n            for(i=0; i<res.length()-1; i++){\\n                if(res.charAt(i) == res.charAt(i+1)) count++;\\n                else{\\n                    fRes+= Integer.toString(count)+res.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            fRes+= Integer.toString(count)+res.charAt(i);\\n        }\\n        return fRes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009234,
                "title": "c-100-faster-solution-easy-code-with-explanation",
                "content": "```\\n string countAndSay(int n) \\n    {\\n        string str=\"11\";\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        n-=2; //Becase for n=1 and n=2 i\\'ve already stored the answer so i need to substract the size\\n        while(n--)\\n        {\\n          int count=1;\\n          string temp=\"\";\\n          for(int i=0;i<str.size();i++)\\n          {\\n\\t\\t   //If str[i]!=str[i+1] than i will have only 1 element with frequency one so count will 1 and say will str[i];\\n             if((i+1 < str.size()) and str[i]!=str[i+1])\\n             {\\n\\t\\t\\t    //Push Count\\n                temp.push_back(\\'1\\');\\n\\t\\t\\t\\t//Push Say\\n                temp.push_back(str[i]);\\n             }\\n\\t\\t\\t //Else i will count all the frequency of the charactor and than count will be No. of freq. and say will be str[i]\\n             else\\n             {\\n\\t\\t\\t   //Count total no. of freq. if they are same\\n                 while((i+1<str.size()) and str[i]==str[i+1])\\n                 {\\n                     count++;\\n                     i++;\\n                 }\\n\\t\\t\\t\\t  //Push Count\\n                 temp+=to_string(count);\\n\\t\\t\\t\\t  //Push Say\\n                 temp.push_back(str[i]);       \\n                 count=1;\\n             }\\n          }\\n\\t\\t     //Update str \\n              str = temp;\\n\\t\\t\\t  //Repeat this step n times \\n         }\\n        return str;\\n    }\\n     \\t//This Code is contributed By SOHAIL KHAN\\n\\t\\t//Please Upvote if you find it HELPFULL \\n\\t\\t//Let me know in the comment section if you still have doubts\\n\\t\\t//Thankyou\\n\\t\\t//#Happycoding ;-)\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n string countAndSay(int n) \\n    {\\n        string str=\"11\";\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        n-=2; //Becase for n=1 and n=2 i\\'ve already stored the answer so i need to substract the size\\n        while(n--)\\n        {\\n          int count=1;\\n          string temp=\"\";\\n          for(int i=0;i<str.size();i++)\\n          {\\n\\t\\t   //If str[i]!=str[i+1] than i will have only 1 element with frequency one so count will 1 and say will str[i];\\n             if((i+1 < str.size()) and str[i]!=str[i+1])\\n             {\\n\\t\\t\\t    //Push Count\\n                temp.push_back(\\'1\\');\\n\\t\\t\\t\\t//Push Say\\n                temp.push_back(str[i]);\\n             }\\n\\t\\t\\t //Else i will count all the frequency of the charactor and than count will be No. of freq. and say will be str[i]\\n             else\\n             {\\n\\t\\t\\t   //Count total no. of freq. if they are same\\n                 while((i+1<str.size()) and str[i]==str[i+1])\\n                 {\\n                     count++;\\n                     i++;\\n                 }\\n\\t\\t\\t\\t  //Push Count\\n                 temp+=to_string(count);\\n\\t\\t\\t\\t  //Push Say\\n                 temp.push_back(str[i]);       \\n                 count=1;\\n             }\\n          }\\n\\t\\t     //Update str \\n              str = temp;\\n\\t\\t\\t  //Repeat this step n times \\n         }\\n        return str;\\n    }\\n     \\t//This Code is contributed By SOHAIL KHAN\\n\\t\\t//Please Upvote if you find it HELPFULL \\n\\t\\t//Let me know in the comment section if you still have doubts\\n\\t\\t//Thankyou\\n\\t\\t//#Happycoding ;-)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943045,
                "title": "java-recursion-solution-with-explain",
                "content": "Firstly, we need to confirm our base case\\n```\\nif(n == 1){\\n\\treturn \"1\";\\n}\\n```\\nThen we create a counter and a pointer, go through n - 1 string. Count number of same char, and if pointer met with a different integer, add the counter number and previous integer into stringbuilder. \\n\\nOne reminder is, when adding string to stringbuilder\\ndo\\n```\\n\\tstringBuilder.append(String.valueOf(counter)).append(prev);\\n\\tinstead of\\n\\tstringBuilder.append(String.valueOf(counter + prev));\\n```\\nusing append is faster than suming string\\n\\nComplete code\\n```\\npublic String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String t = countAndSay(n - 1);\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int counter = 1;\\n        char lastInteger = t.charAt(0);\\n        for(int i = 1; i < t.length(); i++){\\n            if(t.charAt(i) == t.charAt(i-1)){\\n                counter++;\\n            }else{\\n                stringBuilder.append(counter).append(lastInteger);\\n                lastInteger = t.charAt(i);\\n                counter = 1;\\n            }\\n        }\\n        stringBuilder.append(counter).append(lastInteger);\\n        return stringBuilder.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nif(n == 1){\\n\\treturn \"1\";\\n}\\n```\n```\\n\\tstringBuilder.append(String.valueOf(counter)).append(prev);\\n\\tinstead of\\n\\tstringBuilder.append(String.valueOf(counter + prev));\\n```\n```\\npublic String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String t = countAndSay(n - 1);\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int counter = 1;\\n        char lastInteger = t.charAt(0);\\n        for(int i = 1; i < t.length(); i++){\\n            if(t.charAt(i) == t.charAt(i-1)){\\n                counter++;\\n            }else{\\n                stringBuilder.append(counter).append(lastInteger);\\n                lastInteger = t.charAt(i);\\n                counter = 1;\\n            }\\n        }\\n        stringBuilder.append(counter).append(lastInteger);\\n        return stringBuilder.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890608,
                "title": "100-fastest-typescript-solution",
                "content": "```\\ntype Group = [number, string]\\nconst results: { [key: string]: string } = { \"1\": \"1\" }\\n\\nfunction countAndSay(n: number): string {\\n  if (n > 30) { throw new Error(\"Max n exceeded\") }\\n\\n  if (!results[n]) { results[n] = sayGroup(getGroups(countAndSay(n - 1))) }\\n  return results[n]\\n}\\n\\nfunction sayGroup(groups: Group[]): string {\\n  return groups\\n         .map(([count, symbol]) => { return `${count}${symbol}` })\\n         .join(\"\")\\n}\\n\\nfunction getGroups(str: string) {\\n  const groups: [number, string][] = []\\n  let lastGroup: [number, string]\\n\\n  str.split(\"\").reduce((prev, curr, i) => {\\n    if (prev !== curr) {\\n      lastGroup = [0, curr]\\n      groups.push(lastGroup)\\n    }\\n\\n    lastGroup[0]++\\n    return curr\\n  }, \"\")\\n\\n  return groups\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Group = [number, string]\\nconst results: { [key: string]: string } = { \"1\": \"1\" }\\n\\nfunction countAndSay(n: number): string {\\n  if (n > 30) { throw new Error(\"Max n exceeded\") }\\n\\n  if (!results[n]) { results[n] = sayGroup(getGroups(countAndSay(n - 1))) }\\n  return results[n]\\n}\\n\\nfunction sayGroup(groups: Group[]): string {\\n  return groups\\n         .map(([count, symbol]) => { return `${count}${symbol}` })\\n         .join(\"\")\\n}\\n\\nfunction getGroups(str: string) {\\n  const groups: [number, string][] = []\\n  let lastGroup: [number, string]\\n\\n  str.split(\"\").reduce((prev, curr, i) => {\\n    if (prev !== curr) {\\n      lastGroup = [0, curr]\\n      groups.push(lastGroup)\\n    }\\n\\n    lastGroup[0]++\\n    return curr\\n  }, \"\")\\n\\n  return groups\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1834726,
                "title": "c-simple-code-easy-to-understand",
                "content": "**Upvote if you like the solution**\\n```\\nstring countAndSay(int n) {\\n        string res=\"1\";\\n        while(--n){\\n            string temp=\"\";\\n            int sze=res.size();\\n            \\n            for(int j=0;j<sze;){\\n                int count=0,left=j,right=j;\\n                while(right<sze && res[left]==res[right]){\\n                    count++;\\n                    right++;\\n                }\\n                j=right;\\n                \\n                temp+=to_string(count)+res[left];\\n            }\\n            res=temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Upvote if you like the solution**\\n```\\nstring countAndSay(int n) {\\n        string res=\"1\";\\n        while(--n){\\n            string temp=\"\";\\n            int sze=res.size();\\n            \\n            for(int j=0;j<sze;){\\n                int count=0,left=j,right=j;\\n                while(right<sze && res[left]==res[right]){\\n                    count++;\\n                    right++;\\n                }\\n                j=right;\\n                \\n                temp+=to_string(count)+res[left];\\n            }\\n            res=temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1596269,
                "title": "problem-explanation-java-solution",
                "content": "I think the problem was not explained very clearly. There are two things to understand:\\n\\n1. **countAndSay** is the way you would read out the string. Let\\'s just call it the compressed version of a string.\\n\\t- For example: If I gave you a random string \"22233413\" you would compress it based on the counts of repeating characters. \\n\\t- So you would see it like this: \"222 - 33 - 4 - 1- 3\" and compress it to \"32 - 23 - 14 - 11 - 13\"  because there are three 2\\'s, two 3\\'s, one 4, two 1\\'s, one 3 in the input string. \\n\\t- Hence, the countAndSay equivalent (or the compressed version) of \"22233413\" is \"3223141113\".\\n\\n2. **What the problem wants?**\\n\\t- Let us first understand the base case. If n=1, we do not perform a countAndSay on it. We just assume it\\'s countAndSay equivalent (or compressed representation) will be \"1\".\\n\\t- Now, for given int n, we return the compressed string of countAndSay(n-1). *This is key to understanding the question.*\\n\\t- Consider the example of input n=2. Remember the compressed string of 1 is \"1\"\\n\\t- so for n=2, countAndSay(2) = compress(countAndSay(2-1)) = compress(countAndSay(1)) = compress(\"1\")  = \"11\" because there is one 1 in \"1\". \\n\\t- So this way, countAndSay(3) = compress(countAndSay(2)) = compress(\"11\") = \"21\" because there are two 1\\'s.\\n\\nI hope this helps you understand what the question is about. \\n\\n```\\nclass Solution {\\n    \\n    public String countAndSay(int n) {\\n        //store compressed version for each integer upto n \\n        String[] memo = new String[n];\\n        \\n        //base case i.e. countAndSay equivalent of n = 1\\n        memo[0] = \"1\";\\n        \\n\\t\\t//for each i < n, we compute the compressed version of i - 1\\n        for(int i=1; i<n; i++){\\n            memo[i] = compress(memo[i-1].toCharArray());\\n        }\\n        \\n        return memo[n-1];\\n    }\\n    \\n    //build the compressed string\\n    public String compress(char[] c){\\n        int count = 1;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for(int i=1; i<c.length; i++){\\n            if(c[i] == c[i-1]){\\n                count++;\\n            }else{\\n                ans.append(count).append(c[i-1]);\\n                count = 1;\\n            }\\n        }\\n        \\n        ans.append(count).append(c[c.length-1]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String countAndSay(int n) {\\n        //store compressed version for each integer upto n \\n        String[] memo = new String[n];\\n        \\n        //base case i.e. countAndSay equivalent of n = 1\\n        memo[0] = \"1\";\\n        \\n\\t\\t//for each i < n, we compute the compressed version of i - 1\\n        for(int i=1; i<n; i++){\\n            memo[i] = compress(memo[i-1].toCharArray());\\n        }\\n        \\n        return memo[n-1];\\n    }\\n    \\n    //build the compressed string\\n    public String compress(char[] c){\\n        int count = 1;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for(int i=1; i<c.length; i++){\\n            if(c[i] == c[i-1]){\\n                count++;\\n            }else{\\n                ans.append(count).append(c[i-1]);\\n                count = 1;\\n            }\\n        }\\n        \\n        ans.append(count).append(c[c.length-1]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231949,
                "title": "100-faster-easy-code",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        if(n == 2) return \"11\";\\n        string s = \"11\";\\n        for(int i=3 ; i<=n ; i++)\\n        {\\n            s+=\"$\"; // to check last character\\n            string t = \"\";\\n            int count = 1;\\n            for(int j=1 ; j<s.length() ; j++)\\n            {\\n                if(s[j]!=s[j-1])\\n                {\\n                    t += count + \\'0\\';\\n                    t += s[j-1];\\n                    count = 1;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        if(n == 2) return \"11\";\\n        string s = \"11\";\\n        for(int i=3 ; i<=n ; i++)\\n        {\\n            s+=\"$\"; // to check last character\\n            string t = \"\";\\n            int count = 1;\\n            for(int j=1 ; j<s.length() ; j++)\\n            {\\n                if(s[j]!=s[j-1])\\n                {\\n                    t += count + \\'0\\';\\n                    t += s[j-1];\\n                    count = 1;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985543,
                "title": "c-iterative-solution",
                "content": "```\\nstring countAndSay(int n) {\\n            if(n==1) return \"1\";\\n            if(n==2) return \"11\";\\n            string s = \"11\";\\n            for(int i = 3;i<=n;i++)\\n            {\\n                    string temp = \"\";\\n                    s=s+\\'&\\';\\n                    int c = 1;\\n                    for(int j = 1;j<s.length();j++)\\n                    {\\n                            if(s[j] == s[j-1]) c++;\\n                            else\\n                            {\\n                                    temp+= to_string(c);\\n                                    temp+=s[j-1];\\n                                    c=1;\\n                            }\\n                            \\n                    }\\n                 s=temp;\\n            }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring countAndSay(int n) {\\n            if(n==1) return \"1\";\\n            if(n==2) return \"11\";\\n            string s = \"11\";\\n            for(int i = 3;i<=n;i++)\\n            {\\n                    string temp = \"\";\\n                    s=s+\\'&\\';\\n                    int c = 1;\\n                    for(int j = 1;j<s.length();j++)\\n                    {\\n                            if(s[j] == s[j-1]) c++;\\n                            else\\n                            {\\n                                    temp+= to_string(c);\\n                                    temp+=s[j-1];\\n                                    c=1;\\n                            }\\n                            \\n                    }\\n                 s=temp;\\n            }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 929252,
                "title": "js-one-line-solution-with-regex",
                "content": "```\\nreturn n === 1 ? \\'1\\' : countAndSay(n - 1).match(/(.)\\\\1*/g).map(match => match.length + match[0]).join(\\'\\');\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nreturn n === 1 ? \\'1\\' : countAndSay(n - 1).match(/(.)\\\\1*/g).map(match => match.length + match[0]).join(\\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413224,
                "title": "python-recursion-solution-12ms-99",
                "content": "```\\n# Runtime: 12 ms, faster than 99.00% of Python online submissions for Count and Say.\\n\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        if n <= 1:\\n            return \"1\"\\n        prevCountAndSay = self.countAndSay(n - 1)\\n        last = None\\n        occurrence = None\\n        output = \"\"\\n        for i in prevCountAndSay:\\n            if last is not None:\\n                if i == last:\\n                    occurrence += 1\\n                else:\\n                    output += str(occurrence) + last\\n                    occurrence = 1\\n            else:\\n                occurrence = 1\\n            last = i\\n        return output if occurrence is None else output + str(occurrence) + last\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Runtime: 12 ms, faster than 99.00% of Python online submissions for Count and Say.\\n\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        if n <= 1:\\n            return \"1\"\\n        prevCountAndSay = self.countAndSay(n - 1)\\n        last = None\\n        occurrence = None\\n        output = \"\"\\n        for i in prevCountAndSay:\\n            if last is not None:\\n                if i == last:\\n                    occurrence += 1\\n                else:\\n                    output += str(occurrence) + last\\n                    occurrence = 1\\n            else:\\n                occurrence = 1\\n            last = i\\n        return output if occurrence is None else output + str(occurrence) + last\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 379838,
                "title": "java-simple-solution-beats-100",
                "content": "We have to build up to the nth # and count how many occurences there are\\n```\\npublic String countAndSay(int n) {\\n        String s = \"1\"; // base \\n        for(int i = 1; i < n; i++){ // build the numbers from 1 to n\\n            s = nextNumber(s);\\n        }\\n        return s; // return result\\n    }\\n    private static String nextNumber(String s){ // our helper method\\n        StringBuilder result = new StringBuilder(); // create new StringBuilder\\n        for(int i = 0; i < s.length(); i++){ // take in previous # and prepare to run across it\\n            int count = 1; // initialize how many times we\\'ve seen a #\\n            while(i + 1 < s.length() && s.charAt(i) == s.charAt(i+1)){ // while we don\\'t run off the end \\n\\t\\t\\t// and we\\'re still on the same #\\n                i++; // increment our pointer\\n                count++; // increment how many times we\\'ve seen that #\\n            }\\n            result.append(count).append(s.charAt(i)); // and append the count and then the #\\n        }\\n        return result.toString(); // and finally return\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        String s = \"1\"; // base \\n        for(int i = 1; i < n; i++){ // build the numbers from 1 to n\\n            s = nextNumber(s);\\n        }\\n        return s; // return result\\n    }\\n    private static String nextNumber(String s){ // our helper method\\n        StringBuilder result = new StringBuilder(); // create new StringBuilder\\n        for(int i = 0; i < s.length(); i++){ // take in previous # and prepare to run across it\\n            int count = 1; // initialize how many times we\\'ve seen a #\\n            while(i + 1 < s.length() && s.charAt(i) == s.charAt(i+1)){ // while we don\\'t run off the end \\n\\t\\t\\t// and we\\'re still on the same #\\n                i++; // increment our pointer\\n                count++; // increment how many times we\\'ve seen that #\\n            }\\n            result.append(count).append(s.charAt(i)); // and append the count and then the #\\n        }\\n        return result.toString(); // and finally return\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376384,
                "title": "java-hint-and-solution",
                "content": "OK I found this question quite hard to understand and my inital solutions were \"timing out\" at n=5.  I realized I had not understood the problem correctly.\\n\\nMy tip is run the code for n=6 and n=7 to see more of the pattern - then it\\'s easier to understand the problem:\\n\\nn=1:   1\\nn=2:   11\\nn=3:   21\\nn=4:   1211\\nn=5:   111221\\nn=6:   312211\\nn=7:   13112221\\n\\nNotice how at n=5 the \\'111\\' is translated to \\'31\\' in the next iteration (at n=6).  \\'111\\' means \"3 ones\" so convert to the number of times that number occured, followed by the value (i.e. \\'31\\').  This helped me understand the problem correctly.\\n\\nHere\\'s my final solution below using recrsion:\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n == 0) return \"1\";\\n        if (n == 1) return \"1\";\\n        if (n == 2) return \"11\";\\n        \\n        String current = countAndSay(n-1);\\n        \\n        int pos = 1;\\n        char prev = current.charAt(0);\\n        int count = 1;\\n        \\n        StringBuffer sb = new StringBuffer();\\n        \\n        while (pos < current.length()) {\\n            if (current.charAt(pos) == prev) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(prev);\\n                count = 1;\\n                prev = current.charAt(pos);\\n            }\\n            \\n            if (pos+1 == current.length()) {\\n                sb.append(count);\\n                sb.append(prev);\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n == 0) return \"1\";\\n        if (n == 1) return \"1\";\\n        if (n == 2) return \"11\";\\n        \\n        String current = countAndSay(n-1);\\n        \\n        int pos = 1;\\n        char prev = current.charAt(0);\\n        int count = 1;\\n        \\n        StringBuffer sb = new StringBuffer();\\n        \\n        while (pos < current.length()) {\\n            if (current.charAt(pos) == prev) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(prev);\\n                count = 1;\\n                prev = current.charAt(pos);\\n            }\\n            \\n            if (pos+1 == current.length()) {\\n                sb.append(count);\\n                sb.append(prev);\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248980,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1:**\\n\\n**Algorithm:**\\n1. We compute the `N`<sup>th</sup> number by iteratively applying the given rule `N - 1` times.\\n1. Since we are counting digits, it is natural to use strings to represent the integers in the sequence. Specifically going from `i`<sup>th</sup> number to the `(i + 1)`<sup>th</sup> number entails scanning the digits from the most significant to least significant, counting the number of consecutive equal digits, and writing these counts.\\n\\n**Time complexity:** O(N * 2<sup>N</sup>)\\n- The precise time complexity is a function of the lengths of the terms, which is extremely hard to analyze.\\n- Each successive number can have at most twice as many digits as the previous number and this happens when all digits are different [`21` -> `1211`]. This means a maximum length number has length no more than 2<sup>N</sup>.\\n- Since there are `N` iterations and the work in each iteration is proportional to the length of the number computed in the iteration (which is 2<sup>N</sup>). So the simple bound on the time complexity is O(N * 2<sup>N</sup>)\\n\\n**Space complexity:** O(2<sup>N</sup>), space required for the `StringBuilder`. The generaed `N`<sup>th</sup> term for a number `N` can have a length of at most 2<sup>N</sup>.\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n\\n        for (int i = 1; i < n; i++) {\\n            s = nextNumber(s);\\n        }\\n        return s;\\n    }\\n\\n    private String nextNumber(String s) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int count = 1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {\\n                count++;\\n            } else {\\n                stringBuilder.append(count);\\n                stringBuilder.append(s.charAt(i));\\n                count = 1;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n\\n        for (int i = 1; i < n; i++) {\\n            s = nextNumber(s);\\n        }\\n        return s;\\n    }\\n\\n    private String nextNumber(String s) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int count = 1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {\\n                count++;\\n            } else {\\n                stringBuilder.append(count);\\n                stringBuilder.append(s.charAt(i));\\n                count = 1;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16274,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n        public String countAndSay(int n) {\\n            if(n <= 0) return \"\";\\n            String init = \"1\";\\n            while(n-- > 1){\\n                init = say(init);\\n            }\\n            return init;\\n        }\\n        public String say(String str){\\n            if(str.length() < 1) return \"\";\\n            int count = 1;\\n            StringBuilder sb = new StringBuilder();\\n            char c = str.charAt(0);\\n            if(str.length() == 1){\\n                sb.append(count);\\n                sb.append(c);\\n                return sb.toString();\\n            }\\n            for(int i = 1; i < str.length(); i ++){\\n                if(str.charAt(i) == str.charAt(i - 1)){\\n                    count ++;\\n                }else{\\n                    sb.append(count);\\n                    sb.append(c);\\n                    count = 1;\\n                    c = str.charAt(i);\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(c);\\n            return sb.toString();\\n        }\\n    }\\nA simple java solution, say function is to return the next item in the sequence using the previous item.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            if(n <= 0) return \"\";\\n            String init = \"1\";\\n            while(n-- > 1){\\n                init = say(init);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 16388,
                "title": "simple-java-solution",
                "content": "\\n    public String countAndSay(int n) {\\n        if (n <= 0) {return \"\";}\\n        String res = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            String pre = res;\\n            res = \"\";\\n            char temp = pre.charAt(0);\\n            int count = 1;\\n            for (int j = 1; j < pre.length(); j++) {\\n                if (pre.charAt(j) != temp) {\\n                    res = res + count + temp;\\n                    temp = pre.charAt(j);\\n                    count = 1;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            res = res + count + temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public String countAndSay(int n) {\\n        if (n <= 0) {return \"\";}\\n        String res = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            String pre = res;\\n            res = \"\";\\n            char temp = pre.charAt(0);\\n            int count = 1;\\n            for (int j = 1; j < pre.length(); j++) {\\n                if (pre.charAt(j) != temp) {\\n                    res = res + count + temp;\\n                    temp = pre.charAt(j);\\n                    count = 1;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            res = res + count + temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16244,
                "title": "accepted-python-solution-not-efficiency-but-easy-to-read",
                "content": "    class Solution:\\n    # @return a string\\n    def countAndSay(self, n):\\n        s = ['1']\\n        result = '1'\\n        # The n-th sequance, input 1 should output '1'\\n        for i in range(n-1):\\n            start = 0\\n            temp = []\\n            # Process one sequence, scan from start to end\\n            while start < len(s):\\n                count = 1\\n                next = start + 1\\n                # Scan until s[next] is different\\n                while next < len(s) and s[start] == s[next]:\\n                    next += 1\\n                    count += 1\\n                # Get the new items in\\n                temp.append(str(count))\\n                temp.append(s[start])\\n                # Start from next one\\n                start = next\\n            # Concatenate list into string, using \",\" as separator in default \\n            result = ''.join(temp)\\n            s = temp\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a string\\n    def countAndSay(self, n):\\n        s = ['1']\\n        result = '1'\\n        # The n-th sequance, input 1 should output '1'\\n        for i in range(n-1):\\n            start = 0\\n            temp = []\\n            # Process one sequence, scan from start to end\\n            while start < len(s):\\n                count = 1\\n                next = start + 1\\n                # Scan until s[next] is different\\n                while next < len(s) and s[start] == s[next]:\\n                    next += 1\\n                    count += 1\\n                # Get the new items in\\n                temp.append(str(count))\\n                temp.append(s[start])\\n                # Start from next one\\n                start = next\\n            # Concatenate list into string, using \",\" as separator in default \\n            result = ''.join(temp)\\n            s = temp\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 16471,
                "title": "9-line-solution-in-python",
                "content": "    class Solution:\\n    def countAndSay(self, n):\\n        say = '1'\\n        for i in xrange(n - 1):\\n            next = ''\\n            for item in [list(g) for k, g in itertools.groupby(say)]:\\n                next += str(len(item)) + str(item[0])\\n            say = next\\n        return say",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    def countAndSay(self, n):\\n        say = '1'\\n        for i in xrange(n - 1):\\n            next = ''\\n            for item in [list(g) for k, g in itertools.groupby(say)]:\\n                next += str(len(item)) + str(item[0])\\n            say = next\\n        return say",
                "codeTag": "Java"
            },
            {
                "id": 3884789,
                "title": "beginners-level-easy-solution-easy-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String val=\"1\";\\n        for (int i=0;i<n-1;i++)\\n        {\\n            char ch=val.charAt(0);\\n            StringBuilder sb=new StringBuilder();\\n            int count=1;\\n            for (int j=1;j<val.length();j++)\\n            {\\n                if (ch!=val.charAt(j))\\n                {\\n                    \\n                    sb.append(count);\\n                    sb.append(ch);\\n                    count=0;\\n                    ch=val.charAt(j);\\n                }\\n                count++;\\n            }\\n            sb.append(count);\\n            sb.append(ch);\\n            val=sb.toString();\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String val=\"1\";\\n        for (int i=0;i<n-1;i++)\\n        {\\n            char ch=val.charAt(0);\\n            StringBuilder sb=new StringBuilder();\\n            int count=1;\\n            for (int j=1;j<val.length();j++)\\n            {\\n                if (ch!=val.charAt(j))\\n                {\\n                    \\n                    sb.append(count);\\n                    sb.append(ch);\\n                    count=0;\\n                    ch=val.charAt(j);\\n                }\\n                count++;\\n            }\\n            sb.append(count);\\n            sb.append(ch);\\n            val=sb.toString();\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860139,
                "title": "simple-c-100-faster-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n*len) len = size of string returned in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for n recursion calls.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring fun (string str1 )\\n{\\n    str1 +=\" \"; //to capture the last count \\n    int len = str1.size();\\n    int count =1;\\n    string ans= \"\";\\n\\n    for ( int i =0; i< len-1 ;i++)\\n    {\\n        if(str1[i+1] == str1[i]) count++;\\n        else {\\n            ans+=(\\'0\\'+count);\\n            ans+=str1[i];\\n            count =1;\\n        }\\n    }\\n    return ans ;\\n}\\n\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        string x=fun(countAndSay(n-1));\\n        return x;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring fun (string str1 )\\n{\\n    str1 +=\" \"; //to capture the last count \\n    int len = str1.size();\\n    int count =1;\\n    string ans= \"\";\\n\\n    for ( int i =0; i< len-1 ;i++)\\n    {\\n        if(str1[i+1] == str1[i]) count++;\\n        else {\\n            ans+=(\\'0\\'+count);\\n            ans+=str1[i];\\n            count =1;\\n        }\\n    }\\n    return ans ;\\n}\\n\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        string x=fun(countAndSay(n-1));\\n        return x;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777236,
                "title": "easy-solution-by-using-loops-that-s-it-with-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        else if(n==2)\\n        return \"11\";\\n        string ans=\"11\";\\n        for(int i=3;i<=n;i++){\\n            string temp=\"\";\\n            ans+=\\'@\\';\\n            int count=1;\\n            for(int j=1;j<ans.size();j++){\\n                if(ans[j]!=ans[j-1]){\\n                    temp+=to_string(count);\\n                    temp+=ans[j-1];\\n                    count=1;\\n                }\\n                else\\n                count++;\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n/* UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        else if(n==2)\\n        return \"11\";\\n        string ans=\"11\";\\n        for(int i=3;i<=n;i++){\\n            string temp=\"\";\\n            ans+=\\'@\\';\\n            int count=1;\\n            for(int j=1;j<ans.size();j++){\\n                if(ans[j]!=ans[j-1]){\\n                    temp+=to_string(count);\\n                    temp+=ans[j-1];\\n                    count=1;\\n                }\\n                else\\n                count++;\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n/* UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740215,
                "title": "count-and-say-o-m-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar countAndSay = function (n) {\\n    let start = \"1\"\\n    while (--n) {\\n        let tempStart = \"\"\\n        let frequency = 1\\n        for (let index = 0; index < start.length; index++) {\\n            if (start[index] !== start[index + 1]) {\\n                tempStart += `${frequency}${start[index]}`\\n                frequency = 1\\n            } else {\\n                frequency += 1\\n            }\\n        }\\n        start = tempStart\\n    }\\n    return start\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function (n) {\\n    let start = \"1\"\\n    while (--n) {\\n        let tempStart = \"\"\\n        let frequency = 1\\n        for (let index = 0; index < start.length; index++) {\\n            if (start[index] !== start[index + 1]) {\\n                tempStart += `${frequency}${start[index]}`\\n                frequency = 1\\n            } else {\\n                frequency += 1\\n            }\\n        }\\n        start = tempStart\\n    }\\n    return start\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662639,
                "title": "easy-dynamic-programming-tabulation-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive method can take to much time complexity for big n values .\\nso use DP.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is very simple first if n==1 push \"1\" and for other value of n take previous value in a string then count the no. of same elements in string with maintaing then count as c and current value as curr then if there is a change push the value into string..\\ndo these even after the loop ends for the last value of c and curr.\\nafter that push that into the dp array..\\nreturn the dp[n-1];\\n.. this can be more simplified using memorization.\\n\\nIf found helpful please upvote\\n\\n# Complexity\\n- Time complexity:\\n- O(n) as array of n size is traversed\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) as array of n size is created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    vector<string>dp;\\npublic:\\nvoid func(int x)\\n    {\\n        string s = dp[x-1];\\n        string ans=\"\";\\n        int i, n= s.length();\\n        int curr=0,c=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0) \\n            {\\n                curr=s[i]-\\'0\\';\\n                c++;\\n            }\\n            else{\\n                if(s[i]!=s[i-1])\\n                {   \\n                   string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n                    c=1;\\n                    curr=s[i]-\\'0\\';\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n       string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n        dp[x]=ans;\\n    }\\n    string countAndSay(int n) {\\n        dp.resize(n);\\n        dp[0]=\"1\";\\n        for(int i=1;i<n;i++)\\n        {\\n            func(i);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<string>dp;\\npublic:\\nvoid func(int x)\\n    {\\n        string s = dp[x-1];\\n        string ans=\"\";\\n        int i, n= s.length();\\n        int curr=0,c=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0) \\n            {\\n                curr=s[i]-\\'0\\';\\n                c++;\\n            }\\n            else{\\n                if(s[i]!=s[i-1])\\n                {   \\n                   string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n                    c=1;\\n                    curr=s[i]-\\'0\\';\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n       string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n        dp[x]=ans;\\n    }\\n    string countAndSay(int n) {\\n        dp.resize(n);\\n        dp[0]=\"1\";\\n        for(int i=1;i<n;i++)\\n        {\\n            func(i);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288774,
                "title": "python-solution-dp-with-sample-output",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        dp = [ \"\" for i in range(0,n+1)]\\n        dp[1] = \"1 \"\\n        i = 2 ;\\n        while( i < n+1 ):\\n            print(f\\'i:{i} dp[{i-1}]:{dp[i-1]}\\')\\n            c = 0 \\n            for j in range(0,len(dp[i-1])-1):\\n                if( dp[i-1][j] == dp[i-1][j+1]):\\n                    c += 1;\\n                else:\\n                    dp[i] += chr(c+1+ord(\\'0\\')) + dp[i-1][j] ;\\n                    c=0;\\n            dp[i] += \\' \\';\\n            i +=1\\n            \\n\\n        return dp[-1][:-1];\\n\\n```\\n\\n```\\ni:2 dp[1]:1 \\ni:3 dp[2]:11 \\ni:4 dp[3]:21 \\ni:5 dp[4]:1211 \\ni:6 dp[5]:111221 \\ni:7 dp[6]:312211 \\ni:8 dp[7]:13112221 \\ni:9 dp[8]:1113213211 \\ni:10 dp[9]:31131211131221 \\ni:11 dp[10]:13211311123113112211 \\ni:12 dp[11]:11131221133112132113212221 \\ni:13 dp[12]:3113112221232112111312211312113211 \\ni:14 dp[13]:1321132132111213122112311311222113111221131221 \\ni:15 dp[14]:11131221131211131231121113112221121321132132211331222113112211\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        dp = [ \"\" for i in range(0,n+1)]\\n        dp[1] = \"1 \"\\n        i = 2 ;\\n        while( i < n+1 ):\\n            print(f\\'i:{i} dp[{i-1}]:{dp[i-1]}\\')\\n            c = 0 \\n            for j in range(0,len(dp[i-1])-1):\\n                if( dp[i-1][j] == dp[i-1][j+1]):\\n                    c += 1;\\n                else:\\n                    dp[i] += chr(c+1+ord(\\'0\\')) + dp[i-1][j] ;\\n                    c=0;\\n            dp[i] += \\' \\';\\n            i +=1\\n            \\n\\n        return dp[-1][:-1];\\n\\n```\n```\\ni:2 dp[1]:1 \\ni:3 dp[2]:11 \\ni:4 dp[3]:21 \\ni:5 dp[4]:1211 \\ni:6 dp[5]:111221 \\ni:7 dp[6]:312211 \\ni:8 dp[7]:13112221 \\ni:9 dp[8]:1113213211 \\ni:10 dp[9]:31131211131221 \\ni:11 dp[10]:13211311123113112211 \\ni:12 dp[11]:11131221133112132113212221 \\ni:13 dp[12]:3113112221232112111312211312113211 \\ni:14 dp[13]:1321132132111213122112311311222113111221131221 \\ni:15 dp[14]:11131221131211131231121113112221121321132132211331222113112211\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246378,
                "title": "beats-100-easy-basic-recursion-fastest-c",
                "content": "# Intuition\\n- the basic idea or intution behind this question is\\n- it\\'s just a recursion that has a base case of n=\"1\"\\n- after n=2 call for n-1 that means call for \"1\" , the result should return \"11\" \\n the first character is count of the second character of the string passed in call\\n- for n=3 (call(n-1) means for n==2) string for call =\"11\" it will return \"21\"\\n - it goes a follows until n\\n \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- create a say function , which return a string , it will always return a even length string in which every odd term will return the frequency of its consecutive even term\\n- the say(\"44455\")  should return \"3425\" it means there are 3 four\\'s and 2 five\\'s\\n- \\n```c++ []\\nstring say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\n```\\n- and after call form 1 to n\\n- return ur ans\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    string say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        string temp=\"1\";\\n        int k=1;\\n        while(k<n){\\n            temp = say(temp);\\n            k++;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```c++ []\\nstring say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\n```\n```\\nclass Solution {\\n    private:\\n    string say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        string temp=\"1\";\\n        int k=1;\\n        while(k<n){\\n            temp = say(temp);\\n            k++;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886415,
                "title": "fully-explained-append-the-count-o-n-java",
                "content": "# Problem says :\\n```\\nFind the n\\u2019th term in Look-and-say (Or Count and Say) Sequence.\\nThe look-and-say sequence is the sequence of the below integers: \\n1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, \\u2026 \\n```\\n# Approach :\\n```\\nHow is the above sequence generated? \\n\\nn\\u2019th term is generated by reading (n-1)\\u2019th term.\\n\\nThe first term is \"1\"\\n\\nSecond term is \"11\", generated by reading first term as \"One 1\" \\n(There is one 1 in previous term)\\n\\nThird term is \"21\", generated by reading second term as \"Two 1\"\\n\\nFourth term is \"1211\", generated by reading third term as \"One 2 One 1\" \\n\\nand so on\\n```\\n\\n# How to find n\\u2019th term? \\n```\\nInput: n = 3\\nOutput: 21\\n\\nInput: n = 5\\nOutput: 111221\\n\\nThe idea is simple, we generate all terms from 1 to n. First, \\ntwo terms are initialized as \\u201C1\\u201D and \\u201C11\\u201D, and all other terms\\nare generated using previous terms. To generate a term using the\\nprevious term, we scan the previous term. While scanning a term,\\nwe simply keep track of the count of all consecutive characters. \\nFor a sequence of the same characters, we append the count followed\\nby the character to generate the next term.\\n```\\n```\\nIf you find this solution easy to understand and helpful, then \\nplease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    public String countAndSay(int n) \\n    {\\n        // Base cases\\n        if(n==1)\\n          return \"1\";\\n        if(n==2)\\n          return \"11\";\\n        // Find n\\'th term by generating\\n        // all terms from 3 to n-1.\\n        // Every term is generated\\n        // using previous term\\n     \\n        // Initialize previous term\\n        String str=\"11\";\\n        for(int i=3;i<=n;i++)\\n        {\\n            // In below for loop, previous\\n            // character is processed in\\n            // current iteration. That is\\n            // why a dummy character is\\n            // added to make sure that loop\\n            // runs one extra iteration.\\n            str+=\\'$\\';\\n\\n            int len=str.length();\\n            int cnt=1; // Initialize count\\n                     // of matching chars\\n            String tmp=\"\";// Initialize i\\'th\\n                         // term in series\\n            char[] arr=str.toCharArray();\\n            // Process previous term\\n            // to find the next term\\n            for(int j=1;j<len;j++)\\n            {\\n                // If current character\\n                // doesn\\'t match\\n                if(arr[j]!=arr[j-1])\\n                {\\n                    // Append count of\\n                    // str[j-1] to temp\\n                    tmp += cnt + 0;\\n    \\n                    // Append str[j-1]\\n                    tmp += arr[j - 1];\\n    \\n                    // Reset count\\n                    cnt = 1;\\n                }\\n                // If matches, then increment\\n                // count of matching characters\\n                else\\n                  cnt++;  \\n            }\\n            // Update str\\n            str=tmp;\\n        }\\n       return str; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nFind the n\\u2019th term in Look-and-say (Or Count and Say) Sequence.\\nThe look-and-say sequence is the sequence of the below integers: \\n1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, \\u2026 \\n```\n```\\nHow is the above sequence generated? \\n\\nn\\u2019th term is generated by reading (n-1)\\u2019th term.\\n\\nThe first term is \"1\"\\n\\nSecond term is \"11\", generated by reading first term as \"One 1\" \\n(There is one 1 in previous term)\\n\\nThird term is \"21\", generated by reading second term as \"Two 1\"\\n\\nFourth term is \"1211\", generated by reading third term as \"One 2 One 1\" \\n\\nand so on\\n```\n```\\nInput: n = 3\\nOutput: 21\\n\\nInput: n = 5\\nOutput: 111221\\n\\nThe idea is simple, we generate all terms from 1 to n. First, \\ntwo terms are initialized as \\u201C1\\u201D and \\u201C11\\u201D, and all other terms\\nare generated using previous terms. To generate a term using the\\nprevious term, we scan the previous term. While scanning a term,\\nwe simply keep track of the count of all consecutive characters. \\nFor a sequence of the same characters, we append the count followed\\nby the character to generate the next term.\\n```\n```\\nIf you find this solution easy to understand and helpful, then \\nplease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public String countAndSay(int n) \\n    {\\n        // Base cases\\n        if(n==1)\\n          return \"1\";\\n        if(n==2)\\n          return \"11\";\\n        // Find n\\'th term by generating\\n        // all terms from 3 to n-1.\\n        // Every term is generated\\n        // using previous term\\n     \\n        // Initialize previous term\\n        String str=\"11\";\\n        for(int i=3;i<=n;i++)\\n        {\\n            // In below for loop, previous\\n            // character is processed in\\n            // current iteration. That is\\n            // why a dummy character is\\n            // added to make sure that loop\\n            // runs one extra iteration.\\n            str+=\\'$\\';\\n\\n            int len=str.length();\\n            int cnt=1; // Initialize count\\n                     // of matching chars\\n            String tmp=\"\";// Initialize i\\'th\\n                         // term in series\\n            char[] arr=str.toCharArray();\\n            // Process previous term\\n            // to find the next term\\n            for(int j=1;j<len;j++)\\n            {\\n                // If current character\\n                // doesn\\'t match\\n                if(arr[j]!=arr[j-1])\\n                {\\n                    // Append count of\\n                    // str[j-1] to temp\\n                    tmp += cnt + 0;\\n    \\n                    // Append str[j-1]\\n                    tmp += arr[j - 1];\\n    \\n                    // Reset count\\n                    cnt = 1;\\n                }\\n                // If matches, then increment\\n                // count of matching characters\\n                else\\n                  cnt++;  \\n            }\\n            // Update str\\n            str=tmp;\\n        }\\n       return str; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780507,
                "title": "c-beats-95-in-runtime-with-comments-beginner-s-solution",
                "content": "class Solution {\\npublic:\\n    \\n    string transform(string s)\\n    {\\n        char curr = s[0];\\n        int curr_freq = 1;\\n        string ans = \"\";\\n        \\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            /* If current character is same as \\n                the last we increase the frequency by 1 */\\n            if (s[i] == curr)   \\n            {    \\n                curr_freq++;\\n            }\\n            else\\n            {\\n                /* If new character is encountered then we add the last \\n                character\\'s frequency followed by the last character\\n                itself to the answer string*/\\n                \\n                ans += (char)(curr_freq + \\'0\\'); // adding Frequency to ans\\n                ans += (char)(curr);    //adding the character to the answer\\n                curr = s[i];\\n                curr_freq = 1;\\n            }\\n        }\\n        \\n        /* when we exit the loop the last character is \\n        yet to be added to the string since the \"else\"\\n        block won\\'t be executed for the last character*/\\n        \\n        ans += (char)(curr_freq + \\'0\\');\\n        ans += (char)(curr);\\n        \\n        return ans;\\n    }\\n    \\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        /*Recursively Calling for N-1 till we reach N = 1\\n        And in each recursive call we call the function \\n        \"transform\" which transforms the string into \\n        a count and say form. Then we return the transformed \\n        string as our answer for that value of N*/\\n        \\n        string x = transform(countAndSay(n-1));\\n        \\n        return x;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    string transform(string s)\\n    {\\n        char curr = s[0];\\n        int curr_freq = 1;\\n        string ans = \"\";\\n        \\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            /* If current character is same as \\n                the last we increase the frequency by 1 */\\n            if (s[i] == curr)   \\n            {    \\n                curr_freq++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2718181,
                "title": "c-easy-to-understand-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n        {\\n            return \"1\";\\n        }\\n\\n        string s = countAndSay(n-1);\\n        string ans = \"\";\\n        int count = 1;\\n        char prev = s[0], c;\\n\\n        for(int i = 1; i < s.size(); i++)\\n        {\\n            if(prev == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans.push_back(\\'0\\'+count);\\n                ans.push_back(prev);\\n                prev = s[i];\\n                count = 1;\\n            }\\n        }\\n        ans.push_back(\\'0\\'+count);\\n        ans.push_back(prev);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n        {\\n            return \"1\";\\n        }\\n\\n        string s = countAndSay(n-1);\\n        string ans = \"\";\\n        int count = 1;\\n        char prev = s[0], c;\\n\\n        for(int i = 1; i < s.size(); i++)\\n        {\\n            if(prev == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans.push_back(\\'0\\'+count);\\n                ans.push_back(prev);\\n                prev = s[i];\\n                count = 1;\\n            }\\n        }\\n        ans.push_back(\\'0\\'+count);\\n        ans.push_back(prev);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718061,
                "title": "easy-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        String ans=helper(countAndSay(n-1));\\n        return ans;\\n    }\\n\\t\\n\\tprivate static String helper(String str) {\\n\\t\\tString ans=\"\";\\n\\t\\tfor(int i=str.length()-1;i>=0;i--) {\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(i>0) {\\n\\t\\t\\t\\tif(str.charAt(i)==str.charAt(i-1)) {\\n\\t\\t\\t\\t\\ti--;\\n                    count++;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tans=Integer.toString(count)+str.charAt(i)+ans;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```\\n\\nmore optimize way is welcomed",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        String ans=helper(countAndSay(n-1));\\n        return ans;\\n    }\\n\\t\\n\\tprivate static String helper(String str) {\\n\\t\\tString ans=\"\";\\n\\t\\tfor(int i=str.length()-1;i>=0;i--) {\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(i>0) {\\n\\t\\t\\t\\tif(str.charAt(i)==str.charAt(i-1)) {\\n\\t\\t\\t\\t\\ti--;\\n                    count++;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tans=Integer.toString(count)+str.charAt(i)+ans;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717786,
                "title": "java-simple-recursive-solution-with-explanation-and-comments",
                "content": "**Intution**\\n\\n* We know that when n = 1 then answer is \"1\", which is the base case.\\n* Now if we have to make the **count and say string** we have to start preparing the string form n = 1 to any given n.\\n* example if n = 5 : Recursion explaination\\n\\t* we have to calculate 5 using the prev number 4 -> \"111221\" for n = 5.\\n\\t* 4 will created from 3 -> \"1211\" for n = 4.\\n\\t* 3 from 2 -> \"21\" for n = 3.\\n\\t* 2 from 1 -> \"11\" for n = 2.\\n\\t* At last for 1 -> \"1\" for n = 1.\\n\\n**Time complexity will be O(N)** , where n = the input number.\\n\\n```\\npublic String countAndSay(int n) {\\n        // Recursive function to give us output.\\n        return solve(n);\\n        \\n    }\\n    \\n    public String solve(int n){\\n        \\n\\t\\t// Base case when our n == 1 we have to return \"1\".\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        \\n\\t\\t// We will make recursion call to \"n - 1\" and get the output of previous number.\\t\\t\\n        String prev = solve(n - 1);\\n        \\n\\t\\t// Count will be 1 at the starting because we are going to iterate the string from 1st index.\\n        int count = 1;\\n        \\n\\t\\t// To store the current count and say string.\\n\\t\\t// The answer will be created in the postorder because we need the previous result.\\n\\t\\t// postorder means after all the previous recursion calls is completed till here.\\n        StringBuilder ans = new StringBuilder();\\n        \\n\\t\\t// index\\n        int i = 1;        \\n        \\n\\t\\t\\n        while(i < prev.length()){\\n\\t\\t\\n\\t\\t// We have to compare previous and current characters of the string \"prev\" \\n\\t\\t\\n            char prevChar = prev.charAt(i - 1);\\n            char currChar = prev.charAt(i);\\n            \\n\\t\\t// When prevChar != currChar we have add it our answer first add the \"count\" and then add the \"prevChar\".\\n            if(prevChar != currChar){\\n                ans.append(count);\\n                ans.append(prevChar);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Reset the count.\\n                count = 1;\\n            } else {\\n\\t\\t\\t\\t// Increement count if prevChar and currChar is equal.\\n                count++;\\n            }\\n            \\n\\t\\t\\t// Increement the index.\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// At the last when our iteration is over add the count and lastChar of the string \"prev\" to the answer.\\n\\t\\t// because our while loop will run till last index and it can\\'t able to compare the lastChar with the next char\\n\\t\\t// Therefore the lastChar is not included in the answer.\\n        ans.append(count);\\n        ans.append(prev.charAt(prev.length() - 1));\\n        \\n\\t\\t// return the answer.\\n        return ans.toString();\\n    }\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        // Recursive function to give us output.\\n        return solve(n);\\n        \\n    }\\n    \\n    public String solve(int n){\\n        \\n\\t\\t// Base case when our n == 1 we have to return \"1\".\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        \\n\\t\\t// We will make recursion call to \"n - 1\" and get the output of previous number.\\t\\t\\n        String prev = solve(n - 1);\\n        \\n\\t\\t// Count will be 1 at the starting because we are going to iterate the string from 1st index.\\n        int count = 1;\\n        \\n\\t\\t// To store the current count and say string.\\n\\t\\t// The answer will be created in the postorder because we need the previous result.\\n\\t\\t// postorder means after all the previous recursion calls is completed till here.\\n        StringBuilder ans = new StringBuilder();\\n        \\n\\t\\t// index\\n        int i = 1;        \\n        \\n\\t\\t\\n        while(i < prev.length()){\\n\\t\\t\\n\\t\\t// We have to compare previous and current characters of the string \"prev\" \\n\\t\\t\\n            char prevChar = prev.charAt(i - 1);\\n            char currChar = prev.charAt(i);\\n            \\n\\t\\t// When prevChar != currChar we have add it our answer first add the \"count\" and then add the \"prevChar\".\\n            if(prevChar != currChar){\\n                ans.append(count);\\n                ans.append(prevChar);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Reset the count.\\n                count = 1;\\n            } else {\\n\\t\\t\\t\\t// Increement count if prevChar and currChar is equal.\\n                count++;\\n            }\\n            \\n\\t\\t\\t// Increement the index.\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// At the last when our iteration is over add the count and lastChar of the string \"prev\" to the answer.\\n\\t\\t// because our while loop will run till last index and it can\\'t able to compare the lastChar with the next char\\n\\t\\t// Therefore the lastChar is not included in the answer.\\n        ans.append(count);\\n        ans.append(prev.charAt(prev.length() - 1));\\n        \\n\\t\\t// return the answer.\\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716914,
                "title": "easy-java-solution-with-explanation-faster-than-93-92",
                "content": "![image](https://assets.leetcode.com/users/images/1d60139f-4d75-419b-b33c-3cbe546362b7_1666070354.8036132.png)\\n\\n# Explanation: \\nThe question is very simple when you understand it.\\n\\nEvery number **n** will start from **1** . \\nThe base case is: encoding of **1** is **1**.\\n\\nThen we go to the next number that is **2**. If we wanna know this result, we need to count the previous result, which is \"**1**\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is **foo(2) = \"11\"**, so there are 2 \"1\" in the result, so this time the result is **\"21\"**.\\nNext for number **3**, we know last result was \"21\", which means there are one \"2\"s and one \"1\"s, the result will be **foo(3) = \"1211\"**\\n....\\nNow, for your understanding try and solve this: if the **(n-1) th** result is **\"122211233333127755\"**, what is the **n th** result? Let\\'s count it. one \"1\"s, three \"2\"s, two \"1\"s, one \"2\" , five \"3\"s , one \"1\"s , one \"2\"s, two \"7\"s, and two \"5\"s. Therefore, the result is **\"113221125311122725\"**\\nSo, if we wanna know the **n th result, we just need to count the (n - 1)th result, and the first result is \"1\"**. The calculation for each letter will follow the pattern **(count)(letter)**.\\n\\n# Solution:\\n\\n1. Recursive approach:\\n\\n```\\nclass Solution {\\n    Map<Integer, String> say = new HashMap<>();\\n    public String countAndSay(int n) {\\n        say.put(1, \"1\");\\n        say.put(2, \"11\");\\n        String res = helper(n);\\n        return res;\\n    }\\n    private String helper(int n){\\n        if(say.containsKey(n))\\n            return say.get(n);\\n        StringBuilder prevPattern = new StringBuilder(helper(n-1));\\n        StringBuilder currentPattern = new StringBuilder();\\n        int count=1;\\n        for(int i=1; i<prevPattern.length(); i++){\\n            if(prevPattern.charAt(i-1)!=prevPattern.charAt(i)){\\n                currentPattern.append(count).append(prevPattern.charAt(i-1));\\n\\t\\t\\t\\t// reset the count to 1 for new characters\\n                count=1;\\n            }\\n            else{\\n\\t\\t\\t\\t// update the count\\n                count++;\\n            }\\n        }\\n        // we didn\\'t check the last character..so, need to check\\n        currentPattern.append(count).append(prevPattern.charAt(prevPattern.length()-1));\\n        say.put(n, currentPattern.toString());\\n        return say.get(n);\\n    }\\n}\\n```\\n\\n<hr>\\n\\n2. Iterative Solution:\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n        if(n==3){\\n            return \"21\";\\n        }\\n        String s = countAndSay(n-1);\\n        int start = 0; // starting index\\n        int count = 1;\\n        StringBuilder builder = new StringBuilder();\\n        while(start < s.length()){\\n            char prev = s.charAt(start);\\n            int index = start+1;\\n            while(index<s.length() && prev == s.charAt(index)){\\n                count++;\\n                index++;\\n            }\\n            builder.append(count);//add counter to back of string\\n            builder.append(prev); // add prev char after counter\\n            start = index; // update start to last index that had differnt char\\n            count = 1; // update count var back to 1\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, String> say = new HashMap<>();\\n    public String countAndSay(int n) {\\n        say.put(1, \"1\");\\n        say.put(2, \"11\");\\n        String res = helper(n);\\n        return res;\\n    }\\n    private String helper(int n){\\n        if(say.containsKey(n))\\n            return say.get(n);\\n        StringBuilder prevPattern = new StringBuilder(helper(n-1));\\n        StringBuilder currentPattern = new StringBuilder();\\n        int count=1;\\n        for(int i=1; i<prevPattern.length(); i++){\\n            if(prevPattern.charAt(i-1)!=prevPattern.charAt(i)){\\n                currentPattern.append(count).append(prevPattern.charAt(i-1));\\n\\t\\t\\t\\t// reset the count to 1 for new characters\\n                count=1;\\n            }\\n            else{\\n\\t\\t\\t\\t// update the count\\n                count++;\\n            }\\n        }\\n        // we didn\\'t check the last character..so, need to check\\n        currentPattern.append(count).append(prevPattern.charAt(prevPattern.length()-1));\\n        say.put(n, currentPattern.toString());\\n        return say.get(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n        if(n==3){\\n            return \"21\";\\n        }\\n        String s = countAndSay(n-1);\\n        int start = 0; // starting index\\n        int count = 1;\\n        StringBuilder builder = new StringBuilder();\\n        while(start < s.length()){\\n            char prev = s.charAt(start);\\n            int index = start+1;\\n            while(index<s.length() && prev == s.charAt(index)){\\n                count++;\\n                index++;\\n            }\\n            builder.append(count);//add counter to back of string\\n            builder.append(prev); // add prev char after counter\\n            start = index; // update start to last index that had differnt char\\n            count = 1; // update count var back to 1\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716807,
                "title": "c-short-simple-solution-for-beginners-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        \\n        string res = \"11\";\\n        \\n        for(int i=3;i<=n;i++)                     // outer loop for reaching to the Nth integer\\n        {\\n            string curr = \"\";                     // for storing the count and say of the current integer\\n            res += \"*\";                           // add * because we check for j-1 so when we reach to the last , we need to add last value count and say as well\\n            int cnt = 1;                          // curr value count\\n            \\n            for(int j=1;j<res.length();j++)       // loop over the prev value count and say\\n            {\\n                if(res[j]==res[j-1])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    curr += to_string(cnt);        // if not matching then addup the count\\n                    curr += res[j-1];              // that int\\n                    cnt = 1;                       // reset cnt as 1 for next value\\n                }\\n            }\\n            res = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        \\n        string res = \"11\";\\n        \\n        for(int i=3;i<=n;i++)                     // outer loop for reaching to the Nth integer\\n        {\\n            string curr = \"\";                     // for storing the count and say of the current integer\\n            res += \"*\";                           // add * because we check for j-1 so when we reach to the last , we need to add last value count and say as well\\n            int cnt = 1;                          // curr value count\\n            \\n            for(int j=1;j<res.length();j++)       // loop over the prev value count and say\\n            {\\n                if(res[j]==res[j-1])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    curr += to_string(cnt);        // if not matching then addup the count\\n                    curr += res[j-1];              // that int\\n                    cnt = 1;                       // reset cnt as 1 for next value\\n                }\\n            }\\n            res = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716773,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        \\n        def mapToCntArr(n):\\n            if n == 1:\\n                return [[1,1]]\\n            tmp = str(n)\\n            cnt = 1\\n            res = []\\n            for i in range(1,len(tmp)):\\n                if tmp[i] == tmp[i-1]:\\n                    cnt += 1\\n                else:\\n                    res.append([tmp[i-1],cnt])\\n                    cnt = 1\\n            res.append([tmp[-1],cnt])\\n            return res\\n        \\n        def pairsToInteger(arr):\\n            tmp = \"\"\\n            for dig , freq in arr:\\n                tmp += str(freq) + str(dig)\\n            return tmp\\n        \\n        ans = \"1\"\\n        # print(mapToCntArr(12345))\\n        for i in range(n-1):\\n            arrOfPairs = mapToCntArr(ans)\\n            ans = pairsToInteger(arrOfPairs)\\n            # print(arrOfPairs,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        \\n        def mapToCntArr(n):\\n            if n == 1:\\n                return [[1,1]]\\n            tmp = str(n)\\n            cnt = 1\\n            res = []\\n            for i in range(1,len(tmp)):\\n                if tmp[i] == tmp[i-1]:\\n                    cnt += 1\\n                else:\\n                    res.append([tmp[i-1],cnt])\\n                    cnt = 1\\n            res.append([tmp[-1],cnt])\\n            return res\\n        \\n        def pairsToInteger(arr):\\n            tmp = \"\"\\n            for dig , freq in arr:\\n                tmp += str(freq) + str(dig)\\n            return tmp\\n        \\n        ans = \"1\"\\n        # print(mapToCntArr(12345))\\n        for i in range(n-1):\\n            arrOfPairs = mapToCntArr(ans)\\n            ans = pairsToInteger(arrOfPairs)\\n            # print(arrOfPairs,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716682,
                "title": "python-classic-count-and-say-problem-99-faster-fastest-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1: return \\'1\\'\\n        \\n        res = [\\'1\\']\\n        for i in range(n-1):\\n            i = 0\\n            s = res[-1]\\n            curr_s = \\'\\'\\n            j = 0\\n            while i<len(s):\\n                c = 0\\n                while j<len(s) and s[i] == s[j]:\\n                    c+=1\\n                    j+=1\\n                curr_s += str(c)\\n                curr_s += str(s[i])\\n                i = j\\n                \\n            res.append(curr_s)\\n        \\n        return res[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1: return \\'1\\'\\n        \\n        res = [\\'1\\']\\n        for i in range(n-1):\\n            i = 0\\n            s = res[-1]\\n            curr_s = \\'\\'\\n            j = 0\\n            while i<len(s):\\n                c = 0\\n                while j<len(s) and s[i] == s[j]:\\n                    c+=1\\n                    j+=1\\n                curr_s += str(c)\\n                curr_s += str(s[i])\\n                i = j\\n                \\n            res.append(curr_s)\\n        \\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716342,
                "title": "js-2-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/count-and-say.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    let s = \\'1\\';\\n    \\n  while (n > 1) {\\n    let count = 0;\\n    let next = \\'\\';\\n\\n    for (let i = 0; i <= s.length; i++) {\\n      if (i === s.length || (i > 0 && s[i] !== s[i - 1])) {\\n        next += count + s[i - 1]; // Say\\n        count = 0;\\n      }\\n\\n      count++; // Count\\n    }\\n\\n    s = next;\\n    n--;\\n  }\\n\\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    let s = \\'1\\';\\n    \\n  while (n > 1) {\\n    let count = 0;\\n    let next = \\'\\';\\n\\n    for (let i = 0; i <= s.length; i++) {\\n      if (i === s.length || (i > 0 && s[i] !== s[i - 1])) {\\n        next += count + s[i - 1]; // Say\\n        count = 0;\\n      }\\n\\n      count++; // Count\\n    }\\n\\n    s = next;\\n    n--;\\n  }\\n\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716224,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> fun(string &digit)\\n    {\\n        vector<pair<int,int>> ans;\\n        if(digit.size()==1) \\n        {\\n            ans.push_back({1,1});\\n            return ans;\\n        }\\n        char prev=digit[0];\\n        int cnt=0;\\n        int i=0;\\n        while(i<digit.size())\\n        {\\n            if(digit[i]==prev)\\n                cnt++;\\n            else\\n            {\\n                ans.push_back({cnt,prev-\\'0\\'});\\n                cnt=0;\\n                prev=digit[i];\\n                i--;\\n            }\\n            i++;\\n        }\\n        ans.push_back({cnt,prev-\\'0\\'});\\n        return ans;\\n    }\\n    string count_And_Say(vector<pair<int,int>> &digit)\\n    {\\n        string ans=\"\";\\n        for(auto &it:digit)\\n        {\\n            int temp=it.first*10+it.second;\\n            string s1=to_string(temp);\\n            ans+=s1;\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        string digit=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<pair<int,int>> ans=fun(digit);\\n            digit=\"\";\\n            digit=count_And_Say(ans);\\n        }\\n        return digit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> fun(string &digit)\\n    {\\n        vector<pair<int,int>> ans;\\n        if(digit.size()==1) \\n        {\\n            ans.push_back({1,1});\\n            return ans;\\n        }\\n        char prev=digit[0];\\n        int cnt=0;\\n        int i=0;\\n        while(i<digit.size())\\n        {\\n            if(digit[i]==prev)\\n                cnt++;\\n            else\\n            {\\n                ans.push_back({cnt,prev-\\'0\\'});\\n                cnt=0;\\n                prev=digit[i];\\n                i--;\\n            }\\n            i++;\\n        }\\n        ans.push_back({cnt,prev-\\'0\\'});\\n        return ans;\\n    }\\n    string count_And_Say(vector<pair<int,int>> &digit)\\n    {\\n        string ans=\"\";\\n        for(auto &it:digit)\\n        {\\n            int temp=it.first*10+it.second;\\n            string s1=to_string(temp);\\n            ans+=s1;\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        string digit=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<pair<int,int>> ans=fun(digit);\\n            digit=\"\";\\n            digit=count_And_Say(ans);\\n        }\\n        return digit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261946,
                "title": "c-easy-simple-solution-count-and-say",
                "content": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n       string s=\"1\",ns;\\n        for(int i=2;i<=n;++i){\\n            for(int j=0;j<s.size();++j){\\n                int freq=1;\\n                while(j+1<s.size() && s[j+1]==s[j]){\\n                    ++freq;\\n                    ++j;\\n                }\\n                ns+=to_string(freq)+s[j];\\n            }\\n            s=ns;\\n            ns.clear();\\n        }\\n        return s;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n       string s=\"1\",ns;\\n        for(int i=2;i<=n;++i){\\n            for(int j=0;j<s.size();++j){\\n                int freq=1;\\n                while(j+1<s.size() && s[j+1]==s[j]){\\n                    ++freq;\\n                    ++j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2160802,
                "title": "easy-explanation-in-c-with-given-algorithm",
                "content": "I guess you too thought the same after reading the question : \"what the f-ck wrong with this question\" but belive there is nothing much to do after understanding it once  \\n1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n\\nits a recursive function to find a string with a similar type of pattern for n times \\n\\nlets understand with an example n=6\\nwe start from n=1\\nquestion says we have the string \"1\" \\nnow, for second iteration n=2 and s=\"1\" get from previous iteration\\nwe have the string s=\"1\" , in which we can count how many times the first character i.e. the frequency of the character (that is one) is present store both frequency and character in the temporary string res (\"11\") where first character is frequency and second is the character itself so the iteration shifts to next \\n\\nnow , n=3  we have s=\"11\"\\nso repeat the process extract first character count the consecutive frequence and store it in a variable i.e count=2 , update the string res(\"21\") and shifted to the next iteration \\n\\nfor n=4 ,we have s=\"21\"\\ncount the first character which is \\'2\\' we have one time update the string res=\"12\" (here we can say we have 2 one times ) now count the second character \\'1\\' which we have only one time so add it to string res=\"12\" + \"11\"  and go to next iteration \\n\\nn=5, and s=\"1211\"\\ncount first character \\'1\\' we have one times --> update res=res+\"11\"\\nsecond character \\'2\\' we have one times -->update res=res+\"12\"\\nthird character \\'1\\' we have two times --> update res=res+\"21\"\\n\\nso, final answer is s=\"111221\"\\nso i guess you got the drill so calculate yourself for n=6,7 etc...\\n\\n\\nhere\\'s the code :\\n\\n\\tstring countAndSay(int n)\\n\\t{\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn \"1\";\\n\\t\\t\\tstring s=countAndSay(n-1);\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tchar ch=s[0];int count =1;\\n\\t\\t\\tfor(int i=1;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch==s[i])\\n\\t\\t\\t\\t\\tcount ++;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres+=to_string(count );\\n\\t\\t\\t\\t\\tres+=ch;\\n\\t\\t\\t\\t\\tch=s[i];\\n\\t\\t\\t\\t\\tcount=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tres+=to_string(count);\\n\\t\\t\\tres+=ch;\\n\\t\\t\\treturn res;\\n        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "I guess you too thought the same after reading the question : \"what the f-ck wrong with this question\" but belive there is nothing much to do after understanding it once  \\n1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n\\nits a recursive function to find a string with a similar type of pattern for n times \\n\\nlets understand with an example n=6\\nwe start from n=1\\nquestion says we have the string \"1\" \\nnow, for second iteration n=2 and s=\"1\" get from previous iteration\\nwe have the string s=\"1\" , in which we can count how many times the first character i.e. the frequency of the character (that is one) is present store both frequency and character in the temporary string res (\"11\") where first character is frequency and second is the character itself so the iteration shifts to next \\n\\nnow , n=3  we have s=\"11\"\\nso repeat the process extract first character count the consecutive frequence and store it in a variable i.e count=2 , update the string res(\"21\") and shifted to the next iteration \\n\\nfor n=4 ,we have s=\"21\"\\ncount the first character which is \\'2\\' we have one time update the string res=\"12\" (here we can say we have 2 one times ) now count the second character \\'1\\' which we have only one time so add it to string res=\"12\" + \"11\"  and go to next iteration \\n\\nn=5, and s=\"1211\"\\ncount first character \\'1\\' we have one times --> update res=res+\"11\"\\nsecond character \\'2\\' we have one times -->update res=res+\"12\"\\nthird character \\'1\\' we have two times --> update res=res+\"21\"\\n\\nso, final answer is s=\"111221\"\\nso i guess you got the drill so calculate yourself for n=6,7 etc...\\n\\n\\nhere\\'s the code :\\n\\n\\tstring countAndSay(int n)\\n\\t{\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn \"1\";\\n\\t\\t\\tstring s=countAndSay(n-1);\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tchar ch=s[0];int count =1;\\n\\t\\t\\tfor(int i=1;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch==s[i])\\n\\t\\t\\t\\t\\tcount ++;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres+=to_string(count );\\n\\t\\t\\t\\t\\tres+=ch;\\n\\t\\t\\t\\t\\tch=s[i];\\n\\t\\t\\t\\t\\tcount=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tres+=to_string(count);\\n\\t\\t\\tres+=ch;\\n\\t\\t\\treturn res;\\n        \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1851876,
                "title": "simple-python-solution-with-explaination",
                "content": "the main reason for adding \"#\" at end because the last char will not be ever equal to \"#\" while comparing so we start with first string as \"1#\" and we iterate n-1 times since already we taken 1 time \"1\" into consideration and then we initialize the count as 1 and a temp variable and we run the a loop until the length of array -1 because we will compare the current character and its next character if they are same we will just increment the count else we will add the count and the character to temp string and make c as 1 then this pattern repeats if we dont keep \"#\" at end then the last character will not be checked and its a problem though writing out side for loop we can solve but by adding \"#\" this character makes our code look lot simpler!\\noutside the for loop ans will be replaced with temp variable and \"#\" and decrement the n count when n==1 the while will be ended then we return ans string upto last before since the last charcater consists of \"#\".\\n\\n```\\n        ans=\"1#\"\\n        while n-1:\\n            c=1\\n            temp=\"\"\\n            for i in range(len(ans)-1):\\n                if ans[i]==ans[i+1]:\\n                    c+=1\\n                else:\\n                    temp+=str(c)\\n                    temp+=ans[i]\\n                    c=1\\n            ans=temp+\"#\"\\n            n-=1\\n        return ans[:-1]\\n```\\n\\n**PLEASE UPVOTE IF U FIND THIS AS HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n        ans=\"1#\"\\n        while n-1:\\n            c=1\\n            temp=\"\"\\n            for i in range(len(ans)-1):\\n                if ans[i]==ans[i+1]:\\n                    c+=1\\n                else:\\n                    temp+=str(c)\\n                    temp+=ans[i]\\n                    c=1\\n            ans=temp+\"#\"\\n            n-=1\\n        return ans[:-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705398,
                "title": "simplest-program-using-recursion-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        else {\\n            string x = countAndSay(n-1);                    // recursion\\n            string res = \"\";                                // result will be appended in this\\n            char temp = x[0];                               // storing first character of the string\\n            int count = 0;\\n            for(int i = 0; i < x.size(); i++) {\\n                if(temp == x[i])                            // checking the number of times the will appear continuously\\n                    count++;\\n                else {\\n                    res += to_string(count) + temp;         // when another number arrives, append the previous number\\n                    temp = x[i];                            // update temp\\n                    count = 1;                              // count the occurence of the new number\\n                }\\n            }\\n            res += to_string(count) + temp;                 // to append the last number\\n            return res;\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        else {\\n            string x = countAndSay(n-1);                    // recursion\\n            string res = \"\";                                // result will be appended in this\\n            char temp = x[0];                               // storing first character of the string\\n            int count = 0;\\n            for(int i = 0; i < x.size(); i++) {\\n                if(temp == x[i])                            // checking the number of times the will appear continuously\\n                    count++;\\n                else {\\n                    res += to_string(count) + temp;         // when another number arrives, append the previous number\\n                    temp = x[i];                            // update temp\\n                    count = 1;                              // count the occurence of the new number\\n                }\\n            }\\n            res += to_string(count) + temp;                 // to append the last number\\n            return res;\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503718,
                "title": "python-iterative-solution-95-75-run-time-99-88-space",
                "content": "I have been seeing a lot of solutions here, but they were mostly recursive. Personally, I believe an iterative way would be easier to read, and take up less space in the stack\\n\\nWithout further ado, here\\'s my solution:\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        curr_string = \"1\"\\n        for iteration in range(2, n+1):\\n            prev_char = curr_string[0]\\n            count = 0\\n            \\n            new_string = \"\"\\n            \\n            for curr_char in curr_string:\\n                if curr_char == prev_char:\\n                    count += 1\\n                else:\\n                    new_string += str(count)\\n                    new_string += prev_char\\n                    prev_char = curr_char\\n                    count = 1\\n                    prev_char = curr_char\\n\\t\\t\\t\\t\\t\\n            new_string += str(count)\\n            new_string += prev_char\\n            curr_string = new_string\\n\\n        return curr_string\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        curr_string = \"1\"\\n        for iteration in range(2, n+1):\\n            prev_char = curr_string[0]\\n            count = 0\\n            \\n            new_string = \"\"\\n            \\n            for curr_char in curr_string:\\n                if curr_char == prev_char:\\n                    count += 1\\n                else:\\n                    new_string += str(count)\\n                    new_string += prev_char\\n                    prev_char = curr_char\\n                    count = 1\\n                    prev_char = curr_char\\n\\t\\t\\t\\t\\t\\n            new_string += str(count)\\n            new_string += prev_char\\n            curr_string = new_string\\n\\n        return curr_string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374730,
                "title": "simple-c-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:   \\n    string countAndSay(int p) {\\n        \\n        if(p == 1)  return \"1\";\\n        \\n        string curr = \"\";\\n        string prev = countAndSay(p-1);\\n        int c = 0;\\n        \\n        for(int i = 0; i < prev.size(); i++){\\n            c += 1;\\n            if(i == prev.size()-1 || prev[i] != prev[i+1]){\\n                curr += to_string(c);\\n                curr += prev[i];\\n                c = 0;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    string countAndSay(int p) {\\n        \\n        if(p == 1)  return \"1\";\\n        \\n        string curr = \"\";\\n        string prev = countAndSay(p-1);\\n        int c = 0;\\n        \\n        for(int i = 0; i < prev.size(); i++){\\n            c += 1;\\n            if(i == prev.size()-1 || prev[i] != prev[i+1]){\\n                curr += to_string(c);\\n                curr += prev[i];\\n                c = 0;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292720,
                "title": "python-3-easy-recursion-88-faster",
                "content": "```\\nclass Solution:\\n    def rec(self, s, n):\\n        \\n        count = 0\\n        ans = \\'\\'\\n        prev = \\'\\'\\n        i = 0\\n        print(f\\'n={n}\\')\\n        while i < len(s):\\n            \\n            if s[i] == prev:\\n                count +=1\\n            else:\\n                if count != 0:\\n                    ans += (str(count) + prev)\\n                count = 1\\n                prev = s[i]\\n            i+=1\\n        ans += (str(count)+prev)\\n        \\n        if n == 1:\\n            return ans\\n        else:\\n            return self.rec(ans, n-1)\\n    \\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.rec(\\'1\\', n-1)\\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rec(self, s, n):\\n        \\n        count = 0\\n        ans = \\'\\'\\n        prev = \\'\\'\\n        i = 0\\n        print(f\\'n={n}\\')\\n        while i < len(s):\\n            \\n            if s[i] == prev:\\n                count +=1\\n            else:\\n                if count != 0:\\n                    ans += (str(count) + prev)\\n                count = 1\\n                prev = s[i]\\n            i+=1\\n        ans += (str(count)+prev)\\n        \\n        if n == 1:\\n            return ans\\n        else:\\n            return self.rec(ans, n-1)\\n    \\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.rec(\\'1\\', n-1)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274868,
                "title": "0-ms-c-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) {\\n            return \"1\";\\n        }\\n\\t\\t\\n        if(n==2) {\\n            return \"11\";\\n        }\\n        \\n        else {\\n\\t\\t\\n            string str = countAndSay(n-1);\\n            int i = 0;\\n            string res = \"\";\\n\\t\\t\\t\\n            while(i < str.length()) {\\n\\t\\t\\t\\n                int count = 0;\\n                char digit = str.at(i);\\n\\t\\t\\t\\t\\n                while(i< str.length() && str.at(i) == digit) {\\n                    count++;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                res.push_back(count + \\'0\\');\\n                res.push_back(digit);\\n            }\\n\\t\\t\\t\\n            return res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) {\\n            return \"1\";\\n        }\\n\\t\\t\\n        if(n==2) {\\n            return \"11\";\\n        }\\n        \\n        else {\\n\\t\\t\\n            string str = countAndSay(n-1);\\n            int i = 0;\\n            string res = \"\";\\n\\t\\t\\t\\n            while(i < str.length()) {\\n\\t\\t\\t\\n                int count = 0;\\n                char digit = str.at(i);\\n\\t\\t\\t\\t\\n                while(i< str.length() && str.at(i) == digit) {\\n                    count++;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                res.push_back(count + \\'0\\');\\n                res.push_back(digit);\\n            }\\n\\t\\t\\t\\n            return res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228561,
                "title": "java-99-74-faster-similar-to-string-compression-lc-443",
                "content": "Use Helper funciton to determine count of each character similar to https://leetcode.com/problems/string-compression/\\n\\n```\\n    public String countAndSay(int n) {\\n\\t    String s = \"1\";\\n\\t\\tif (n == 1) \\n\\t\\t\\treturn s;\\n        for (int i = 1; i < n; i++) {\\n            s = helper(s);\\n        }\\n        return s;\\n    }\\n\\n    private String helper(String num) {\\n        StringBuilder n = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < num.length()) { // get each character count \\n            while (j < num.length() && num.charAt(j) == num.charAt(i)) {\\n                j++;\\n            }\\n            int freq = j-i; \\n            n.append(freq).append(num.charAt(i)); //store freq followed by character to stringbuilder\\n            i = j;\\n        }\\n        return n.toString();\\n    }\\n```\\t",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public String countAndSay(int n) {\\n\\t    String s = \"1\";\\n\\t\\tif (n == 1) \\n\\t\\t\\treturn s;\\n        for (int i = 1; i < n; i++) {\\n            s = helper(s);\\n        }\\n        return s;\\n    }\\n\\n    private String helper(String num) {\\n        StringBuilder n = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < num.length()) { // get each character count \\n            while (j < num.length() && num.charAt(j) == num.charAt(i)) {\\n                j++;\\n            }\\n            int freq = j-i; \\n            n.append(freq).append(num.charAt(i)); //store freq followed by character to stringbuilder\\n            i = j;\\n        }\\n        return n.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184571,
                "title": "c-very-easy-to-understand-with-comment-solution",
                "content": "```\\nstring result = \"1\",current;\\n        \\n\\t\\twhile(--n){\\n        \\n\\t\\tcurrent = \"\";//making an empty string to store final count +value\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;//count start from 1 every time reset \\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;//if we found same values in the string make cout++ and also check for end of string \\n                }\\n                current +=  to_string(count) + result[i] ; // to_string function is inbuilt used to change integer or any other value to string type and here we merged two string count then how much value\\n\\t\\t\\t\\t}\\n            result = current; //make result =current to check for next sequence\\n        }\\n        return result;//return\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring result = \"1\",current;\\n        \\n\\t\\twhile(--n){\\n        \\n\\t\\tcurrent = \"\";//making an empty string to store final count +value\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;//count start from 1 every time reset \\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;//if we found same values in the string make cout++ and also check for end of string \\n                }\\n                current +=  to_string(count) + result[i] ; // to_string function is inbuilt used to change integer or any other value to string type and here we merged two string count then how much value\\n\\t\\t\\t\\t}\\n            result = current; //make result =current to check for next sequence\\n        }\\n        return result;//return\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1087853,
                "title": "c-simple-solution-faster-than-100-c-submissions",
                "content": "* The idea is simple. We store the previous state in vector of pairs(count, character). \\n* After that we make a string from this vector and again we need to clear this vector and insert pairs of this string in vector. The process continue till n.\\n```\\nstring countAndSay(int n) {\\n        string ans = \"1\";\\n        vector<pair<char, char>> v;\\n        v.push_back({\\'1\\', \\'1\\'});\\n        for(int i = 2; i <= n; i++){\\n            string res;\\n            for(auto e : v){\\n                res += e.first;\\n                res += e.second;\\n            }\\n            ans = res;\\n            v.clear();\\n            int cnt = 1;\\n            for(int j = 0; j < res.length(); j++){\\n                if(j == res.length()-1){\\n                    char a = \\'0\\' + cnt; // type cast int to char.\\n                    v.push_back({a, res[j]});\\n                    break;\\n                }\\n                if(res[j] != res[j+1]){\\n                    char a = \\'0\\' + cnt;\\n                    v.push_back({a, res[j]});\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "* The idea is simple. We store the previous state in vector of pairs(count, character). \\n* After that we make a string from this vector and again we need to clear this vector and insert pairs of this string in vector. The process continue till n.\\n```\\nstring countAndSay(int n) {\\n        string ans = \"1\";\\n        vector<pair<char, char>> v;\\n        v.push_back({\\'1\\', \\'1\\'});\\n        for(int i = 2; i <= n; i++){\\n            string res;\\n            for(auto e : v){\\n                res += e.first;\\n                res += e.second;\\n            }\\n            ans = res;\\n            v.clear();\\n            int cnt = 1;\\n            for(int j = 0; j < res.length(); j++){\\n                if(j == res.length()-1){\\n                    char a = \\'0\\' + cnt; // type cast int to char.\\n                    v.push_back({a, res[j]});\\n                    break;\\n                }\\n                if(res[j] != res[j+1]){\\n                    char a = \\'0\\' + cnt;\\n                    v.push_back({a, res[j]});\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980746,
                "title": "swift-readable-solution",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 else { return \"1\" }\\n        return countString(from: countAndSay(n-1))\\n    }\\n    func countString(from inp: String) -> String {\\n        let list = Array(inp)\\n        var result = \"\"\\n        \\n        var elem: Character = list[0]\\n        var count = 1\\n        \\n        for index in 1..<list.count {\\n            let char = list[index]\\n            if char != elem {\\n                result +=  \"\\\\(count)\\\\(elem)\"\\n                elem = char\\n                count = 1\\n            } else {\\n                count += 1\\n            }\\n        }\\n        \\n        result += \"\\\\(count)\\\\(elem)\"\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 else { return \"1\" }\\n        return countString(from: countAndSay(n-1))\\n    }\\n    func countString(from inp: String) -> String {\\n        let list = Array(inp)\\n        var result = \"\"\\n        \\n        var elem: Character = list[0]\\n        var count = 1\\n        \\n        for index in 1..<list.count {\\n            let char = list[index]\\n            if char != elem {\\n                result +=  \"\\\\(count)\\\\(elem)\"\\n                elem = char\\n                count = 1\\n            } else {\\n                count += 1\\n            }\\n        }\\n        \\n        result += \"\\\\(count)\\\\(elem)\"\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922913,
                "title": "python-crazy-fast-constant-time-space",
                "content": "```\\ndef countAndSay(self, n: int) -> str:\\n        d = [\\'1\\',\\n\\'11\\',\\n\\'21\\',\\n\\'1211\\',\\n\\'111221\\',\\n\\'312211\\',\\n\\'13112221\\',\\n\\'1113213211\\',\\n\\'31131211131221\\',\\n\\'13211311123113112211\\',\\n\\'11131221133112132113212221\\',\\n\\'3113112221232112111312211312113211\\',\\n\\'1321132132111213122112311311222113111221131221\\',\\n\\'11131221131211131231121113112221121321132132211331222113112211\\',\\n\\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n\\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n\\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n\\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n\\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\']\\n        return d[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef countAndSay(self, n: int) -> str:\\n        d = [\\'1\\',\\n\\'11\\',\\n\\'21\\',\\n\\'1211\\',\\n\\'111221\\',\\n\\'312211\\',\\n\\'13112221\\',\\n\\'1113213211\\',\\n\\'31131211131221\\',\\n\\'13211311123113112211\\',\\n\\'11131221133112132113212221\\',\\n\\'3113112221232112111312211312113211\\',\\n\\'1321132132111213122112311311222113111221131221\\',\\n\\'11131221131211131231121113112221121321132132211331222113112211\\',\\n\\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n\\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n\\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n\\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n\\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\']\\n        return d[n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 847301,
                "title": "java-easy-video-tutorial",
                "content": "https://www.youtube.com/watch?v=INl9Ha294E0",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=INl9Ha294E0",
                "codeTag": "Unknown"
            },
            {
                "id": 825688,
                "title": "c-simple-easy-to-read-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        string prev = countAndSay(n-1);\\n        string cur = \"\";\\n        int count = 1;\\n        \\n        for (int i = 0; i < prev.length()-1; i++) {\\n            if (prev[i] == prev[i+1]) {\\n                count++;\\n            }\\n            else {\\n                cur += to_string(count);\\n                cur += prev[i];\\n                count = 1;\\n            }\\n        }\\n        \\n        cur += to_string(count);\\n        cur += prev.back();\\n        \\n        return cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        string prev = countAndSay(n-1);\\n        string cur = \"\";\\n        int count = 1;\\n        \\n        for (int i = 0; i < prev.length()-1; i++) {\\n            if (prev[i] == prev[i+1]) {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 823441,
                "title": "go-straightforward-simple-recursion",
                "content": "```\\nfunc countAndSay(n int) string {\\n\\tif n == 1 {\\n\\t\\treturn \"1\"\\n\\t}\\n\\tprev := countAndSay(n - 1)\\n\\tvar say string\\n\\tcount := 0\\n\\tfor i := range prev {\\n\\t\\tcount++\\n\\t\\tif i == len(prev)-1 || prev[i] != prev[i+1] {\\n\\t\\t\\tsay += strconv.Itoa(count) + prev[i:i+1]\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn say\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countAndSay(n int) string {\\n\\tif n == 1 {\\n\\t\\treturn \"1\"\\n\\t}\\n\\tprev := countAndSay(n - 1)\\n\\tvar say string\\n\\tcount := 0\\n\\tfor i := range prev {\\n\\t\\tcount++\\n\\t\\tif i == len(prev)-1 || prev[i] != prev[i+1] {\\n\\t\\t\\tsay += strconv.Itoa(count) + prev[i:i+1]\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn say\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643996,
                "title": "python-solution",
                "content": "Runtime: 32 ms, faster than 80.65% of Python3 online submissions for Count and Say. \\nMemory Usage: 14.1 MB, less than 6.38% of Python3 online submissions for Count and Say.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n <= 1:\\n            return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for i in range(n-1):\\n            \\n            previous,count = s[0],0\\n            new = \\'\\'\\n            \\n            for current in s:\\n                if previous != current:\\n                    new += str(count) + previous\\n                    previous,count = current,1\\n                \\n                else:\\n                    count += 1\\n                    \\n            new += str(count) + previous\\n            s = new\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n <= 1:\\n            return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for i in range(n-1):\\n            \\n            previous,count = s[0],0\\n            new = \\'\\'\\n            \\n            for current in s:\\n                if previous != current:\\n                    new += str(count) + previous\\n                    previous,count = current,1\\n                \\n                else:\\n                    count += 1\\n                    \\n            new += str(count) + previous\\n            s = new\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 616415,
                "title": "4-ms-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n        string recurseSol(string s,int i,int n){\\n        if(i==n){\\n            return s;\\n        }\\n        else{\\n            string nextStr;\\n            stack<char> st;\\n            for(int i=0;i<s.length();++i){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }\\n                else if(!st.empty() && s[i]==st.top()){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            if(!st.empty()){\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n            }\\n            return recurseSol(nextStr,i+1,n);\\n            \\n        }\\n    }\\n    \\n    string countAndSay(int n) {\\n        return recurseSol(\"1\",1,n);\\n    }\\n\\n};```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        string recurseSol(string s,int i,int n){\\n        if(i==n){\\n            return s;\\n        }\\n        else{\\n            string nextStr;\\n            stack<char> st;\\n            for(int i=0;i<s.length();++i){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }\\n                else if(!st.empty() && s[i]==st.top()){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            if(!st.empty()){\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n            }\\n            return recurseSol(nextStr,i+1,n);\\n            \\n        }\\n    }\\n    \\n    string countAndSay(int n) {\\n        return recurseSol(\"1\",1,n);\\n    }\\n\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 593675,
                "title": "clean-regex",
                "content": "```\\nvar countAndSay = function(n) {\\n    var parse = \\'1\\'\\n\\n    for ( var i = 1; i < n; i++ ) {\\n        parse = parse\\n            .match(/(.)\\\\1+|./g)\\n            .map( x => x.length + x[0] )\\n            .join(\\'\\')\\n    }\\n    \\n    return parse\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    var parse = \\'1\\'\\n\\n    for ( var i = 1; i < n; i++ ) {\\n        parse = parse\\n            .match(/(.)\\\\1+|./g)\\n            .map( x => x.length + x[0] )\\n            .join(\\'\\')\\n    }\\n    \\n    return parse\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 510583,
                "title": "python3-recursion-with-brief-explanation-faster-than-74",
                "content": "```\\n# base case:\\nif n == 1:\\n    return \"1\"\\n\\n# recursive case:\\nprev = self.countAndSay(n - 1)\\nresult = \"\"\\ncnt = 1\\nfor i in range(1, len(prev)):\\n    # add into count\\n    if prev[i] == prev[i - 1]:\\n        cnt += 1\\n    # start of new digit\\n    else:\\n        result += (str(cnt) + prev[i - 1])\\n        cnt = 1\\nresult += (str(cnt) + prev[-1])\\nreturn result\\n```\\nDon\\'t forget to upvote my post if you like my solution, thanks a lot :)",
                "solutionTags": [],
                "code": "```\\n# base case:\\nif n == 1:\\n    return \"1\"\\n\\n# recursive case:\\nprev = self.countAndSay(n - 1)\\nresult = \"\"\\ncnt = 1\\nfor i in range(1, len(prev)):\\n    # add into count\\n    if prev[i] == prev[i - 1]:\\n        cnt += 1\\n    # start of new digit\\n    else:\\n        result += (str(cnt) + prev[i - 1])\\n        cnt = 1\\nresult += (str(cnt) + prev[-1])\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498299,
                "title": "iterative-javascript-solution-56ms",
                "content": "Don\\'t love this brute force solution but it\\'s fast for a finite input and I didn\\'t see a similiar one posted. \\n\\n```\\nvar countAndSay = function(n) {\\n    if(n === 1) return \"1\";\\n    let string = \"1\";\\n    for(let i = 0; i < n - 1; i++){\\n       string = countChars(string); \\n    }\\n    return string;\\n};\\n\\nfunction countChars(string){\\n    let idx = 0;\\n    let char = \"\";\\n    let count = 0;\\n    let result = \"\";\\n    \\n    while(idx < string.length){\\n        char = string[idx];\\n        while(string[idx] === char){\\n            count++;\\n            idx++;\\n        }\\n        result += count + char;\\n        count = 0;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    if(n === 1) return \"1\";\\n    let string = \"1\";\\n    for(let i = 0; i < n - 1; i++){\\n       string = countChars(string); \\n    }\\n    return string;\\n};\\n\\nfunction countChars(string){\\n    let idx = 0;\\n    let char = \"\";\\n    let count = 0;\\n    let result = \"\";\\n    \\n    while(idx < string.length){\\n        char = string[idx];\\n        while(string[idx] === char){\\n            count++;\\n            idx++;\\n        }\\n        result += count + char;\\n        count = 0;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462161,
                "title": "recursive-java-solution-commented-runtime-beats-99-memory-beats-100",
                "content": "```\\npublic String countAndSay(int n) {\\n\\t// base cases\\n\\tif(n == 1)\\n\\t\\treturn \"1\";\\n\\tif(n == 2)\\n\\t\\treturn \"11\";\\n\\t\\t\\n\\t// recursive call on n-1\\n\\tString str = countAndSay(n-1);\\n\\t\\n\\tStringBuilder sb = new StringBuilder();\\n\\t\\n\\t// holding the count of the precedding character\\n\\tint tempCount = 1;\\n\\tfor(int i = 1; i < str.length(); i++){\\n\\t\\tif(str.charAt(i) == str.charAt(i-1))\\n\\t\\t\\ttempCount+=1;\\n\\t\\t// done with consecutive digits\\n\\t\\telse{\\n\\t\\t\\tsb.append(tempCount);\\n\\t\\t\\tsb.append(str.charAt(i-1));\\n\\t\\t\\ttempCount = 1;  // reset\\n\\t\\t}\\n\\t}\\n\\t// wrapping up the last digit\\n\\tsb.append(tempCount);\\n\\tsb.append(str.charAt(str.length()-1));\\n\\t\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n\\t// base cases\\n\\tif(n == 1)\\n\\t\\treturn \"1\";\\n\\tif(n == 2)\\n\\t\\treturn \"11\";\\n\\t\\t\\n\\t// recursive call on n-1\\n\\tString str = countAndSay(n-1);\\n\\t\\n\\tStringBuilder sb = new StringBuilder();\\n\\t\\n\\t// holding the count of the precedding character\\n\\tint tempCount = 1;\\n\\tfor(int i = 1; i < str.length(); i++){\\n\\t\\tif(str.charAt(i) == str.charAt(i-1))\\n\\t\\t\\ttempCount+=1;\\n\\t\\t// done with consecutive digits\\n\\t\\telse{\\n\\t\\t\\tsb.append(tempCount);\\n\\t\\t\\tsb.append(str.charAt(i-1));\\n\\t\\t\\ttempCount = 1;  // reset\\n\\t\\t}\\n\\t}\\n\\t// wrapping up the last digit\\n\\tsb.append(tempCount);\\n\\tsb.append(str.charAt(str.length()-1));\\n\\t\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427652,
                "title": "js-iterative-solution",
                "content": "```\\nvar countAndSay = function(n) {\\n  let res = \\'1\\';\\n  \\n  while (n > 1) {\\n    let temp = \\'\\';\\n    let cur = \\'\\';\\n    \\n    for (let i = 0; i < res.length; i++) {      \\n      cur += res[i];\\n      \\n      if (res[i] !== res[i + 1]) {\\n        temp += `${cur.length}${cur[0]}`;\\n        cur = \\'\\';\\n      }\\n    };\\n    \\n    res = temp;\\n    \\n    n--;\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countAndSay = function(n) {\\n  let res = \\'1\\';\\n  \\n  while (n > 1) {\\n    let temp = \\'\\';\\n    let cur = \\'\\';\\n    \\n    for (let i = 0; i < res.length; i++) {      \\n      cur += res[i];\\n      \\n      if (res[i] !== res[i + 1]) {\\n        temp += `${cur.length}${cur[0]}`;\\n        cur = \\'\\';\\n      }\\n    };\\n    \\n    res = temp;\\n    \\n    n--;\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260092,
                "title": "java-solution-with-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        return helper(n, \"1\");\\n    }\\n\\n    public static String helper(int n, String str) {\\n        if (n == 1) {\\n            return str;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char[] nums = str.toCharArray();\\n        char pre = nums[0];\\n        int count = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == pre) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(pre);\\n                pre = nums[i];\\n                count = 1;\\n            }\\n        }\\n        // add the occurrence number of the last few numbers to the \"str\"\\n        sb.append(count);\\n        sb.append(pre);\\n        return helper(n-1, sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        return helper(n, \"1\");\\n    }\\n\\n    public static String helper(int n, String str) {\\n        if (n == 1) {\\n            return str;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char[] nums = str.toCharArray();\\n        char pre = nums[0];\\n        int count = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == pre) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(pre);\\n                pre = nums[i];\\n                count = 1;\\n            }\\n        }\\n        // add the occurrence number of the last few numbers to the \"str\"\\n        sb.append(count);\\n        sb.append(pre);\\n        return helper(n-1, sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161826,
                "title": "javascript-regexp-oneliner-with-explanation",
                "content": "Just split the string to strings of the same digits so `\\'1223334444\\'` would become `[\\'1\\', \\'22\\', \\'333\\', \\'4444\\']`. You know what to do next :)\\n```\\nconst countAndSay = function(n) {\\n  return n > 1 ? countAndSay(n - 1).match(/(\\\\d)\\\\1*/g).map(D => D.length + D[0]).join(\\'\\') : \\'1\\'\\n}\\n```\\nOr, without recursion\\n```\\nvar countAndSay = function(n) {\\n  let result = \\'1\\'\\n  while(--n)\\n    result = result\\n      .match(/(\\\\d)\\\\1*/g)\\n      .map(sameDigits => sameDigits.length + sameDigits[0])\\n      .join(\\'\\')\\n  return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst countAndSay = function(n) {\\n  return n > 1 ? countAndSay(n - 1).match(/(\\\\d)\\\\1*/g).map(D => D.length + D[0]).join(\\'\\') : \\'1\\'\\n}\\n```\n```\\nvar countAndSay = function(n) {\\n  let result = \\'1\\'\\n  while(--n)\\n    result = result\\n      .match(/(\\\\d)\\\\1*/g)\\n      .map(sameDigits => sameDigits.length + sameDigits[0])\\n      .join(\\'\\')\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16047,
                "title": "swift-solution-29ms-90",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        \\n        if n == 1 {\\n            return \"1\"\\n        }\\n        \\n        var currentTerm: String = \"1\"\\n        var newTerm = \"\"\\n        var count = 0\\n        var char: Character = currentTerm.characters.first!\\n        \\n        for i in 2...n {\\n            newTerm = \"\"\\n            count = 0\\n            char = currentTerm.characters.first!\\n            \\n            for currentChar in currentTerm.characters {\\n                if currentChar == char {\\n                    count += 1\\n                } else {\\n                    newTerm += \"\\\\(count)\\\\(char)\"\\n                    char = currentChar\\n                    count = 1\\n                }\\n            }\\n            \\n            newTerm += \"\\\\(count)\\\\(char)\"\\n            currentTerm = newTerm\\n        }\\n        \\n        return currentTerm\\n    }\\n}\\n```\\n\\nFairly fast & straightforward.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        \\n        if n == 1 {\\n            return \"1\"\\n        }\\n        \\n        var currentTerm: String = \"1\"\\n        var newTerm = \"\"\\n        var count = 0\\n        var char: Character = currentTerm.characters.first!\\n        \\n        for i in 2...n {\\n            newTerm = \"\"\\n            count = 0\\n            char = currentTerm.characters.first!\\n            \\n            for currentChar in currentTerm.characters {\\n                if currentChar == char {\\n                    count += 1\\n                } else {\\n                    newTerm += \"\\\\(count)\\\\(char)\"\\n                    char = currentChar\\n                    count = 1\\n                }\\n            }\\n            \\n            newTerm += \"\\\\(count)\\\\(char)\"\\n            currentTerm = newTerm\\n        }\\n        \\n        return currentTerm\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570800,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566016,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650611,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1567821,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1724185,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566471,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650192,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1576549,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1649804,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1568855,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1570800,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566016,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650611,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1567821,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1724185,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566471,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650192,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1576549,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1649804,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1568855,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1814421,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567819,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1568858,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1770537,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1569540,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1568857,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1570140,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567820,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567822,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 2069155,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 2068396,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2066370,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2062122,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2048197,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2047041,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2043573,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2035631,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1914664,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1831027,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1650572,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1576903,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1575022,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1574357,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1574071,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1572255,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1571850,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1571095,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1575288,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1568856,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 2057602,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 2019331,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2013351,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2010964,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2009159,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2008514,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2004237,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2003865,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2003856,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2001868,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2001551,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesnt matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 1987973,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1983418,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1973041,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1967780,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1944508,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1913283,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1904104,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1892325,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1862841,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1855192,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1810750,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1793136,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1790290,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1780873,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1766928,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1756510,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1752943,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1752942,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1751592,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1748637,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1723369,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1722444,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1715825,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1684119,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1671310,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649888,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649769,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649656,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649579,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1635755,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Copy List with Random Pointer",
        "question_content": "<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 43491,
                "title": "a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n",
                "content": "An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is `O(N)`, although with a linear time complexity. \\n\\n*Note:  if we do not consider the space reversed for the output, then we could say that the algorithm does not consume any additional memory during the processing, i.e. O(1) space complexity*\\n\\nAs an optimised solution, we could reduce the space complexity into constant. ***The idea is to associate the original node with its copy node in a single linked list. In this way, we don\\'t need extra space to keep track of the new nodes.***\\n\\nThe algorithm is composed of the follow three steps which are also 3 iteration rounds. \\n\\n 1. Iterate the original list and duplicate each node. The duplicate\\n    of each node follows its original immediately.\\n 2. Iterate the new list and assign the random pointer for each\\n    duplicated node.\\n 3. Restore the original list and extract the duplicated nodes.\\n\\nThe algorithm is implemented as follows:\\n```java\\npublic RandomListNode copyRandomList(RandomListNode head) {\\n  RandomListNode iter = head, next;\\n\\n  // First round: make copy of each node,\\n  // and link them together side-by-side in a single list.\\n  while (iter != null) {\\n    next = iter.next;\\n\\n    RandomListNode copy = new RandomListNode(iter.label);\\n    iter.next = copy;\\n    copy.next = next;\\n\\n    iter = next;\\n  }\\n\\n  // Second round: assign random pointers for the copy nodes.\\n  iter = head;\\n  while (iter != null) {\\n    if (iter.random != null) {\\n      iter.next.random = iter.random.next;\\n    }\\n    iter = iter.next.next;\\n  }\\n\\n  // Third round: restore the original list, and extract the copy list.\\n  iter = head;\\n  RandomListNode pseudoHead = new RandomListNode(0);\\n  RandomListNode copy, copyIter = pseudoHead;\\n\\n  while (iter != null) {\\n    next = iter.next.next;\\n\\n    // extract the copy\\n    copy = iter.next;\\n    copyIter.next = copy;\\n    copyIter = copy;\\n\\n    // restore the original list\\n    iter.next = next;\\n\\n    iter = next;\\n  }\\n\\n  return pseudoHead.next;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java\\npublic RandomListNode copyRandomList(RandomListNode head) {\\n  RandomListNode iter = head, next;\\n\\n  // First round: make copy of each node,\\n  // and link them together side-by-side in a single list.\\n  while (iter != null) {\\n    next = iter.next;\\n\\n    RandomListNode copy = new RandomListNode(iter.label);\\n    iter.next = copy;\\n    copy.next = next;\\n\\n    iter = next;\\n  }\\n\\n  // Second round: assign random pointers for the copy nodes.\\n  iter = head;\\n  while (iter != null) {\\n    if (iter.random != null) {\\n      iter.next.random = iter.random.next;\\n    }\\n    iter = iter.next.next;\\n  }\\n\\n  // Third round: restore the original list, and extract the copy list.\\n  iter = head;\\n  RandomListNode pseudoHead = new RandomListNode(0);\\n  RandomListNode copy, copyIter = pseudoHead;\\n\\n  while (iter != null) {\\n    next = iter.next.next;\\n\\n    // extract the copy\\n    copy = iter.next;\\n    copyIter.next = copy;\\n    copyIter = copy;\\n\\n    // restore the original list\\n    iter.next = next;\\n\\n    iter = next;\\n  }\\n\\n  return pseudoHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43488,
                "title": "java-o-n-solution",
                "content": "    public RandomListNode copyRandomList(RandomListNode head) {\\n      if (head == null) return null;\\n      \\n      Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n      \\n      // loop 1. copy all the nodes\\n      RandomListNode node = head;\\n      while (node != null) {\\n        map.put(node, new RandomListNode(node.label));\\n        node = node.next;\\n      }\\n      \\n      // loop 2. assign next and random pointers\\n      node = head;\\n      while (node != null) {\\n        map.get(node).next = map.get(node.next);\\n        map.get(node).random = map.get(node.random);\\n        node = node.next;\\n      }\\n      \\n      return map.get(head);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public RandomListNode copyRandomList(RandomListNode head) {\\n      if (head == null) return null;\\n      \\n      Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n      \\n      // loop 1. copy all the nodes\\n      RandomListNode node = head;\\n      while (node != null) {\\n        map.put(node, new RandomListNode(node.label));\\n        node = node.next;\\n      }\\n      \\n      // loop 2. assign next and random pointers\\n      node = head;\\n      while (node != null) {\\n        map.get(node).next = map.get(node.next);\\n        map.get(node).random = map.get(node.random);\\n        node = node.next;\\n      }\\n      \\n      return map.get(head);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 811151,
                "title": "extremely-simple-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node*, Node*> m;\\n        int i=0;\\n        Node* ptr = head;\\n        while (ptr) {\\n            m[ptr] =new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            m[ptr]->next = m[ptr->next];\\n            m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```\\n\\nEdit : Since this post has gained a lot of upvotes, I thought to mention the source from where I got this solution - Youtube channel of back to back swe",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node*, Node*> m;\\n        int i=0;\\n        Node* ptr = head;\\n        while (ptr) {\\n            m[ptr] =new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            m[ptr]->next = m[ptr->next];\\n            m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43497,
                "title": "2-clean-c-algorithms-without-using-extra-array-hash-table-algorithms-are-explained-step-by-step",
                "content": "    //\\n    // Here's how the 1st algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, insert each new node after it's corresponding node in the 1st list.\\n    // Step 2:\\n    // The new head is the 2nd node as that was the first inserted node.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->next is actually l2)\\n    // l2->random will be the node in 2nd list that corresponds l1->random, \\n    // which is next node of l1->random.\\n    // Step 4:\\n    // Separate the combined list into 2: Splice out nodes that are part of second list. \\n    // Return the new head that we saved in step 2.\\n    //\\n    \\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->next;\\n            l1->next = l2;\\n        }\\n            \\n        newHead = head->next;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            if (l1->random != NULL) l1->next->random = l1->random->next;\\n        }\\n            \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->next;\\n            l1->next = l2->next;\\n            if (l2->next != NULL) l2->next = l2->next->next;\\n        }\\n    \\n        return newHead;\\n    }\\n\\n\\n    //\\n    // Here's how the 2nd algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, set the next pointer of the new node to the random pointer \\n    // of the corresponding node in the 1st list.  And set the random pointer of the \\n    // 1st list's node to the newly created node.\\n    // Step 2:\\n    // The new head is the node pointed to by the random pointer of the 1st list.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->random is l2)\\n    // l2->random will be the node in 2nd list that corresponds to the node in the \\n    // 1st list that is pointed to by l2->next, \\n    // Step 4:\\n    // Restore the random pointers of the 1st list and fix the next pointers of the \\n    // 2nd list. random pointer of the node in 1st list is the next pointer of the \\n    // corresponding node in the 2nd list.  This is what we had done in the \\n    // 1st step and now we are reverting back. next pointer of the node in \\n    // 2nd list is the random pointer of the node in 1st list that is pointed to \\n    // by the next pointer of the corresponding node in the 1st list.\\n    // Return the new head that we saved in step 2.\\n    //\\n\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->random;\\n            l1->random = l2;\\n        }\\n        \\n        newHead = head->random;\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l2->random = l2->next ? l2->next->random : NULL;\\n        }\\n        \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l1->random = l2->next;\\n            l2->next = l1->next ? l1->next->random : NULL;\\n        }\\n\\n        return newHead;\\n    }",
                "solutionTags": [],
                "code": "    //\\n    // Here's how the 1st algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, insert each new node after it's corresponding node in the 1st list.\\n    // Step 2:\\n    // The new head is the 2nd node as that was the first inserted node.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->next is actually l2)\\n    // l2->random will be the node in 2nd list that corresponds l1->random, \\n    // which is next node of l1->random.\\n    // Step 4:\\n    // Separate the combined list into 2: Splice out nodes that are part of second list. \\n    // Return the new head that we saved in step 2.\\n    //\\n    \\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->next;\\n            l1->next = l2;\\n        }\\n            \\n        newHead = head->next;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            if (l1->random != NULL) l1->next->random = l1->random->next;\\n        }\\n            \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->next;\\n            l1->next = l2->next;\\n            if (l2->next != NULL) l2->next = l2->next->next;\\n        }\\n    \\n        return newHead;\\n    }\\n\\n\\n    //\\n    // Here's how the 2nd algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, set the next pointer of the new node to the random pointer \\n    // of the corresponding node in the 1st list.  And set the random pointer of the \\n    // 1st list's node to the newly created node.\\n    // Step 2:\\n    // The new head is the node pointed to by the random pointer of the 1st list.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->random is l2)\\n    // l2->random will be the node in 2nd list that corresponds to the node in the \\n    // 1st list that is pointed to by l2->next, \\n    // Step 4:\\n    // Restore the random pointers of the 1st list and fix the next pointers of the \\n    // 2nd list. random pointer of the node in 1st list is the next pointer of the \\n    // corresponding node in the 2nd list.  This is what we had done in the \\n    // 1st step and now we are reverting back. next pointer of the node in \\n    // 2nd list is the random pointer of the node in 1st list that is pointed to \\n    // by the next pointer of the corresponding node in the 1st list.\\n    // Return the new head that we saved in step 2.\\n    //\\n\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->random;\\n            l1->random = l2;\\n        }\\n        \\n        newHead = head->random;\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l2->random = l2->next ? l2->next->random : NULL;\\n        }\\n        \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l1->random = l2->next;\\n            l2->next = l1->next ? l1->next->random : NULL;\\n        }\\n\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43485,
                "title": "clear-and-short-python-o-2n-and-o-n-solution",
                "content": "    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = dict()\\n        m = n = head\\n        while m:\\n            dic[m] = RandomListNode(m.label)\\n            m = m.next\\n        while n:\\n            dic[n].next = dic.get(n.next)\\n            dic[n].random = dic.get(n.random)\\n            n = n.next\\n        return dic.get(head)\\n\\nO(n)\\n\\n    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = collections.defaultdict(lambda: RandomListNode(0))\\n        dic[None] = None\\n        n = head\\n        while n:\\n            dic[n].label = n.label\\n            dic[n].next = dic[n.next]\\n            dic[n].random = dic[n.random]\\n            n = n.next\\n        return dic[head]",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = dict()\\n        m = n = head\\n        while m:\\n            dic[m] = RandomListNode(m.label)\\n            m = m.next\\n        while n:\\n            dic[n].next = dic.get(n.next)\\n            dic[n].random = dic.get(n.random)\\n            n = n.next\\n        return dic.get(head)\\n\\nO(n)\\n\\n    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = collections.defaultdict(lambda: RandomListNode(0))\\n        dic[None] = None\\n        n = head\\n        while n:\\n            dic[n].label = n.label\\n            dic[n].next = dic[n.next]\\n            dic[n].random = dic[n.random]\\n            n = n.next\\n        return dic[head]",
                "codeTag": "Java"
            },
            {
                "id": 1059181,
                "title": "c-three-pass-o-n-0ms-beats-100-explanation-with-example",
                "content": "**EXPLANATION**\\nThe algorithm is divided into 3 steps (**3 passes**) :\\n**Let us assume :**\\n![image](https://assets.leetcode.com/users/images/3ab58991-e753-4052-9a1a-bfb5030e3819_1612961783.2270477.png)\\n\\n**STEP 1: PASS 1** *(Altering the link list)*\\nIterate the given link list and at *each* iteration create a **copy (except random pointer)** of each node and **insert** it just *next to the node it\\'s copied from* as shown below.\\n- If **initially** the link list is like : **A->B->C->D**\\n- Then **after** this step the link list will be : **A->A\\'->B->B\\'->C->C\\'->D->D\\'**\\nwhere **A\\',B\\',C\\',D\\'** nodes are the copy of **A,B,C,D** nodes respectively **except** the **random** pointers.\\n```\\nNode* node=head;\\nwhile(node){\\n\\tNode* temp=node->next;\\n\\tnode->next=new Node(node->val);\\n\\tnode->next->next=temp;\\n\\tnode=temp;\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/726d9160-1c58-4c2b-bbd6-9a61dd427b1f_1612961921.3060675.png)\\n\\n**STEP 2: PASS 2** *(Copying the random pointers)*\\nAgain iterate the link list and **alternatively copy** the *old node\\'s random pointer* (*if exists*) to the *new node\\'s random pointer* as shown below **```node->next->random=node->random->next```**.\\n```\\nnode=head;\\nwhile(node){\\n\\tif(node->random)\\n\\t\\tnode->next->random=node->random->next;\\n\\tnode=node->next->next; // go to next old node\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/0a5299d4-68ee-4746-8b34-85c944454fa1_1612962505.5484135.png)\\n\\n\\n**STEP 3 : (PASS 3)** *(Restoring the old link list)*\\n- Create a **dummy node (here ```ans```)** that will be used to **copy the alternative new nodes** from the link list using ```helper``` node along with **restoring** the *old link list*.\\n- Finally, return ```ans->next``` as **```ans```** currenly points to a dummy node as shown below.\\n```\\nNode* ans=new Node(0); // first node is a dummy node\\nNode* helper=ans;\\n\\nwhile(head){\\n\\t// Copy the alternate added nodes from the old linklist\\n\\thelper->next=head->next;\\n\\thelper=helper->next;\\n\\n\\t// Restoring the old linklist, by removing the alternative newly added nodes\\n\\thead->next=head->next->next;\\n\\thead=head->next; // go to next alternate node   \\n}\\nreturn ans->next; // Since first node is a dummy node\\n```\\n![image](https://assets.leetcode.com/users/images/19d05849-6da1-4272-a575-48f4a7e5dad2_1612963056.7245958.png)\\n\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        // STEP 1: PASS 1\\n        // Creating a copy (except random pointer) of each old node and insert it next to the old node it\\'s copied from.\\n        // That is, it will create new alternative nodes which are a copy (except random pointer) of its previous node.\\n        Node* node=head;\\n        while(node){\\n            Node* temp=node->next;\\n            node->next=new Node(node->val);\\n            node->next->next=temp;\\n            node=temp;\\n        }\\n        \\n        // STEP 2: PASS 2\\n        // Now copy the random pointer (if exists) of the old nodes to their copy new nodes.\\n        node=head;\\n        while(node){\\n            if(node->random)\\n                node->next->random=node->random->next;\\n            node=node->next->next; // go to next old node\\n        }\\n        \\n        //STEP 3: PASS 3\\n        // Copy the alternative nodes into \"ans\" link list using the \"helper\" pointer along with restoring the old link list.\\n        Node* ans=new Node(0); // first node is a dummy node\\n        Node* helper=ans;\\n    \\n        while(head){\\n            // Copy the alternate added nodes from the old linklist\\n            helper->next=head->next;\\n            helper=helper->next;\\n            \\n            // Restoring the old linklist, by removing the alternative newly added nodes\\n            head->next=head->next->next;\\n            head=head->next; // go to next alternate node   \\n        }\\n        return ans->next; // Since first node is a dummy node\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n+n+n)=O(n)** [ *Each step (pass) takes O(n) time* }\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [],
                "code": "```\\nNode* node=head;\\nwhile(node){\\n\\tNode* temp=node->next;\\n\\tnode->next=new Node(node->val);\\n\\tnode->next->next=temp;\\n\\tnode=temp;\\n}\\n```\n```node->next->random=node->random->next```\n```\\nnode=head;\\nwhile(node){\\n\\tif(node->random)\\n\\t\\tnode->next->random=node->random->next;\\n\\tnode=node->next->next; // go to next old node\\n}\\n```\n```ans```\n```helper```\n```ans->next```\n```ans```\n```\\nNode* ans=new Node(0); // first node is a dummy node\\nNode* helper=ans;\\n\\nwhile(head){\\n\\t// Copy the alternate added nodes from the old linklist\\n\\thelper->next=head->next;\\n\\thelper=helper->next;\\n\\n\\t// Restoring the old linklist, by removing the alternative newly added nodes\\n\\thead->next=head->next->next;\\n\\thead=head->next; // go to next alternate node   \\n}\\nreturn ans->next; // Since first node is a dummy node\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        // STEP 1: PASS 1\\n        // Creating a copy (except random pointer) of each old node and insert it next to the old node it\\'s copied from.\\n        // That is, it will create new alternative nodes which are a copy (except random pointer) of its previous node.\\n        Node* node=head;\\n        while(node){\\n            Node* temp=node->next;\\n            node->next=new Node(node->val);\\n            node->next->next=temp;\\n            node=temp;\\n        }\\n        \\n        // STEP 2: PASS 2\\n        // Now copy the random pointer (if exists) of the old nodes to their copy new nodes.\\n        node=head;\\n        while(node){\\n            if(node->random)\\n                node->next->random=node->random->next;\\n            node=node->next->next; // go to next old node\\n        }\\n        \\n        //STEP 3: PASS 3\\n        // Copy the alternative nodes into \"ans\" link list using the \"helper\" pointer along with restoring the old link list.\\n        Node* ans=new Node(0); // first node is a dummy node\\n        Node* helper=ans;\\n    \\n        while(head){\\n            // Copy the alternate added nodes from the old linklist\\n            helper->next=head->next;\\n            helper=helper->next;\\n            \\n            // Restoring the old linklist, by removing the alternative newly added nodes\\n            head->next=head->next->next;\\n            head=head->next; // go to next alternate node   \\n        }\\n        return ans->next; // Since first node is a dummy node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258935,
                "title": "detailed-explanation-with-pictures-c-javascript",
                "content": "**Intuition**\\n* First, how do we clone a **Normal** linked list? (i.e, a linked list with no **Random** field). One easy way is to iterate the list and create the nodes on the fly. \\n* This is exactly **Step 1** of the algorithm. We clone the linked list while not caring about the random pointers (setting it to **Null**).\\n* Now, suppose that you have a rope that takes you from any node in the original list to its counterpart in the cloned list. (This is demonstrated by the vertical lines in the picture). How do we actually correct the **random** pointers using this rope? Well, one easy way is to traverse both the lists simultaneously, get the **random** field of the top node, use it reach the location of the **random pointer** (in the top node) and then use the rope to get down vertically, This would be the **random node** for the cloned counterpart.\\n* All that remains is to create the ropes. This can be easily done via **HashMap**. The key is the *address* of the top nodes while the value is the *address* of its copy. The map can be populated while creating the list. \\n* **Remark** ---- *Node* to *Node* hashing is necessary to deal with duplicates. (As can be seen with **2** in the picture).\\n\\n---\\n\\n**Example**\\n\\n![image](https://assets.leetcode.com/users/just__a__visitor/image_1553084036.png)\\n\\n* First, the nodes are cloned with randome pointers set to **Null**. Meanwhile, the virtual ropes are created via hashmap.\\n* Let us say we want to poulate the random field of **1**. We first traverse to **3** (top) and then go down to **3** (bot) and set the random field for the bottom 1.\\n---\\n**Terminology**\\n * `originalHead` represents the head of the original_head. It is never modified.\\n * `clonedHead` represents the head of the cloned linked list. It is never altered once set.\\n * `oldHead` represents a reference to the the head of the original linked list.\\n     It is used for traversing the original list (and hence mutable).\\n * `newHead` represents a reference to the head of the cloned linked list.\\n     It is used for traversing the cloned linked list (and hence mutable).\\n---\\n\\n**Miscellaneous**\\nThe above method handles duplicates but does not handle *Loops* in the linked list. (As it would lead to infinite loop while cloning the lined list). However, this can be easily remedied by using a map and checking whether we have reached the same node twice or not (instead of checking for **null**) which would ensure that the cloning process terminates.\\n\\n**Improving the Space Complexity**\\nThe space compelxity can be further reduced to O(1). You can see my blog post [here](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/259563/Detailed-Explanation-Constant-Space-C%2B%2BJavaScript)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* orig_head);\\n};\\n\\n/* Deep copies the linked list (along with random pointers) */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the corner case\\n    if(!originalHead) return originalHead;\\n    \\n    // Create the head of the cloned linked list and store its reference permanently\\n    Node* clonedHead = new Node(originalHead->val, nullptr, nullptr);\\n    \\n    // Create iterators for both the linked lists\\n    Node* newHead = clonedHead;\\n    Node* oldHead = originalHead;\\n    \\n    // Create a map which facilitates going vertically down from the original to cloned node\\n    unordered_map<Node*, Node*> nodeJustBelow;\\n    \\n    /* Node to Node mapping is compulsory to deal with duplicates in the linked list */\\n    \\n    // Link the nodes vertically\\n    nodeJustBelow[oldHead] = newHead;\\n    \\n    // Check whether the next node exists or not\\n    while(oldHead->next)\\n    {\\n        // First, create the next node in the cloned list.\\n        newHead->next = new Node(oldHead->next->val, nullptr, nullptr);\\n        \\n        // After the node has been created, step on it by the new thread\\n        newHead = newHead->next;\\n        oldHead = oldHead->next;\\n        \\n        // After you\\'ve moved to the newly created node, connect it vertically\\n        nodeJustBelow[oldHead] = newHead;\\n    }\\n    \\n    /* The linked list has been cloned correctly (except the random pointers) */\\n\\n    // Traverse both the lists together and fill the random pointers\\n    oldHead = originalHead;\\n    newHead = clonedHead;\\n    \\n    // As long as both the lists exist, correct the random pointers\\n    while(oldHead && newHead)\\n    {\\n        // Traverse the random pointer of the original list and go down vertically and connect it\\n        newHead->random = oldHead->random? nodeJustBelow[oldHead->random] : nullptr;\\n        \\n        // Move forward in both the lists\\n        oldHead = oldHead->next;\\n        newHead = newHead->next;\\n    }\\n    \\n    // Return the stored reference of the cloned list\\n    return clonedHead;\\n}\\n```\\n\\nSorry, I didn\\'t mean to extend it so long, but I hope you understand the concept and its working.",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* orig_head);\\n};\\n\\n/* Deep copies the linked list (along with random pointers) */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the corner case\\n    if(!originalHead) return originalHead;\\n    \\n    // Create the head of the cloned linked list and store its reference permanently\\n    Node* clonedHead = new Node(originalHead->val, nullptr, nullptr);\\n    \\n    // Create iterators for both the linked lists\\n    Node* newHead = clonedHead;\\n    Node* oldHead = originalHead;\\n    \\n    // Create a map which facilitates going vertically down from the original to cloned node\\n    unordered_map<Node*, Node*> nodeJustBelow;\\n    \\n    /* Node to Node mapping is compulsory to deal with duplicates in the linked list */\\n    \\n    // Link the nodes vertically\\n    nodeJustBelow[oldHead] = newHead;\\n    \\n    // Check whether the next node exists or not\\n    while(oldHead->next)\\n    {\\n        // First, create the next node in the cloned list.\\n        newHead->next = new Node(oldHead->next->val, nullptr, nullptr);\\n        \\n        // After the node has been created, step on it by the new thread\\n        newHead = newHead->next;\\n        oldHead = oldHead->next;\\n        \\n        // After you\\'ve moved to the newly created node, connect it vertically\\n        nodeJustBelow[oldHead] = newHead;\\n    }\\n    \\n    /* The linked list has been cloned correctly (except the random pointers) */\\n\\n    // Traverse both the lists together and fill the random pointers\\n    oldHead = originalHead;\\n    newHead = clonedHead;\\n    \\n    // As long as both the lists exist, correct the random pointers\\n    while(oldHead && newHead)\\n    {\\n        // Traverse the random pointer of the original list and go down vertically and connect it\\n        newHead->random = oldHead->random? nodeJustBelow[oldHead->random] : nullptr;\\n        \\n        // Move forward in both the lists\\n        oldHead = oldHead->next;\\n        newHead = newHead->next;\\n    }\\n    \\n    // Return the stored reference of the cloned list\\n    return clonedHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003262,
                "title": "97-92-hash-table-linked-list",
                "content": "# Interview Guide - Copying a Linked List with Random Pointers: A Dual-Approach Analysis\\n\\n## Introduction & Problem Understanding\\n\\nThe problem at hand involves creating a deep copy of a given singly-linked list where each node has a `next` pointer and an additional `random` pointer. The `random` pointer could point to any node within the list or be `null`. The deep copy should have brand new nodes with the same `next` and `random` pointers as the original list.\\n\\n### Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n   Each node in the list has an integer value, a `next` pointer pointing to the subsequent node, and a `random` pointer that could point to any node in the list or be `null`.\\n\\n2. **Deep Copy**:  \\n   We are required to return a deep copy of the list, meaning that the new list should consist of entirely new nodes that don\\'t refer to nodes in the original list.\\n\\n3. **Memory Efficiency**:  \\n   While one approach uses $$ O(n) $$ additional memory, the other achieves the task without extra memory, using only $$ O(1) $$ extra space.\\n\\n## Strategies to Tackle the Problem\\n\\n1. **Hash Map Method**:  \\n   This approach leverages a hash map to store the mapping between each node in the original list and its corresponding node in the copied list.\\n\\n2. **Interweaving Nodes Method**:  \\n   This approach cleverly interweaves the nodes of the copied list with the original list, using the structure to adjust the `random` pointers correctly, and then separates them.\\n\\n---\\n\\n# Live Coding Hash & More:\\nhttps://youtu.be/eplAWtfkz5o?si=6OwomT_z5ClgyhUc\\n\\n## Solution #1: Hash Map Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe basic idea is to traverse the list twice. In the first pass, we create a new node for each node in the original list and store the mapping in a hash map. In the second pass, we set the `next` and `random` pointers for each new node based on the hash map.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create an empty hash map, `old_to_new`, to store the mapping from old nodes to new nodes.\\n\\n2. **First Pass - Node Creation**:  \\n    - Traverse the original list and for each node, create a corresponding new node.\\n    - Store the mapping in `old_to_new`.\\n\\n3. **Second Pass - Setting Pointers**:  \\n    - Traverse the original list again.\\n    - For each node, set its corresponding new node\\'s `next` and `random` pointers based on the hash map.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited twice.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 To store the hash map.\\n\\n---\\n\\n## Solution #2: Interweaving Nodes Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe crux of this method is to interweave the nodes of the original and copied lists. This interweaving allows us to set the `random` pointers for the new nodes without needing additional memory for mapping.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization and Interweaving**:  \\n    - Traverse the original list.\\n    - For each node, create a corresponding new node and place it between the current node and the current node\\'s `next`.\\n\\n2. **Setting Random Pointers**:  \\n    - Traverse the interweaved list.\\n    - For each old node, set its corresponding new node\\'s `random` pointer.\\n\\n3. **Separating Lists**:  \\n    - Traverse the interweaved list again to separate the old and new lists.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited multiple times but it\\'s still linear time.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 No additional memory is used for mapping; we only allocate nodes for the new list.\\n\\nBoth methods provide a deep copy of the original list but differ in their use of additional memory. The choice between them would depend on the specific requirements of your application.\\n\\n# Performance\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Java      | 0 ms      | 44 MB       |\\n| Go        | 3 ms      | 3.5 MB      |\\n| C++       | 8 ms      | 11.3 MB     | \\n| Python3 (Hash)   | 33 ms     | 17.3 MB     |\\n| JavaScript| 34 ms     | 43.8 MB     | \\n| Python3 (Inter)   | 39 ms     | 17.3 MB     |\\n| C#        | 87 ms     | 39.9 MB     | \\n\\n![v5.png](https://assets.leetcode.com/users/images/29feaf30-0f7c-456b-ad97-77e59b7778a5_1693880496.8172286.png)\\n\\n\\n# Code #1 Hash Map\\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        old_to_new = {}\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr] = Node(curr.val)\\n            curr = curr.next\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr].next = old_to_new.get(curr.next)\\n            old_to_new[curr].random = old_to_new.get(curr.random)\\n            curr = curr.next\\n            \\n        return old_to_new[head]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n        \\n        unordered_map<Node*, Node*> old_to_new;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            old_to_new[curr] = new Node(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            old_to_new[curr]->next = old_to_new[curr->next];\\n            old_to_new[curr]->random = old_to_new[curr->random];\\n            curr = curr->next;\\n        }\\n        \\n        return old_to_new[head];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        HashMap<Node, Node> oldToNew = new HashMap<>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew.get(curr).next = oldToNew.get(curr.next);\\n            oldToNew.get(curr).random = oldToNew.get(curr.random);\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew.get(head);\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    \\n    const oldToNew = new Map();\\n    \\n    let curr = head;\\n    while (curr) {\\n        oldToNew.set(curr, new Node(curr.val));\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while (curr) {\\n        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;\\n        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;\\n        curr = curr.next;\\n    }\\n    \\n    return oldToNew.get(head);\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Dictionary<Node, Node> oldToNew = new Dictionary<Node, Node>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew[curr] = new Node(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew[curr].next = curr.next != null ? oldToNew[curr.next] : null;\\n            oldToNew[curr].random = curr.random != null ? oldToNew[curr.random] : null;\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew[head];\\n    }\\n}\\n```\\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    oldToNew := make(map[*Node]*Node)\\n\\n    curr := head\\n    for curr != nil {\\n        oldToNew[curr] = &Node{Val: curr.Val}\\n        curr = curr.Next\\n    }\\n\\n    curr = head\\n    for curr != nil {\\n        oldToNew[curr].Next = oldToNew[curr.Next]\\n        oldToNew[curr].Random = oldToNew[curr.Random]\\n        curr = curr.Next\\n    }\\n\\n    return oldToNew[head]\\n}\\n```\\n\\n# Code #2 Interweaving Nodes\\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr:\\n            new_node = Node(curr.val, curr.next)\\n            curr.next = new_node\\n            curr = new_node.next\\n            \\n        curr = head\\n        while curr:\\n            if curr.random:\\n                curr.next.random = curr.random.next\\n            curr = curr.next.next\\n        \\n        old_head = head\\n        new_head = head.next\\n        curr_old = old_head\\n        curr_new = new_head\\n        \\n        while curr_old:\\n            curr_old.next = curr_old.next.next\\n            curr_new.next = curr_new.next.next if curr_new.next else None\\n            curr_old = curr_old.next\\n            curr_new = curr_new.next\\n            \\n        return new_head\\n```\\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n        if head == nil {\\n        return nil\\n    }\\n    \\n    curr := head\\n    for curr != nil {\\n        new_node := &Node{Val: curr.Val, Next: curr.Next}\\n        curr.Next = new_node\\n        curr = new_node.Next\\n    }\\n    \\n    curr = head\\n    for curr != nil {\\n        if curr.Random != nil {\\n            curr.Next.Random = curr.Random.Next\\n        }\\n        curr = curr.Next.Next\\n    }\\n    \\n    old_head := head\\n    new_head := head.Next\\n    curr_old := old_head\\n    curr_new := new_head\\n    \\n    for curr_old != nil {\\n        curr_old.Next = curr_old.Next.Next\\n        if curr_new.Next != nil {\\n            curr_new.Next = curr_new.Next.Next\\n        } else {\\n            curr_new.Next = nil\\n        }\\n        curr_old = curr_old.Next\\n        curr_new = curr_new.Next\\n    }\\n    \\n    return new_head\\n}\\n```\\n``` C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n                if (!head) return nullptr;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            Node* new_node = new Node(curr->val);\\n            new_node->next = curr->next;\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            if (curr->random) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        Node* old_head = head;\\n        Node* new_head = head->next;\\n        Node* curr_old = old_head;\\n        Node* curr_new = new_head;\\n        \\n        while (curr_old) {\\n            curr_old->next = curr_old->next->next;\\n            curr_new->next = curr_new->next ? curr_new->next->next : nullptr;\\n            curr_old = curr_old->next;\\n            curr_new = curr_new->next;\\n        }\\n        \\n        return new_head;       \\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            Node new_node = new Node(curr.val, curr.next);\\n            curr.next = new_node;\\n            curr = new_node.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        Node old_head = head;\\n        Node new_head = head.next;\\n        Node curr_old = old_head;\\n        Node curr_new = new_head;\\n        \\n        while (curr_old != null) {\\n            curr_old.next = curr_old.next.next;\\n            curr_new.next = curr_new.next != null ? curr_new.next.next : null;\\n            curr_old = curr_old.next;\\n            curr_new = curr_new.next;\\n        }\\n        \\n        return new_head;\\n    }\\n}\\n```\\n\\n# Live Coding Interweaving & More\\nhttps://youtu.be/DH0HDU4ScYY?si=P-P1Er3P8q5XekTU\\n\\n### Reflections on Copying Lists with Random Pointers\\n\\n#### Hash Map Method:\\nClear and simple, this method uses extra memory to map each node from the original to the copied list. It\\'s straightforward but can be memory-inefficient.\\n\\n#### Interweaving Nodes Method:\\nSleek and space-efficient, this in-place method interweaves new nodes within the existing structure before making them their own list. It\\'s elegant but requires careful attention.\\n\\nThis problem isn\\'t just coding; it\\'s a deep dive into data structures and algorithms. Whether you prefer the clarity of Hash Map or the finesse of Interweaving Nodes, each sharpens your algorithmic skill set. Embrace the challenge! \\uD83C\\uDF1F\\uD83D\\uDE80\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        old_to_new = {}\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr] = Node(curr.val)\\n            curr = curr.next\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr].next = old_to_new.get(curr.next)\\n            old_to_new[curr].random = old_to_new.get(curr.random)\\n            curr = curr.next\\n            \\n        return old_to_new[head]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n        \\n        unordered_map<Node*, Node*> old_to_new;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            old_to_new[curr] = new Node(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            old_to_new[curr]->next = old_to_new[curr->next];\\n            old_to_new[curr]->random = old_to_new[curr->random];\\n            curr = curr->next;\\n        }\\n        \\n        return old_to_new[head];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        HashMap<Node, Node> oldToNew = new HashMap<>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew.get(curr).next = oldToNew.get(curr.next);\\n            oldToNew.get(curr).random = oldToNew.get(curr.random);\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew.get(head);\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    \\n    const oldToNew = new Map();\\n    \\n    let curr = head;\\n    while (curr) {\\n        oldToNew.set(curr, new Node(curr.val));\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while (curr) {\\n        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;\\n        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;\\n        curr = curr.next;\\n    }\\n    \\n    return oldToNew.get(head);\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Dictionary<Node, Node> oldToNew = new Dictionary<Node, Node>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew[curr] = new Node(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew[curr].next = curr.next != null ? oldToNew[curr.next] : null;\\n            oldToNew[curr].random = curr.random != null ? oldToNew[curr.random] : null;\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew[head];\\n    }\\n}\\n```\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    oldToNew := make(map[*Node]*Node)\\n\\n    curr := head\\n    for curr != nil {\\n        oldToNew[curr] = &Node{Val: curr.Val}\\n        curr = curr.Next\\n    }\\n\\n    curr = head\\n    for curr != nil {\\n        oldToNew[curr].Next = oldToNew[curr.Next]\\n        oldToNew[curr].Random = oldToNew[curr.Random]\\n        curr = curr.Next\\n    }\\n\\n    return oldToNew[head]\\n}\\n```\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr:\\n            new_node = Node(curr.val, curr.next)\\n            curr.next = new_node\\n            curr = new_node.next\\n            \\n        curr = head\\n        while curr:\\n            if curr.random:\\n                curr.next.random = curr.random.next\\n            curr = curr.next.next\\n        \\n        old_head = head\\n        new_head = head.next\\n        curr_old = old_head\\n        curr_new = new_head\\n        \\n        while curr_old:\\n            curr_old.next = curr_old.next.next\\n            curr_new.next = curr_new.next.next if curr_new.next else None\\n            curr_old = curr_old.next\\n            curr_new = curr_new.next\\n            \\n        return new_head\\n```\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n        if head == nil {\\n        return nil\\n    }\\n    \\n    curr := head\\n    for curr != nil {\\n        new_node := &Node{Val: curr.Val, Next: curr.Next}\\n        curr.Next = new_node\\n        curr = new_node.Next\\n    }\\n    \\n    curr = head\\n    for curr != nil {\\n        if curr.Random != nil {\\n            curr.Next.Random = curr.Random.Next\\n        }\\n        curr = curr.Next.Next\\n    }\\n    \\n    old_head := head\\n    new_head := head.Next\\n    curr_old := old_head\\n    curr_new := new_head\\n    \\n    for curr_old != nil {\\n        curr_old.Next = curr_old.Next.Next\\n        if curr_new.Next != nil {\\n            curr_new.Next = curr_new.Next.Next\\n        } else {\\n            curr_new.Next = nil\\n        }\\n        curr_old = curr_old.Next\\n        curr_new = curr_new.Next\\n    }\\n    \\n    return new_head\\n}\\n```\n``` C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n                if (!head) return nullptr;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            Node* new_node = new Node(curr->val);\\n            new_node->next = curr->next;\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            if (curr->random) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        Node* old_head = head;\\n        Node* new_head = head->next;\\n        Node* curr_old = old_head;\\n        Node* curr_new = new_head;\\n        \\n        while (curr_old) {\\n            curr_old->next = curr_old->next->next;\\n            curr_new->next = curr_new->next ? curr_new->next->next : nullptr;\\n            curr_old = curr_old->next;\\n            curr_new = curr_new->next;\\n        }\\n        \\n        return new_head;       \\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            Node new_node = new Node(curr.val, curr.next);\\n            curr.next = new_node;\\n            curr = new_node.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        Node old_head = head;\\n        Node new_head = head.next;\\n        Node curr_old = old_head;\\n        Node curr_new = new_head;\\n        \\n        while (curr_old != null) {\\n            curr_old.next = curr_old.next.next;\\n            curr_new.next = curr_new.next != null ? curr_new.next.next : null;\\n            curr_old = curr_old.next;\\n            curr_new = curr_new.next;\\n        }\\n        \\n        return new_head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43689,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\ndef copyRandomList1(self, head):\\n        if not head:\\n            return \\n        # copy nodes\\n        cur = head\\n        while cur:\\n            nxt = cur.next\\n            cur.next = RandomListNode(cur.label)\\n            cur.next.next = nxt\\n            cur = nxt\\n        # copy random pointers\\n        cur = head\\n        while cur:\\n            if cur.random:\\n                cur.next.random = cur.random.next\\n            cur = cur.next.next\\n        # separate two parts\\n        second = cur = head.next\\n        while cur.next:\\n            head.next = cur.next\\n            head = head.next\\n            cur.next = head.next\\n            cur = cur.next\\n        head.next = None\\n        return second\\n    \\n    # using dictionary    \\n    def copyRandomList(self, head):\\n        if not head:\\n            return \\n        cur, dic = head, {}\\n        # copy nodes\\n        while cur:\\n            dic[cur] = RandomListNode(cur.label)\\n            cur = cur.next\\n        cur = head\\n        # copy random pointers\\n        while cur:\\n            if cur.random:\\n                dic[cur].random = dic[cur.random]\\n            if cur.next:\\n                dic[cur].next = dic[cur.next]\\n            cur = cur.next\\n        return dic[head]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef copyRandomList1(self, head):\\n        if not head:\\n            return \\n        # copy nodes\\n        cur = head\\n        while cur:\\n            nxt = cur.next\\n            cur.next = RandomListNode(cur.label)\\n            cur.next.next = nxt\\n            cur = nxt\\n        # copy random pointers\\n        cur = head\\n        while cur:\\n            if cur.random:\\n                cur.next.random = cur.random.next\\n            cur = cur.next.next\\n        # separate two parts\\n        second = cur = head.next\\n        while cur.next:\\n            head.next = cur.next\\n            head = head.next\\n            cur.next = head.next\\n            cur = cur.next\\n        head.next = None\\n        return second\\n    \\n    # using dictionary    \\n    def copyRandomList(self, head):\\n        if not head:\\n            return \\n        cur, dic = head, {}\\n        # copy nodes\\n        while cur:\\n            dic[cur] = RandomListNode(cur.label)\\n            cur = cur.next\\n        cur = head\\n        # copy random pointers\\n        while cur:\\n            if cur.random:\\n                dic[cur].random = dic[cur.random]\\n            if cur.next:\\n                dic[cur].next = dic[cur.next]\\n            cur = cur.next\\n        return dic[head]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43496,
                "title": "o-n-time-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43484,
                "title": "c-6-lines-recursive-solution-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<RandomListNode*, RandomListNode*>mp;\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        if(!head) return NULL;\\n        if(mp[head]!=NULL) return mp[head];\\n        mp[head] = new RandomListNode(head->label);\\n        mp[head] -> next = copyRandomList(head->next);\\n        mp[head] -> random = copyRandomList(head->random);\\n        return mp[head];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<RandomListNode*, RandomListNode*>mp;\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        if(!head) return NULL;\\n        if(mp[head]!=NULL) return mp[head];\\n        mp[head] = new RandomListNode(head->label);\\n        mp[head] -> next = copyRandomList(head->next);\\n        mp[head] -> random = copyRandomList(head->random);\\n        return mp[head];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 373694,
                "title": "python3-dictionary",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None: return None\\n        mapping = {}\\n        cur = head\\n        while cur:\\n            mapping[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        cur = head\\n        while cur:\\n            if cur.next:\\n                mapping[cur].next = mapping[cur.next]\\n            if cur.random:\\n                mapping[cur].random = mapping[cur.random]\\n            cur = cur.next\\n        return mapping[head]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None: return None\\n        mapping = {}\\n        cur = head\\n        while cur:\\n            mapping[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        cur = head\\n        while cur:\\n            if cur.next:\\n                mapping[cur].next = mapping[cur.next]\\n            if cur.random:\\n                mapping[cur].random = mapping[cur.random]\\n            cur = cur.next\\n        return mapping[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379056,
                "title": "python-solution-with-comments-o-n-using-a-dictionary",
                "content": "```\\nclass Solution(object):\\n    \"\"\"\\n    \"\"\"\\n    def copyRandomList(self, head):\\n        dic, prev, node = {}, None, head\\n        while node:\\n            if node not in dic:\\n                # Use a dictionary to map the original node to its copy\\n                dic[node] = Node(node.val, node.next, node.random)\\n            if prev:\\n                # Make the previous node point to the copy instead of the original.\\n                prev.next = dic[node]\\n            else:\\n                # If there is no prev, then we are at the head. Store it to return later.\\n                head = dic[node]\\n            if node.random:\\n                if node.random not in dic:\\n                    # If node.random points to a node that we have not yet encountered, store it in the dictionary.\\n                    dic[node.random] = Node(node.random.val, node.random.next, node.random.random)\\n                # Make the copy\\'s random property point to the copy instead of the original.\\n                dic[node].random = dic[node.random]\\n            # Store prev and advance to the next node.\\n            prev, node = dic[node], node.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \"\"\"\\n    \"\"\"\\n    def copyRandomList(self, head):\\n        dic, prev, node = {}, None, head\\n        while node:\\n            if node not in dic:\\n                # Use a dictionary to map the original node to its copy\\n                dic[node] = Node(node.val, node.next, node.random)\\n            if prev:\\n                # Make the previous node point to the copy instead of the original.\\n                prev.next = dic[node]\\n            else:\\n                # If there is no prev, then we are at the head. Store it to return later.\\n                head = dic[node]\\n            if node.random:\\n                if node.random not in dic:\\n                    # If node.random points to a node that we have not yet encountered, store it in the dictionary.\\n                    dic[node.random] = Node(node.random.val, node.random.next, node.random.random)\\n                # Make the copy\\'s random property point to the copy instead of the original.\\n                dic[node].random = dic[node.random]\\n            # Store prev and advance to the next node.\\n            prev, node = dic[node], node.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341495,
                "title": "javascript-o-n-space-solution",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if(!head) {\\n      return null;\\n    }\\n    const clones = new Map();\\n    let n = head;\\n    while(n) {\\n      clones.set(n, new Node(n.val));\\n      n = n.next\\n    }\\n    n = head;\\n    while(n) {\\n      clones.get(n).next = clones.get(n.next) || null;\\n      clones.get(n).random = clones.get(n.random) || null;\\n      n = n.next\\n    }\\n    return clones.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if(!head) {\\n      return null;\\n    }\\n    const clones = new Map();\\n    let n = head;\\n    while(n) {\\n      clones.set(n, new Node(n.val));\\n      n = n.next\\n    }\\n    n = head;\\n    while(n) {\\n      clones.get(n).next = clones.get(n.next) || null;\\n      clones.get(n).random = clones.get(n.random) || null;\\n      n = n.next\\n    }\\n    return clones.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255721,
                "title": "c-both-solutions-explained-clearly-hashmap-method-constant-space-method",
                "content": "**Solution 1: Using Hashmap\\nTime: O(N) \\nSpace: O(N)**\\n\\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        // this map points to the clone of the original node\\n        map<Node*,Node*> mp;\\n        \\n        Node* temp=head;\\n        \\n        // 1st Pass - Creation of Nodes and no wiring\\n        while(temp!=NULL)\\n        {\\n            // Pointing the original node to its clone node\\n            // Now I can access the clone node in O(1)\\n            mp[temp] = new Node(temp->val);\\n            temp=temp->next;\\n            \\n        }\\n        \\n        // 2nd pass - Filling the next and random pointers\\n        temp=head;\\n        \\n        while(temp!=NULL)\\n        {\\n            // mp[ptr] is the clone node and its next is the next original\\n            // node\\'s clone node. \\n            // mp[ptr->next] refers to the clone node of ptr->next;\\n            mp[temp]->next= mp[temp->next]; \\n            \\n            // similar thing for the random pointer\\n            mp[temp]->random=mp[temp->random];\\n            \\n            temp=temp->next;\\n        }\\n        \\n        return mp[head];\\n        \\n    }\\n```\\n\\n**Solution 2: Constant Space without Hashmap\\nTime: O(N)\\nSpace: O(1)**\\n\\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        // temporary (copied) head node\\n        Node* temp=head;\\n        \\n        // 1st Pass\\n        \\n        while(temp!=NULL)\\n        {\\n             // Cloned node with same val as head\\n            Node* newnode= new Node(temp->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            \\n            newnode->next=temp->next;\\n            temp->next=newnode;\\n            temp=newnode->next;\\n        }\\n        \\n        temp=head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n        \\n        // 2nd Pass\\n        \\n        while(temp!=NULL)\\n        {\\n            temp->next->random=(temp->random)?(temp->random->next):NULL;       \\n            temp=temp->next->next;\\n        }\\n        \\n         // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* original=head;\\n        \\n        // A\\'->B\\'->C\\'\\n        Node* clone=head->next;\\n        \\n        // Result is used for returning\\n        Node* result=head->next;\\n        // 3rd Pass\\n        \\n        while(original!=NULL)\\n        {\\n            original->next=original->next->next;\\n            clone->next= (clone->next)?(clone->next->next):NULL;\\n            \\n            original=original->next;\\n            clone=clone->next;\\n        }\\n        \\n        return result;\\n```\\nIf you have any doubts, post in the comments.\\nUpvote if you like the solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nNode* copyRandomList(Node* head) {\\n        \\n        // this map points to the clone of the original node\\n        map<Node*,Node*> mp;\\n        \\n        Node* temp=head;\\n        \\n        // 1st Pass - Creation of Nodes and no wiring\\n        while(temp!=NULL)\\n        {\\n            // Pointing the original node to its clone node\\n            // Now I can access the clone node in O(1)\\n            mp[temp] = new Node(temp->val);\\n            temp=temp->next;\\n            \\n        }\\n        \\n        // 2nd pass - Filling the next and random pointers\\n        temp=head;\\n        \\n        while(temp!=NULL)\\n        {\\n            // mp[ptr] is the clone node and its next is the next original\\n            // node\\'s clone node. \\n            // mp[ptr->next] refers to the clone node of ptr->next;\\n            mp[temp]->next= mp[temp->next]; \\n            \\n            // similar thing for the random pointer\\n            mp[temp]->random=mp[temp->random];\\n            \\n            temp=temp->next;\\n        }\\n        \\n        return mp[head];\\n        \\n    }\\n```\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        // temporary (copied) head node\\n        Node* temp=head;\\n        \\n        // 1st Pass\\n        \\n        while(temp!=NULL)\\n        {\\n             // Cloned node with same val as head\\n            Node* newnode= new Node(temp->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            \\n            newnode->next=temp->next;\\n            temp->next=newnode;\\n            temp=newnode->next;\\n        }\\n        \\n        temp=head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n        \\n        // 2nd Pass\\n        \\n        while(temp!=NULL)\\n        {\\n            temp->next->random=(temp->random)?(temp->random->next):NULL;       \\n            temp=temp->next->next;\\n        }\\n        \\n         // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* original=head;\\n        \\n        // A\\'->B\\'->C\\'\\n        Node* clone=head->next;\\n        \\n        // Result is used for returning\\n        Node* result=head->next;\\n        // 3rd Pass\\n        \\n        while(original!=NULL)\\n        {\\n            original->next=original->next->next;\\n            clone->next= (clone->next)?(clone->next->next):NULL;\\n            \\n            original=original->next;\\n            clone=clone->next;\\n        }\\n        \\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649910,
                "title": "java-solution-using-hashmap-beat-100",
                "content": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // HashMap which holds old nodes as keys and new nodes as its values. \\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        //copy list nodes into hash table\\n        Node p = head;\\n        while(p != null){\\n            map.put(p, new Node(p.val));\\n            p = p.next;\\n        }\\n        \\n        //deep copy using hash table\\n        Node q = head;\\n        while(q != null){\\n            map.get(q).next = map.get(q.next);\\n            map.get(q).random = map.get(q.random);\\n            q = q.next;\\n        }\\n        \\n        //return new head\\n        return map.get(head);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // HashMap which holds old nodes as keys and new nodes as its values. \\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        //copy list nodes into hash table\\n        Node p = head;\\n        while(p != null){\\n            map.put(p, new Node(p.val));\\n            p = p.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43515,
                "title": "my-accepted-java-code-o-n-but-need-to-iterate-the-list-3-times",
                "content": "The idea is:\\nStep 1: create a new node for each existing node and join them together\\neg: A->B->C will be A->A'->B->B'->C->C'\\n\\nStep2: copy the random links: for each new node n', n'.random = n.random.next\\n\\nStep3: detach the list: basically n.next = n.next.next; n'.next = n'.next.next\\n\\nHere is the code:\\n\\n    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * class RandomListNode {\\n     *     int label;\\n     *     RandomListNode next, random;\\n     *     RandomListNode(int x) { this.label = x; }\\n     * };\\n     */\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if(head==null){\\n                return null;\\n            }\\n            RandomListNode n = head;\\n            while (n!=null){\\n                RandomListNode n2 = new RandomListNode(n.label);\\n                RandomListNode tmp = n.next;\\n                n.next = n2;\\n                n2.next = tmp;\\n                n = tmp;\\n            }\\n            \\n            n=head;\\n            while(n != null){\\n                RandomListNode n2 = n.next;\\n                if(n.random != null)\\n                    n2.random = n.random.next;\\n                else\\n                    n2.random = null;\\n                n = n.next.next;\\n            }\\n            \\n            //detach list\\n            RandomListNode n2 = head.next;\\n            n = head;\\n            RandomListNode head2 = head.next;\\n            while(n2 != null && n != null){\\n                n.next = n.next.next;\\n                if (n2.next == null){\\n                    break;\\n                }\\n                n2.next = n2.next.next;\\n                \\n                n2 = n2.next;\\n                n = n.next;\\n            }\\n            return head2;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if(head==null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1841010,
                "title": "python3-just-two-steps-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main problem is that a random pointer can point to any node in the list. So we can\\'t get by here without a hashmap to remember copied nodes. We need a hashmap that maps the original node to its copy. Having that, we can proceed with two simple steps:\\n\\n1. First pass to create a copy of nodes and fill the hashmap\\n2. Second pass to set random pointers in the copied nodes with according nodes.\\n\\nTime: **O(n)** - for two passes\\nSpace: **O(n)** - for the hashmap\\n\\nRuntime: 36 ms, faster than **91.34%** of Python3 online submissions for Copy List with Random Pointer.\\nMemory Usage: 14.8 MB, less than **85.83%** of Python3 online submissions for Copy List with Random Pointer.\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hm, zero = dict(), Node(0)\\n        \\n        cur, copy = head, zero\\n        while cur:\\n            copy.next = Node(cur.val)\\n            hm[cur] = copy.next\\n            cur, copy = cur.next, copy.next\\n            \\n        cur, copy = head, zero.next\\n        while cur:\\n            copy.random = hm[cur.random] if cur.random else None\\n            cur, copy = cur.next, copy.next\\n                \\n        return zero.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hm, zero = dict(), Node(0)\\n        \\n        cur, copy = head, zero\\n        while cur:\\n            copy.next = Node(cur.val)\\n            hm[cur] = copy.next\\n            cur, copy = cur.next, copy.next\\n            \\n        cur, copy = head, zero.next\\n        while cur:\\n            copy.random = hm[cur.random] if cur.random else None\\n            cur, copy = cur.next, copy.next\\n                \\n        return zero.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43567,
                "title": "c-simple-recursive-solution",
                "content": "    class Solution {\\n\\tunordered_map<RandomListNode*, RandomListNode*> hmap;\\n\\n    public:\\n\\tRandomListNode *copyRandomList(RandomListNode *head) {\\n\\t\\tif (!head) return NULL;\\n\\t\\tif (hmap.find(head) != hmap.end())\\n\\t\\t\\treturn hmap.find(head)->second;\\n\\n\\t\\tRandomListNode* node = new RandomListNode(head->label);\\n\\t\\thmap[head] = node;\\n\\t\\tnode->next = copyRandomList(head->next);\\n\\t\\tnode->random = copyRandomList(head->random);\\n\\t\\treturn node;\\n\\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n\\tunordered_map<RandomListNode*, RandomListNode*> hmap;\\n\\n    public:\\n\\tRandomListNode *copyRandomList(RandomListNode *head) {\\n\\t\\tif (!head) return NULL;\\n\\t\\tif (hmap.find(head) != hmap.end())\\n\\t\\t\\treturn hmap.find(head)->second;\\n\\n\\t\\tRandomListNode* node = new RandomListNode(head->label);\\n\\t\\thmap[head] = node;\\n\\t\\tnode->next = copyRandomList(head->next);\\n\\t\\tnode->random = copyRandomList(head->random);\\n\\t\\treturn node;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 43540,
                "title": "very-short-java-solution-with-map",
                "content": "I realized with Map, we don't really need to care about the internal structure of the list. What we need is just deep copy exactly what the original data. So here I just create all nodes and put <old, new> pairs into a map. Then update next and random pointers for each new node.\\n\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null) {\\n                return null;\\n            }\\n            \\n            final Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n    \\n            RandomListNode cur = head;\\n            while(cur != null) {\\n                map.put(cur, new RandomListNode(cur.label));\\n                cur = cur.next;\\n            }\\n            \\n            for (Map.Entry<RandomListNode, RandomListNode> entry : map.entrySet()) {\\n                final RandomListNode newNode = entry.getValue();\\n                newNode.next = map.get(entry.getKey().next);\\n                newNode.random = map.get(entry.getKey().random);\\n            }\\n            \\n            return map.get(head);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null) {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003329,
                "title": "c-2-approaches-o-n-space-and-o-1-space",
                "content": "# Approach 1: Hashmap for Relationships\\n**1. Initialize a hashamp of [original, copied] kv pairs**\\n- Initializing a hashmap where the key is the original node, we can create a copy of this node and place it has the value for the key value pair. Therefore we can always access the corresponding copied node by refrencing the hashmap\\n\\n**2. Pass 1: Create Copied Nodes**\\n- We create the copied nodes with the value of the original node.\\n- In the example below, we place the original nodes in the keys, and create a copy of the node with the same value as the corresponding value in the map.\\n```\\nll = 1 -> 2 -> 3 -> 4 -> 5\\n\\nhashmap:\\nkeys = node1    , node2    , node3    , node4    , node5\\nvals = copynode1, copynode2, copynode3, copynode4, copynode5\\n```\\n\\n**3. Pass 2: Assign next and random to the copied nodes**\\n- we can iterate through our original linked list, and access the copied node of the current original node we are at by refrencing the map.\\n- we can then assign the copied node the copied next and copied random nodes as its connections\\n- the code below steps this process out\\n```\\nitr = head; // set iterator of original list to the head node\\nwhile(itr) {\\n    map[itr]->next = map[itr->next]; // assign copied next\\n    map[itr]->random = map[itr->random]; // assign copied random\\n    itr = itr->next; // iterate in original list to next node\\n}\\n```\\n# Complexity\\n**Time complexity: O(n)**\\n- requires two traversals of n nodes = O(2n) = O(n)\\n\\n**Space complexity: O(n)**\\n- we use a hashmap to store n key value pairs = O(n)\\n\\n# Code\\n```,\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> map;\\n\\n        Node* itr = head;\\n        while(itr) {\\n            map[itr] = new Node(itr->val);\\n            itr=itr->next;\\n        }\\n\\n        itr = head;\\n        while(itr) {\\n            map[itr]->next = map[itr->next];\\n            map[itr]->random = map[itr->random];\\n            itr = itr->next;\\n        }\\n\\n        return map[head];\\n    }\\n};\\n```\\n\\n# Approach 2: Clever Pointer Manipulation\\n**1. Initalize Pointers**\\n- one for iterating through original list\\n- one for iterating through a cloned list\\n- one for temporary node creation\\n```\\nNode* original = head; // itr for original\\nNode* cloned = nullptr; // itr for cloed\\nNode* temp = nullptr; // temporary for node creation\\n```\\n**2. First Pass Clone Nodes and link them to original**\\n- this allows us to access the cloned nodes as they will be stored in original->next\\n- see example below\\n```\\noriginal: 1 -> 2 -> 3 \\nmanipulated: 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n```\\n\\n**3. Assign Random pointers to the clones**\\n- again this is done by accessing the original->next\\n- when we move the pointer in iteration, we do original->next->next to skip the copied nodes\\n- the code below is the process\\n```\\nwhile(original) {\\n    if(original->random) {\\n        original->next->random = original->random->next;\\n        } else {\\n            original->next->random = nullptr;\\n        }\\n            original = original->next->next; // skip copy\\n    }\\n}\\n```\\n\\n**4. Seperate the original and cloned lists**\\n- this will allows us to have the copied nodes all next to eachother in the correct order, in regards to their next pointers\\n- see the continued example below\\n```\\nmanipulated = 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n\\nseperated original = 1 -> 2 -> 3\\nseperated cloned = 1copy -> 2copy -> 3copy\\n```\\n\\nafter this seperation we can return the head of the cloned list\\n\\n# Complexity\\n**Time Complexity: O(n)**\\n- still three traversals = O(3n) = O(n)\\n\\n**Space Complexity: O(1)**\\n- only a constant number of pointers is used for additional memory\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return nullptr;\\n\\n        Node* original = head; // itr for original\\n        Node* cloned = nullptr; // itr for cloed\\n        Node* temp = nullptr; // temporary for node creation\\n\\n        // First pass: clone nodes and link them next to origial\\n        while(original) {\\n            temp = new Node(original->val);\\n            temp->next = original->next;\\n            original->next=temp;\\n            original = temp->next;\\n        }\\n\\n        original = head;\\n        Node* newHead = head->next;\\n\\n        // Second pass: Assign random pointers to cloned nodes\\n        while(original) {\\n            if(original->random) {\\n                original->next->random = original->random->next;\\n            } else {\\n                original->next->random = nullptr;\\n            }\\n            original = original->next->next; // skip copy\\n        }\\n        \\n        original = head;\\n\\n        // Third Pass: Seperate original and cloned \\n        while(original) {\\n            temp = original->next; \\n            original->next = temp->next; \\n            original = original->next;\\n\\n            if(original) {\\n                temp->next = original->next;\\n            } else {\\n                temp->next = nullptr;\\n            }\\n        }\\n\\n    return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nll = 1 -> 2 -> 3 -> 4 -> 5\\n\\nhashmap:\\nkeys = node1    , node2    , node3    , node4    , node5\\nvals = copynode1, copynode2, copynode3, copynode4, copynode5\\n```\n```\\nitr = head; // set iterator of original list to the head node\\nwhile(itr) {\\n    map[itr]->next = map[itr->next]; // assign copied next\\n    map[itr]->random = map[itr->random]; // assign copied random\\n    itr = itr->next; // iterate in original list to next node\\n}\\n```\n```,\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> map;\\n\\n        Node* itr = head;\\n        while(itr) {\\n            map[itr] = new Node(itr->val);\\n            itr=itr->next;\\n        }\\n\\n        itr = head;\\n        while(itr) {\\n            map[itr]->next = map[itr->next];\\n            map[itr]->random = map[itr->random];\\n            itr = itr->next;\\n        }\\n\\n        return map[head];\\n    }\\n};\\n```\n```\\nNode* original = head; // itr for original\\nNode* cloned = nullptr; // itr for cloed\\nNode* temp = nullptr; // temporary for node creation\\n```\n```\\noriginal: 1 -> 2 -> 3 \\nmanipulated: 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n```\n```\\nwhile(original) {\\n    if(original->random) {\\n        original->next->random = original->random->next;\\n        } else {\\n            original->next->random = nullptr;\\n        }\\n            original = original->next->next; // skip copy\\n    }\\n}\\n```\n```\\nmanipulated = 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n\\nseperated original = 1 -> 2 -> 3\\nseperated cloned = 1copy -> 2copy -> 3copy\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return nullptr;\\n\\n        Node* original = head; // itr for original\\n        Node* cloned = nullptr; // itr for cloed\\n        Node* temp = nullptr; // temporary for node creation\\n\\n        // First pass: clone nodes and link them next to origial\\n        while(original) {\\n            temp = new Node(original->val);\\n            temp->next = original->next;\\n            original->next=temp;\\n            original = temp->next;\\n        }\\n\\n        original = head;\\n        Node* newHead = head->next;\\n\\n        // Second pass: Assign random pointers to cloned nodes\\n        while(original) {\\n            if(original->random) {\\n                original->next->random = original->random->next;\\n            } else {\\n                original->next->random = nullptr;\\n            }\\n            original = original->next->next; // skip copy\\n        }\\n        \\n        original = head;\\n\\n        // Third Pass: Seperate original and cloned \\n        while(original) {\\n            temp = original->next; \\n            original->next = temp->next; \\n            original = original->next;\\n\\n            if(original) {\\n                temp->next = original->next;\\n            } else {\\n                temp->next = nullptr;\\n            }\\n        }\\n\\n    return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003730,
                "title": "clear-explanation-code-step-by-step-guide-to-deep-copying",
                "content": "# Problem Description:\\n\\nYou are given a **linked list** where each node has a **\"random\"** pointer that can **point to any other node in the list**, or it can be null. You need to **create a deep copy of this linked list**, such that the **copied list has new nodes with the same values as the original list**, and the \"next\" and \"random\" pointers in the copied list represent the **same relationships as in the original list**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe **key** to solving this problem **efficiently** is to use a **recursive approach** along with a **hash map** (unordered_map in C++). **Here\\'s how the provided solution works:**\\n\\n**1.** **Base Cases:**\\n- If the input **head is null**, **return null** because there\\'s nothing to copy.\\n- **Check if the hash map (mp) already contains the head node. If it does, return the corresponding copied node from the map**. This is done to avoid copying the same node multiple times.\\n2. **Creating a New Node:**\\n\\n- If the head node is **not in the hash map, create a new node (newNode) with the same value as the head node**.\\n- **Store this mapping** in the hash map, where the original head node is mapped to the newly created newNode.\\n3. **Recursion:**\\n\\n- **Recursively call copyRandomList for the next and random pointers of the head node**. This will ensure that we create deep copies of the nodes pointed to by next and random.\\n- **Assign the results of the recursive calls to newNode->next and newNode->random**. This establishes the correct relationships in the copied list.\\n4. **Return Result:**\\n\\n- **Return newNode** as the result, which is the head of the copied list.\\n# Summary:\\n- **The solution uses a recursive approach** to traverse the original linked list.\\n- **It maintains a hash map** (mp) to keep track of the mapping between nodes in the original list and their corresponding nodes in the copied list.\\n- When you encounter **a node in the original list for the first time,** **you create a new node** in the copied list with the same value.\\n- **Then, you recursively copy the next and random pointers of the original node.**\\n- By using this recursive approach and the hash map to avoid duplicating nodes, you ensure that the copied list preserves the same structure and relationships as the original list.\\n\\n**This solution is efficient because it avoids redundant copying of nodes and ensures that the relationships between nodes (both next and random) are correctly maintained in the copied list.**\\n# Complexity\\n- Time complexity:  The overall time complexity of the code is **O(N)**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  The overall space complexity of the code is **O(N).**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n# Code\\n\\n\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n    if (head == NULL)\\n      return NULL ;\\n    if (mp.count(head))\\n      return mp[head];\\n\\n    Node* newNode = new Node(head->val);\\n    mp[head] = newNode;\\n    newNode->next = copyRandomList(head->next);\\n    newNode->random = copyRandomList(head->random);\\n    return newNode;\\n  }\\n};\\n```\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    Map<Node, Node> map = new HashMap<>();\\n\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n\\n        if (map.containsKey(head)) return map.get(head);\\n\\n        Node newNode = new Node(head.val);\\n        map.put(head, newNode);\\n\\n        newNode.next = copyRandomList(head.next);\\n        newNode.random = copyRandomList(head.random);\\n\\n        return newNode;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        newNode = Node(head.val)\\n        self.visited[head] = newNode\\n\\n        newNode.next = self.copyRandomList(head.next)\\n        newNode.random = self.copyRandomList(head.random)\\n\\n        return newNode\\n\\n\\n```\\n```Javascript []\\nvar copyRandomList = function(head) {\\n    const visited = new Map();\\n\\n    const copy = (node) => {\\n        if (!node) return null;\\n\\n        if (visited.has(node)) return visited.get(node);\\n\\n        const newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n\\n        newNode.next = copy(node.next);\\n        newNode.random = copy(node.random);\\n\\n        return newNode;\\n    };\\n\\n    return copy(head);\\n};\\n\\n```\\n\\n---\\n\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n![UPVOTE.png](https://assets.leetcode.com/users/images/5e6c8908-1135-4b04-8ee5-68bd93f2cab9_1693888435.9082885.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n    if (head == NULL)\\n      return NULL ;\\n    if (mp.count(head))\\n      return mp[head];\\n\\n    Node* newNode = new Node(head->val);\\n    mp[head] = newNode;\\n    newNode->next = copyRandomList(head->next);\\n    newNode->random = copyRandomList(head->random);\\n    return newNode;\\n  }\\n};\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    Map<Node, Node> map = new HashMap<>();\\n\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n\\n        if (map.containsKey(head)) return map.get(head);\\n\\n        Node newNode = new Node(head.val);\\n        map.put(head, newNode);\\n\\n        newNode.next = copyRandomList(head.next);\\n        newNode.random = copyRandomList(head.random);\\n\\n        return newNode;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        newNode = Node(head.val)\\n        self.visited[head] = newNode\\n\\n        newNode.next = self.copyRandomList(head.next)\\n        newNode.random = self.copyRandomList(head.random)\\n\\n        return newNode\\n\\n\\n```\n```Javascript []\\nvar copyRandomList = function(head) {\\n    const visited = new Map();\\n\\n    const copy = (node) => {\\n        if (!node) return null;\\n\\n        if (visited.has(node)) return visited.get(node);\\n\\n        const newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n\\n        newNode.next = copy(node.next);\\n        newNode.random = copy(node.random);\\n\\n        return newNode;\\n    };\\n\\n    return copy(head);\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840970,
                "title": "c-o-1-space",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        \\n        Node* temp = head;\\n        \\n        while(temp){\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n        \\n        Node* ans = head->next;\\n        temp = head->next;\\n        while(head){\\n            head->next = temp->next;\\n            head = head->next;\\n            if(!head) break;\\n            temp->next = head->next;\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        \\n        Node* temp = head;\\n        \\n        while(temp){\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n        \\n        Node* ans = head->next;\\n        temp = head->next;\\n        while(head){\\n            head->next = temp->next;\\n            head = head->next;\\n            if(!head) break;\\n            temp->next = head->next;\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614624,
                "title": "python-o-n-by-mirror-node-85-w-visualization",
                "content": "Python O(n) by mirror node\\n\\n---\\n\\n\\n**Illustration and Visualization**\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677659.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677705.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677740.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677781.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677807.png)\\n\\n---\\n\\n**Implementation** by mirror node:\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        # --------------------------------------------------------\\n        \\n        # Create mirror node for each node in linked list\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            # backup original next node of input linkied list\\n            original_next_hop = cur.next\\n            \\n            # create mirror node with original order\\n            cur.next = Node( x = cur.val, next = original_next_hop, random = None)\\n            \\n            # move to next position\\n            cur = original_next_hop\\n        \\n        \\n        # --------------------------------------------------------\\n        \\n        # Let mirror node get the random pointer\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            if cur.random:\\n                # assign random pointer to mirror node\\n                cur.next.random = cur.random.next\\n                \\n            try:\\n                # move to next position\\n                cur = cur.next.next\\n            except AttributeError:\\n                break\\n                \\n        \\n        # --------------------------------------------------------\\n                \\n        # Separate copy linked list from original linked list\\n        \\n        try:\\n            # locate the head node of copy linked list\\n            head_of_copy_list = head.next\\n            cur = head_of_copy_list\\n            \\n        except AttributeError:\\n            # original input is an empty linked list\\n            return None\\n        \\n        while cur:\\n            \\n            try:\\n                # link mirror node to copy linked list\\n                cur.next = cur.next.next\\n            except AttributeError:\\n                break\\n            \\n            # move to next position\\n            cur = cur.next\\n            \\n        return head_of_copy_list\\n```\\n\\n---\\n\\nSupport function to help trace and debugging:\\n\\n```\\n    def print_linked_list( self, node ):\\n        \\n        cur = node\\n        \\n        while cur:\\n            print( f\\' val = {cur.val} \\')\\n            \\n            if cur.next:\\n                print( f\\' next = {cur.next.val} \\')\\n            else:\\n                print( f\\' next = None \\')\\n                \\n            if cur.random:\\n                print( f\\' random = {cur.random.val} \\')\\n            else:\\n                print( f\\' random = None\\')\\n                \\n            print( \\'\\\\n => \\\\n\\' )\\n            \\n            cur = cur.next\\n```\\n\\n---\\n\\nShare another solution by dictionary of mirror node\\n\\n**Implementation**:\\n\\n```\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\n        if not head:\\n            return None\\n\\n        dict_of_copy = {}\\n\\n        cur = head\\n        while cur:\\n            dict_of_copy[ id(cur) ] = Node(x=cur.val, next=None, random=None)\\n            cur = cur.next\\n\\n        cur = head\\n        while cur:\\n\\n            if cur.next:\\n                dict_of_copy[ id(cur) ].next = dict_of_copy[ id(cur.next) ]\\n\\n            if cur.random:\\n                dict_of_copy[ id(cur) ].random = dict_of_copy[ id(cur.random) ]\\n\\n            cur = cur.next\\n\\n        return dict_of_copy[ id(head) ]\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        # --------------------------------------------------------\\n        \\n        # Create mirror node for each node in linked list\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            # backup original next node of input linkied list\\n            original_next_hop = cur.next\\n            \\n            # create mirror node with original order\\n            cur.next = Node( x = cur.val, next = original_next_hop, random = None)\\n            \\n            # move to next position\\n            cur = original_next_hop\\n        \\n        \\n        # --------------------------------------------------------\\n        \\n        # Let mirror node get the random pointer\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            if cur.random:\\n                # assign random pointer to mirror node\\n                cur.next.random = cur.random.next\\n                \\n            try:\\n                # move to next position\\n                cur = cur.next.next\\n            except AttributeError:\\n                break\\n                \\n        \\n        # --------------------------------------------------------\\n                \\n        # Separate copy linked list from original linked list\\n        \\n        try:\\n            # locate the head node of copy linked list\\n            head_of_copy_list = head.next\\n            cur = head_of_copy_list\\n            \\n        except AttributeError:\\n            # original input is an empty linked list\\n            return None\\n        \\n        while cur:\\n            \\n            try:\\n                # link mirror node to copy linked list\\n                cur.next = cur.next.next\\n            except AttributeError:\\n                break\\n            \\n            # move to next position\\n            cur = cur.next\\n            \\n        return head_of_copy_list\\n```\n```\\n    def print_linked_list( self, node ):\\n        \\n        cur = node\\n        \\n        while cur:\\n            print( f\\' val = {cur.val} \\')\\n            \\n            if cur.next:\\n                print( f\\' next = {cur.next.val} \\')\\n            else:\\n                print( f\\' next = None \\')\\n                \\n            if cur.random:\\n                print( f\\' random = {cur.random.val} \\')\\n            else:\\n                print( f\\' random = None\\')\\n                \\n            print( \\'\\\\n => \\\\n\\' )\\n            \\n            cur = cur.next\\n```\n```\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\n        if not head:\\n            return None\\n\\n        dict_of_copy = {}\\n\\n        cur = head\\n        while cur:\\n            dict_of_copy[ id(cur) ] = Node(x=cur.val, next=None, random=None)\\n            cur = cur.next\\n\\n        cur = head\\n        while cur:\\n\\n            if cur.next:\\n                dict_of_copy[ id(cur) ].next = dict_of_copy[ id(cur.next) ]\\n\\n            if cur.random:\\n                dict_of_copy[ id(cur) ].random = dict_of_copy[ id(cur.random) ]\\n\\n            cur = cur.next\\n\\n        return dict_of_copy[ id(head) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059152,
                "title": "python-3-stage-o-n-solution-explained",
                "content": "First, we can go through the linked list, put all nodes to hash table and then connect all additional nodes. It takes additional `O(n)` memory. If we more memory efficient solution, we need to think more.\\n\\nUnfortunately, we can not use BFS or DFS here, because, we do not  really know the number of node for random field, only the reference, which can be found in either `O(n)` or we need to keep all references in hash table. \\n\\nThe trick to solve this problem in `O(1)` memory is to use duplication trick. Imagine, that we have list `7 -> 13 -> 11 -> null`, then we need to do `3` stages:\\n\\n1. Create duplicated list, that is `7 -> 7 -> 13 -> 13 -> 11 -> 11 -> null`, where every second value will be elements of new list.\\n2. Second step is to add `random` field pointers, it can be done as `curr.next.random = curr.random.next`, that is where we need to point random pointer of second node with value `7`? We need to look at random field of first `7` and take next element. We need to be careful with null pointers.\\n3. Finally, we need to cut list into two parts, we can do it with simple `2` pointers `curr` and `nxt`, which always will have adjacent elements inside.\\n\\n**Complexity**: time complexity is `O(n)`, this is complexity of every stage. Space complexity is `O(1)`, if we do not count our output list.\\n\\nThe trick to solve is to duplicate our list, after each node add the node with the same value, then add new random fields, and then cut it into 2 lists.\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        dummy = Node(-1)\\n        dummy.next = head\\n        curr = head\\n        while curr:\\n            tmp = Node(curr.val)\\n            tmp.next = curr.next\\n            curr.next = tmp\\n            curr = tmp.next\\n            \\n        curr = head\\n        while curr:\\n            curr.next.random = curr.random.next if curr.random else None\\n            curr = curr.next.next\\n            \\n        curr, nxt = dummy, head\\n        while nxt:\\n            curr.next = nxt.next\\n            curr = nxt\\n            nxt = curr.next\\n            \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        dummy = Node(-1)\\n        dummy.next = head\\n        curr = head\\n        while curr:\\n            tmp = Node(curr.val)\\n            tmp.next = curr.next\\n            curr.next = tmp\\n            curr = tmp.next\\n            \\n        curr = head\\n        while curr:\\n            curr.next.random = curr.random.next if curr.random else None\\n            curr = curr.next.next\\n            \\n        curr, nxt = dummy, head\\n        while nxt:\\n            curr.next = nxt.next\\n            curr = nxt\\n            nxt = curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841347,
                "title": "java-solution-simple-code-7-line-code",
                "content": "\\tPoints:-\\n\\n1. Store the old and corresponding new Node in the map.\\n2. Traverse the Node recursivelly and while returning from recursion set the respective pointer, next and random pointer.\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n\\n    Map<Node,Node> map = new HashMap<>();\\n\\t\\n    public Node copyRandomList(Node head) {\\n        if(head == null) return null;\\n        Node temp = new Node(head.val);\\n        map.put(head,temp);\\n        temp.next = copyRandomList(head.next);\\n        temp.random = map.get(head.random);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Node,Node> map = new HashMap<>();\\n\\t\\n    public Node copyRandomList(Node head) {\\n        if(head == null) return null;\\n        Node temp = new Node(head.val);\\n        map.put(head,temp);\\n        temp.next = copyRandomList(head.next);\\n        temp.random = map.get(head.random);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004716,
                "title": "easy-code-with-comment-multiple-approaches-video-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do manipulation of pointers.\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an unordered map `u` to store the mapping between the original nodes and their corresponding copied nodes.\\n\\n2. Iterate through the original linked list `head` and for each node encountered, create a new node with the same value, and store it in the map `u` with the original node as the key.\\n\\n3. Reset `temp` to the beginning of the list `head`.\\n\\n4. Iterate through the list again, this time connecting the `next` and `random` pointers for the copied nodes using the information stored in the map `u`.\\n\\n5. Return the copied head node, which is stored as `u[head]`.\\n\\nThis code first creates a copy of each node and stores it in the map, and then connects the copied nodes\\' `next` and `random` pointers to complete the deep copy. Finally, it returns the head of the copied list.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *temp=head;\\n        unordered_map<Node*,Node*>u;\\n        while(temp!=NULL){\\n         u[temp]=new Node(temp->val);\\n         temp=temp->next;\\n        }\\n        temp=head;\\n        while(temp!=NULL){\\n         Node*curr=u[temp];\\n         Node* nex=u[temp->next];\\n         Node*r=u[temp->random];\\n         curr->next=nex;\\n         curr->random=r;\\n         temp=temp->next;\\n        }\\n        return u[head];\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node current = head;\\n        \\n        // First pass: Create a copy of each node and store it in the map\\n        while (current != null) {\\n            map.put(current, new Node(current.val));\\n            current = current.next;\\n        }\\n        \\n        current = head;\\n        \\n        // Second pass: Connect the copied nodes\\' next and random pointers\\n        while (current != null) {\\n            Node copyNode = map.get(current);\\n            copyNode.next = map.get(current.next);\\n            copyNode.random = map.get(current.random);\\n            current = current.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        node_map = {}\\n        current = head\\n        \\n        # First pass: Create a copy of each node and store it in the map\\n        while current:\\n            node_map[current] = Node(current.val)\\n            current = current.next\\n        \\n        current = head\\n        \\n        # Second pass: Connect the copied nodes\\' next and random pointers\\n        while current:\\n            copy_node = node_map[current]\\n            copy_node.next = node_map.get(current.next)\\n            copy_node.random = node_map.get(current.random)\\n            current = current.next\\n        \\n        return node_map[head]\\n\\n```\\n# Approach 2\\n\\nThis code is an implementation of deep copying a linked list with random pointers using a constant amount of extra space.\\n\\n1. Iterate through the original linked list `head`, and for each node encountered:\\n   - Create a new node with the same value as the original node.\\n   - Insert the new node right after the original node.\\n   - Advance the current pointer by two steps (skip the newly created node).\\n\\n2. Iterate through the list again, this time connecting the `random` pointers for the copied nodes. Update the `random` pointer of each copied node to point to the correct node (if not `NULL`) by using the relationship `copied_node->random = original_node->random->next`.\\n\\n3. Separate the original list and the copied list by adjusting the `next` pointers. Reset the `current` pointer to `head`, and while iterating:\\n   - Set `current->next` to its correct value (either the next original node or `NULL`).\\n   - Adjust the `next` pointer for the corresponding copied node in the copied list similarly.\\n   - Move `current` and the temporary pointer for the copied list forward by one step.\\n\\n4. Return the head of the copied list, which is the node right after the original head node.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        \\n        // First pass: Create a new node after each original node\\n        while (curr != NULL) {\\n            Node* next = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = next;\\n            curr = next;\\n        }\\n        \\n        // Second pass: Connect random pointers for the copied nodes\\n        curr = head;\\n        while (curr != NULL) {\\n            if (curr->random != NULL) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        // Third pass: Separate the original and copied lists\\n        Node* p = head->next;\\n        Node* temp = p;\\n        curr = head;\\n        while (curr != NULL && temp != NULL) {\\n            curr->next = (curr->next != NULL) ? curr->next->next : curr->next;\\n            temp->next = (temp->next != NULL) ? temp->next->next : temp->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        \\n        return p;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node current = head;\\n\\n        // First pass: Create a new node after each original node\\n        while (current != null) {\\n            Node next = current.next;\\n            current.next = new Node(current.val);\\n            current.next.next = next;\\n            current = next;\\n        }\\n\\n        // Second pass: Connect random pointers for the copied nodes\\n        current = head;\\n        while (current != null) {\\n            if (current.random != null) {\\n                current.next.random = current.random.next;\\n            }\\n            current = current.next.next;\\n        }\\n\\n        // Third pass: Separate the original and copied lists\\n        Node p = head.next;\\n        Node temp = p;\\n        current = head;\\n        while (current != null && temp != null) {\\n            current.next = (current.next != null) ? current.next.next : current.next;\\n            temp.next = (temp.next != null) ? temp.next.next : temp.next;\\n            current = current.next;\\n            temp = temp.next;\\n        }\\n\\n        return p;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        current = head\\n\\n        # First pass: Create a new node after each original node\\n        while current:\\n            next_node = current.next\\n            current.next = Node(current.val)\\n            current.next.next = next_node\\n            current = next_node\\n\\n        # Second pass: Connect random pointers for the copied nodes\\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n\\n        # Third pass: Separate the original and copied lists\\n        p = head.next\\n        temp = p\\n        current = head\\n        while current and temp:\\n            current.next = current.next.next if current.next else current.next\\n            temp.next = temp.next.next if temp.next else temp.next\\n            current = current.next\\n            temp = temp.next\\n\\n        return p\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *temp=head;\\n        unordered_map<Node*,Node*>u;\\n        while(temp!=NULL){\\n         u[temp]=new Node(temp->val);\\n         temp=temp->next;\\n        }\\n        temp=head;\\n        while(temp!=NULL){\\n         Node*curr=u[temp];\\n         Node* nex=u[temp->next];\\n         Node*r=u[temp->random];\\n         curr->next=nex;\\n         curr->random=r;\\n         temp=temp->next;\\n        }\\n        return u[head];\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node current = head;\\n        \\n        // First pass: Create a copy of each node and store it in the map\\n        while (current != null) {\\n            map.put(current, new Node(current.val));\\n            current = current.next;\\n        }\\n        \\n        current = head;\\n        \\n        // Second pass: Connect the copied nodes\\' next and random pointers\\n        while (current != null) {\\n            Node copyNode = map.get(current);\\n            copyNode.next = map.get(current.next);\\n            copyNode.random = map.get(current.random);\\n            current = current.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        node_map = {}\\n        current = head\\n        \\n        # First pass: Create a copy of each node and store it in the map\\n        while current:\\n            node_map[current] = Node(current.val)\\n            current = current.next\\n        \\n        current = head\\n        \\n        # Second pass: Connect the copied nodes\\' next and random pointers\\n        while current:\\n            copy_node = node_map[current]\\n            copy_node.next = node_map.get(current.next)\\n            copy_node.random = node_map.get(current.random)\\n            current = current.next\\n        \\n        return node_map[head]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        \\n        // First pass: Create a new node after each original node\\n        while (curr != NULL) {\\n            Node* next = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = next;\\n            curr = next;\\n        }\\n        \\n        // Second pass: Connect random pointers for the copied nodes\\n        curr = head;\\n        while (curr != NULL) {\\n            if (curr->random != NULL) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        // Third pass: Separate the original and copied lists\\n        Node* p = head->next;\\n        Node* temp = p;\\n        curr = head;\\n        while (curr != NULL && temp != NULL) {\\n            curr->next = (curr->next != NULL) ? curr->next->next : curr->next;\\n            temp->next = (temp->next != NULL) ? temp->next->next : temp->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        \\n        return p;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node current = head;\\n\\n        // First pass: Create a new node after each original node\\n        while (current != null) {\\n            Node next = current.next;\\n            current.next = new Node(current.val);\\n            current.next.next = next;\\n            current = next;\\n        }\\n\\n        // Second pass: Connect random pointers for the copied nodes\\n        current = head;\\n        while (current != null) {\\n            if (current.random != null) {\\n                current.next.random = current.random.next;\\n            }\\n            current = current.next.next;\\n        }\\n\\n        // Third pass: Separate the original and copied lists\\n        Node p = head.next;\\n        Node temp = p;\\n        current = head;\\n        while (current != null && temp != null) {\\n            current.next = (current.next != null) ? current.next.next : current.next;\\n            temp.next = (temp.next != null) ? temp.next.next : temp.next;\\n            current = current.next;\\n            temp = temp.next;\\n        }\\n\\n        return p;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        current = head\\n\\n        # First pass: Create a new node after each original node\\n        while current:\\n            next_node = current.next\\n            current.next = Node(current.val)\\n            current.next.next = next_node\\n            current = next_node\\n\\n        # Second pass: Connect random pointers for the copied nodes\\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n\\n        # Third pass: Separate the original and copied lists\\n        p = head.next\\n        temp = p\\n        current = head\\n        while current and temp:\\n            current.next = current.next.next if current.next else current.next\\n            temp.next = temp.next.next if temp.next else temp.next\\n            current = current.next\\n            temp = temp.next\\n\\n        return p\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003497,
                "title": "video-solution-with-hashmap-python-javascript-java-c",
                "content": "# Intuition\\nThe main idea to solve the question of copying a linked list with random pointers is to create a deep copy of the original linked list while maintaining the relationships between nodes. By following these steps below, you can create an exact deep copy of the original linked list, including its random pointers, and return the head of the copied list. This approach ensures that you maintain the relationships between nodes while copying the linked list with minimal time and space complexity.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 255 videos as of September 5th, 2023.\\n\\nhttps://youtu.be/eO8TmVWbcxw\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Create a dictionary (`hash`) to map original nodes to their corresponding copied nodes.\\n   - Initialize the dictionary with a mapping of `None` to `None`.\\n\\n2. Traverse the original linked list using a pointer `cur`.\\n   - While `cur` is not `None`:\\n     - Create a new node with the same value as the current node and store it in the dictionary `hash` with the current node as the key.\\n     - Move `cur` to the next node in the original list.\\n\\n3. Reset the `cur` pointer to the head of the original linked list.\\n\\n4. Traverse the original linked list again using `cur`.\\n   - While `cur` is not `None`:\\n     - Retrieve the copied node from the `hash` dictionary using `cur` as the key and store it in the `copy` variable.\\n     - Set the `next` pointer of the `copy` node to the copied node obtained from the `hash` dictionary using `cur.next` as the key.\\n     - Set the `random` pointer of the `copy` node to the copied node obtained from the `hash` dictionary using `cur.random` as the key.\\n     - Move `cur` to the next node in the original list.\\n\\n5. Return the copied head node obtained from the `hash` dictionary using the original head node as the key.\\n\\nThis algorithm first creates a mapping of original nodes to their copied nodes and then iterates through the original list twice to connect the `next` and `random` pointers of the copied nodes. Finally, it returns the head of the copied linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':    \\n        hash = {None:None}\\n        cur = head\\n        \\n        while cur:\\n            hash[cur] = Node(cur.val)\\n            cur = cur.next\\n            \\n        cur = head\\n        \\n        while cur:\\n            copy = hash[cur]\\n            copy.next = hash[cur.next]\\n            copy.random = hash[cur.random]\\n            cur = cur.next\\n            \\n        return hash[head]\\n```\\n```javascript []\\nvar copyRandomList = function(head) {\\n    const hashMap = new Map();\\n    let cur = head;\\n\\n    while (cur) {\\n        hashMap.set(cur, new Node(cur.val));\\n        cur = cur.next;\\n    }\\n\\n    cur = head;\\n\\n    while (cur) {\\n        const copy = hashMap.get(cur);\\n        copy.next = hashMap.get(cur.next) || null;\\n        copy.random = hashMap.get(cur.random) || null;\\n        cur = cur.next;\\n    }\\n\\n    return hashMap.get(head);   \\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> hashMap = new HashMap<>();\\n        Node cur = head;\\n\\n        while (cur != null) {\\n            hashMap.put(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur != null) {\\n            Node copy = hashMap.get(cur);\\n            copy.next = hashMap.get(cur.next);\\n            copy.random = hashMap.get(cur.random);\\n            cur = cur.next;\\n        }\\n\\n        return hashMap.get(head);        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        std::unordered_map<Node*, Node*> hashMap;\\n        Node* cur = head;\\n\\n        while (cur) {\\n            hashMap[cur] = new Node(cur->val);\\n            cur = cur->next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur) {\\n            Node* copy = hashMap[cur];\\n            copy->next = hashMap[cur->next];\\n            copy->random = hashMap[cur->random];\\n            cur = cur->next;\\n        }\\n\\n        return hashMap[head];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':    \\n        hash = {None:None}\\n        cur = head\\n        \\n        while cur:\\n            hash[cur] = Node(cur.val)\\n            cur = cur.next\\n            \\n        cur = head\\n        \\n        while cur:\\n            copy = hash[cur]\\n            copy.next = hash[cur.next]\\n            copy.random = hash[cur.random]\\n            cur = cur.next\\n            \\n        return hash[head]\\n```\n```javascript []\\nvar copyRandomList = function(head) {\\n    const hashMap = new Map();\\n    let cur = head;\\n\\n    while (cur) {\\n        hashMap.set(cur, new Node(cur.val));\\n        cur = cur.next;\\n    }\\n\\n    cur = head;\\n\\n    while (cur) {\\n        const copy = hashMap.get(cur);\\n        copy.next = hashMap.get(cur.next) || null;\\n        copy.random = hashMap.get(cur.random) || null;\\n        cur = cur.next;\\n    }\\n\\n    return hashMap.get(head);   \\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> hashMap = new HashMap<>();\\n        Node cur = head;\\n\\n        while (cur != null) {\\n            hashMap.put(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur != null) {\\n            Node copy = hashMap.get(cur);\\n            copy.next = hashMap.get(cur.next);\\n            copy.random = hashMap.get(cur.random);\\n            cur = cur.next;\\n        }\\n\\n        return hashMap.get(head);        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        std::unordered_map<Node*, Node*> hashMap;\\n        Node* cur = head;\\n\\n        while (cur) {\\n            hashMap[cur] = new Node(cur->val);\\n            cur = cur->next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur) {\\n            Node* copy = hashMap[cur];\\n            copy->next = hashMap[cur->next];\\n            copy->random = hashMap[cur->random];\\n            cur = cur->next;\\n        }\\n\\n        return hashMap[head];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136000,
                "title": "clean-javascript-solution-using-hashmap",
                "content": "```js\\nfunction copyRandomList(head) {\\n  const map = new Map();\\n  \\n  function copy(node)   {\\n    if (node == null) return null;\\n    if (map.get(node) != null) return map.get(node);\\n\\n    const n = new Node(node.val);\\n    map.set(node, n);\\n\\n    n.next = copy(node.next);\\n    n.random = copy(node.random);\\n    return n;\\n  }\\n\\n  return copy(head);\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction copyRandomList(head) {\\n  const map = new Map();\\n  \\n  function copy(node)   {\\n    if (node == null) return null;\\n    if (map.get(node) != null) return map.get(node);\\n\\n    const n = new Node(node.val);\\n    map.set(node, n);\\n\\n    n.next = copy(node.next);\\n    n.random = copy(node.random);\\n    return n;\\n  }\\n\\n  return copy(head);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43714,
                "title": "accepted-c-solution-rt-o-n-sp-o-1",
                "content": "    struct RandomListNode *copyRandomList(struct RandomListNode *head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct RandomListNode *p=head;\\n    \\tstruct RandomListNode *pt;\\n\\n    \\t//copy\\n    \\twhile(NULL!=p){\\n    \\t\\tpt=p->next;\\n    \\t\\tp->next=malloc(sizeof(struct RandomListNode));\\n    \\t\\tp->next->label=p->label;\\n    \\t\\tp->next->next=pt;\\n    \\t\\tp->next->random=NULL; \\n    \\t\\tp=pt;\\n    \\t};\\n\\n    \\t//fix random pointer\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=p->random){\\n    \\t\\t\\tp->next->random=p->random->next;\\n    \\t\\t}\\n    \\t\\tp=p->next->next;\\n    \\t};\\n\\n    \\t//separate\\n    \\tstruct RandomListNode *copyed_head=NULL;\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=copyed_head){\\n    \\t\\t\\tpt->next=p->next;\\n    \\t\\t\\tpt=pt->next;\\n    \\t\\t}else{\\n    \\t\\t\\tcopyed_head=p->next;\\n    \\t\\t\\tpt=copyed_head;\\n    \\t\\t}\\n    \\t\\tp->next=p->next->next;\\n    \\t\\tp=p->next;\\n    \\t};\\n    \\n    \\treturn copyed_head;\\n    }\\n\\nWell, someone already share this idea.\\n\\n - step 1:copy each node and append it to the original one;\\n - step 2:iterate the new list and fix the random pointers\\n - step 3:separate the list.",
                "solutionTags": [],
                "code": "    struct RandomListNode *copyRandomList(struct RandomListNode *head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct RandomListNode *p=head;\\n    \\tstruct RandomListNode *pt;\\n\\n    \\t//copy\\n    \\twhile(NULL!=p){\\n    \\t\\tpt=p->next;\\n    \\t\\tp->next=malloc(sizeof(struct RandomListNode));\\n    \\t\\tp->next->label=p->label;\\n    \\t\\tp->next->next=pt;\\n    \\t\\tp->next->random=NULL; \\n    \\t\\tp=pt;\\n    \\t};\\n\\n    \\t//fix random pointer\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=p->random){\\n    \\t\\t\\tp->next->random=p->random->next;\\n    \\t\\t}\\n    \\t\\tp=p->next->next;\\n    \\t};\\n\\n    \\t//separate\\n    \\tstruct RandomListNode *copyed_head=NULL;\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=copyed_head){\\n    \\t\\t\\tpt->next=p->next;\\n    \\t\\t\\tpt=pt->next;\\n    \\t\\t}else{\\n    \\t\\t\\tcopyed_head=p->next;\\n    \\t\\t\\tpt=copyed_head;\\n    \\t\\t}\\n    \\t\\tp->next=p->next->next;\\n    \\t\\tp=p->next;\\n    \\t};\\n    \\n    \\treturn copyed_head;\\n    }\\n\\nWell, someone already share this idea.\\n\\n - step 1:copy each node and append it to the original one;\\n - step 2:iterate the new list and fix the random pointers\\n - step 3:separate the list.",
                "codeTag": "Unknown"
            },
            {
                "id": 1841654,
                "title": "visual-python-easy-to-understand-o-n-time-o-n-space",
                "content": "\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n\\n**Approach**\\nWe use a dictionary to store the original list nodes as keys. Then we create the new nodes as the dictionary values. This way we can lookup the new node given the old node and perform any operations on the new node at the same time.\\n\\n![image](https://assets.leetcode.com/users/images/0115d285-2273-47e7-b29d-34a52bb20b68_1647068325.1311626.png)\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n<iframe src=\"https://leetcode.com/playground/h6HY3aBo/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n\\n**Approach**\\nWe use a dictionary to store the original list nodes as keys. Then we create the new nodes as the dictionary values. This way we can lookup the new node given the old node and perform any operations on the new node at the same time.\\n\\n![image](https://assets.leetcode.com/users/images/0115d285-2273-47e7-b29d-34a52bb20b68_1647068325.1311626.png)\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n<iframe src=\"https://leetcode.com/playground/h6HY3aBo/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 43632,
                "title": "java-very-simple-and-clean-solution-with-o-n-time-o-1-space-with-algorithm",
                "content": " \\n/* Algorithm  \\n\\n1) Create the copy of node 1 and insert it between node 1 & node 2 in original Linked List, create the copy of 2 and insert    it between 2 & 3.. Continue in this fashion, add the copy of N after the Nth node\\n    \\n 2)  Now copy the random link in this fashion\\n           \\n       original->next->random = original->random->next;\\n        \\nThis works because original->next is nothing but copy of original and Original->random->next is nothing but copy of random.\\n     \\n3) Now restore the original and copy linked lists in this fashion in a single loop.\\n         \\n       original->next = original->next->next;  \\n       copy->next = copy->next->next;\\n     \\n4) Make sure that last element of original->next is NULL.\\n */\\n\\n\\n\\npublic class Solution {\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if(head == null) return head;\\n        \\n        RandomListNode original=head;\\n        RandomListNode curOriginal=head;\\n        \\n        // step 1\\n        while(original.next != null ){\\n            RandomListNode copy=new RandomListNode(original.label);\\n            RandomListNode temp=original.next;\\n            original.next=copy;\\n            copy.next=temp;\\n            original=original.next.next;\\n        }\\n        original.next=new RandomListNode(original.label);\\n        \\n        //step 2\\n        while(curOriginal!= null && curOriginal.next != null){\\n            if(curOriginal.random != null){\\n                curOriginal.next.random=curOriginal.random.next;\\n            }\\n            curOriginal=curOriginal.next.next;\\n        }\\n        \\n        //step 3 and 4\\n        RandomListNode orig=head;\\n        RandomListNode copyCur=head.next;\\n        RandomListNode copyHead=head.next;\\n        \\n        while(orig.next != null && copyCur.next != null){\\n            orig.next=orig.next.next;\\n            copyCur.next=copyCur.next.next;\\n            orig=orig.next;\\n            copyCur=copyCur.next;\\n        }\\n        orig.next=null;\\n        \\n        return copyHead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if(head == null) return head;\\n        \\n        RandomListNode original=head;\\n        RandomListNode curOriginal=head;\\n        \\n        // step 1\\n        while(original.next != null ){\\n            RandomListNode copy=new RandomListNode(original.label);\\n            RandomListNode temp=original.next;\\n            original.next=copy;\\n            copy.next=temp;\\n            original=original.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 543309,
                "title": "javascript-solution-90",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    let curr = head;\\n    while (curr) {\\n        let copy = new Node(curr.val, curr.next, null);\\n        copy.next = curr.next;\\n        curr.next = copy;\\n        curr = curr.next;\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while(curr) {\\n        curr.next.random = curr.random ? curr.random.next : null;\\n        curr = curr.next.next;\\n    }\\n    \\n    curr = head;\\n    let result = head.next;\\n    let resPtr = result;\\n    while(curr) {\\n        curr.next = curr.next.next;\\n        curr = curr.next;\\n        resPtr.next = resPtr.next ? resPtr.next.next : null;\\n        resPtr = resPtr.next;\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nRuntime: 52 ms, faster than 90.76% of JavaScript online submissions for Copy List with Random Pointer.\\nMemory Usage: 35.1 MB, less than 100.00% of JavaScript online submissions for Copy List with Random Pointer.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    let curr = head;\\n    while (curr) {\\n        let copy = new Node(curr.val, curr.next, null);\\n        copy.next = curr.next;\\n        curr.next = copy;\\n        curr = curr.next;\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while(curr) {\\n        curr.next.random = curr.random ? curr.random.next : null;\\n        curr = curr.next.next;\\n    }\\n    \\n    curr = head;\\n    let result = head.next;\\n    let resPtr = result;\\n    while(curr) {\\n        curr.next = curr.next.next;\\n        curr = curr.next;\\n        resPtr.next = resPtr.next ? resPtr.next.next : null;\\n        resPtr = resPtr.next;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059380,
                "title": "c-explanation-o-1-space-o-n-time-three-pass-easy-solution",
                "content": "**Explanation:** This is the most optimal solution and the logic is **simply rewiring the pointers** to create a mapping between the original linked list and cloned linked list. This can get a bit tricky because while we are utilising the next pointer of the original LL to store the mapping of the cloned linked list, we want to make sure that the original linked list is not affected in any manner. The problem can be divided into three sub-problems\\n\\n**1. Cloning of original linked list:** In this step we are **creating a new node and making it the next of original LL\\'s node.** Then we are pointing this **new node\\'s next to the original LL\\'s node\\'s next.** We are utilising the next pointer to store the cloned node\\'s location. \\n\\n   ![image](https://assets.leetcode.com/users/images/635767b4-ee5c-4837-a3d8-0b335368b467_1613021559.7102857.png)\\n\\n\\n**2. Mapping of random pointers:** Now that we have created our cloned singly linked list, we need to assign the random pointers. For this, again we are gonna use next pointer of both original and cloned LL. Using original node\\'s next and random pointer, we will find the cloned node\\'s random pointer and assign it. \\n\\n   ![image](https://assets.leetcode.com/users/images/0e7d740f-37d2-43ca-ad08-68aac22f81d4_1613022137.5576704.png)\\n   \\n \\n**3. Restoring the original linked list:** Now as you can see in the above diagram, the next pointers of original LL is still connected to the cloned LL. We need to detach these pointers and restore the original LL. For this, create a new node currN and it make it next of temp2. Then assign currN as next of temp. Then iterate the linked list untill temp and temp2 reached NULL. Dry run this step for better understanding.\\n\\nThis solution is inspired by [Back to Back SWE\\'s video explanation](https://youtu.be/OvpKeraoxW0)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        \\n        Node* temp=head;\\n        \\n        //creates mapping of cloned list using original list\\n        while(temp)\\n        {\\n            Node* newNode= new Node(temp->val);\\n            newNode->next=temp->next;\\n            temp->next=newNode;\\n            temp=newNode->next;\\n            \\n        }\\n        \\n        //assigning random pointers\\n        temp=head;\\n        while(temp)\\n        {\\n            if(temp->random)\\n            {\\n               temp->next->random= temp->random->next;   \\n            }\\n            temp=temp->next->next;\\n        }\\n        \\n        //restore the original linked list\\n        Node* newHead= head->next;\\n        Node* temp2=head->next;\\n        temp=head;\\n        \\n        while(temp  && temp2)\\n        {\\n            Node* currN=temp2->next;\\n            temp->next=currN;\\n            if(currN)\\n            {\\n                temp2->next=currN->next;\\n            }\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        \\n        Node* temp=head;\\n        \\n        //creates mapping of cloned list using original list\\n        while(temp)\\n        {\\n            Node* newNode= new Node(temp->val);\\n            newNode->next=temp->next;\\n            temp->next=newNode;\\n            temp=newNode->next;\\n            \\n        }\\n        \\n        //assigning random pointers\\n        temp=head;\\n        while(temp)\\n        {\\n            if(temp->random)\\n            {\\n               temp->next->random= temp->random->next;   \\n            }\\n            temp=temp->next->next;\\n        }\\n        \\n        //restore the original linked list\\n        Node* newHead= head->next;\\n        Node* temp2=head->next;\\n        temp=head;\\n        \\n        while(temp  && temp2)\\n        {\\n            Node* currN=temp2->next;\\n            temp->next=currN;\\n            if(currN)\\n            {\\n                temp2->next=currN->next;\\n            }\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561863,
                "title": "awesome-hashmap-concept",
                "content": "# Using Hashmap--->TC:O(N)\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dic={None:None}\\n        cur=head\\n        while cur:\\n            dic[cur]=Node(cur.val)\\n            cur=cur.next\\n        cur=head\\n        while cur:\\n            copy=dic[cur]\\n            copy.next=dic[cur.next]\\n            copy.random=dic[cur.random]\\n            cur=cur.next\\n        return dic[head]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dic={None:None}\\n        cur=head\\n        while cur:\\n            dic[cur]=Node(cur.val)\\n            cur=cur.next\\n        cur=head\\n        while cur:\\n            copy=dic[cur]\\n            copy.next=dic[cur.next]\\n            copy.random=dic[cur.random]\\n            cur=cur.next\\n        return dic[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841437,
                "title": "clean-c-soln-w-explanation-o-n-time-o-1-space-iterative-o-n-time-space-recursive",
                "content": "#### Iterative Solution:\\n\\n**Idea In Brief:** We would want to avoid hashing each and every node in the input list with the corresponding new list nodes. In order to do that, we could traverse the input list once and add a new node with the same node value as input list and modify the list as follows:\\n```\\nInput List: [7]->[13]->[11]->[10]->[1] \\nModified List: [7]-[copy7]->[13]->[copy13]->[11]->[copy11]->[10]->[copy10]->[1]->[copy1]\\n``` \\nOnce we have modified the input list, we could traverse the entire list and update the random pointers for the newly create list nodes. Finally we need to traverse the list to disconnect all the input list nodes and link the new nodes and return the `copyHead` of the new list. It will be better understood with the code:\\n\\n**Code:**\\n```\\n Node* copyRandomList(Node* head) {\\n        if(not head) \\n            return head;\\n// Modifying the input list:\\n        Node *temp = head, *ptr = head;\\n        while(ptr){\\n            temp = ptr->next;\\n            ptr->next = new Node(ptr->val);\\n            ptr->next->next = temp;\\n            ptr = temp;\\n        }\\n// List Updated to: [7]-[copy7]->[13]->[copy13]... \\n\\n//  Updating the random pointers\\n\\tptr = head;\\n    while(ptr){\\n            ptr->next->random = (ptr->random)? ptr->random->next : nullptr;\\n            ptr = ptr->next->next;\\n        }\\n//  Disconnecting to generate cloned list.\\n        Node *copyHead = head->next, *copyptr = head->next;\\n        while(head){\\n            head->next = head->next->next;\\n            copyptr->next = copyptr->next? copyptr->next->next : nullptr;\\n            head = head->next;\\n            copyptr = copyptr->next;\\n        }   \\n     return copyHead; \\n    }\\n```\\nThe above solution is a linear time `O(N)` and constant space solution `O(1)`\\n\\n---\\n\\n#### Recursive Solution\\nThe problem can intuitively be solved using recursion, and using hashing of nodes. Recursive approach is a `O(N) Time and O(N) Space` solution. \\n**Idea In Brief:** We need to traverse the list and maintain a mapping between the old list node and the newly created listnode with corresponding node values. We need to make sure that the entire `input` list is traversed first so that we have access to `input` list\\'s all the nodes, and we can update our `new list\\'s` random pointer. \\n\\n**Code:** \\n```\\n unordered_map<Node*,Node*> mp;\\n    Node *Solve(Node *curr){\\n        if(not curr)\\n            return curr;\\n        Node *newNode = new Node(curr->val);\\n        mp[curr] = newNode;\\n        newNode->next = Solve(curr->next);\\n        newNode->random = mp[curr->random];\\n        \\n        return newNode;\\n    }\\n    Node* copyRandomList(Node* head){\\n        if(not head)\\n            return head;\\n        return Solve(head);\\n    }\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nInput List: [7]->[13]->[11]->[10]->[1] \\nModified List: [7]-[copy7]->[13]->[copy13]->[11]->[copy11]->[10]->[copy10]->[1]->[copy1]\\n```\n```\\n Node* copyRandomList(Node* head) {\\n        if(not head) \\n            return head;\\n// Modifying the input list:\\n        Node *temp = head, *ptr = head;\\n        while(ptr){\\n            temp = ptr->next;\\n            ptr->next = new Node(ptr->val);\\n            ptr->next->next = temp;\\n            ptr = temp;\\n        }\\n// List Updated to: [7]-[copy7]->[13]->[copy13]... \\n\\n//  Updating the random pointers\\n\\tptr = head;\\n    while(ptr){\\n            ptr->next->random = (ptr->random)? ptr->random->next : nullptr;\\n            ptr = ptr->next->next;\\n        }\\n//  Disconnecting to generate cloned list.\\n        Node *copyHead = head->next, *copyptr = head->next;\\n        while(head){\\n            head->next = head->next->next;\\n            copyptr->next = copyptr->next? copyptr->next->next : nullptr;\\n            head = head->next;\\n            copyptr = copyptr->next;\\n        }   \\n     return copyHead; \\n    }\\n```\n```\\n unordered_map<Node*,Node*> mp;\\n    Node *Solve(Node *curr){\\n        if(not curr)\\n            return curr;\\n        Node *newNode = new Node(curr->val);\\n        mp[curr] = newNode;\\n        newNode->next = Solve(curr->next);\\n        newNode->random = mp[curr->random];\\n        \\n        return newNode;\\n    }\\n    Node* copyRandomList(Node* head){\\n        if(not head)\\n            return head;\\n        return Solve(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059384,
                "title": "python-optimal-2-pass-o-1-space-w-diagram-explanation",
                "content": "Should be most optimal since we only need two passes and constant space. Other solutions are either [two passes with O(n) space] or [three passes with O(1) space], so we have the best of both worlds! It\\'s also quite short.\\n\\nInstead of creating a new map, we can use the original linked list as a map instead i.e. we use constant space. Since we don\\'t interleave, we can remove one of the passes in the three-pass algorithms.\\n\\nNB: this method is accepted and passes all tests by creating a true deep copy; however, it also irreversibly modifies the original linked list. \\n\\n##### Approach Summary\\nTwo passes. `A` is a node in the original linked list. `a` is the copy of `A`.\\n- On first pass, create a copy `a` of `A`\\n  - Set `a.val` to match `A.val`\\n  - Set `a.random` to point to `A.random`\\n  - Set `A.next` to point to `a`\\n- On second pass, resolve the `random` pointers in the copied linked list\\n\\t- Set `a.random` to point to `a.random.next`\\n\\n# Code\\n\\n#### Code Only [no comments]\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n        while head:\\n            orig_next = head.next\\n            head.next = copy.next = Node(head.val, None, head.random)\\n            head, copy = orig_next, copy.next\\n        \\n        copy = preroot.next\\n        while copy:\\n            copy.random = copy.random.next if copy.random else None\\n            copy = copy.next\\n            \\n        return preroot.next\\n```\\n\\n#### With comments\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n\\t\\t# first pass: create a copy of linked list\\n        while head:\\n            orig_next = head.next\\n\\t\\t\\t\\n\\t\\t\\t# keep RANDOM pointing to original random node\\n\\t\\t\\tnew_node = Node(head.val, None, head.random)\\n\\t\\t\\t\\n\\t\\t\\t# set NEXT to point to copied node\\n            head.next = copy.next = new_node\\n            \\n\\t\\t\\t# head pointer should move forward in the original linked list\\n            head = orig_next\\n            copy = copy.next\\n        \\n\\t\\t# second pass: resolve RANDOM pointers in copies\\n        copy = preroot.next\\n        while copy:\\n\\t\\t\\t# set RANDOM pointers to nodes in the copied linked list\\n            if copy.random:\\n\\t\\t\\t\\tcopy.random = copy.random.next \\n            copy = copy.next\\n            \\n        return preroot.next\\n```\\n\\n# Explanation\\n\\nWhen creating a copy `a` of  a node `A` in the original linked list, we have four pointers we can work with (`a.next`, `a.random`, `A.next`, `A.random = RA`). Of these, we never modify the `A.random` pointer. `A.next` and `a.random` are the tricky pointers: at some point during our construction, `A.next` will point to a node in the copied linked list and `a.random` will point to a node in the original list (but will eventually point to a node in the copied list). The original linked list is modified and not returned to its original state.\\n\\nWe iterate through the original linked list via `next` and create a copy `a` of each original node `A` maintianing the correct `next` order. This means copying `A.val`. We maintain `next` order by construction.\\n\\nWhile we do this for each node, we also set `a.random` (the `random` pointer of the copied node) to point to `RA = A.random` (the node pointed to by the original node\\'s `random` pointer).\\n\\nBy then setting `A.next = a`, we can later use `A.next` to find which copied node `a` corresponds to the original node `A`. \\n\\nSimilarly, let `ra` be the **desired** node that `a.random` should point to in the copied linked list. After the first pass, given that we set `X.next = x` for all original nodes `X`, we know that `RA.next = ra`. \\n\\nIn other words, on the first pass, we make sure we can get from an original node to its copied node using the original node\\'s `next` pointer. \\n\\nIn this way, we can then update `a.random` to actually point to `a.random.next`, as we resolve `(a.random).next = (A.random).next = RA.next = ra`. So after setting `a.random = a.random.next`, we ultimately end up with `a.random` pointing to `ra` as desired (indirectly, `a.random = ra`).\\n\\nEssentially, we use the original linked list as a dictionary / map instead of creating a new one.\\n\\n# Example in Pictures\\n\\nRed represents a `next` pointer\\nBlue represents a `random` pointer\\n\\n##### Original linked list\\n![image](https://assets.leetcode.com/users/images/b9c12203-93f8-4bda-83ba-6d82f75a5015_1612983331.0993712.png)\\n\\n\\n##### First loop\\n- Copy the original row\\'s black boxes and red lines to a row below\\n- Draw red lines from the top row to the bottom row for nodes with the same letters\\n- Draw dotted blue lines from the bottom row to the top row\\n  - Find the top node with the same letter as the bottom node i.e. with a red line to the bottom node\\n  - Follow the solid blue line of the top node\\n  - Draw a dotted blue line from the bottom node to the end of the solid blue line that starts from the top node\\n- All blue lines should point to nodes in the top row\\n  - e.g. all `random` pointers should point to nodes in the original linked list\\n\\n![image](https://assets.leetcode.com/users/images/1f76d1a9-3b19-4fb0-b522-7a9a61a92a01_1612983346.0374637.png)\\n\\n\\n##### Second loop\\n- For each node in the bottom row, follow the dotted blue lines to a node in the top row, then follow the top row node\\'s red line to get to a bottom node. Update the dotted blue line so that it points to the node at the end of this path in the bottom row\\n  - e.g. all `random` pointers in the copied linked list should be resolved to nodes in the copied linked list\\n\\n![image](https://assets.leetcode.com/users/images/b4bc023e-1808-498c-acef-6fcecf4cec55_1612983353.7213051.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n        while head:\\n            orig_next = head.next\\n            head.next = copy.next = Node(head.val, None, head.random)\\n            head, copy = orig_next, copy.next\\n        \\n        copy = preroot.next\\n        while copy:\\n            copy.random = copy.random.next if copy.random else None\\n            copy = copy.next\\n            \\n        return preroot.next\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n\\t\\t# first pass: create a copy of linked list\\n        while head:\\n            orig_next = head.next\\n\\t\\t\\t\\n\\t\\t\\t# keep RANDOM pointing to original random node\\n\\t\\t\\tnew_node = Node(head.val, None, head.random)\\n\\t\\t\\t\\n\\t\\t\\t# set NEXT to point to copied node\\n            head.next = copy.next = new_node\\n            \\n\\t\\t\\t# head pointer should move forward in the original linked list\\n            head = orig_next\\n            copy = copy.next\\n        \\n\\t\\t# second pass: resolve RANDOM pointers in copies\\n        copy = preroot.next\\n        while copy:\\n\\t\\t\\t# set RANDOM pointers to nodes in the copied linked list\\n            if copy.random:\\n\\t\\t\\t\\tcopy.random = copy.random.next \\n            copy = copy.next\\n            \\n        return preroot.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43577,
                "title": "my-short-python-solution-with-o-n-complex-using-collections-defaultdict",
                "content": "    def factory():\\n    \\treturn RandomListNode(0)\\n    \\n    class Solution:\\n    \\t# @param head, a RandomListNode\\n    \\t# @return a RandomListNode\\n    \\tdef copyRandomList(self, head):\\n    \\t\\tif not head:\\n    \\t\\t\\treturn None\\n    \\t\\ttemp = head\\n    \\t\\tnode_map =collections.defaultdict(factory)\\n    \\t\\tnode_map[None] = None # avoid None as key to generate a RandomListNode\\n    \\t\\twhile temp:\\n    \\t\\t\\tnode_map[temp].label = temp.label\\n    \\t\\t\\tnode_map[temp].next = node_map[temp.next]\\n    \\t\\t\\tnode_map[temp].random = node_map[temp.random]\\n    \\t\\t\\ttemp = temp.next\\n    \\t\\tdel node_map[None]\\n    \\t\\treturn node_map[head]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def factory():\\n    \\treturn RandomListNode(0)\\n    \\n    class Solution:\\n    \\t# @param head, a RandomListNode\\n    \\t# @return a RandomListNode\\n    \\tdef copyRandomList(self, head):\\n    \\t\\tif not head:\\n    \\t\\t\\treturn None\\n    \\t\\ttemp = head\\n    \\t\\tnode_map =collections.defaultdict(factory)\\n    \\t\\tnode_map[None] = None # avoid None as key to generate a RandomListNode\\n    \\t\\twhile temp:\\n    \\t\\t\\tnode_map[temp].label = temp.label\\n    \\t\\t\\tnode_map[temp].next = node_map[temp.next]\\n    \\t\\t\\tnode_map[temp].random = node_map[temp.random]\\n    \\t\\t\\ttemp = temp.next\\n    \\t\\tdel node_map[None]\\n    \\t\\treturn node_map[head]",
                "codeTag": "Java"
            },
            {
                "id": 1938497,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var next: Node?\\n *     public var random: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *    \\t   self.random = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        guard let head = head else { return nil }\\n        \\n        var cur: Node? = head\\n        while let val = cur?.val {\\n            var newNode = Node(val)\\n            newNode.next = cur?.next\\n            cur?.next = newNode\\n            cur = newNode.next\\n        }\\n        \\n        cur = head\\n        while cur != nil {\\n            cur?.next?.random = cur?.random?.next\\n            cur = cur?.next?.next\\n        }\\n        \\n        var oldList: Node? = head\\n        var newList = head.next\\n        let headOld = head.next\\n        \\n        while oldList != nil {\\n            oldList?.next = oldList?.next?.next\\n            newList?.next = newList?.next?.next\\n            oldList = oldList?.next\\n            newList = newList?.next\\n        }\\n        return headOld\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var next: Node?\\n *     public var random: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *    \\t   self.random = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        guard let head = head else { return nil }\\n        \\n        var cur: Node? = head\\n        while let val = cur?.val {\\n            var newNode = Node(val)\\n            newNode.next = cur?.next\\n            cur?.next = newNode\\n            cur = newNode.next\\n        }\\n        \\n        cur = head\\n        while cur != nil {\\n            cur?.next?.random = cur?.random?.next\\n            cur = cur?.next?.next\\n        }\\n        \\n        var oldList: Node? = head\\n        var newList = head.next\\n        let headOld = head.next\\n        \\n        while oldList != nil {\\n            oldList?.next = oldList?.next?.next\\n            newList?.next = newList?.next?.next\\n            oldList = oldList?.next\\n            newList = newList?.next\\n        }\\n        return headOld\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864305,
                "title": "python-3-two-methods-recursive-iterative-explanation",
                "content": "### Approach \\\\#1. Iterative\\n- Use hash table to store information `{original_node: new_node}`\\n- Two pass\\n\\t- First create new node and connect with `next`\\n\\t- Second use hash table to connect `random` node\\n- Time: `O(n)`; Space: `O(n)`\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = {None:None}\\n        dummy = Node(-1)\\n        cur, new_cur = head, dummy\\n        while cur:\\n            new_cur.next = d[cur] = Node(cur.val)\\n            cur, new_cur = cur.next, new_cur.next\\n        cur, new_cur = head, dummy.next\\n        while cur:\\n            new_cur.random = d[cur.random]\\n            cur, new_cur = cur.next, new_cur.next\\n        return dummy.next    \\n```\\n### Approach \\\\#2. Recursive\\n- Recursively create copy of each node and connect their random nodes\\n- Time: `O(n)`; Space: `O(n)`\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = dict()\\n        def deep_copy(node):\\n            if not node: return\\n            if node in d: return d[node]\\n            d[node] = n = Node(node.val)\\n            n.next = deep_copy(node.next)\\n            n.random = deep_copy(node.random)\\n            return n\\n        return deep_copy(head)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = {None:None}\\n        dummy = Node(-1)\\n        cur, new_cur = head, dummy\\n        while cur:\\n            new_cur.next = d[cur] = Node(cur.val)\\n            cur, new_cur = cur.next, new_cur.next\\n        cur, new_cur = head, dummy.next\\n        while cur:\\n            new_cur.random = d[cur.random]\\n            cur, new_cur = cur.next, new_cur.next\\n        return dummy.next    \\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = dict()\\n        def deep_copy(node):\\n            if not node: return\\n            if node in d: return d[node]\\n            d[node] = n = Node(node.val)\\n            n.next = deep_copy(node.next)\\n            n.random = deep_copy(node.random)\\n            return n\\n        return deep_copy(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752807,
                "title": "c-o-n-o-1-in-three-steps-explained",
                "content": "THREE STEPS:\\n**(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN **\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)\\n            return NULL;\\n        Node* head_cp = NULL;\\n        Node* curr = head;\\n        Node* curr_cp = NULL;\\n//(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n        while(curr!=NULL){\\n            curr_cp = new Node(curr->val,curr->next,NULL);\\n            curr->next = curr_cp;\\n            curr = curr_cp->next;\\n        }\\n//(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n        curr = head;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            if(curr->random)\\n                curr_cp->random = curr->random->next;\\n            curr = curr_cp->next;\\n        }\\n//(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN \\n        curr = head;\\n        head_cp = head->next;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            curr->next = curr_cp->next; // making the question\\'s list back to normal\\n            curr = curr->next;\\n            if(curr)\\n                curr_cp->next = curr->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```\\nIF THIS SOLUTION HELPS, THEN DON\\'T FORGET TO UPVOTE. :D",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)\\n            return NULL;\\n        Node* head_cp = NULL;\\n        Node* curr = head;\\n        Node* curr_cp = NULL;\\n//(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n        while(curr!=NULL){\\n            curr_cp = new Node(curr->val,curr->next,NULL);\\n            curr->next = curr_cp;\\n            curr = curr_cp->next;\\n        }\\n//(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n        curr = head;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            if(curr->random)\\n                curr_cp->random = curr->random->next;\\n            curr = curr_cp->next;\\n        }\\n//(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN \\n        curr = head;\\n        head_cp = head->next;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            curr->next = curr_cp->next; // making the question\\'s list back to normal\\n            curr = curr->next;\\n            if(curr)\\n                curr_cp->next = curr->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689730,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * // Definition for a Node.\\n * function Node(val, next, random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    const map = new Map([[null, null]]);\\n    \\n    let node = head;\\n    \\n    while (node) {\\n        map.set(node, new Node(node.val, null, null));\\n        node = node.next;\\n    }\\n    \\n    node = head;\\n    \\n    while (node) {\\n        const newNode = map.get(node);\\n        newNode.next = map.get(node.next);\\n        newNode.random = map.get(node.random);\\n        node = node.next;\\n    }\\n\\n    return map.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * // Definition for a Node.\\n * function Node(val, next, random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    const map = new Map([[null, null]]);\\n    \\n    let node = head;\\n    \\n    while (node) {\\n        map.set(node, new Node(node.val, null, null));\\n        node = node.next;\\n    }\\n    \\n    node = head;\\n    \\n    while (node) {\\n        const newNode = map.get(node);\\n        newNode.next = map.get(node.next);\\n        newNode.random = map.get(node.random);\\n        node = node.next;\\n    }\\n\\n    return map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841132,
                "title": "c-clean-and-concise-with-recursion",
                "content": "Using recursion to create all node and put it into `hash map`. After create all node, we can get the random node.\\n```C++\\nclass Solution {\\nprivate:\\n    unordered_map<Node *, Node *> map;\\npublic:\\n    Node *copyRandomList(Node *head, Node *result = nullptr) {\\n        if (!head) return head;\\n        result = new Node(head->val);\\n        map[head] = result;\\n        result->next = copyRandomList(head->next, result->next);\\n        result->random = map[head->random];\\n        return result;\\n    }\\n};\\n```\\nTime complexity: `O(n)` \\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```C++\\nclass Solution {\\nprivate:\\n    unordered_map<Node *, Node *> map;\\npublic:\\n    Node *copyRandomList(Node *head, Node *result = nullptr) {\\n        if (!head) return head;\\n        result = new Node(head->val);\\n        map[head] = result;\\n        result->next = copyRandomList(head->next, result->next);\\n        result->random = map[head->random];\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227276,
                "title": "my-c-simple-solution-without-hashmap",
                "content": "UPVOTE IF IT HELPS\\n```\\nNode* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* newHead, *copyNode, *temp= head;\\n        \\n        //step 1. create copy node in between original node which helps to connect random node of copy node.\\n        while(temp)\\n        {\\n            copyNode = new Node(temp->val);\\n            copyNode->next = temp->next;\\n            temp->next = copyNode;\\n            temp = copyNode->next;\\n        }\\n        //result - 7 -> 7 -> 13 -> 13 -> 11 -> 11 -> 10 -> 10 -> 1 -> 1 -> NULL\\n        \\n        newHead = head->next;\\n        temp = head;\\n        \\n        //step 2. now copyNode->random lie just after original->randomNode.\\n        while(temp)\\n        {\\n            if(temp->random == NULL)\\n                temp->next->random = NULL;\\n            \\n            else \\n                temp->next->random = temp->random->next;\\n            \\n            temp = temp->next->next;\\n        }\\n        //result-  Nodes copied successfully. Now we just need to seprate them.\\n        temp = head;\\n        \\n        //step 3. separating copy Node from original Nodes\\n        while(temp)\\n        {\\n            copyNode = temp->next;\\n            temp->next = copyNode->next;\\n            \\n            if(copyNode->next)\\n                copyNode->next = copyNode->next->next;\\n            \\n            temp = temp->next;\\n        }\\n        \\n        return newHead;\\n    }",
                "solutionTags": [],
                "code": "UPVOTE IF IT HELPS\\n```\\nNode* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* newHead, *copyNode, *temp= head;\\n        \\n        //step 1. create copy node in between original node which helps to connect random node of copy node.\\n        while(temp)\\n        {\\n            copyNode = new Node(temp->val);\\n            copyNode->next = temp->next;\\n            temp->next = copyNode;\\n            temp = copyNode->next;\\n        }\\n        //result - 7 -> 7 -> 13 -> 13 -> 11 -> 11 -> 10 -> 10 -> 1 -> 1 -> NULL\\n        \\n        newHead = head->next;\\n        temp = head;\\n        \\n        //step 2. now copyNode->random lie just after original->randomNode.\\n        while(temp)\\n        {\\n            if(temp->random == NULL)\\n                temp->next->random = NULL;\\n            \\n            else \\n                temp->next->random = temp->random->next;\\n            \\n            temp = temp->next->next;\\n        }\\n        //result-  Nodes copied successfully. Now we just need to seprate them.\\n        temp = head;\\n        \\n        //step 3. separating copy Node from original Nodes\\n        while(temp)\\n        {\\n            copyNode = temp->next;\\n            temp->next = copyNode->next;\\n            \\n            if(copyNode->next)\\n                copyNode->next = copyNode->next->next;\\n            \\n            temp = temp->next;\\n        }\\n        \\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1058990,
                "title": "c-simple-recursive-and-iterative-solutions-faster-than-90",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        if (m[head]) return m[head];\\n        m[head] = new Node(head->val);\\n        m[head]->next = copyRandomList(head->next);\\n        m[head]->random = copyRandomList(head->random);\\n        return m[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        Node *ptr = head, *new_head = new Node(0), *new_ptr = new_head;\\n        while (ptr) {\\n            new_ptr->next = new Node(ptr->val);\\n            m[ptr] = new_ptr->next;\\n            ptr = ptr->next;\\n            new_ptr = new_ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            if (ptr->random)\\n                m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n\\n        }\\n        return new_head->next;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        if (m[head]) return m[head];\\n        m[head] = new Node(head->val);\\n        m[head]->next = copyRandomList(head->next);\\n        m[head]->random = copyRandomList(head->random);\\n        return m[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        Node *ptr = head, *new_head = new Node(0), *new_ptr = new_head;\\n        while (ptr) {\\n            new_ptr->next = new Node(ptr->val);\\n            m[ptr] = new_ptr->next;\\n            ptr = ptr->next;\\n            new_ptr = new_ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            if (ptr->random)\\n                m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n\\n        }\\n        return new_head->next;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757913,
                "title": "python-100-recursive-deepcopy",
                "content": "**Python 100% | Recursive Deepcopy**\\n\\nTraditional implementation of a Python \"deepcopy\" function using recursion. The key to this problem is that we can return a Node (with a basic initialization), and fix its properties later :)\\n\\nI hope the code is helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head): # -> \\'Node\\':\\n        memo = {}\\n        def deepcopy(n):\\n            # Trivial Returns\\n            if not n:\\n                return\\n            if n in memo:\\n                return memo[n]\\n            #\\n            # Create node and register it immediately (to break cycles)\\n            memo[n] = new = Node( n.val )\\n            #\\n            # Fix Node Properties\\n            new.next   = deepcopy(n.next  )\\n            new.random = deepcopy(n.random)\\n            return new\\n        return deepcopy(head)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head): # -> \\'Node\\':\\n        memo = {}\\n        def deepcopy(n):\\n            # Trivial Returns\\n            if not n:\\n                return\\n            if n in memo:\\n                return memo[n]\\n            #\\n            # Create node and register it immediately (to break cycles)\\n            memo[n] = new = Node( n.val )\\n            #\\n            # Fix Node Properties\\n            new.next   = deepcopy(n.next  )\\n            new.random = deepcopy(n.random)\\n            return new\\n        return deepcopy(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632977,
                "title": "c-solution",
                "content": "**Approach 1**\\n- Time: O(n)\\n- Space: O(n)\\n\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        Dictionary<Node, Node> dic = new Dictionary<Node, Node>();\\n        \\n        // Deep copy nodes for values\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            dic.Add(curr, new Node(curr.val, null, null));\\n            curr = curr.next;\\n        }\\n        \\n        // Deep copy nodes for pointers\\n        curr = head;\\n        while(curr != null)\\n        {\\n            // key of dictionary can\\'t be null\\n            dic[curr].next = curr.next == null? null : dic[curr.next];\\n            dic[curr].random = curr.random == null? null : dic[curr.random];\\n            curr = curr.next;\\n        }\\n        \\n        return dic[head];\\n    }\\n}\\n```\\n\\n**Approach 2**\\n- Time: O(n): 3 passes\\n- Space: O(1)\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        // linked each node to its copy. 1 -> 1\\' -> 2 -> 2\\' -> 3 -> 3\\'\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            Node next = curr.next;          \\n            curr.next = new Node(curr.val);\\n            curr.next.next = next;\\n            \\n            curr = next;\\n        }\\n        \\n        // set random pointers for the copy nodes\\n        curr = head;\\n        while(curr != null)\\n        {\\n            if(curr.random != null)\\n                curr.next.random = curr.random.next;\\n            curr = curr.next.next;\\n        }\\n        \\n        // seperate copy linkedList from the original linkedList\\n        Node dummyHead = head.next;\\n        curr = head;\\n        Node curr2 = dummyHead;\\n        while(curr2.next != null)\\n        {    \\n            curr.next = curr.next.next;\\n            curr = curr.next;\\n            \\n            curr2.next = curr2.next.next;\\n            curr2 = curr2.next;\\n        }\\n        \\n        // handle the last original node\\n        curr.next = null;\\n        \\n        return dummyHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        Dictionary<Node, Node> dic = new Dictionary<Node, Node>();\\n        \\n        // Deep copy nodes for values\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            dic.Add(curr, new Node(curr.val, null, null));\\n            curr = curr.next;\\n        }\\n        \\n        // Deep copy nodes for pointers\\n        curr = head;\\n        while(curr != null)\\n        {\\n            // key of dictionary can\\'t be null\\n            dic[curr].next = curr.next == null? null : dic[curr.next];\\n            dic[curr].random = curr.random == null? null : dic[curr.random];\\n            curr = curr.next;\\n        }\\n        \\n        return dic[head];\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        // linked each node to its copy. 1 -> 1\\' -> 2 -> 2\\' -> 3 -> 3\\'\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            Node next = curr.next;          \\n            curr.next = new Node(curr.val);\\n            curr.next.next = next;\\n            \\n            curr = next;\\n        }\\n        \\n        // set random pointers for the copy nodes\\n        curr = head;\\n        while(curr != null)\\n        {\\n            if(curr.random != null)\\n                curr.next.random = curr.random.next;\\n            curr = curr.next.next;\\n        }\\n        \\n        // seperate copy linkedList from the original linkedList\\n        Node dummyHead = head.next;\\n        curr = head;\\n        Node curr2 = dummyHead;\\n        while(curr2.next != null)\\n        {    \\n            curr.next = curr.next.next;\\n            curr = curr.next;\\n            \\n            curr2.next = curr2.next.next;\\n            curr2 = curr2.next;\\n        }\\n        \\n        // handle the last original node\\n        curr.next = null;\\n        \\n        return dummyHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259563,
                "title": "detailed-explanation-constant-space-c-javascript",
                "content": "The HashMap based solution can be found [here](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/258935/Detailed-Explanation-with-Pictures-C%2B%2BJavaScript)\\n\\n**Intuition**\\n* As discussed in the above link, the only thing forcing us to use extra space is the fact that we need a mapping from the old node to the new node counterpart (The vertical threading). Now, can we overcome this? (Of course, we would still need a mapping).\\n* The idea is to clone the nodes such the cloned node is just to the right of the old node. This way, we can have a mapping in O(1).\\n* We traverse the original list and for each node we create a copy and insert it to the right. So, *1 2 3 4 2 5* would become *1 1 2 2 3 3 4 4 2 2 5 5*. \\n* Now, we traverse the list again and correct the random field of the cloned nodes. (How?). We stand at the original node, go to its **random** field, and then move right (the mapping) and set the newly found node as the random field of the cloned node (the node to the current right). We continue this process, while ensuring that we only stand at the original nodes.\\n* Now, we need to free the lists. This is easy, for each node, we set it\\'s next field to the **node.next.next**. (This has to be done to each node since we need to free both the lists).\\n\\n**Credits** ----- Inspired by a couple of **Discuss** posts and a question on **StackOverFlow**.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* originalHead);\\n};\\n\\n/* Returns a deep copy of the list using constant space */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the base case\\n    if(!originalHead) return originalHead;\\n    \\n    // The iterator for the list and the backup.\\n    Node* weavedHead;\\n    Node* backup;\\n    weavedHead = originalHead;\\n    \\n    /* Never declare variables inside for loop if you need O(1) space solution */\\n    \\n    /* Interleave the nodes (Make copies to the right) */\\n    \\n    // Create the copies and put them to the right\\n    while(weavedHead)\\n    {\\n        // Make a backup of the next (original) node\\n        backup = weavedHead->next;\\n        \\n        // Attach a copy. The next field of the new node is the original right node\\n        weavedHead->next = new Node(weavedHead->val, backup, nullptr);\\n        \\n        // Move to the original right node.(Don\\'t create copies of copies)\\n        weavedHead = backup;\\n    }\\n    \\n    // Store a permanent reference to the cloned head\\n    Node* clonedHead = originalHead->next;\\n    \\n    // Iterator for the list\\n    weavedHead = originalHead;\\n    \\n    // Start filling the random pointers\\n    while(weavedHead)\\n    {\\n        /* We are standing at a node from the original list\\n         * The next node is its clone. \\n         * Get the random pointer of the original list and traverse there.\\n         * The corresponding counterpart of the random node would be to its right\\n         * Fill the random pointers of the cloned part (right) using this\\n         */\\n        (weavedHead->next)->random = weavedHead->random ? (weavedHead->random)->next : nullptr;\\n        \\n        /* Make sure to go 2 steps to the right.\\n         * We always stand at the original node and correct the clone node\\n         * It is guaranteed that weavedHead->next is not null. How? Check the first assumption\\n         */\\n        weavedHead = weavedHead->next->next;\\n    }\\n    \\n    // Remove the interlacing and correct the original list\\n    weavedHead = originalHead;\\n    while(weavedHead)\\n    {\\n        // We can stand on both types of nodes. Get a backup of the next element\\n        backup = weavedHead->next;\\n        \\n        // The correct neighbour is shifted to the right by 1 place\\n        weavedHead->next = weavedHead->next ? weavedHead->next->next : nullptr;\\n        \\n        // Remember to go one step at a time to correct both the lists\\n        weavedHead = backup;\\n    }\\n    \\n    // Return the stored permananent reference\\n    return clonedHead;\\n}\\n```\\n[JavaScript Implementation](https://github.com/Just-A-Visitor/Coding/tree/master/LeetCode%20Non-Contest%20Solutions/%23138%20Cloning%20a%20Linked%20List%20with%20Random%20Pointers)",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* originalHead);\\n};\\n\\n/* Returns a deep copy of the list using constant space */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the base case\\n    if(!originalHead) return originalHead;\\n    \\n    // The iterator for the list and the backup.\\n    Node* weavedHead;\\n    Node* backup;\\n    weavedHead = originalHead;\\n    \\n    /* Never declare variables inside for loop if you need O(1) space solution */\\n    \\n    /* Interleave the nodes (Make copies to the right) */\\n    \\n    // Create the copies and put them to the right\\n    while(weavedHead)\\n    {\\n        // Make a backup of the next (original) node\\n        backup = weavedHead->next;\\n        \\n        // Attach a copy. The next field of the new node is the original right node\\n        weavedHead->next = new Node(weavedHead->val, backup, nullptr);\\n        \\n        // Move to the original right node.(Don\\'t create copies of copies)\\n        weavedHead = backup;\\n    }\\n    \\n    // Store a permanent reference to the cloned head\\n    Node* clonedHead = originalHead->next;\\n    \\n    // Iterator for the list\\n    weavedHead = originalHead;\\n    \\n    // Start filling the random pointers\\n    while(weavedHead)\\n    {\\n        /* We are standing at a node from the original list\\n         * The next node is its clone. \\n         * Get the random pointer of the original list and traverse there.\\n         * The corresponding counterpart of the random node would be to its right\\n         * Fill the random pointers of the cloned part (right) using this\\n         */\\n        (weavedHead->next)->random = weavedHead->random ? (weavedHead->random)->next : nullptr;\\n        \\n        /* Make sure to go 2 steps to the right.\\n         * We always stand at the original node and correct the clone node\\n         * It is guaranteed that weavedHead->next is not null. How? Check the first assumption\\n         */\\n        weavedHead = weavedHead->next->next;\\n    }\\n    \\n    // Remove the interlacing and correct the original list\\n    weavedHead = originalHead;\\n    while(weavedHead)\\n    {\\n        // We can stand on both types of nodes. Get a backup of the next element\\n        backup = weavedHead->next;\\n        \\n        // The correct neighbour is shifted to the right by 1 place\\n        weavedHead->next = weavedHead->next ? weavedHead->next->next : nullptr;\\n        \\n        // Remember to go one step at a time to correct both the lists\\n        weavedHead = backup;\\n    }\\n    \\n    // Return the stored permananent reference\\n    return clonedHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719735,
                "title": "2-clean-java-solutions-with-explanations-o-1-and-o-n-space",
                "content": "O(n) - time | O(n) - space\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Map<Node, Node> map =  new HashMap<Node, Node>();\\n    \\n        Node curNode = head;\\n        while(curNode != null)\\n        {\\n            map.put(curNode, new Node(curNode.val));\\n            curNode = curNode.next;\\n        }\\n        \\n        for(Map.Entry<Node, Node> entry : map.entrySet())  // key -> value;  node -> copy\\n        {\\n            Node node = entry.getValue();\\n            node.next = map.get(entry.getKey().next);\\n            node.random = map.get(entry.getKey().random);\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------------------------------------------------\\n\\nO(n) - time | O(1) - space\\n\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Node curr = head;\\n        //add a copy extra node after each node\\n        while (curr != null)\\n        {\\n            Node temp = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = temp;\\n            curr = temp;            \\n        }\\n        \\n        // put the random reference for copies\\n        curr = head;\\n        while (curr != null)\\n        {\\n            if(curr.next != null)  \\n              curr.next.random = (curr.random != null) ? curr.random.next : curr.random;  \\n  \\n        // move to the next newly added node by  \\n        // skipping an original node  \\n        curr = (curr.next != null) ? curr.next.next : curr.next;  \\n        }\\n        \\n        // separa in two lists : original and copy\\n        // restore initial next configuration\\n        Node original = head, copy = head.next;  \\n  \\n        // save the start of copied linked list  \\n        Node result = copy;  \\n\\n        // now separate the original list and copied list  \\n        while (original != null && copy != null)  \\n        {  \\n            original.next = (original.next != null) ? original.next.next : original.next;  \\n            copy.next = (copy.next != null) ? copy.next.next : copy.next;  \\n            \\n            original = original.next;  \\n            copy = copy.next;  \\n        }  \\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Map<Node, Node> map =  new HashMap<Node, Node>();\\n    \\n        Node curNode = head;\\n        while(curNode != null)\\n        {\\n            map.put(curNode, new Node(curNode.val));\\n            curNode = curNode.next;\\n        }\\n        \\n        for(Map.Entry<Node, Node> entry : map.entrySet())  // key -> value;  node -> copy\\n        {\\n            Node node = entry.getValue();\\n            node.next = map.get(entry.getKey().next);\\n            node.random = map.get(entry.getKey().random);\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Node curr = head;\\n        //add a copy extra node after each node\\n        while (curr != null)\\n        {\\n            Node temp = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = temp;\\n            curr = temp;            \\n        }\\n        \\n        // put the random reference for copies\\n        curr = head;\\n        while (curr != null)\\n        {\\n            if(curr.next != null)  \\n              curr.next.random = (curr.random != null) ? curr.random.next : curr.random;  \\n  \\n        // move to the next newly added node by  \\n        // skipping an original node  \\n        curr = (curr.next != null) ? curr.next.next : curr.next;  \\n        }\\n        \\n        // separa in two lists : original and copy\\n        // restore initial next configuration\\n        Node original = head, copy = head.next;  \\n  \\n        // save the start of copied linked list  \\n        Node result = copy;  \\n\\n        // now separate the original list and copied list  \\n        while (original != null && copy != null)  \\n        {  \\n            original.next = (original.next != null) ? original.next.next : original.next;  \\n            copy.next = (copy.next != null) ? copy.next.next : copy.next;  \\n            \\n            original = original.next;  \\n            copy = copy.next;  \\n        }  \\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786604,
                "title": "python-sentinel-node-o-n-time-o-1-space",
                "content": "Hello there,\\n\\nHere is my solution. The analysis is below. \\n\\n1. Clarifications:\\n    Is the linked-list ready-only? Let\\'s assume that it\\'s not.\\n\\n2. Implementation:\\n\\n```\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        clone_prehead = Node(0) # To keep track of the new list head and to avoid having 2 cases (cloning the head node and internal nodes)\\n        \\n\\t\\t# 1. Clone Values and Next pointers\\n        clone = clone_prehead\\n        while head:\\n            clone.next = Node(head.val, None, head.random)\\n            clone = clone.next\\n            \\n            head.next, head = clone, head.next\\n        \\n\\t\\t# 2. Clone Random pointers\\n        clone = clone_prehead.next\\n        while clone:\\n            if clone.random:\\n                clone.random = clone.random.next\\n            \\n            clone = clone.next\\n                \\n        return clone_prehead.next\\n\\n```\\n        \\n3. Intuition:\\n\\t* Create a new list by cloning `Values` and `Next` pointers\\n\\t\\t* Create each new node as follow: (**Val**: original val, **Next**: points to its new next node, **Random**: points to the original random node)\\n\\t\\t* Update the original node next node to point to its clone node: `Original.next = Clone`\\n\\t* Update new list by cloning  `Random` pointers:\\n\\t\\t* Scan new list nodes, \\n\\t\\t* For each node which random node isn\\'t `None`, assign it with the next node of the original random node: `Clone = Clone.random.next`\\n\\t\\t\\n\\t\\t```\\n       Initially:   \\n              Original list: 1 -> 2 -> 3\\n                             |________ ^\\n                    original.node(1).random = original.node(3)\\n\\n      After the 1st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3  |\\n                             ^    ^    ^  |\\n                   Original: 1    2    3 <-\\n                             |________ ^\\n                    original.node(3).next = clone.node(3)\\n                    clone.node(1).random = original.node(3)\\n\\n      After the 2st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3 <|\\n                             ^    ^    ^  \\n                   Original: 1    2    3\\n                             |________ ^\\n                    clone.node(1).random = original.node(3).next = clone.node(1).random.next\\n\\n\\t\\t```\\n\\n4. Complexity Analysis:\\n\\t* Time Complexity: O(n)\\n\\t* Space Complexity: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        clone_prehead = Node(0) # To keep track of the new list head and to avoid having 2 cases (cloning the head node and internal nodes)\\n        \\n\\t\\t# 1. Clone Values and Next pointers\\n        clone = clone_prehead\\n        while head:\\n            clone.next = Node(head.val, None, head.random)\\n            clone = clone.next\\n            \\n            head.next, head = clone, head.next\\n        \\n\\t\\t# 2. Clone Random pointers\\n        clone = clone_prehead.next\\n        while clone:\\n            if clone.random:\\n                clone.random = clone.random.next\\n            \\n            clone = clone.next\\n                \\n        return clone_prehead.next\\n\\n```\n```\\n       Initially:   \\n              Original list: 1 -> 2 -> 3\\n                             |________ ^\\n                    original.node(1).random = original.node(3)\\n\\n      After the 1st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3  |\\n                             ^    ^    ^  |\\n                   Original: 1    2    3 <-\\n                             |________ ^\\n                    original.node(3).next = clone.node(3)\\n                    clone.node(1).random = original.node(3)\\n\\n      After the 2st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3 <|\\n                             ^    ^    ^  \\n                   Original: 1    2    3\\n                             |________ ^\\n                    clone.node(1).random = original.node(3).next = clone.node(1).random.next\\n\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 494261,
                "title": "single-pass-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head == null) {\\n            return head;\\n        }\\n        \\n        //first form the list with current nodes and new nodes\\n        // if list is 1->2->3\\n        // we make it 1->1->2->2->3->3\\n        Node curr = head;\\n        while(curr != null) {\\n            Node n = new Node(curr.val);\\n            n.next = curr.next;\\n            curr.next = n;\\n            curr = curr.next.next;\\n        }\\n        \\n        //Now we have actual nodes and new Nodes\\n        // understand this clearly first\\n        // curr.next.random = curr.random.next;\\n\\t\\t\\n        curr = head;\\n        while(curr!=null) {\\n            if(curr.random == null) {\\n                curr.next.random = null;\\n            } else {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n        \\n        //separate out both the lists and return the new list\\n        curr = head;\\n        Node curr1 = head.next;\\n        Node h = curr1;\\n        while(curr != null) {\\n            curr.next = curr.next.next;\\n            if(curr1.next != null) {\\n                curr1.next = curr1.next.next;\\n            } \\n            curr = curr.next;\\n            curr1 = curr1.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head == null) {\\n            return head;\\n        }\\n        \\n        //first form the list with current nodes and new nodes\\n        // if list is 1->2->3\\n        // we make it 1->1->2->2->3->3\\n        Node curr = head;\\n        while(curr != null) {\\n            Node n = new Node(curr.val);\\n            n.next = curr.next;\\n            curr.next = n;\\n            curr = curr.next.next;\\n        }\\n        \\n        //Now we have actual nodes and new Nodes\\n        // understand this clearly first\\n        // curr.next.random = curr.random.next;\\n\\t\\t\\n        curr = head;\\n        while(curr!=null) {\\n            if(curr.random == null) {\\n                curr.next.random = null;\\n            } else {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n        \\n        //separate out both the lists and return the new list\\n        curr = head;\\n        Node curr1 = head.next;\\n        Node h = curr1;\\n        while(curr != null) {\\n            curr.next = curr.next.next;\\n            if(curr1.next != null) {\\n                curr1.next = curr1.next.next;\\n            } \\n            curr = curr.next;\\n            curr1 = curr1.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443593,
                "title": "c-solution-using-dictionary-beats-99",
                "content": "```\\n public Node CopyRandomList(Node head)\\n        {\\n            if (head == null) return null;\\n\\n            var originalToCopyNodeMap = new Dictionary<Node , Node>();\\n            var p = head;\\n            while (p != null)\\n            {\\n                originalToCopyNodeMap.Add(p, new Node(p.val, null, null));\\n                p = p.next;\\n            }\\n\\n            p = head;\\n            while (p != null)\\n            {\\n                if (p.next != null) originalToCopyNodeMap[p].next = originalToCopyNodeMap[p.next];\\n                if( p.random != null) originalToCopyNodeMap[p].random = originalToCopyNodeMap[p.random];\\n                p = p.next;\\n            }\\n            return originalToCopyNodeMap[head];\\n\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public Node CopyRandomList(Node head)\\n        {\\n            if (head == null) return null;\\n\\n            var originalToCopyNodeMap = new Dictionary<Node , Node>();\\n            var p = head;\\n            while (p != null)\\n            {\\n                originalToCopyNodeMap.Add(p, new Node(p.val, null, null));\\n                p = p.next;\\n            }\\n\\n            p = head;\\n            while (p != null)\\n            {\\n                if (p.next != null) originalToCopyNodeMap[p].next = originalToCopyNodeMap[p.next];\\n                if( p.random != null) originalToCopyNodeMap[p].random = originalToCopyNodeMap[p.random];\\n                p = p.next;\\n            }\\n            return originalToCopyNodeMap[head];\\n\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43617,
                "title": "one-loop-can-be-a-bad-choice-in-three-solutions-c",
                "content": "140ms using loop to hack this problem but due to frequent invoking of **node_map.count**, there is a dramatic performance decrease.\\n\\n    \\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL;\\n            while(p)\\n            {\\n                if(!node_map.count(p)) node_map[p] = new RandomListNode(p->label);\\n                if(p->random)\\n                {\\n                    if(!node_map.count(p->random)) node_map[p->random] = new RandomListNode(p->random->label); \\n                    node_map[p]->random = node_map[p->random];\\n                }\\n                if(pre) pre->next = node_map[p];\\n                pre = node_map[p];\\n                p = p->next;\\n            }\\n            return node_map[head];\\n        }\\n    };\\n\\n\\n----------\\n\\nUsing 110ms to solve this, though traverse twice but it's more clean and easy-understanding.\\n\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL, t(0);\\n            pre = &t;\\n            while(p)\\n            {\\n                pre->next = node_map[p] = new RandomListNode(p->label);\\n                p = p->next;\\n                pre = pre->next;\\n            }\\n            p = head;\\n            pre = t.next;\\n            while(p)\\n            {\\n                pre->random = node_map[p->random];\\n                pre = pre->next;\\n                p = p->next;\\n            }\\n            return t.next;\\n        }\\n    };\\n\\n\\n----------\\n\\nUsing 110ms without map, copy all the nodes just after its original position then the random pointer of the cloned node can be easily retrieved by the original nodes (since the original is just before its corresponding cloned nodes so the random) Check the code directly, quite simple.\\n\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            RandomListNode *p = head, *next, *cloned, *pre;\\n            while(p)\\n            {\\n                cloned = new RandomListNode(p->label);\\n                next = p->next;\\n                p->next = cloned;\\n                cloned->next = next;\\n                p = next;\\n            }\\n            p = head;\\n            cloned = head->next;\\n            while(p)\\n            {\\n                if(p->random) cloned->random = p->random->next;\\n                if(cloned->next) cloned = cloned->next->next;\\n                else break;\\n                p = p->next->next;\\n            }\\n            RandomListNode t(0);\\n            p = head;\\n            pre = &t;\\n            while(p)\\n            {\\n                pre->next = p->next;\\n                p->next = p->next->next;\\n                p = p->next;\\n                pre = pre->next;\\n            }\\n            return t.next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL;\\n            while(p)\\n            {\\n                if(!node_map.count(p)) node_map[p] = new RandomListNode(p->label);\\n                if(p->random)\\n                {\\n                    if(!node_map.count(p->random)) node_map[p->random] = new RandomListNode(p->random->label); \\n                    node_map[p]->random = node_map[p->random];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3698001,
                "title": "easy-c-soln-time-complexity-o-n-and-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- Approach : \\n       - Add node with same data after original node \\n       - Then update the random of copy node by random of original node\\n       - After that saperate the original and copied nodes as a linked list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![WhatsApp Image 2023-06-30 at 12.43.51 AM.jpeg](https://assets.leetcode.com/users/images/6f304a47-fd2b-4820-b8ae-39c9f12da8ea_1688066101.2978802.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL)return NULL;\\n        for(Node* curr=head;curr!=NULL;)\\n        {\\n            Node* tmp = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = tmp;\\n            curr = tmp;\\n        }\\n        for(Node* curr=head;curr!=NULL;curr=curr->next->next)\\n        {\\n            curr->next->random = curr->random?curr->random->next:NULL;\\n        }\\n        Node* temp = head->next,*original=head,*copy=head->next;\\n        while(copy && original)\\n        {\\n            original->next = original->next?original->next->next:original->next;\\n            copy->next = copy->next?copy->next->next:copy->next;\\n            original = original->next;\\n            copy = copy->next;\\n\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL)return NULL;\\n        for(Node* curr=head;curr!=NULL;)\\n        {\\n            Node* tmp = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = tmp;\\n            curr = tmp;\\n        }\\n        for(Node* curr=head;curr!=NULL;curr=curr->next->next)\\n        {\\n            curr->next->random = curr->random?curr->random->next:NULL;\\n        }\\n        Node* temp = head->next,*original=head,*copy=head->next;\\n        while(copy && original)\\n        {\\n            original->next = original->next?original->next->next:original->next;\\n            copy->next = copy->next?copy->next->next:copy->next;\\n            original = original->next;\\n            copy = copy->next;\\n\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205736,
                "title": "138-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a dictionary to keep track of nodes that have already been processed. It recursively copies the next and random pointers of the original list, creating new nodes as needed, and saves them in the visited dictionary. If a node has already been processed, it returns the cloned version of it from the dictionary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        # If we have already processed the current node, return the cloned version of it\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        # Create a new node with the same value as the original node\\n        node = Node(head.val, None, None)\\n\\n        # Save the new node in the visited dictionary\\n        self.visited[head] = node\\n\\n        # Recursively copy the next and random pointers\\n        node.next = self.copyRandomList(head.next)\\n        node.random = self.copyRandomList(head.random)\\n\\n        return node\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        # If we have already processed the current node, return the cloned version of it\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        # Create a new node with the same value as the original node\\n        node = Node(head.val, None, None)\\n\\n        # Save the new node in the visited dictionary\\n        self.visited[head] = node\\n\\n        # Recursively copy the next and random pointers\\n        node.next = self.copyRandomList(head.next)\\n        node.random = self.copyRandomList(head.random)\\n\\n        return node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230997,
                "title": "simple-c-solution-2-approach-with-extra-space-without-extra-space",
                "content": "**Approach -1** **[** **With extra Space** **--** **Using Haspmap** **]**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        unordered_map<Node* ,Node*> map;\\n        Node* dummy=new Node(-1);\\n        Node* temp=head;\\n        Node* temp2=dummy;\\n        while(temp!=NULL){\\n            Node* copy=new Node(temp->val);\\n            map[temp]=copy;\\n            \\n            temp2->next=copy;\\n            temp2=copy;\\n            temp=temp->next; \\n        }\\n        dummy=dummy->next;\\n        \\n        temp=dummy;\\n        temp2=head;\\n        while(temp!=NULL){\\n           temp->random=map[temp2->random];\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        return dummy;\\n    }\\n};\\n```\\n\\n**Approach -2** **[** **Without using extra Space** **--** **Merging Lists** **]**\\n```\\nclass Solution {\\npublic:\\n    void copy_merge(Node* head){\\n        Node* curr=head;\\n        Node* next=head->next;\\n        while(curr!=NULL){\\n            Node* copy=new Node(curr->val);\\n            curr->next=copy;\\n            copy->next=next;\\n            curr=next;\\n            if(next!=NULL){\\n                next=next->next;\\n            }\\n        }\\n    }\\n    \\n    void handle_random(Node* head){\\n        Node* curr=head;\\n        while(curr!=NULL){\\n            if(curr->random!=NULL){\\n            curr->next->random=curr->random->next;\\n            }\\n            curr=curr->next->next;\\n        }\\n    }\\n    \\n    Node* detach(Node* head){\\n        Node* curr=head;\\n        Node* dummy=new Node(-1);\\n        Node* tail=dummy;\\n        while(curr!=NULL){\\n            tail->next=curr->next;\\n            tail=tail->next;\\n            curr->next=tail->next;\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        copy_merge(head);\\n        \\n        handle_random(head);\\n        \\n        return detach(head);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        unordered_map<Node* ,Node*> map;\\n        Node* dummy=new Node(-1);\\n        Node* temp=head;\\n        Node* temp2=dummy;\\n        while(temp!=NULL){\\n            Node* copy=new Node(temp->val);\\n            map[temp]=copy;\\n            \\n            temp2->next=copy;\\n            temp2=copy;\\n            temp=temp->next; \\n        }\\n        dummy=dummy->next;\\n        \\n        temp=dummy;\\n        temp2=head;\\n        while(temp!=NULL){\\n           temp->random=map[temp2->random];\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        return dummy;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void copy_merge(Node* head){\\n        Node* curr=head;\\n        Node* next=head->next;\\n        while(curr!=NULL){\\n            Node* copy=new Node(curr->val);\\n            curr->next=copy;\\n            copy->next=next;\\n            curr=next;\\n            if(next!=NULL){\\n                next=next->next;\\n            }\\n        }\\n    }\\n    \\n    void handle_random(Node* head){\\n        Node* curr=head;\\n        while(curr!=NULL){\\n            if(curr->random!=NULL){\\n            curr->next->random=curr->random->next;\\n            }\\n            curr=curr->next->next;\\n        }\\n    }\\n    \\n    Node* detach(Node* head){\\n        Node* curr=head;\\n        Node* dummy=new Node(-1);\\n        Node* tail=dummy;\\n        while(curr!=NULL){\\n            tail->next=curr->next;\\n            tail=tail->next;\\n            curr->next=tail->next;\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        copy_merge(head);\\n        \\n        handle_random(head);\\n        \\n        return detach(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465844,
                "title": "c-detailed-o-n-time-o-1-space-without-hash-map",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\nclass Solution {\\n// Iterative sol\\'n with O(N) time, O(1) space without a hash map\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n                \\n        // temporary (copied) head node\\n        Node* tmp_node = head;\\n\\t\\t\\n        while(tmp_node)\\n        {\\n            // Cloned node with same val as head\\n            Node* tmp_copy_node = new Node(tmp_node->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            tmp_copy_node->next = tmp_node->next;\\n            tmp_node->next = tmp_copy_node;\\n            tmp_node = tmp_copy_node->next;\\n        }\\n            \\n        tmp_node = head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n            \\n        while (tmp_node)\\n        {\\n            tmp_node->next->random = (tmp_node->random) ? tmp_node->random->next : nullptr;\\n            tmp_node = tmp_node->next->next;\\n        }\\n        \\n        // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* tmp_node_old_list = head;\\n\\t\\t\\n\\t\\t// A\\'->B\\'->C\\'\\n        Node* tmp_node_new_list = head->next;\\n        \\n\\t\\tNode* old_head = head->next;\\n        \\n        while(tmp_node_old_list)\\n        {\\n            tmp_node_old_list->next = tmp_node_old_list->next->next;\\n            tmp_node_new_list->next = (tmp_node_new_list->next) ? tmp_node_new_list->next->next : nullptr;\\n            \\n            tmp_node_old_list = tmp_node_old_list->next;\\n            tmp_node_new_list = tmp_node_new_list->next;\\n        }\\n        return old_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\nclass Solution {\\n// Iterative sol\\'n with O(N) time, O(1) space without a hash map\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n                \\n        // temporary (copied) head node\\n        Node* tmp_node = head;\\n\\t\\t\\n        while(tmp_node)\\n        {\\n            // Cloned node with same val as head\\n            Node* tmp_copy_node = new Node(tmp_node->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            tmp_copy_node->next = tmp_node->next;\\n            tmp_node->next = tmp_copy_node;\\n            tmp_node = tmp_copy_node->next;\\n        }\\n            \\n        tmp_node = head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n            \\n        while (tmp_node)\\n        {\\n            tmp_node->next->random = (tmp_node->random) ? tmp_node->random->next : nullptr;\\n            tmp_node = tmp_node->next->next;\\n        }\\n        \\n        // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* tmp_node_old_list = head;\\n\\t\\t\\n\\t\\t// A\\'->B\\'->C\\'\\n        Node* tmp_node_new_list = head->next;\\n        \\n\\t\\tNode* old_head = head->next;\\n        \\n        while(tmp_node_old_list)\\n        {\\n            tmp_node_old_list->next = tmp_node_old_list->next->next;\\n            tmp_node_new_list->next = (tmp_node_new_list->next) ? tmp_node_new_list->next->next : nullptr;\\n            \\n            tmp_node_old_list = tmp_node_old_list->next;\\n            tmp_node_new_list = tmp_node_new_list->next;\\n        }\\n        return old_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453258,
                "title": "easy-to-understand-c-solution-o-n-time-o-1-space",
                "content": "Runtime: 24 ms, faster than 99.04% of C++ online submissions for Copy List with Random Pointer.\\nMemory Usage: 21.8 MB, less than 100.00% of C++ online submissions for Copy List with Random Pointer.\\n\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n\\n    Node() {}\\n\\n    Node(int _val, Node* _next, Node* _random) {\\n        val = _val;\\n        next = _next;\\n        random = _random;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if(head == nullptr) return head;\\n        Node* curr = head;\\n        Node* temp;\\n        \\n        while(curr)\\n        {\\n            temp = curr->next;\\n            curr->next = new Node(curr->val,nullptr, nullptr);\\n            curr->next->next = temp;\\n            curr = temp;\\n        }\\n        \\n        curr = head;\\n        while(curr)\\n        {\\n            if(curr->next && curr->random)\\n                curr->next->random = curr->random->next;\\n            curr = curr->next ? curr->next->next : curr->next;\\n        }\\n        \\n        Node* original = head;\\n        Node* copy = head->next;\\n        temp = copy;\\n        \\n        while(original && copy)\\n        {\\n            original->next = original->next ? original->next->next : original->next;\\n            copy->next = copy->next ? copy->next->next : copy->next;\\n            \\n            original = original->next;\\n            copy = copy->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n\\n    Node() {}\\n\\n    Node(int _val, Node* _next, Node* _random) {\\n        val = _val;\\n        next = _next;\\n        random = _random;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if(head == nullptr) return head;\\n        Node* curr = head;\\n        Node* temp;\\n        \\n        while(curr)\\n        {\\n            temp = curr->next;\\n            curr->next = new Node(curr->val,nullptr, nullptr);\\n            curr->next->next = temp;\\n            curr = temp;\\n        }\\n        \\n        curr = head;\\n        while(curr)\\n        {\\n            if(curr->next && curr->random)\\n                curr->next->random = curr->random->next;\\n            curr = curr->next ? curr->next->next : curr->next;\\n        }\\n        \\n        Node* original = head;\\n        Node* copy = head->next;\\n        temp = copy;\\n        \\n        while(original && copy)\\n        {\\n            original->next = original->next ? original->next->next : original->next;\\n            copy->next = copy->next ? copy->next->next : copy->next;\\n            \\n            original = original->next;\\n            copy = copy->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417399,
                "title": "python-simple-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        d = {}\\n        p = head\\n        \\n        while p:\\n            d[p] = Node(p.val, None, None)\\n            p = p.next\\n        \\n        p = head\\n        while p:\\n            if p.random:\\n                d[p].random = d[p.random]\\n            if p.next:\\n                d[p].next = d[p.next]\\n            p = p.next\\n        \\n        return d[head]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        d = {}\\n        p = head\\n        \\n        while p:\\n            d[p] = Node(p.val, None, None)\\n            p = p.next\\n        \\n        p = head\\n        while p:\\n            if p.random:\\n                d[p].random = d[p.random]\\n            if p.next:\\n                d[p].next = d[p.next]\\n            p = p.next\\n        \\n        return d[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004195,
                "title": "java-solution-linear-time-constant-space-o-n-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node temp = head;\\n        while(temp != null) {\\n            Node next = temp.next;\\n            Node clone = new Node(temp.val);\\n            temp.next = clone;\\n            clone.next = next;\\n            temp = next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            if(temp.random != null) {\\n                temp.next.random = temp.random.next;\\n            }\\n            temp = temp.next.next;\\n        }\\n        Node cloneHead = new Node(0);\\n        Node tempHead = cloneHead;\\n        temp = head;\\n        while(temp != null) {\\n            Node next = temp.next.next;\\n            Node clone = temp.next;\\n            tempHead.next = clone;\\n            tempHead = clone;\\n            temp.next = next;\\n            temp = next;\\n        }\\n        return cloneHead.next;\\n    }\\n}\\n\\n// Refrences : \\n// https://www.youtube.com/watch?v=83mPr0i56Gg\\n// https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node temp = head;\\n        while(temp != null) {\\n            Node next = temp.next;\\n            Node clone = new Node(temp.val);\\n            temp.next = clone;\\n            clone.next = next;\\n            temp = next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            if(temp.random != null) {\\n                temp.next.random = temp.random.next;\\n            }\\n            temp = temp.next.next;\\n        }\\n        Node cloneHead = new Node(0);\\n        Node tempHead = cloneHead;\\n        temp = head;\\n        while(temp != null) {\\n            Node next = temp.next.next;\\n            Node clone = temp.next;\\n            tempHead.next = clone;\\n            tempHead = clone;\\n            temp.next = next;\\n            temp = next;\\n        }\\n        return cloneHead.next;\\n    }\\n}\\n\\n// Refrences : \\n// https://www.youtube.com/watch?v=83mPr0i56Gg\\n// https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177657,
                "title": "python-list-interweaving-with-explanation-o-n-time-and-o-1-space-complexity",
                "content": "Solution manipulating the original list.\\n**1. We need to make a copy of each node and add it after the original node.**\\nThe resulting list looks like this: (7->7C->13->13C->11->11C->10->10C->1->1C)\\n**2. The random pointer of every new node has to point to the original random.next - the node that is after the original random node.**\\nIf current.random 11 points to 1, the new node copy.random has to point to the 1C.\\n**3. Return the original list to its initial state and extract the copied list.** \\nThis is the most tricky part. We have to remember that the first node in the list we have is original, second is a copy, third is original, fourth is a copy and so on...\\nUsing two pointers current and current_old, we can start current at head.next (the first copied node) and current_old at head.\\nthe next pointers always have to skip one node, so current_old.next = current_old.next.next and current.next = current.next.next.\\n\\nThis code is not the shortest, but with plenty of comments, to make it more understandable.\\n\\n```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if head is None:\\n            return None\\n\\n        current = head\\n\\n        # copy nodes inside the original list --------------------------------------------------------------------------\\n\\n        while current is not None:\\n            # create new copied node\\n            new_node = Node(x=current.val, next=current.next)\\n            # change current.next pointer to the new_node\\n            current.next = new_node\\n\\n            # move current to the next after the copied node\\n            current = current.next.next\\n\\n        # add random pointers --------------------------------------------------------------------------------------\\n\\n        # we have to replicate the random pointers for the copied nodes\\n        # also we have to break pointers of the copied nodes to the original nodes\\n\\n        current = head\\n        while current is not None:\\n            # go to the next copied node - copy is always the node after the current\\n            copy = current.next\\n            # random pointer will point to the random node after the original random\\n            if current.random is not None:\\n                copy.random = current.random.next\\n            else:\\n                copy.random = None\\n\\n            # go to he next original node\\n            current = current.next.next\\n\\n        # break connections of the copied nodes to the original nodes --------------------------------------------------\\n        # this could probably be done inside previous loop, but it complicates the code\\n\\n        # second node is the head node of the new copied list inside the original list\\n        copied_head = head.next\\n        current = head.next\\n        # another pointer to return the list to its original state\\n        current_old = head\\n\\n        while current is not None:\\n            # Return original list to its original state\\n            # pointers for the original list\\n            if current_old.next is not None:\\n                current_old.next = current_old.next.next\\n                current_old = current_old.next\\n            else:\\n                current_old.next = None\\n                current_old = None\\n\\n            # Separate new list from the original list\\n            # pointers for the new list\\n            if current.next is not None:\\n                current.next = current.next.next\\n                current = current.next\\n            else:\\n                current.next = None\\n                current = None\\n\\n        return copied_head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if head is None:\\n            return None\\n\\n        current = head\\n\\n        # copy nodes inside the original list --------------------------------------------------------------------------\\n\\n        while current is not None:\\n            # create new copied node\\n            new_node = Node(x=current.val, next=current.next)\\n            # change current.next pointer to the new_node\\n            current.next = new_node\\n\\n            # move current to the next after the copied node\\n            current = current.next.next\\n\\n        # add random pointers --------------------------------------------------------------------------------------\\n\\n        # we have to replicate the random pointers for the copied nodes\\n        # also we have to break pointers of the copied nodes to the original nodes\\n\\n        current = head\\n        while current is not None:\\n            # go to the next copied node - copy is always the node after the current\\n            copy = current.next\\n            # random pointer will point to the random node after the original random\\n            if current.random is not None:\\n                copy.random = current.random.next\\n            else:\\n                copy.random = None\\n\\n            # go to he next original node\\n            current = current.next.next\\n\\n        # break connections of the copied nodes to the original nodes --------------------------------------------------\\n        # this could probably be done inside previous loop, but it complicates the code\\n\\n        # second node is the head node of the new copied list inside the original list\\n        copied_head = head.next\\n        current = head.next\\n        # another pointer to return the list to its original state\\n        current_old = head\\n\\n        while current is not None:\\n            # Return original list to its original state\\n            # pointers for the original list\\n            if current_old.next is not None:\\n                current_old.next = current_old.next.next\\n                current_old = current_old.next\\n            else:\\n                current_old.next = None\\n                current_old = None\\n\\n            # Separate new list from the original list\\n            # pointers for the new list\\n            if current.next is not None:\\n                current.next = current.next.next\\n                current = current.next\\n            else:\\n                current.next = None\\n                current = None\\n\\n        return copied_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961881,
                "title": "java-solution-with-hashmap-easy-to-understand",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        \\n        if (head ==null)\\n            return head;\\n        \\n        HashMap<Node,Node> map = new HashMap<Node,Node>();\\n        Node temp = head;\\n        while(temp!=null)\\n        {\\n            map.put(temp,new Node(temp.val));\\n            temp=temp.next;\\n        }\\n         temp = head;\\n        while(temp!=null){\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        \\n        if (head ==null)\\n            return head;\\n        \\n        HashMap<Node,Node> map = new HashMap<Node,Node>();\\n        Node temp = head;\\n        while(temp!=null)\\n        {\\n            map.put(temp,new Node(temp.val));\\n            temp=temp.next;\\n        }\\n         temp = head;\\n        while(temp!=null){\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618019,
                "title": "golang",
                "content": "```\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tcloneMap := map[*Node]*Node{}\\n\\tfor cur := head; cur != nil; cur = cur.Next {\\n\\t\\tcloneMap[cur] = &Node{}\\n\\t}\\n\\tfor k, v := range cloneMap {\\n\\t\\tv.Val = k.Val\\n\\t\\tif k.Next != nil {\\n\\t\\t\\tv.Next = cloneMap[k.Next]\\n\\t\\t}\\n\\t\\tif k.Random != nil {\\n\\t\\t\\tv.Random = cloneMap[k.Random]\\n\\t\\t}\\n\\t}\\n\\treturn cloneMap[head]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tcloneMap := map[*Node]*Node{}\\n\\tfor cur := head; cur != nil; cur = cur.Next {\\n\\t\\tcloneMap[cur] = &Node{}\\n\\t}\\n\\tfor k, v := range cloneMap {\\n\\t\\tv.Val = k.Val\\n\\t\\tif k.Next != nil {\\n\\t\\t\\tv.Next = cloneMap[k.Next]\\n\\t\\t}\\n\\t\\tif k.Random != nil {\\n\\t\\t\\tv.Random = cloneMap[k.Random]\\n\\t\\t}\\n\\t}\\n\\treturn cloneMap[head]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252962,
                "title": "java-solution-1ms-using-hashmap-easy-to-understand",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        if(head == null)\\n            return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        while(node != null) {\\n            map.put(node, new Node(node.val, node.next, node.random));\\n            node = node.next;\\n        }\\n        \\n        node = head;\\n        while(node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        if(head == null)\\n            return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        while(node != null) {\\n            map.put(node, new Node(node.val, node.next, node.random));\\n            node = node.next;\\n        }\\n        \\n        node = head;\\n        while(node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249256,
                "title": "c-iterative-recursive-and-o-1-space",
                "content": "Use an `unordered_map` to record the copies of nodes and use it if it has already been copied.\\n\\n**Iterative**\\n\\nFollow from `head` onwards.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        copies[head] = new Node(head -> val, NULL, NULL);\\n        Node* node = head;\\n        while (node) {\\n            Node *next = node -> next, *random = node -> random;\\n            if (next && copies.find(next) == copies.end()) {\\n                copies[next] = new Node(next -> val, NULL, NULL);\\n            }\\n            if (random && copies.find(random) == copies.end()) {\\n                copies[random] = new Node(random -> val, NULL, NULL);\\n            }\\n            copies[node] -> next = next ? copies[next] : NULL;\\n            copies[node] -> random = random ? copies[random] : NULL;\\n            node = next;\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\\n\\n**Recursive**\\n\\nRecursively copy the `next` and `random` pointers.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        if (copies.find(head) == copies.end()) {\\n            copies[head] = new Node(head -> val, NULL, NULL);\\n            copies[head] -> next = copyRandomList(head -> next);\\n            copies[head] -> random = copyRandomList(head -> random);\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\\n\\n**O(1)-space**\\n\\nOf course, as suggested by the hints, you may use the `next` pointer of each node to store its copy. This method is fancier.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        Node *cur = head, *next, *temp, *ans;\\n        while (cur) {\\n            next = cur -> next;\\n            cur -> next = new Node(cur -> val, next, NULL);;\\n            cur = next;\\n        }\\n        cur = head;\\n        while (cur) {\\n            if (cur -> random) {\\n                cur -> next -> random = cur -> random -> next;\\n            }\\n            cur = cur -> next -> next;\\n        }\\n        cur = head, ans = temp = head -> next;\\n        while (cur) {\\n            cur -> next = cur -> next -> next;\\n            temp -> next = temp -> next ? temp -> next -> next : NULL;\\n            cur = cur -> next;\\n            temp = temp -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        copies[head] = new Node(head -> val, NULL, NULL);\\n        Node* node = head;\\n        while (node) {\\n            Node *next = node -> next, *random = node -> random;\\n            if (next && copies.find(next) == copies.end()) {\\n                copies[next] = new Node(next -> val, NULL, NULL);\\n            }\\n            if (random && copies.find(random) == copies.end()) {\\n                copies[random] = new Node(random -> val, NULL, NULL);\\n            }\\n            copies[node] -> next = next ? copies[next] : NULL;\\n            copies[node] -> random = random ? copies[random] : NULL;\\n            node = next;\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        if (copies.find(head) == copies.end()) {\\n            copies[head] = new Node(head -> val, NULL, NULL);\\n            copies[head] -> next = copyRandomList(head -> next);\\n            copies[head] -> random = copyRandomList(head -> random);\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        Node *cur = head, *next, *temp, *ans;\\n        while (cur) {\\n            next = cur -> next;\\n            cur -> next = new Node(cur -> val, next, NULL);;\\n            cur = next;\\n        }\\n        cur = head;\\n        while (cur) {\\n            if (cur -> random) {\\n                cur -> next -> random = cur -> random -> next;\\n            }\\n            cur = cur -> next -> next;\\n        }\\n        cur = head, ans = temp = head -> next;\\n        while (cur) {\\n            cur -> next = cur -> next -> next;\\n            temp -> next = temp -> next ? temp -> next -> next : NULL;\\n            cur = cur -> next;\\n            temp = temp -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004014,
                "title": "simple-java-solution-using-hashmap-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap();\\n        Node temp = head;\\n        while(temp != null) {\\n            map.put(temp, new Node(temp.val));\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap();\\n        Node temp = head;\\n        while(temp != null) {\\n            map.put(temp, new Node(temp.val));\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841320,
                "title": "c-efficient-without-using-map-tc-o-n-sc-o-1-3-steps-with-solution-video",
                "content": "#### *please Upvote, If you find its helpful :)*\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *iter = head; \\n          Node *front = head;\\n\\n          // First round: make copy of each node,\\n          // and link them together side-by-side in a single list.\\n          while (iter != NULL) {\\n            front = iter->next;\\n\\n            Node *copy = new Node(iter->val);\\n            iter->next = copy;\\n            copy->next = front;\\n\\n            iter = front;\\n          }\\n\\n          // Second round: assign random pointers for the copy nodes.\\n          iter = head;\\n          while (iter != NULL) {\\n            if (iter->random != NULL) {\\n              iter->next->random = iter->random->next;\\n            }\\n            iter = iter->next->next;\\n          }\\n\\n          // Third round: restore the original list, and extract the copy list.\\n          iter = head;\\n          Node *pseudoHead = new Node(0);\\n          Node *copy = pseudoHead;\\n\\n          while (iter != NULL) {\\n            front = iter->next->next;\\n\\n            // extract the copy\\n            copy->next = iter->next;\\n\\n            // restore the original list\\n            iter->next = front;\\n              \\n            copy = copy -> next; \\n            iter = front;\\n          }\\n          return pseudoHead->next;\\n    }\\n};\\n```\\n*Check comment for video solution by striver* :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *iter = head; \\n          Node *front = head;\\n\\n          // First round: make copy of each node,\\n          // and link them together side-by-side in a single list.\\n          while (iter != NULL) {\\n            front = iter->next;\\n\\n            Node *copy = new Node(iter->val);\\n            iter->next = copy;\\n            copy->next = front;\\n\\n            iter = front;\\n          }\\n\\n          // Second round: assign random pointers for the copy nodes.\\n          iter = head;\\n          while (iter != NULL) {\\n            if (iter->random != NULL) {\\n              iter->next->random = iter->random->next;\\n            }\\n            iter = iter->next->next;\\n          }\\n\\n          // Third round: restore the original list, and extract the copy list.\\n          iter = head;\\n          Node *pseudoHead = new Node(0);\\n          Node *copy = pseudoHead;\\n\\n          while (iter != NULL) {\\n            front = iter->next->next;\\n\\n            // extract the copy\\n            copy->next = iter->next;\\n\\n            // restore the original list\\n            iter->next = front;\\n              \\n            copy = copy -> next; \\n            iter = front;\\n          }\\n          return pseudoHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748462,
                "title": "simple-and-short-swift-solution",
                "content": "```\\nclass Solution {\\n    var memo = [Node? : Node?]()\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        return constructList(head)\\n    }\\n    \\n    func constructList(_ node: Node?) -> Node? {\\n        if let node = memo[node] {\\n            return node\\n        }\\n        guard let node = node else { return nil }\\n        let newNode = Node(node.val)\\n        memo[node] = newNode\\n        newNode.next = constructList(node.next)\\n        newNode.random = constructList(node.random)\\n        return newNode\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var memo = [Node? : Node?]()\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        return constructList(head)\\n    }\\n    \\n    func constructList(_ node: Node?) -> Node? {\\n        if let node = memo[node] {\\n            return node\\n        }\\n        guard let node = node else { return nil }\\n        let newNode = Node(node.val)\\n        memo[node] = newNode\\n        newNode.next = constructList(node.next)\\n        newNode.random = constructList(node.random)\\n        return newNode\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443516,
                "title": "super-simple-python-solution-99-time-100-space",
                "content": "\\n        \\n        if head is None:\\n            return None\\n        \\n        d = {}\\n        curr = head\\n        \\n        while curr:\\n            d[curr] = Node(curr.val, None, None)\\n            curr = curr.next\\n            \\n        \\n        curr = head\\n        \\n        while curr:\\n            if curr.next != None:\\n                d[curr].next = d[curr.next]\\n            if curr.random != None:\\n                d[curr].random = d[curr.random]\\n            curr = curr.next\\n        \\n            \\n        \\n        return d[head]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n        \\n        if head is None:\\n            return None\\n        \\n        d = {}\\n        curr = head\\n        \\n        while curr:\\n            d[curr] = Node(curr.val, None, None)\\n            curr = curr.next\\n            \\n        \\n        curr = head\\n        \\n        while curr:\\n            if curr.next != None:\\n                d[curr].next = d[curr.next]\\n            if curr.random != None:\\n                d[curr].random = d[curr.random]\\n            curr = curr.next\\n        \\n            \\n        \\n        return d[head]\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 360360,
                "title": "javascript-recursive",
                "content": "```\\nvar copyRandomList = function(head) {\\n    let visited = new Map();\\n    \\n    let helper = (node) => {\\n        if (!node) return null;\\n        if (visited.has(node)) return visited.get(node);\\n        \\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        newNode.next = helper(node.next);\\n        newNode.random = helper(node.random);\\n        return newNode;\\n    }\\n    return helper(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    let visited = new Map();\\n    \\n    let helper = (node) => {\\n        if (!node) return null;\\n        if (visited.has(node)) return visited.get(node);\\n        \\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        newNode.next = helper(node.next);\\n        newNode.random = helper(node.random);\\n        return newNode;\\n    }\\n    return helper(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136171,
                "title": "simple-python-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: RandomListNode\\n        :rtype: RandomListNode\\n        \"\"\"\\n        map = {}\\n        iterNode = head\\n        while iterNode:\\n            map[iterNode] = RandomListNode(iterNode.label)\\n            iterNode = iterNode.next\\n        \\n        iterNode = head\\n        while iterNode:\\n            map[iterNode].next = map[iterNode.next] if iterNode.next else None\\n            map[iterNode].random = map[iterNode.random] if iterNode.random else None\\n            iterNode = iterNode.next\\n        return map[head] if head else None\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: RandomListNode\\n        :rtype: RandomListNode\\n        \"\"\"\\n        map = {}\\n        iterNode = head\\n        while iterNode:\\n            map[iterNode] = RandomListNode(iterNode.label)\\n            iterNode = iterNode.next\\n        \\n        iterNode = head\\n        while iterNode:\\n            map[iterNode].next = map[iterNode.next] if iterNode.next else None\\n            map[iterNode].random = map[iterNode.random] if iterNode.random else None\\n            iterNode = iterNode.next\\n        return map[head] if head else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43607,
                "title": "simple-yet-best-solution-in-c-using-constant-space",
                "content": "\\n* clone each node of the list and connect the cloned just after its original\\n* the random pointer of the cloned node can be easily fetched by its previous node `p->random->next`\\n* split the original node and its cloned collecting the `odd and even` nodes in a list\\n\\n```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        RandomListNode newHead(0), *p = head, *t = NULL;\\n        while(p)\\n        {\\n            RandomListNode *cloned = new RandomListNode(p->label);\\n            cloned->next = p->next;\\n            p->next = cloned;\\n            p = cloned->next;\\n        }\\n        \\n        p = head;\\n        while(p && p->next)\\n        {\\n            if(p->random) p->next->random = p->random->next;\\n            p = p->next->next;\\n        }\\n        \\n        p = head;\\n        t = &newHead;\\n        while(p && p->next)\\n        {\\n            t->next = p->next;\\n            p->next = p->next->next;\\n            t = t->next;\\n            p = p->next;\\n        }\\n        t->next = NULL;\\n        return newHead.next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        RandomListNode newHead(0), *p = head, *t = NULL;\\n        while(p)\\n        {\\n            RandomListNode *cloned = new RandomListNode(p->label);\\n            cloned->next = p->next;\\n            p->next = cloned;\\n            p = cloned->next;\\n        }\\n        \\n        p = head;\\n        while(p && p->next)\\n        {\\n            if(p->random) p->next->random = p->random->next;\\n            p = p->next->next;\\n        }\\n        \\n        p = head;\\n        t = &newHead;\\n        while(p && p->next)\\n        {\\n            t->next = p->next;\\n            p->next = p->next->next;\\n            t = t->next;\\n            p = p->next;\\n        }\\n        t->next = NULL;\\n        return newHead.next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43765,
                "title": "o-n-time-3-passes-o-1-memory-usage-solution",
                "content": "    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * class RandomListNode {\\n     *     int label;\\n     *     RandomListNode next, random;\\n     *     RandomListNode(int x) { this.label = x; }\\n     * };\\n     */\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null)\\n                return null;\\n            RandomListNode c = head;\\n            while (c != null) {\\n                RandomListNode n = new RandomListNode(c.label);\\n                n.random = c.random;\\n                n.next = c.next;\\n                c.next = n;\\n                c = n.next;\\n            }\\n            c = head;\\n            while (c != null) {\\n                c = c.next;\\n                if (c.random != null)\\n                    c.random = c.random.next;\\n                c = c.next;\\n            }\\n            RandomListNode newHead = new RandomListNode(0);\\n            newHead.next = head;\\n            c = head;\\n            RandomListNode cNew = newHead;\\n            while (c != null) {\\n               cNew.next = c.next;\\n               c.next = c.next.next;\\n               cNew = cNew.next;\\n               c = c.next;\\n            }\\n            return newHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null)\\n                return null;\\n            RandomListNode c = head;\\n            while (c != null) {\\n                RandomListNode n = new RandomListNode(c.label);\\n                n.random = c.random;\\n                n.next = c.next;\\n                c.next = n;\\n                c = n.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3797257,
                "title": "69-iq-solution",
                "content": "# Code\\n```\\nfunction copyRandomList(head: Node | null): Node | null {\\n    if (head == null) return null;\\n\\n    let map = new Map();\\n\\n    let current = head;\\n\\n    while (current) {\\n        map.set(current, new Node(current.val, current.next, current.random));\\n        current = current.next;\\n    }\\n\\n    map.forEach(node => {\\n        if (node.next) node.next = map.get(node.next);\\n        if (node.random) node.random = map.get(node.random);\\n    });\\n\\n    return map.get(head);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction copyRandomList(head: Node | null): Node | null {\\n    if (head == null) return null;\\n\\n    let map = new Map();\\n\\n    let current = head;\\n\\n    while (current) {\\n        map.set(current, new Node(current.val, current.next, current.random));\\n        current = current.next;\\n    }\\n\\n    map.forEach(node => {\\n        if (node.next) node.next = map.get(node.next);\\n        if (node.random) node.random = map.get(node.random);\\n    });\\n\\n    return map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718767,
                "title": "sharing-my-o-1-extra-space-solution-that-uses-pointer-tagging",
                "content": "# Intuition\\nTo get a O(1) solution, we essentially need to modify the original list (in-place) somehow to keep track of the copies of each node. [Most](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/) [other](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1255721/c-both-solutions-explained-clearly-hashmap-method-constant-space-method/) [solutions](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/) go with inserting the copy right after the original, but I was in the mood for something fancier.\\n\\nInsight: We can store the address (memory pointer) of the copied node inside the original node itself- there is enough space! Or rather, we can _make_ enough space for it...\\n\\n# Background\\n## Pointer tagging\\n\\nSee [Wikipedia](https://en.wikipedia.org/wiki/Tagged_pointer).\\nOn a 64-bit system, pointers usually take up 64-bits = 8 bytes of space. But this is a convenient lie- pointers don\\'t _really_ need so much space. Having 64-bits would be enough to reference `2**64` bytes of memory, which is around 1.6 MILLION TERABYTES. Much more RAM than a single machine typically has. So, most operating systems cheat, and only use the first 48-bits of the pointer- the rest are usually set to 0.\\n\\nNow, we only need to find a place inside `Node` where we can stash an entire additional pointer (48-bits). (Remember, we need to modify each node in-place to get an `O(1)` solution.)\\n\\nWe can\\'t use `next` and `random` since those are pointers and use up at least 48 bits in their respective fields, leaving only 32 bits total - not enough.\\n\\nFlipping around the problem, if we somehow had 64 bits inside `Node`, we could store the pointer in the 48 bits, and use 16 bits to store some other value.\\n\\nOh- what divine coincidence... 16 bits is more than enough to represent all the values from our problem description; the range `[-10000, 10000]` has 20001 values, which is much less than `2**16` = 65536. (Even 15 bits, with 32768 values, would work... but that is a minor detail.) Maybe we can store `val` in the top 16-bits of our extra pointer.\\n\\nBuuut `val` is itself just an `int`, giving us a measely 32 bits. We need 64 bits to store the combination of `val` (16 bits) and the extra pointer (48 bits). Where do we get the extra 32 bits from?\\n\\nSeems like we are stuck... Or are we??\\n\\nTime to dig deeper...\\n\\n## Memory padding in C++ structs\\nHere\\'s the `Node` struct as given in the problem statement:\\n```cpp\\nclass Node {\\n    int val;\\n    Node* next;\\n    Node* random;\\n    //...\\n};\\n```\\n\\nNaively, one would think that our `Node` struct is just 20 bytes in size- `4`(`int val`) + `8`(`Node* next`) + `8`(`Node* random`). (`int` is 32-bits, and on a 64-bit system, a pointer typically takes up 8 bytes.)\\n\\nHowever, our compiler says `Node` is really 24 bytes wide:\\n```cpp\\ncout << sizeof(Node);  // prints 24\\n```\\n\\nWhat gives?\\n\\nThe answer lies in how the fields inside the struct are really laid out in memory. Instead of putting them right next to each other, the compiler is free to leave some blank bytes between them. This space is called padding.\\n\\nIn typical systems, pointers are aligned to 8 bytes. For `Node`, the compiler inserts extra 4 bytes of padding after `val` to make sure that `next` is properly aligned. See [Typical alignment of C structs on x86 (Wikipedia)](https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86) for more details.\\n\\nWe can take advantage of this padding to \"procure\" the extra space we needed.\\n\\n# Approach\\nWe define a separate struct `Node2` that is the same as `Node`, but with `uint64_t` for the `val` field instead of `int`. **Crucially, on most systems/compilers, this struct has the same size as `Node`.**\\n\\nNow, by casting our `Node*` pointers to `Node2*` pointers, we are able to access the padding bytes from the original struct. We can use pointer tagging to store both the original node value _and_ the additional address in this field.\\n\\n# Code\\n```cpp\\n// assuming 64-bit system\\nstatic_assert(sizeof(uintptr_t) == 8);\\n// number of extra bits that are unused in the pointers.\\n// we could technically make do with just 15 bits\\n// since the range of vals is between [-10000, 10000], i.e. 20001 numbers\\n// and pow(2, 15) == 32768 is enough to store all these nums.\\nconstexpr uint64_t NUM_EXTRA_BITS = 16;\\nconstexpr uint64_t VAL_SHIFT = 64 - NUM_EXTRA_BITS;\\nconstexpr uint64_t make_mask(uint64_t num_bits) {\\n    return (1ULL << num_bits) - 1;\\n}\\nconstexpr uint64_t PTR_BITS = make_mask(VAL_SHIFT);\\nconstexpr uint64_t VAL_BITS = make_mask(NUM_EXTRA_BITS) << VAL_SHIFT;\\n// make sure there is no overlap\\nstatic_assert((PTR_BITS & VAL_BITS) == 0);\\n\\nstruct Node2 {\\n    uint64_t tagged;\\n    struct Node2* next;\\n    struct Node2* random;\\n    int get_v() const {\\n        return tagged >> VAL_SHIFT;\\n    }\\n    void put_v(int v) {\\n        tagged |= uint64_t(v) << VAL_SHIFT;\\n    }\\n    void* get_ptr() const {\\n        return (void*)(tagged & PTR_BITS); \\n    }\\n    void put(void* ptr, int v) {\\n        // zero-ing out the field is really crucial to avoid undefined behaviour\\n        // without this line, we can\\'t be sure about the contents of padding bytes\\n        tagged = 0;\\n        put_ptr(ptr);\\n        put_v(v);\\n    }\\n    void put_ptr(void* ptr) {\\n        assert((int64_t(ptr) & VAL_BITS) == 0);\\n        tagged |= (int64_t)ptr;\\n    }\\n};\\n// this solution will break if the following assert is false\\nstatic_assert(sizeof(Node2) == sizeof(Node));\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head) {\\n        Node *copyhead = nullptr, *copytail = nullptr;\\n\\n        // create copy list and add tagged pointers\\n        for (Node* p = head; p; p = p->next) {\\n            auto copy = new Node(p->val);\\n            if (!copyhead) {\\n                copyhead = copy;\\n            }\\n            if (copytail) {\\n                copytail->next = copy;\\n            }\\n            copytail = copy;\\n            copy->random = p->random;\\n            auto* origptr = reinterpret_cast<Node2*>(p);\\n            // store address of copied node into the original node using pointer tagging\\n            origptr->put(copy, copy->val);\\n        }\\n        // get the addresses from tagged pointer\\n        for (Node* copy = copyhead; copy; copy = copy->next) {\\n            if (copy->random) {\\n                // copy->random is currently the original random node\\n                auto* taggedptr = reinterpret_cast<Node2*>(copy->random);\\n                // get the copied node from the original node\\n                copy->random = (Node*)taggedptr->get_ptr();\\n            }\\n        }\\n        // restore the original values\\n        for (Node* p = head; p; p = p->next) {\\n            auto* taggedptr = reinterpret_cast<Node2*>(p);\\n            p->val = taggedptr->get_v();\\n        }\\n        return copyhead;\\n    }\\n};\\n```\\n\\n# Another solution\\nIf you were following closely, you might have noticed an alternate solution which avoids using the padding bytes entirely.\\n\\nOur requirements are that we need to store the 48-bit pointer somewhere inside the `Node` fields. Now note that our `next` and `random` fields are themselves pointers, so they only take up 48-bits each, leaving 16+16 = 32 bits unused. We can get another 16 bits from the upper half of `val` (again, we only need 15 bits to store all the nums between `[-10000, 10000]`). \\n\\nSo, by taking 16 bits from each of the three fields, we actually have enough space for our additional pointer. We just need to split it across the three fields. See if you can implement this :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Node {\\n    int val;\\n    Node* next;\\n    Node* random;\\n    //...\\n};\\n```\n```cpp\\ncout << sizeof(Node);  // prints 24\\n```\n```cpp\\n// assuming 64-bit system\\nstatic_assert(sizeof(uintptr_t) == 8);\\n// number of extra bits that are unused in the pointers.\\n// we could technically make do with just 15 bits\\n// since the range of vals is between [-10000, 10000], i.e. 20001 numbers\\n// and pow(2, 15) == 32768 is enough to store all these nums.\\nconstexpr uint64_t NUM_EXTRA_BITS = 16;\\nconstexpr uint64_t VAL_SHIFT = 64 - NUM_EXTRA_BITS;\\nconstexpr uint64_t make_mask(uint64_t num_bits) {\\n    return (1ULL << num_bits) - 1;\\n}\\nconstexpr uint64_t PTR_BITS = make_mask(VAL_SHIFT);\\nconstexpr uint64_t VAL_BITS = make_mask(NUM_EXTRA_BITS) << VAL_SHIFT;\\n// make sure there is no overlap\\nstatic_assert((PTR_BITS & VAL_BITS) == 0);\\n\\nstruct Node2 {\\n    uint64_t tagged;\\n    struct Node2* next;\\n    struct Node2* random;\\n    int get_v() const {\\n        return tagged >> VAL_SHIFT;\\n    }\\n    void put_v(int v) {\\n        tagged |= uint64_t(v) << VAL_SHIFT;\\n    }\\n    void* get_ptr() const {\\n        return (void*)(tagged & PTR_BITS); \\n    }\\n    void put(void* ptr, int v) {\\n        // zero-ing out the field is really crucial to avoid undefined behaviour\\n        // without this line, we can\\'t be sure about the contents of padding bytes\\n        tagged = 0;\\n        put_ptr(ptr);\\n        put_v(v);\\n    }\\n    void put_ptr(void* ptr) {\\n        assert((int64_t(ptr) & VAL_BITS) == 0);\\n        tagged |= (int64_t)ptr;\\n    }\\n};\\n// this solution will break if the following assert is false\\nstatic_assert(sizeof(Node2) == sizeof(Node));\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head) {\\n        Node *copyhead = nullptr, *copytail = nullptr;\\n\\n        // create copy list and add tagged pointers\\n        for (Node* p = head; p; p = p->next) {\\n            auto copy = new Node(p->val);\\n            if (!copyhead) {\\n                copyhead = copy;\\n            }\\n            if (copytail) {\\n                copytail->next = copy;\\n            }\\n            copytail = copy;\\n            copy->random = p->random;\\n            auto* origptr = reinterpret_cast<Node2*>(p);\\n            // store address of copied node into the original node using pointer tagging\\n            origptr->put(copy, copy->val);\\n        }\\n        // get the addresses from tagged pointer\\n        for (Node* copy = copyhead; copy; copy = copy->next) {\\n            if (copy->random) {\\n                // copy->random is currently the original random node\\n                auto* taggedptr = reinterpret_cast<Node2*>(copy->random);\\n                // get the copied node from the original node\\n                copy->random = (Node*)taggedptr->get_ptr();\\n            }\\n        }\\n        // restore the original values\\n        for (Node* p = head; p; p = p->next) {\\n            auto* taggedptr = reinterpret_cast<Node2*>(p);\\n            p->val = taggedptr->get_v();\\n        }\\n        return copyhead;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3341661,
                "title": "c-easy-commented-code-map-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, an unordered map is used to store [key : pairs] as [old nodes : new nodes]\\n\\nSteps :\\n1. If the given Linked List is empty return it\\n2. Loop through the Linked List and check for the presence of each node in the map. If absent, make a new copy for the current node and store it in the map as [Old Node : New Node]\\n3. Now we have all the new copies in our map. Loop through the Linked List again and set the corresponding next and random pointers for new nodes.\\n4. Return the corresponding copy for head;\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)   return head;\\n        unordered_map<Node*, Node*> copy;\\n        Node* it = head;\\n        while(it) if(!copy[it]) copy[it] = new Node(it->val), it = it->next;\\n        it = head;\\n        while(it) copy[it]->next = it->next ? copy[it->next] : nullptr, copy[it]->random = it->random ? copy[it->random] : nullptr, it = it->next;\\n        return copy[head];\\n    }\\n};\\n```\\n\\nUpvote if you find this helpful :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)   return head;\\n        unordered_map<Node*, Node*> copy;\\n        Node* it = head;\\n        while(it) if(!copy[it]) copy[it] = new Node(it->val), it = it->next;\\n        it = head;\\n        while(it) copy[it]->next = it->next ? copy[it->next] : nullptr, copy[it]->random = it->random ? copy[it->random] : nullptr, it = it->next;\\n        return copy[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203441,
                "title": "python-straightforward-iterative-solution-with-a-dict",
                "content": "```\\ndef copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        \\n        d = {}\\n        dummy = Node(-1000)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n\\t\\t# iterate over original list\\n        while cur:\\n\\t\\t\\t# create a copy of current node\\n            prev.next = Node(cur.val)\\n\\t\\t\\t\\n\\t\\t\\t# map original node to its\\' copy\\n            d[cur] = prev.next\\n\\t\\t\\t\\n            prev = prev.next\\n            cur = cur.next\\n        \\n        cur = head\\n        \\n        while cur:\\n\\t\\t\\t# set each random pointer in the new list to correct node using mapping\\n            d[cur].random = d[cur.random] if cur.random else None\\n            cur = cur.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\ndef copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        \\n        d = {}\\n        dummy = Node(-1000)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n\\t\\t# iterate over original list\\n        while cur:\\n\\t\\t\\t# create a copy of current node\\n            prev.next = Node(cur.val)\\n\\t\\t\\t\\n\\t\\t\\t# map original node to its\\' copy\\n            d[cur] = prev.next\\n\\t\\t\\t\\n            prev = prev.next\\n            cur = cur.next\\n        \\n        cur = head\\n        \\n        while cur:\\n\\t\\t\\t# set each random pointer in the new list to correct node using mapping\\n            d[cur].random = d[cur.random] if cur.random else None\\n            cur = cur.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1841602,
                "title": "most-optimal-approach-with-constant-space-with-intuition",
                "content": "![image](https://assets.leetcode.com/users/images/836ed23c-8302-4414-b472-20f4f9957155_1647064947.629208.png)\\nNow after these operations the linked list will look like\\n\\n![image](https://assets.leetcode.com/users/images/a968a4e4-47a0-42ad-8da7-c48697dee9c7_1647065226.635323.png)\\n![image](https://assets.leetcode.com/users/images/dc58fbed-18d4-4fb2-a786-221aa324b84d_1647065467.7630546.png)\\n![image](https://assets.leetcode.com/users/images/898e94c4-4f0b-4417-93a2-dd00bbe52698_1647065508.4319434.png)\\n\\nNow comes the third step which is seperating these two linked lists.\\n![image](https://assets.leetcode.com/users/images/9d77a9ac-8f0f-4fb9-bd96-02515319ed83_1647066370.315812.png)\\n\\nReturn the final in the end.\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) { \\n\\t //STEP 1\\n        if(!head) return NULL; \\n        Node* temp = head;\\n        while(temp){ // while temp is not null\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next; \\n            temp->next = node;\\n            temp = node->next;\\n        }\\n\\t\\t\\n\\t\\t//Step 2\\n        temp = head; \\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL; \\n            temp = temp->next->next; \\n        }\\n\\t\\t\\n\\t\\t//Step 3\\n        Node* final = head->next;\\n        temp = head->next;\\n        while(head){ \\n            head->next = temp->next;\\n            head = head->next; \\n            if(!head) break; \\n            temp->next = head->next; \\n            temp = temp->next;\\n        }\\n        return final;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) { \\n\\t //STEP 1\\n        if(!head) return NULL; \\n        Node* temp = head;\\n        while(temp){ // while temp is not null\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next; \\n            temp->next = node;\\n            temp = node->next;\\n        }\\n\\t\\t\\n\\t\\t//Step 2\\n        temp = head; \\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL; \\n            temp = temp->next->next; \\n        }\\n\\t\\t\\n\\t\\t//Step 3\\n        Node* final = head->next;\\n        temp = head->next;\\n        while(head){ \\n            head->next = temp->next;\\n            head = head->next; \\n            if(!head) break; \\n            temp->next = head->next; \\n            temp = temp->next;\\n        }\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059423,
                "title": "c-recursive-dfs-solution-explained-100-time-20-space",
                "content": "Not the most memory-efficient approach, but still fun to develop.\\n\\nWith the more naive solution, we will store the created nodes as we go in `m`, an `unordered_map` with original `Node`s as key and matching copies of them as values.\\n\\nIn our main function we will just create a `res` `Node` pointer and assign the value of `copyNode(head)` to it.\\n\\nThe `copyNode` helper function will:\\n* return `head`, when this is `NULL`;\\n* create a new pointer `res` with the same `->val` of `head` and and assign it to `m`;\\n* we will then go down the list with recursive calls to generate all the `next` values up to the end;\\n* by now, the whole list has been generated, so we can easily assign `res->random` as well, picking it from the matching element we stored in `m[head->random]`;\\n* return the fully created and connected new `Node` pointer `res`.\\n\\nOnce done with the helper function, we will also return `res` in the main one :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n    Node* copyNode(Node* head) {\\n        // edge case: NULL head\\n        if (!head) return head;\\n        // creating and storing the new node\\n        Node *res = m[head] = new Node(head->val);\\n        // creating all the next nodes\\n        res->next = copyNode(head->next);\\n        // assigning random\\n        res->random = m[head->random];\\n        return res;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *res = copyNode(head);\\n        return res;\\n    }\\n};\\n```\\n\\nSame logic, but with iteration instead of leveraging a big recursive stack; similar time performance, but with memory usage from 5% to ~50%:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead = m[head] = new Node(tmp->val), *newTmp = newHead;\\n        tmp = tmp->next;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // storing and connecting next nodes\\n            newTmp->next = m[tmp] = new Node(tmp->val);\\n            // advancing newTmp and tmp\\n            newTmp = newTmp->next;\\n            tmp = tmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            m[tmp]->random = m[tmp->random];\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```\\n\\nFinally, the extra challenge from the problem - no extra memory.\\n\\nTo do so, we first of all check if we have an empty list - no point in moving forward, in case.\\n\\nIf not, then we create a couple of support variables:\\n* `tmp`, our main iterator, initially set to point to the original `head`;\\n* `newHead`, that we will use only at the end to return the copied list;\\n* `newTmp`, as the name implies the homologous of `tmp` in our cloned list.\\n\\nThen we will move on with a first loop, running as long as `tmp` is not `NULL`, to create all the new nodes, splicing them right after the matching node from the original list:\\n* `newTmp` will be assigned the value of a new node with value `tmp->val`;\\n* `newTmp->next` will become `tmp->next`;\\n* and in turn `tmp->next` will be `newTmp`;\\n* finally, we advance `tmp` by one step and loop again.\\n\\nTime for the second loop, right after resetting `tmp = head` and with the same condition; here we will take care of the `random` property:\\n* `tmp->next->random` (ie: the `random` property of a newly created node right after `tmp`, with it always being an original node) will take the value of `tmp->random->next`, since we know that `tmp->random` is again an original node and the one immediately following it is its matching copy;\\n* since we want to keep working only with original nodes, this time we advance by 2 positions (and we can be sure that as long as `tmp` is not `NULL`, so it will be the case for `tmp->next`, since an original node is now always followed by a copied one).\\n\\nTime for one last loop, after again resetting `tmp = head`, but this time also storing `newHead = head->next`. We will then:\\n* store the node following `tmp` (guaranted to be a new one) in `newTmp`;\\n* splice said node out of the old list, with `tmp->next = tmp->next->next`;\\n* if `newTmp` is not the last node, then we will similarly set it to connect with the next cloned node;\\n* finally, we advance `tmp` by one step and loop again.\\n\\nOnce done, we can safely return `newHead` :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead, *newTmp;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // creating a new node\\n            newTmp = new Node(tmp->val);\\n            // splicing newTmp\\n            newTmp->next = tmp->next;\\n            tmp->next = newTmp;\\n            // advancing tmp\\n            tmp = newTmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            tmp->next->random = tmp->random ? tmp->random->next : NULL;\\n            // advancing tmp\\n            tmp = tmp->next->next;\\n        }\\n        // splitting the lists\\n        tmp = head;\\n        newHead = head->next;\\n        while (tmp) {\\n            // storing the new node\\n\\t\\t\\tnewTmp = tmp->next;\\n            // restoring original list to be only made of original nodes\\n            tmp->next = tmp->next->next;\\n            if (newTmp->next) newTmp->next = newTmp->next->next;\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n    Node* copyNode(Node* head) {\\n        // edge case: NULL head\\n        if (!head) return head;\\n        // creating and storing the new node\\n        Node *res = m[head] = new Node(head->val);\\n        // creating all the next nodes\\n        res->next = copyNode(head->next);\\n        // assigning random\\n        res->random = m[head->random];\\n        return res;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *res = copyNode(head);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead = m[head] = new Node(tmp->val), *newTmp = newHead;\\n        tmp = tmp->next;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // storing and connecting next nodes\\n            newTmp->next = m[tmp] = new Node(tmp->val);\\n            // advancing newTmp and tmp\\n            newTmp = newTmp->next;\\n            tmp = tmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            m[tmp]->random = m[tmp->random];\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead, *newTmp;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // creating a new node\\n            newTmp = new Node(tmp->val);\\n            // splicing newTmp\\n            newTmp->next = tmp->next;\\n            tmp->next = newTmp;\\n            // advancing tmp\\n            tmp = newTmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            tmp->next->random = tmp->random ? tmp->random->next : NULL;\\n            // advancing tmp\\n            tmp = tmp->next->next;\\n        }\\n        // splitting the lists\\n        tmp = head;\\n        newHead = head->next;\\n        while (tmp) {\\n            // storing the new node\\n\\t\\t\\tnewTmp = tmp->next;\\n            // restoring original list to be only made of original nodes\\n            tmp->next = tmp->next->next;\\n            if (newTmp->next) newTmp->next = newTmp->next->next;\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935355,
                "title": "two-js-solutions",
                "content": "```\\n/*\\n[Recursion, Memoization]\\n1. Consider every node as a list.\\n2. Record each original node to hash table with its value being a clone node.\\n3. Copy next node and random node.\\n4. Return node.\\n*/\\nvar copyRandomList = function(head, cloneMap=new Map()) {\\n    if (!head) {\\n        return null;\\n    }\\n    if (cloneMap.has(head)) {\\n        return cloneMap.get(head);\\n    }\\n    let clone = new Node(head.val, null, null);\\n    cloneMap.set(head, clone);\\n    clone.next = copyRandomList(head.next, cloneMap);\\n    clone.random = copyRandomList(head.random, cloneMap);\\n    return clone;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n/*\\n1. Iterate through given list. For each node, create a clone and record it to a hash table with an entry being\\n(node, clone node). Then, push the original node to an array.\\n2. Iterate through the array. For each node, get the clone node and\\n(1) Set next pointer to next node\\'s clone\\n(2) Set random pointer to current node\\'s random node\\'s clone\\n3. Return the cloned head from hash table.\\n*/\\nvar copyRandomList = function(head) {\\n    if (!head) {\\n        return null;\\n    }\\n    let cloneMap = new Map(), arr = [];\\n    let cur = head;\\n    while (cur !== null) {\\n        arr.push(cur);\\n        let cloneNode = new Node(cur.val, null, null);\\n        cloneMap.set(cur, cloneNode);\\n        cur = cur.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        let clone = cloneMap.get(arr[i]);\\n        // set next pointer\\n        if (i < arr.length-1) {\\n            clone.next = cloneMap.get(arr[i+1]);\\n        }\\n        // set random pointer\\n        if (arr[i].random !== null) {\\n            clone.random = cloneMap.get(arr[i].random);\\n        }\\n    }\\n    return cloneMap.get(head);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n[Recursion, Memoization]\\n1. Consider every node as a list.\\n2. Record each original node to hash table with its value being a clone node.\\n3. Copy next node and random node.\\n4. Return node.\\n*/\\nvar copyRandomList = function(head, cloneMap=new Map()) {\\n    if (!head) {\\n        return null;\\n    }\\n    if (cloneMap.has(head)) {\\n        return cloneMap.get(head);\\n    }\\n    let clone = new Node(head.val, null, null);\\n    cloneMap.set(head, clone);\\n    clone.next = copyRandomList(head.next, cloneMap);\\n    clone.random = copyRandomList(head.random, cloneMap);\\n    return clone;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\n1. Iterate through given list. For each node, create a clone and record it to a hash table with an entry being\\n(node, clone node). Then, push the original node to an array.\\n2. Iterate through the array. For each node, get the clone node and\\n(1) Set next pointer to next node\\'s clone\\n(2) Set random pointer to current node\\'s random node\\'s clone\\n3. Return the cloned head from hash table.\\n*/\\nvar copyRandomList = function(head) {\\n    if (!head) {\\n        return null;\\n    }\\n    let cloneMap = new Map(), arr = [];\\n    let cur = head;\\n    while (cur !== null) {\\n        arr.push(cur);\\n        let cloneNode = new Node(cur.val, null, null);\\n        cloneMap.set(cur, cloneNode);\\n        cur = cur.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        let clone = cloneMap.get(arr[i]);\\n        // set next pointer\\n        if (i < arr.length-1) {\\n            clone.next = cloneMap.get(arr[i+1]);\\n        }\\n        // set random pointer\\n        if (arr[i].random !== null) {\\n            clone.random = cloneMap.get(arr[i].random);\\n        }\\n    }\\n    return cloneMap.get(head);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744455,
                "title": "modular-and-easy-o-n-o-1-cpp",
                "content": "After writing my code, I saw the top answers. I felt that this question needs a good modular structure for others to really understand without scratching their head.\\n\\nIdea: \\n1. Simply insert copy of nodes between the nodes of original List\\n2. Copy Random pointers for the Clone/Copy List.\\n3. Then assign the next pointers correctly to segragate both the list.\\n\\nNote: We need to keep the original list Untouched. (I was stuck for 5 mins because after writing everything correctly, I was not restoring the original List, And I was getting some weird error.) :(\\n\\nOne of my friends adviced me to practice writng quality code. Its something every Interviewer looks forward to.\\n\\nMy code: \\n\\n```\\nclass Solution {\\n    private:\\n        void insertNewNodes(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=new Node(itr->val);\\n                temp->next=itr->next;\\n                itr->next=temp;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyRandomPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                if(itr->random == NULL) itr->next->random=NULL;\\n                else itr->next->random=itr->random->next;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyNextPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=itr->next->next;\\n                if(temp) itr->next->next=itr->next->next->next;\\n                itr->next=temp;\\n                itr=itr->next;\\n            }\\n        }\\n    public:\\n        Node* copyRandomList(Node* head) {\\n            if(head == NULL) return NULL;\\n            insertNewNodes(head);\\n            Node* headCopy=head->next;\\n            copyRandomPointers(head);\\n            copyNextPointers(head);\\n            return headCopy;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private:\\n        void insertNewNodes(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=new Node(itr->val);\\n                temp->next=itr->next;\\n                itr->next=temp;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyRandomPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                if(itr->random == NULL) itr->next->random=NULL;\\n                else itr->next->random=itr->random->next;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyNextPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=itr->next->next;\\n                if(temp) itr->next->next=itr->next->next->next;\\n                itr->next=temp;\\n                itr=itr->next;\\n            }\\n        }\\n    public:\\n        Node* copyRandomList(Node* head) {\\n            if(head == NULL) return NULL;\\n            insertNewNodes(head);\\n            Node* headCopy=head->next;\\n            copyRandomPointers(head);\\n            copyNextPointers(head);\\n            return headCopy;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710506,
                "title": "standard-java-solution",
                "content": "### Theory\\nOnce you know the pattern for this problem, its actually very trivial. We simply need to keep a clone space mapping from the original to the newly created ones. We first traverse through to create the clone space, then we do a second pass to attach the pointers. Notice how once we do our initial traversal, all the nodes are defined in our map, and therefore assigning random pointers will not be a problem now. \\n\\n### Solution\\n```\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node curr = head;\\n        while (curr != null) {\\n            map.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            map.get(curr).random = map.get(curr.random);\\n            map.get(curr).next = map.get(curr.next);\\n            curr = curr.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node curr = head;\\n        while (curr != null) {\\n            map.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            map.get(curr).random = map.get(curr.random);\\n            map.get(curr).next = map.get(curr.next);\\n            curr = curr.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650032,
                "title": "java-solution-without-using-hashmap",
                "content": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        if(head == null){\\n            return null;\\n        }\\n        \\n        //copy linked list to following structure A -> A\\' -> B -> B\\' .... -> C -> C\\'\\n        Node p = head;\\n        while(p != null){\\n            Node tmp = p.next;\\n            p.next = new Node(p.val);\\n            p.next.next = tmp;\\n            p = tmp;\\n        }\\n        \\n        //copy random list\\n        p = head;\\n        while(p != null){\\n            if(p.random == null){\\n                p.next.random = null;\\n            }else{\\n                p.next.random = p.random.next;\\n            }\\n            p = p.next.next;\\n        }\\n        \\n        //split structure A -> A\\' -> B -> B\\' => A -> B | A\\' -> B\\'\\n        Node newHead = head.next;\\n        Node q = newHead;\\n        p = head;\\n        \\n        while(p!= null){\\n            p.next = p.next.next;\\n            if(p.next == null){\\n                q.next = null;\\n            }else{\\n                q.next = p.next.next;\\n            }\\n            p = p.next;\\n            q = q.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        if(head == null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 594662,
                "title": "go-two-solutions",
                "content": "O(N) space hash map solution:\\n```\\nfunc copyRandomList(head *Node) *Node {\\n    m := make(map[*Node]*Node)\\n    \\n    dummy := &Node{}\\n    \\n    curr1 := head\\n    curr2 := dummy\\n    for curr1 != nil {\\n        newNode := &Node{Val: curr1.Val}\\n        m[curr1] = newNode\\n        curr2.Next = newNode\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    curr1 = head\\n    curr2 = dummy.Next\\n    for curr1 != nil {\\n        curr2.Random = m[curr1.Random]\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```\\n\\n<hr>\\n\\nO(1) Space duplicate list and then extract:\\n```\\nfunc copyRandomList(head *Node) *Node {\\n    // Duplicate each node.\\n    curr := head\\n    for curr != nil {\\n        newNode := &Node{\\n            Val: curr.Val,\\n            Next: curr.Next,\\n            Random: curr.Random,\\n        }\\n        \\n        curr.Next = newNode\\n        curr = newNode.Next\\n    }\\n    \\n    // Make the duplicated nodes point to the correct random.\\n    curr = head\\n    for curr != nil {\\n        curr = curr.Next\\n        if curr.Random != nil {\\n            curr.Random = curr.Random.Next\\n        }\\n        curr = curr.Next\\n    }\\n    \\n    // Extract the duplicated nodes and recover the original list.\\n    dummy := &Node{}\\n    curr2 := dummy\\n    curr = head\\n    for curr != nil {\\n        n := curr.Next\\n        curr.Next = curr.Next.Next\\n        curr = curr.Next\\n        curr2.Next = n\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc copyRandomList(head *Node) *Node {\\n    m := make(map[*Node]*Node)\\n    \\n    dummy := &Node{}\\n    \\n    curr1 := head\\n    curr2 := dummy\\n    for curr1 != nil {\\n        newNode := &Node{Val: curr1.Val}\\n        m[curr1] = newNode\\n        curr2.Next = newNode\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    curr1 = head\\n    curr2 = dummy.Next\\n    for curr1 != nil {\\n        curr2.Random = m[curr1.Random]\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```\n```\\nfunc copyRandomList(head *Node) *Node {\\n    // Duplicate each node.\\n    curr := head\\n    for curr != nil {\\n        newNode := &Node{\\n            Val: curr.Val,\\n            Next: curr.Next,\\n            Random: curr.Random,\\n        }\\n        \\n        curr.Next = newNode\\n        curr = newNode.Next\\n    }\\n    \\n    // Make the duplicated nodes point to the correct random.\\n    curr = head\\n    for curr != nil {\\n        curr = curr.Next\\n        if curr.Random != nil {\\n            curr.Random = curr.Random.Next\\n        }\\n        curr = curr.Next\\n    }\\n    \\n    // Extract the duplicated nodes and recover the original list.\\n    dummy := &Node{}\\n    curr2 := dummy\\n    curr = head\\n    for curr != nil {\\n        n := curr.Next\\n        curr.Next = curr.Next.Next\\n        curr = curr.Next\\n        curr2.Next = n\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522507,
                "title": "easy-java-solution",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            map.put(curr, new Node(curr.val));\\n        }\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            Node clonedCurr = map.get(curr);\\n            clonedCurr.next = map.get(curr.next);\\n            clonedCurr.random = map.get(curr.random);\\n        }\\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            map.put(curr, new Node(curr.val));\\n        }\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            Node clonedCurr = map.get(curr);\\n            clonedCurr.next = map.get(curr.next);\\n            clonedCurr.random = map.get(curr.random);\\n        }\\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306481,
                "title": "js-map-solution-o-n",
                "content": "We use map to solve this problem. In the first while loop, we create a new map, the key is the object itself, the value is the copy of the object node. In the second loop, we set:\\n* map.get(tmp).next = map.get(tmp.next) OR null\\n* map.get(tmp).random = map.get(tmp.random) OR null\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val,next,random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (head == null)\\n        return head\\n    let map = new Map(), tmp = head\\n    while (tmp != null) {\\n        map.set(tmp, new Node(tmp.val, null, null))\\n        tmp = tmp.next\\n    }\\n    tmp = head\\n    while (tmp != null) {\\n        map.get(tmp).next = tmp.next == null? null: map.get(tmp.next)\\n        map.get(tmp).random = tmp.random == null? null: map.get(tmp.random)\\n        tmp = tmp.next\\n    }\\n    return map.get(head)\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,next,random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (head == null)\\n        return head\\n    let map = new Map(), tmp = head\\n    while (tmp != null) {\\n        map.set(tmp, new Node(tmp.val, null, null))\\n        tmp = tmp.next\\n    }\\n    tmp = head\\n    while (tmp != null) {\\n        map.get(tmp).next = tmp.next == null? null: map.get(tmp.next)\\n        map.get(tmp).random = tmp.random == null? null: map.get(tmp.random)\\n        tmp = tmp.next\\n    }\\n    return map.get(head)\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43520,
                "title": "javascript-o-n-solution-using-es6-map",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    const dummy = new RandomListNode();\\n    const map = new Map();\\n    \\n    let src = head;\\n    let dest = dummy;\\n    while (src && !map.has(src)) {\\n        dest.next = new RandomListNode(src.label);\\n        map.set(src, dest.next);\\n        src = src.next;\\n        dest = dest.next;\\n    }\\n    \\n    for (let [src, dest] of map) {\\n        dest.random = map.get(src.random) || null;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\n`Map` allows us to key by node reference. This should also work for lists that cycle.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    const dummy = new RandomListNode();\\n    const map = new Map();\\n    \\n    let src = head;\\n    let dest = dummy;\\n    while (src && !map.has(src)) {\\n        dest.next = new RandomListNode(src.label);\\n        map.set(src, dest.next);\\n        src = src.next;\\n        dest = dest.next;\\n    }\\n    \\n    for (let [src, dest] of map) {\\n        dest.random = map.get(src.random) || null;\\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43682,
                "title": "easy-to-understand-and-fast-o-n-solution-memory-complexity-o-n",
                "content": "The idea is to copy the main list first, keep map of oldPrt-newPrt and then go through again and duplicate random pointers. please see the code and feel free to ask any questions\\n\\n    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * struct RandomListNode {\\n     *     int label;\\n     *     RandomListNode *next, *random;\\n     *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head)\\n        {\\n            // copy the main list first and remember to keep map of original item addresses to the new addresses\\n            map<RandomListNode*, RandomListNode*> oldNewPtrs;\\n            \\n            // pointers for new list\\n            RandomListNode *newHead = NULL;\\n            RandomListNode *newTail = NULL;\\n            \\n            // just an iterator through the original list\\n            RandomListNode *curr = head;\\n            while (curr != NULL)\\n            {\\n                RandomListNode *newItem = new RandomListNode(curr->label);\\n                oldNewPtrs[curr] = newItem;\\n                \\n                // add new item into new list\\n                if (newHead == NULL)\\n                {\\n                    newHead = newItem;\\n                    newTail = newItem;\\n                }\\n                else\\n                {\\n                    newTail->next = newItem;\\n                    newTail = newItem;\\n                }\\n                \\n                curr = curr->next;\\n            }\\n            \\n            // at this point we copied only next pointers.\\n            // here we go through the original list and copy random pointers\\n            curr = head;\\n            while (curr != NULL)\\n            {\\n                // old item points to random old point. we need to have newItem points to new item\\n                // curr - old item\\n                // oldNewPtrs[curr] - new item - copy of old item\\n                if (curr->random != NULL)\\n                    oldNewPtrs[curr]->random = oldNewPtrs[curr->random];\\n                \\n                curr = curr->next;\\n            }\\n            \\n            return newHead;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head)\\n        {\\n            // copy the main list first and remember to keep map of original item addresses to the new addresses\\n            map<RandomListNode*, RandomListNode*> oldNewPtrs;\\n            \\n            // pointers for new list\\n            RandomListNode *newHead = NULL;\\n            RandomListNode *newTail = NULL;\\n            \\n            // just an iterator through the original list\\n            RandomListNode *curr = head;\\n            while (curr != NULL)\\n            {\\n                RandomListNode *newItem = new RandomListNode(curr->label);\\n                oldNewPtrs[curr] = newItem;\\n                \\n                // add new item into new list\\n                if (newHead == NULL)\\n                {\\n                    newHead = newItem;\\n                    newTail = newItem;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 43495,
                "title": "clean-c-o-1-space-solution-the-idea-is-the-same-as-others-but-it-s-clean-and-pure",
                "content": "    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *node = head, *nextNode;\\n        while (node) {\\n            nextNode = node->next;\\n            node->next = new RandomListNode(node->label);\\n            node->next->next = nextNode;\\n            node = nextNode;\\n        }\\n        node = head;\\n        while (node) {\\n            node->next->random = node->random ? node->random->next : nullptr;\\n            node = node->next->next;\\n        }\\n        RandomListNode *psuedoHead = new RandomListNode(0), *copyNode = psuedoHead;\\n        node = head;\\n        while (node) {\\n            copyNode->next = node->next;\\n            copyNode = node->next;\\n            node->next = node->next->next;\\n            node = node->next;\\n        }\\n        return psuedoHead->next;\\n    }",
                "solutionTags": [],
                "code": "    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *node = head, *nextNode;\\n        while (node) {\\n            nextNode = node->next;\\n            node->next = new RandomListNode(node->label);\\n            node->next->next = nextNode;\\n            node = nextNode;\\n        }\\n        node = head;\\n        while (node) {\\n            node->next->random = node->random ? node->random->next : nullptr;\\n            node = node->next->next;\\n        }\\n        RandomListNode *psuedoHead = new RandomListNode(0), *copyNode = psuedoHead;\\n        node = head;\\n        while (node) {\\n            copyNode->next = node->next;\\n            copyNode = node->next;\\n            node->next = node->next->next;\\n            node = node->next;\\n        }\\n        return psuedoHead->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4004383,
                "title": "java-100-time-0ms-using-hash-table",
                "content": "# Problem Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a linked list of length `n` where each node contains an additional **random** pointer that can point to any node in the list (or be null), the **task** is to create a deep copy of this linked list. The copy should consist of `n` new nodes, each with the same value as its original counterpart. Both the **next** and **random** pointers of the new nodes should point to new nodes in the copied list, mirroring the relationships in the original list. **None of the pointers** in the new list should reference nodes in the original list.\\n\\nReturn the `head of the copied` linked list, and you will be given the head of the original linked list as input.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the original list is empty; if so, return null.\\n- Initialize a copied list head `originalCopy` with the value from the original head node.\\n- Initialize another variable refrencing to `originalCopy` name it `copiedHead` and use it for traversal.\\n- Create a mapping between original and copied nodes using a HashMap.\\n- Traverse the original list and copy each node to the copied list while updating the HashMap.\\n- Reset pointers to the heads of both lists.\\n- Iterate through the original list to set the random pointers in the copied list using the HashMap.\\n- Return the head of the copied list `originalCopy`.\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe can say, it is `2*N` since we are iterating over the whole linked list twice. So, it is `O(N)`\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt is `O(N)` since we are using Hashmap (Hash table) \\n\\n# Code\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        // Check if the original list is empty\\n        if (head == null)\\n            return null;\\n        \\n        // Initialize the copied list with the value from the original head\\n        Node originalCopy = new Node(head.val);\\n        Node copiedHead = originalCopy;\\n        Node current = head;\\n        \\n        // Create a mapping between nodes in the original list and their copies\\n        HashMap<Node, Node> referenceMap = new HashMap<>();\\n        referenceMap.put(current, copiedHead);\\n        current = current.next;\\n\\n        // Copy the rest of the nodes in the list\\n        while (current != null) {\\n            copiedHead.next = new Node(current.val);\\n            referenceMap.put(current, copiedHead.next);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Reset pointers for traversing both original and copied lists\\n        current = head;\\n        copiedHead = originalCopy;\\n\\n        // Populate the \\'random\\' pointers in the copied list using the mapping\\n        while (current != null) {\\n            copiedHead.random = referenceMap.get(current.random);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Return the head of the copied list\\n        return originalCopy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        // Check if the original list is empty\\n        if (head == null)\\n            return null;\\n        \\n        // Initialize the copied list with the value from the original head\\n        Node originalCopy = new Node(head.val);\\n        Node copiedHead = originalCopy;\\n        Node current = head;\\n        \\n        // Create a mapping between nodes in the original list and their copies\\n        HashMap<Node, Node> referenceMap = new HashMap<>();\\n        referenceMap.put(current, copiedHead);\\n        current = current.next;\\n\\n        // Copy the rest of the nodes in the list\\n        while (current != null) {\\n            copiedHead.next = new Node(current.val);\\n            referenceMap.put(current, copiedHead.next);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Reset pointers for traversing both original and copied lists\\n        current = head;\\n        copiedHead = originalCopy;\\n\\n        // Populate the \\'random\\' pointers in the copied list using the mapping\\n        while (current != null) {\\n            copiedHead.random = referenceMap.get(current.random);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Return the head of the copied list\\n        return originalCopy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004022,
                "title": "c-recursion-iteration-with-hash-table-for-linked-list-beats-96-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolving such problems, I prefer to use recursion. The reason for that is just much shorter code!\\n\\nThis code efficiently clones a linked list with random pointers by using memoization to avoid duplicate work. The recursive version is short and not slow, while the iterative solution requires 2 or 3 times traversals depending on the ways of implementation.\\n\\n1st approach uses unordered_map as hash table which has linear time complexity $O(n)$; but in the reality, it is slow(Runtime 11 ms Beats 29%). 2nd approach using map instead of unordered_map has TC $O(n\\\\log n)$(Runtime 3 ms Beats 96.91%). Maybe the implementation of unordered_map in GCC is not expected efficient as one wants.\\n\\nYou can clone the Linked list. Using the same technique, you can also solve [Leetcode 133. Clone Graph\\n](https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s how the copyRandomList method works:\\n\\n1.If head is NULL, it returns NULL, which is the base case for the recursion.\\n\\n2.If the head node has already been cloned and exists in the mp map, it returns the cloned node to avoid duplicating nodes.\\n\\n3.Otherwise, it creates a new node (newNode) with the same value as the original node and stores this mapping in the mp map.\\n\\n4.It recursively calls copyRandomList on the next and random pointers of the head node to clone the linked list.\\n\\n5.Finally, it returns the cloned newNode.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\\\to O(n \\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n$O(n)$\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp; // An unordered map to store the mapping between original and cloned nodes.\\n\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL; // Base case: if the input list is empty, return NULL.\\n\\n        if (mp.count(head) != 0) return mp[head]; // If the node has already been cloned, return the cloned node.\\n\\n        Node* newNode = new Node(head->val); // Create a new node with the same value as the original node.\\n        mp[head] = newNode; // Store the mapping between the original and cloned nodes.\\n        \\n        // Recursively clone the next and random pointers.\\n        newNode->next = copyRandomList(head->next);\\n        newNode->random = copyRandomList(head->random);\\n        \\n        return newNode; // Return the cloned node.\\n    }\\n};\\n```\\n\\n# 2nd approach using map instead of unordered_map||Runtime 3 ms Beats 96.91%\\n\\n```\\nclass Solution {\\npublic:\\n    map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\\n# Code for iterative Version using map\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        map<Node*, Node*> mp; \\n// First traversal: create cloned nodes \\n        Node* ptr = head;\\n        while (ptr) {\\n            mp[ptr] = new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n\\n//2nd traversal: assign random pointers for cloned nodes\\n        ptr = head;\\n        while (ptr) {\\n            mp[ptr]->next = mp[ptr->next];\\n            mp[ptr]->random = mp[ptr->random];\\n            ptr = ptr->next;\\n        }\\n\\n        return mp[head];\\n    }\\n};\\n```\\n# 2nd iterative Version\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        unordered_map<Node*, int> nIdx; \\n        vector<Node*> node;\\n        \\n        // First traversal: create cloned nodes \\n        Node* ptr = head;\\n        int i = 0;\\n\\n        // Initialize node vector and nIdx map\\n        while (ptr) {\\n            node.push_back(new Node(ptr->val));\\n            nIdx[ptr] = i;\\n            ptr = ptr->next;\\n            i++;\\n        }\\n\\n        // Reset ptr to head and start the second traversal using a for loop\\n        ptr = head;\\n        for (i = 0; ptr; i++,  ptr = ptr->next) {\\n            if (ptr->next) {\\n                node[i]->next = node[i + 1];\\n            }\\n            if (ptr->random) {\\n                node[i]->random = node[nIdx[ptr->random]];\\n            }\\n        }\\n\\n        return node[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp; // An unordered map to store the mapping between original and cloned nodes.\\n\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL; // Base case: if the input list is empty, return NULL.\\n\\n        if (mp.count(head) != 0) return mp[head]; // If the node has already been cloned, return the cloned node.\\n\\n        Node* newNode = new Node(head->val); // Create a new node with the same value as the original node.\\n        mp[head] = newNode; // Store the mapping between the original and cloned nodes.\\n        \\n        // Recursively clone the next and random pointers.\\n        newNode->next = copyRandomList(head->next);\\n        newNode->random = copyRandomList(head->random);\\n        \\n        return newNode; // Return the cloned node.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        map<Node*, Node*> mp; \\n// First traversal: create cloned nodes \\n        Node* ptr = head;\\n        while (ptr) {\\n            mp[ptr] = new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n\\n//2nd traversal: assign random pointers for cloned nodes\\n        ptr = head;\\n        while (ptr) {\\n            mp[ptr]->next = mp[ptr->next];\\n            mp[ptr]->random = mp[ptr->random];\\n            ptr = ptr->next;\\n        }\\n\\n        return mp[head];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        unordered_map<Node*, int> nIdx; \\n        vector<Node*> node;\\n        \\n        // First traversal: create cloned nodes \\n        Node* ptr = head;\\n        int i = 0;\\n\\n        // Initialize node vector and nIdx map\\n        while (ptr) {\\n            node.push_back(new Node(ptr->val));\\n            nIdx[ptr] = i;\\n            ptr = ptr->next;\\n            i++;\\n        }\\n\\n        // Reset ptr to head and start the second traversal using a for loop\\n        ptr = head;\\n        for (i = 0; ptr; i++,  ptr = ptr->next) {\\n            if (ptr->next) {\\n                node[i]->next = node[i + 1];\\n            }\\n            if (ptr->random) {\\n                node[i]->random = node[nIdx[ptr->random]];\\n            }\\n        }\\n\\n        return node[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003803,
                "title": "python3-solution",
                "content": "\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        old_to_copy={None:None}\\n        cur=head\\n        while cur:\\n            copy=Node(cur.val)\\n            old_to_copy[cur]=copy\\n            cur=cur.next\\n\\n        cur=head\\n        while cur:\\n            copy=old_to_copy[cur]\\n            copy.next=old_to_copy[cur.next]\\n            copy.random=old_to_copy[cur.random]\\n            cur=cur.next\\n\\n        return old_to_copy[head]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        old_to_copy={None:None}\\n        cur=head\\n        while cur:\\n            copy=Node(cur.val)\\n            old_to_copy[cur]=copy\\n            cur=cur.next\\n\\n        cur=head\\n        while cur:\\n            copy=old_to_copy[cur]\\n            copy.next=old_to_copy[cur.next]\\n            copy.random=old_to_copy[cur.random]\\n            cur=cur.next\\n\\n        return old_to_copy[head]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003277,
                "title": "99-00-beats-c-easy-to-understand-c-java-python-javascript-beginner",
                "content": "# Intuition\\n- The goal of this problem is to create a deep copy of a linked list with random pointers. \\n- To do this, we can iterate through the original linked list and create a new node for each node in the original list. \\n- We\\'ll also maintain a mapping between the nodes in the original list and their corresponding nodes in the new list. \\n- This mapping will be useful when setting the random pointers of the new nodes.\\n\\n# Approach\\n1. Handle edge case: If the input linked list `head` is `NULL`, return `NULL` since there\\'s nothing to copy.\\n\\n1. Initialize a new dummy node `newhead` to simplify the construction of the new linked list. This dummy node won\\'t be part of the final result.\\n\\n1. Initialize pointers `new_curr` and `curr` to traverse the new and original linked lists, respectively.\\n\\n1. Create an unordered map (`umap`) to store the mapping between nodes in the original list and their corresponding nodes in the new list.\\n\\n1. First Pass:\\n\\n   -   Iterate through the original linked list (`head`).\\n   - For each node in the original list, create a new node with the same value and insert it into `umap` to establish a mapping.\\n   - Connect the new node to the `new_curr` pointer.\\n   - Move both `new_curr` and `curr` to the next nodes in their respective lists.\\n1. Reset `curr` to the beginning of the original list and `new_curr` to the beginning of the new list.\\n\\n1. Second Pass:\\n\\n   - Iterate through the original linked list again.\\n   - For each node in the original list, get the corresponding random pointer\\'s node from `umap` and assign it as the random pointer for the new node.\\n   - Move both `new_curr` and `curr` to the next nodes in their respective lists.\\n   - Finally, return the `next` pointer of `newhead`, which will be the head of the newly created linked list.\\n\\n# Complexity\\n- Time complexity:\\n- This solution iterates through the original linked list twice, so the time complexity is `O(N)`, where N is the number of nodes in the linked list.\\n- Space complexity:\\n- The space complexity is `O(N)` because we use additional space to store the mapping of nodes from the original list to the new list in the unordered map (`umap`).\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if( head == NULL) return head;\\n        Node* newhead = new Node(0);\\n        Node* new_curr = newhead;\\n        Node* curr = head;\\n        unordered_map<Node*, Node*> umap;\\n        \\n        while(curr){\\n            Node* temp = new Node(curr->val);\\n            umap.insert({curr, temp});\\n            \\n            new_curr->next = temp;\\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        curr = head;\\n        new_curr = newhead->next;\\n        \\n        while(curr){\\n            Node* random = curr->random;\\n            Node* newNode = umap[random];\\n            new_curr->random = newNode;\\n            \\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        \\n        return newhead->next;\\n    }\\n};\\n```\\n**#JAVA**\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node newHead = new Node(0);\\n        Node newCurr = newHead;\\n        Node curr = head;\\n        Map<Node, Node> umap = new HashMap<>();\\n\\n        while (curr != null) {\\n            Node temp = new Node(curr.val);\\n            umap.put(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr != null) {\\n            Node random = curr.random;\\n            Node newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\\n**#PYTHON**\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        new_head = Node(0)\\n        new_curr = new_head\\n        curr = head\\n        umap = {}\\n\\n        while curr:\\n            temp = Node(curr.val)\\n            umap[curr] = temp\\n\\n            new_curr.next = temp\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        curr = head\\n        new_curr = new_head.next\\n\\n        while curr:\\n            random = curr.random\\n            new_node = umap.get(random)\\n            new_curr.random = new_node\\n\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        return new_head.next\\n\\n```\\n**#JAVSCRIPT**\\n```\\nclass Node {\\n    constructor(val, next, random) {\\n        this.val = val;\\n        this.next = next || null;\\n        this.random = random || null;\\n    }\\n}\\n\\nclass Solution {\\n    copyRandomList(head) {\\n        if (!head) {\\n            return null;\\n        }\\n\\n        const newHead = new Node(0);\\n        let newCurr = newHead;\\n        let curr = head;\\n        const umap = new Map();\\n\\n        while (curr) {\\n            const temp = new Node(curr.val);\\n            umap.set(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr) {\\n            const random = curr.random;\\n            const newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if( head == NULL) return head;\\n        Node* newhead = new Node(0);\\n        Node* new_curr = newhead;\\n        Node* curr = head;\\n        unordered_map<Node*, Node*> umap;\\n        \\n        while(curr){\\n            Node* temp = new Node(curr->val);\\n            umap.insert({curr, temp});\\n            \\n            new_curr->next = temp;\\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        curr = head;\\n        new_curr = newhead->next;\\n        \\n        while(curr){\\n            Node* random = curr->random;\\n            Node* newNode = umap[random];\\n            new_curr->random = newNode;\\n            \\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        \\n        return newhead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node newHead = new Node(0);\\n        Node newCurr = newHead;\\n        Node curr = head;\\n        Map<Node, Node> umap = new HashMap<>();\\n\\n        while (curr != null) {\\n            Node temp = new Node(curr.val);\\n            umap.put(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr != null) {\\n            Node random = curr.random;\\n            Node newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        new_head = Node(0)\\n        new_curr = new_head\\n        curr = head\\n        umap = {}\\n\\n        while curr:\\n            temp = Node(curr.val)\\n            umap[curr] = temp\\n\\n            new_curr.next = temp\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        curr = head\\n        new_curr = new_head.next\\n\\n        while curr:\\n            random = curr.random\\n            new_node = umap.get(random)\\n            new_curr.random = new_node\\n\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        return new_head.next\\n\\n```\n```\\nclass Node {\\n    constructor(val, next, random) {\\n        this.val = val;\\n        this.next = next || null;\\n        this.random = random || null;\\n    }\\n}\\n\\nclass Solution {\\n    copyRandomList(head) {\\n        if (!head) {\\n            return null;\\n        }\\n\\n        const newHead = new Node(0);\\n        let newCurr = newHead;\\n        let curr = head;\\n        const umap = new Map();\\n\\n        while (curr) {\\n            const temp = new Node(curr.val);\\n            umap.set(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr) {\\n            const random = curr.random;\\n            const newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726546,
                "title": "3-passes-o-n-python",
                "content": "# Approach\\n- In the first pass, create copy nodes for each node in the linked list\\n- In the 2nd pass, update the random pointers of each copy node\\n- In the 3rd pass, update the next pointers of the copy nodes, and eliminate the original nodes\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n\\n        temp = head\\n        while(temp):\\n            node = Node(temp.val)\\n            node.next = temp.next\\n            temp.next = node\\n            temp = node.next\\n\\n        temp = head\\n        while(temp):\\n            if not temp.random:\\n                temp.next.random = None\\n            else:\\n                temp.next.random = temp.random.next\\n            temp = temp.next.next\\n\\n        temp = head.next\\n        while(temp.next):\\n            print(temp.val)\\n            temp.next = temp.next.next\\n            temp = temp.next\\n\\n        return head.next\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n\\n        temp = head\\n        while(temp):\\n            node = Node(temp.val)\\n            node.next = temp.next\\n            temp.next = node\\n            temp = node.next\\n\\n        temp = head\\n        while(temp):\\n            if not temp.random:\\n                temp.next.random = None\\n            else:\\n                temp.next.random = temp.random.next\\n            temp = temp.next.next\\n\\n        temp = head.next\\n        while(temp.next):\\n            print(temp.val)\\n            temp.next = temp.next.next\\n            temp = temp.next\\n\\n        return head.next\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582492,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        while (temp != NULL) {\\n            Node* newNode = new Node(temp->val);\\n            newNode->next = temp->next;\\n            temp->next = newNode;\\n            temp = temp->next->next;\\n        }\\n        temp = head;\\n        while (temp != NULL) {\\n            if (temp->random != NULL) {\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n        Node* dummy = new Node(0);\\n        Node* itr = dummy;\\n        Node* fast;\\n        temp = head;\\n        while (temp != NULL) {\\n            fast = temp->next->next;\\n            itr->next = temp->next;\\n            itr = itr->next;\\n            temp->next = fast;\\n            temp = fast;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        while (temp != NULL) {\\n            Node* newNode = new Node(temp->val);\\n            newNode->next = temp->next;\\n            temp->next = newNode;\\n            temp = temp->next->next;\\n        }\\n        temp = head;\\n        while (temp != NULL) {\\n            if (temp->random != NULL) {\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n        Node* dummy = new Node(0);\\n        Node* itr = dummy;\\n        Node* fast;\\n        temp = head;\\n        while (temp != NULL) {\\n            fast = temp->next->next;\\n            itr->next = temp->next;\\n            itr = itr->next;\\n            temp->next = fast;\\n            temp = fast;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891888,
                "title": "java-2-solutions-with-without-extra-space",
                "content": "# Please Upvote :D\\n\\n---\\n\\n##### 1. Using extra space (hashmap):\\n\\n![image.png](https://assets.leetcode.com/users/images/d6aec53c-05a3-458d-b045-3513a3e5b51b_1670521786.738047.png)\\n\\n\\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n\\n        node = head;\\n\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n\\n        return map.get(head);\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\\n---\\n\\n##### 2. No extra space:\\n\\n![image.png](https://assets.leetcode.com/users/images/003ffc95-aff9-42ae-a2b0-390fdd5c06ee_1670521842.8753994.png)\\n\\n\\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node curr = head, currNext = head;\\n\\n        // step 1: create copy nodes   \\n        while (curr != null) {\\n            currNext = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = currNext;\\n            curr = currNext;\\n        }\\n\\n        curr = head;\\n\\n        // link the copy nodes\\'s random pointers properly \\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n\\n        Node ans = new Node(-1);\\n        Node copyItr = ans;\\n        curr = head; currNext = head;\\n\\n        // separate the copy nodes and original nodes and restore as lists\\n        while (curr != null) {\\n            currNext = currNext.next.next;\\n            copyItr.next = curr.next;\\n            curr.next = currNext;\\n            curr = curr.next;\\n            copyItr = copyItr.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n\\n        node = head;\\n\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n\\n        return map.get(head);\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node curr = head, currNext = head;\\n\\n        // step 1: create copy nodes   \\n        while (curr != null) {\\n            currNext = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = currNext;\\n            curr = currNext;\\n        }\\n\\n        curr = head;\\n\\n        // link the copy nodes\\'s random pointers properly \\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n\\n        Node ans = new Node(-1);\\n        Node copyItr = ans;\\n        curr = head; currNext = head;\\n\\n        // separate the copy nodes and original nodes and restore as lists\\n        while (curr != null) {\\n            currNext = currNext.next.next;\\n            copyItr.next = curr.next;\\n            curr.next = currNext;\\n            curr = curr.next;\\n            copyItr = copyItr.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258663,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n\\n// Naive Solution :: Time : O(N) + O(N) :: Aux_Space : O(N)\\n\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        unordered_map<Node*,Node*> mp;\\n\\n        Node *temp = head;\\n\\n        while(temp != NULL){\\n\\n            mp[temp] = new Node(temp->val);\\n            temp = temp->next;\\n\\n        }\\n\\n         temp = head;\\n\\n        while(temp != NULL){\\n\\n            Node* listCopy = mp[temp];\\n            listCopy->next = mp[temp->next];\\n            listCopy->random = mp[temp->random];\\n\\n            temp = temp->next;\\n\\n        }\\n        return mp[head];\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) + O(N) + O(N) :: Aux_Space : O(1)\\n\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *temp = head;\\n\\n        // First round: make copy of each node,\\n        // and link them together side-by-side in a single list.\\n\\n        while(temp){\\n\\n            Node *curr = new Node(temp->val);\\n            curr->next = temp->next;\\n            temp->next = curr;\\n\\n            temp = temp->next->next;\\n\\n        }\\n\\n         // Second round: assign random pointers for the copy nodes.\\n\\n        temp = head;\\n\\n        while(temp){\\n\\n            if(temp->random != NULL)\\n                temp->next->random = temp->random->next;\\n\\n            temp = temp->next->next;\\n\\n        }\\n\\n         // Third round: restore the original list, and extract the copy list.\\n\\n        Node *dummy = new Node(0);\\n        Node *copy = dummy;\\n\\n        temp = head;\\n        Node *front;\\n\\n        while(temp){\\n\\n            front = temp->next->next;\\n\\n            copy->next = temp->next;\\n            temp->next = front;\\n\\n            temp = temp->next;\\n            copy = copy->next;\\n        }\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        unordered_map<Node*,Node*> mp;\\n\\n        Node *temp = head;\\n\\n        while(temp != NULL){\\n\\n            mp[temp] = new Node(temp->val);\\n            temp = temp->next;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2126191,
                "title": "c-without-any-hashing-or-saving-the-nodes-optimal",
                "content": "\\t Node* copyRandomList(Node* head) {\\n        \\n        if(!head) return NULL;\\n        \\n\\t//         Node* temp1 = head;\\n\\t//         Node* newhead = new Node(temp1->val);\\n\\t//         Node* temp = newhead;\\n\\t//         temp1 = temp1->next;\\n\\t//         unordered_map<Node*,Node*> map;\\n\\t//         map[head] = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->next = new Node(temp1->val);\\n\\t//             map[temp1] = temp->next;\\n\\t//             temp = temp->next;\\n\\t//             temp1 = temp1->next;\\n\\t//         }\\n\\n\\t//         temp1 = head;\\n\\t//         temp = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->random = map[temp1->random];\\n\\t//             temp1 = temp1->next;\\n\\t//             temp = temp->next;\\n\\t//         }\\n\\n\\t//         return newhead;\\n        \\n        Node* curr = head;\\n        Node* nxt = head->next;\\n        Node* dummy = new Node(-1);\\n        Node* temp = dummy;\\n        while(curr)\\n        {\\n            Node* newnode = new Node(curr->val);\\n            temp->next = curr;\\n            curr->next = newnode;\\n            temp = newnode;\\n            curr = nxt;\\n            if(nxt) nxt = nxt->next;\\n        }\\n    \\n        curr = head;\\n        dummy->next = dummy->next->next;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            temp->random = NULL;\\n            if(curr->random) temp->random = curr->random->next;\\n            curr = temp->next;\\n            if(curr) temp = curr->next;\\n        }\\n        \\n        curr = head;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            curr->next = temp->next;\\n            if(temp->next)  temp->next = temp->next->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        return dummy->next;  \\n    }\\n\\t\\nCommented code is using hashmap to solve this problem and the uncommented is the optimal approach without using space to save original nodes.\\nFirst loop is used to modify the linked list.\\nSecond loop is used to setup the random pointers.\\nThird loop is used to remodify the linked list to its original form.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "\\t Node* copyRandomList(Node* head) {\\n        \\n        if(!head) return NULL;\\n        \\n\\t//         Node* temp1 = head;\\n\\t//         Node* newhead = new Node(temp1->val);\\n\\t//         Node* temp = newhead;\\n\\t//         temp1 = temp1->next;\\n\\t//         unordered_map<Node*,Node*> map;\\n\\t//         map[head] = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->next = new Node(temp1->val);\\n\\t//             map[temp1] = temp->next;\\n\\t//             temp = temp->next;\\n\\t//             temp1 = temp1->next;\\n\\t//         }\\n\\n\\t//         temp1 = head;\\n\\t//         temp = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->random = map[temp1->random];\\n\\t//             temp1 = temp1->next;\\n\\t//             temp = temp->next;\\n\\t//         }\\n\\n\\t//         return newhead;\\n        \\n        Node* curr = head;\\n        Node* nxt = head->next;\\n        Node* dummy = new Node(-1);\\n        Node* temp = dummy;\\n        while(curr)\\n        {\\n            Node* newnode = new Node(curr->val);\\n            temp->next = curr;\\n            curr->next = newnode;\\n            temp = newnode;\\n            curr = nxt;\\n            if(nxt) nxt = nxt->next;\\n        }\\n    \\n        curr = head;\\n        dummy->next = dummy->next->next;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            temp->random = NULL;\\n            if(curr->random) temp->random = curr->random->next;\\n            curr = temp->next;\\n            if(curr) temp = curr->next;\\n        }\\n        \\n        curr = head;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            curr->next = temp->next;\\n            if(temp->next)  temp->next = temp->next->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        return dummy->next;  \\n    }\\n\\t\\nCommented code is using hashmap to solve this problem and the uncommented is the optimal approach without using space to save original nodes.\\nFirst loop is used to modify the linked list.\\nSecond loop is used to setup the random pointers.\\nThird loop is used to remodify the linked list to its original form.",
                "codeTag": "Unknown"
            },
            {
                "id": 1842903,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Next *Node\\n *     Random *Node\\n * }\\n */\\n\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tmp, node := make(map[*Node]*Node), head\\n\\t// loop 1. copy all the nodes\\n\\tfor node != nil {\\n\\t\\tmp[node] = &Node{Val: node.Val}\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\tnode = head\\n\\t// loop 2. assign next and random pointers\\n\\tfor node != nil {\\n\\t\\tmp[node].Next = mp[node.Next]\\n\\t\\tmp[node].Random = mp[node.Random]\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\treturn mp[head]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Next *Node\\n *     Random *Node\\n * }\\n */\\n\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tmp, node := make(map[*Node]*Node), head\\n\\t// loop 1. copy all the nodes\\n\\tfor node != nil {\\n\\t\\tmp[node] = &Node{Val: node.Val}\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\tnode = head\\n\\t// loop 2. assign next and random pointers\\n\\tfor node != nil {\\n\\t\\tmp[node].Next = mp[node.Next]\\n\\t\\tmp[node].Random = mp[node.Random]\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\treturn mp[head]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841446,
                "title": "c-iterative-2-pass-o-n",
                "content": "**APPROACH**\\n```\\n1. Make deep copy of each node and only assign next as of now\\n2. store each node and its shallow copy\\n3. Traverse new list and assign random node\\n```\\n\\nTC - O(n)\\n\\n**CODE**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * temp = head;\\n        Node * nhead = NULL;\\n        Node * ntail = NULL;\\n        unordered_map<Node * , Node *> m;\\n        m[NULL] = NULL;\\n        while(temp != NULL){\\n            if(nhead == NULL){\\n                nhead = new Node(temp->val);\\n                ntail = nhead;\\n            }\\n            else{\\n                ntail->next = new Node(temp->val);\\n                ntail = ntail->next;\\n            }\\n            m[temp] = ntail;\\n            temp = temp->next;\\n        }\\n        \\n        \\n        temp = nhead;\\n        while(temp != NULL){\\n            temp->random = m[head->random];\\n            head = head->next;\\n            temp = temp->next;\\n        }\\n        return nhead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n1. Make deep copy of each node and only assign next as of now\\n2. store each node and its shallow copy\\n3. Traverse new list and assign random node\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * temp = head;\\n        Node * nhead = NULL;\\n        Node * ntail = NULL;\\n        unordered_map<Node * , Node *> m;\\n        m[NULL] = NULL;\\n        while(temp != NULL){\\n            if(nhead == NULL){\\n                nhead = new Node(temp->val);\\n                ntail = nhead;\\n            }\\n            else{\\n                ntail->next = new Node(temp->val);\\n                ntail = ntail->next;\\n            }\\n            m[temp] = ntail;\\n            temp = temp->next;\\n        }\\n        \\n        \\n        temp = nhead;\\n        while(temp != NULL){\\n            temp->random = m[head->random];\\n            head = head->next;\\n            temp = temp->next;\\n        }\\n        return nhead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739675,
                "title": "solution-swift-copy-list-with-random-pointer",
                "content": "```swift\\nclass Solution {\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        if head == nil { return nil }\\n        \\n        var node = head, idx = 0\\n        \\n        while let nod = node {\\n            nod.val = (nod.val + 10000) | (idx << 32)\\n            node = nod.next\\n            idx += 1\\n        }\\n        \\n        var nodes: [Node?] = []\\n        node = head\\n        \\n        while let nod = node {\\n            let new = Node((nod.val & Int(UInt32.max)) - 10000)\\n            if !nodes.isEmpty { nodes[nodes.count - 1]?.next = new }\\n            nodes.append(new)\\n            node = nod.next\\n        }\\n        \\n        node = head\\n        idx = 0\\n        \\n        while let nod = node {\\n            if let rand = nod.random {\\n                nodes[idx]?.random = nodes[rand.val >> 32]\\n            }\\n            node = node?.next\\n            idx += 1\\n        }\\n        return nodes[0]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>Node</b></summary>\\n\\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var next: Node?\\n    public var random: Node?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.next = nil\\n        self.random = nil\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        if head == nil { return nil }\\n        \\n        var node = head, idx = 0\\n        \\n        while let nod = node {\\n            nod.val = (nod.val + 10000) | (idx << 32)\\n            node = nod.next\\n            idx += 1\\n        }\\n        \\n        var nodes: [Node?] = []\\n        node = head\\n        \\n        while let nod = node {\\n            let new = Node((nod.val & Int(UInt32.max)) - 10000)\\n            if !nodes.isEmpty { nodes[nodes.count - 1]?.next = new }\\n            nodes.append(new)\\n            node = nod.next\\n        }\\n        \\n        node = head\\n        idx = 0\\n        \\n        while let nod = node {\\n            if let rand = nod.random {\\n                nodes[idx]?.random = nodes[rand.val >> 32]\\n            }\\n            node = node?.next\\n            idx += 1\\n        }\\n        return nodes[0]\\n    }\\n}\\n```\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var next: Node?\\n    public var random: Node?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.next = nil\\n        self.random = nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680280,
                "title": "simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> ump;\\n        Node* curr = head;\\n        while(curr!=NULL){\\n            Node* copy = new Node(curr->val);\\n            ump[curr] = copy;\\n            curr=curr->next;\\n        }\\n        curr = head;\\n        while(curr!=NULL){\\n            ump[curr]->next= ump[curr->next];\\n            ump[curr]->random = ump[curr->random];\\n            curr=curr->next;\\n        }\\n        return ump[head];\\n    }\\n};\\n```\\n*If you like it pls upvote my answer*",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> ump;\\n        Node* curr = head;\\n        while(curr!=NULL){\\n            Node* copy = new Node(curr->val);\\n            ump[curr] = copy;\\n            curr=curr->next;\\n        }\\n        curr = head;\\n        while(curr!=NULL){\\n            ump[curr]->next= ump[curr->next];\\n            ump[curr]->random = ump[curr->random];\\n            curr=curr->next;\\n        }\\n        return ump[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523760,
                "title": "easy-to-understand-7-8-line-code-in-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    Node* copyRandomList(Node* head) {\\n        map<Node*,Node*> mp;\\n        \\n        Node* var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var] = new Node(var->val);\\n            var=var->next;\\n            \\n        }\\n        \\n        var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var]->next= mp[var->next]; \\n            \\n       \\n            mp[var]->random=mp[var->random];\\n            \\n            var=var->next;\\n        }\\n        \\n        return mp[head];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    Node* copyRandomList(Node* head) {\\n        map<Node*,Node*> mp;\\n        \\n        Node* var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var] = new Node(var->val);\\n            var=var->next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1124767,
                "title": "this-is-the-way-python",
                "content": "Logic:\\nWe need links between old and new list for assigning the `random` nodes.\\n\\n1. For each node `p1` of old linked list: create a new node `q1` such that:\\n\\t`p1.cloned_to = q1`\\n2. For each node `p1` in old list, assign `next` and `random` to `q1`:\\n\\t`q1.next = p1.next.cloned_to`\\n    `q1.random = p1.random.cloned_to`\\n\\t\\n```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        \\n        if not head: return \\n        \\n        p1 = head\\n\\t\\t\\n        while p1:\\n            q1 = Node(p1.val)\\n            p1.cloned_to = q1\\n            p1 = p1.next\\n        \\n        p1 = head\\n\\n        while p1:\\n            q1 = p1.cloned_to\\n            q1.next = p1.next.cloned_to if p1.next else None\\n            q1.random = p1.random.cloned_to if p1.random else None\\n            p1 = p1.next\\n            \\n        return head.cloned_to\\n   ```         \\n   \\n  Time: `O(N)`, Space: `O(1)`\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        \\n        if not head: return \\n        \\n        p1 = head\\n\\t\\t\\n        while p1:\\n            q1 = Node(p1.val)\\n            p1.cloned_to = q1\\n            p1 = p1.next\\n        \\n        p1 = head\\n\\n        while p1:\\n            q1 = p1.cloned_to\\n            q1.next = p1.next.cloned_to if p1.next else None\\n            q1.random = p1.random.cloned_to if p1.random else None\\n            p1 = p1.next\\n            \\n        return head.cloned_to\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1059515,
                "title": "python-faster-than-96-65-cool-easy-understanding-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\t\\t\\thelper = {}\\n\\t\\t\\tdef buildList(head: Node) -> Node:\\n\\t\\t\\t\\tnonlocal helper\\n\\t\\t\\t\\tif not head: return None\\n\\t\\t\\t\\tif helper.get(head): return helper[head]\\n\\t\\t\\t\\thelper[head] = Node( head.val )\\n\\t\\t\\t\\thelper[head].random = buildList(head.random)\\n\\t\\t\\t\\thelper[head].next = buildList(head.next)\\n\\t\\t\\t\\treturn helper[head]\\n\\t\\t\\t\\n\\t\\t\\treturn buildList(head)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "class Solution:\\n\\t\\tdef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\t\\t\\thelper = {}",
                "codeTag": "Java"
            },
            {
                "id": 940030,
                "title": "o-1-space-complexity-and-o-n-time-complexity-solution",
                "content": "*Lets say we have a LinkdeList as*\\n1[13] -> 2[1] -> 13[13] -> 13[2]\\n\\nThe idea here is to do a little trick. We first traverse the list and add the next pointer of the current node to another node having the same value and marking the next of the new pointer to the next of the current pointer and making the next of current pointer to the temp node.\\n\\n*So after the first traversal we get:*\\n1[13] -> 1 ->2[1] -> 2 -> 13[13] -> 13 -> 13[2] -> 13\\n\\n**The next pointer of each node points to a pointer same in value but the random pointer is intact.**\\n\\nNow, as we can see the random pointer is intact, so we can next of current pointer point to the next of the random of current. It is a bit of a tounge twister but what we are basically doing is *1 points to 1 and its random is 13, so the next of 1 will point to the random of 1(i.e. 13) and it\\'s next.*\\n\\nSo we get:\\n1[13] -> 1[13] -> 2[1] -> 2 -> 13[13] -> 13 ->13[2] -> 13\\nSimiliarly we do the above step for 2 pointer. **The next of 2 points to 13 but the random of the next node points to the next of random of the current node.**\\n& that is basically the idea to do it in Constant space and Linear time.\\n\\nI tried to convey the idea to the best of my abilities, if you\\'re still unsure how is it done, don\\'t worry, I didn\\'t get it in the first time either. Take a look at the video and go through the code once.\\nhttps://www.youtube.com/watch?v=xbpUHSKoALg&t=1s\\n\\nHere\\'s the code however\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n\\tdef copyRandomList(self, head):\\n\\n\\t\\t# Insert each node\\'s copy right after it, already copy.val\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tcopy = Node(node.val)\\n\\t\\t\\tcopy.next = node.next\\n\\t\\t\\tnode.next = copy\\n\\t\\t\\tnode = copy.next\\n\\n\\t\\t# Set each copy\\'s.random\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tnode.next.random = node.random and node.random.next\\n\\t\\t\\tnode = node.next.next\\n\\n\\t\\t# Separate the copied list from the original, (re)setting every .next\\n\\t\\tnode = head\\n\\t\\tcopy = head_copy = head and head.next\\n\\t\\twhile node:\\n\\t\\t\\tnode.next = node = copy.next\\n\\t\\t\\tcopy.next = copy = node and node.next\\n\\n\\t\\treturn head_copy\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n\\tdef copyRandomList(self, head):\\n\\n\\t\\t# Insert each node\\'s copy right after it, already copy.val\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tcopy = Node(node.val)\\n\\t\\t\\tcopy.next = node.next\\n\\t\\t\\tnode.next = copy\\n\\t\\t\\tnode = copy.next\\n\\n\\t\\t# Set each copy\\'s.random\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tnode.next.random = node.random and node.random.next\\n\\t\\t\\tnode = node.next.next\\n\\n\\t\\t# Separate the copied list from the original, (re)setting every .next\\n\\t\\tnode = head\\n\\t\\tcopy = head_copy = head and head.next\\n\\t\\twhile node:\\n\\t\\t\\tnode.next = node = copy.next\\n\\t\\t\\tcopy.next = copy = node and node.next\\n\\n\\t\\treturn head_copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679840,
                "title": "easy-detailed-explanation-for-o-1-space-o-n-time",
                "content": "First look at this awesome video https://www.youtube.com/watch?v=OvpKeraoxW0 and understand what exactly are the 3 steps from logic point of view. Don\\'t worry about the code.\\n\\nOnce you have seen the video explanation just go through the below code once and it will be crystal clear.\\n\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        //edge case\\n        if(head == null)\\n            return head;\\n        \\n        Node originalHead = head;\\n        \\n        //Step 1: Make copyNode and insert the copyNode between originalNode and its next originalNode.\\n        //In this step Head will be always placed on original nodes.\\n        while(head != null){\\n            Node nextOriginalNode = head.next;\\n            Node copyNode = new Node(head.val);\\n            head.next = copyNode;\\n            copyNode.next = nextOriginalNode;\\n            head = nextOriginalNode;\\n        }\\n        \\n        //Step 2: Make wiring of random references of copyNodes. In this step Head will be always placed on\\n        //original nodes.\\n        head = originalHead;\\n        while(head != null){\\n            //if the head\\'s random is pointing to null, we don\\'t need to do anything. It is there by deafult\\n            if(head.random != null){\\n                //Whatever node is pointed by the original node\\'s random, we assign the next of that node\\n                //to our copyNode\\'s random. This is because the node pointed by the original node\\'s random\\n                //further points to its copyNode. And we need to wire copyNode\\'s random.\\n                \\n                //So head.next gives us the copyNode whose random needs to be wired. Head is at our original\\n                //node. Now if you look at the node pointed by the head.random, you will observe that it is\\n                //also an original node.\\n                \\n                //But we want to wire copyNode with copyNode. So if you look carefully the original node we\\n                //obtained after head.random, is pointing to is copied version via next. And this is what we\\n                //want.\\n                //So head.random.next ==> gives us the target copyNode to be wired.\\n                //And we need to wire it with head.next.random.\\n                //Hence the code will be head.next.random = head.random.next;\\n                head.next.random = head.random.next;\\n                \\n                //Simplified version \\n                //Node copyNode = head.next;\\n                //copyNode.random = head.random.next;\\n            }\\n            head = head.next.next; //Since we want to move on original Nodes only.\\n        }\\n        \\n        //Step 3: Separate original list with the copied list and return copied head\\n        head = originalHead;\\n        Node copyNodeHead = head.next;\\n        Node copyNodePtr = copyNodeHead;\\n        \\n        while(copyNodePtr.next != null){\\n            head.next = head.next.next;\\n            head = head.next;\\n            \\n            copyNodePtr.next = copyNodePtr.next.next;\\n            copyNodePtr = copyNodePtr.next;\\n        }\\n        head.next = copyNodePtr.next; //Important step. Because copyNode\\'s list last node is connected to\\n        //null. Whereas the last node of the original list is connected to the last node of copyNode list.\\n        //To fully separate these two lists we need to connect the original list\\'s last node to null.\\n        //Hence we do head.next = head.next.next which is similar to head.next = copyNodePtr.next\\n        \\n        return copyNodeHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        //edge case\\n        if(head == null)\\n            return head;\\n        \\n        Node originalHead = head;\\n        \\n        //Step 1: Make copyNode and insert the copyNode between originalNode and its next originalNode.\\n        //In this step Head will be always placed on original nodes.\\n        while(head != null){\\n            Node nextOriginalNode = head.next;\\n            Node copyNode = new Node(head.val);\\n            head.next = copyNode;\\n            copyNode.next = nextOriginalNode;\\n            head = nextOriginalNode;\\n        }\\n        \\n        //Step 2: Make wiring of random references of copyNodes. In this step Head will be always placed on\\n        //original nodes.\\n        head = originalHead;\\n        while(head != null){\\n            //if the head\\'s random is pointing to null, we don\\'t need to do anything. It is there by deafult\\n            if(head.random != null){\\n                //Whatever node is pointed by the original node\\'s random, we assign the next of that node\\n                //to our copyNode\\'s random. This is because the node pointed by the original node\\'s random\\n                //further points to its copyNode. And we need to wire copyNode\\'s random.\\n                \\n                //So head.next gives us the copyNode whose random needs to be wired. Head is at our original\\n                //node. Now if you look at the node pointed by the head.random, you will observe that it is\\n                //also an original node.\\n                \\n                //But we want to wire copyNode with copyNode. So if you look carefully the original node we\\n                //obtained after head.random, is pointing to is copied version via next. And this is what we\\n                //want.\\n                //So head.random.next ==> gives us the target copyNode to be wired.\\n                //And we need to wire it with head.next.random.\\n                //Hence the code will be head.next.random = head.random.next;\\n                head.next.random = head.random.next;\\n                \\n                //Simplified version \\n                //Node copyNode = head.next;\\n                //copyNode.random = head.random.next;\\n            }\\n            head = head.next.next; //Since we want to move on original Nodes only.\\n        }\\n        \\n        //Step 3: Separate original list with the copied list and return copied head\\n        head = originalHead;\\n        Node copyNodeHead = head.next;\\n        Node copyNodePtr = copyNodeHead;\\n        \\n        while(copyNodePtr.next != null){\\n            head.next = head.next.next;\\n            head = head.next;\\n            \\n            copyNodePtr.next = copyNodePtr.next.next;\\n            copyNodePtr = copyNodePtr.next;\\n        }\\n        head.next = copyNodePtr.next; //Important step. Because copyNode\\'s list last node is connected to\\n        //null. Whereas the last node of the original list is connected to the last node of copyNode list.\\n        //To fully separate these two lists we need to connect the original list\\'s last node to null.\\n        //Hence we do head.next = head.next.next which is similar to head.next = copyNodePtr.next\\n        \\n        return copyNodeHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669560,
                "title": "javascript-o-1-space-no-hashmap",
                "content": "```javascript\\nvar copyRandomList = function(head) {\\n    \\n    function createNewNodes(node) {\\n        if(!node) return;\\n        const newNode = new Node(node.val);\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        createNewNodes(newNode.next);\\n    }\\n    \\n    function linkRandomNode(node) {\\n        if(!node) return;\\n        node.next.random = node.random ? node.random.next : null;\\n        linkRandomNode(node.next.next);\\n    }\\n    \\n    function restoreOriginal(node) {\\n        if(!node) return null;\\n        const temp = node.next;\\n        node.next = node.next.next;\\n        temp.next = restoreOriginal(node.next)\\n        return temp;\\n    }\\n    \\n    createNewNodes(head);\\n    linkRandomNode(head);\\n    return restoreOriginal(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar copyRandomList = function(head) {\\n    \\n    function createNewNodes(node) {\\n        if(!node) return;\\n        const newNode = new Node(node.val);\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        createNewNodes(newNode.next);\\n    }\\n    \\n    function linkRandomNode(node) {\\n        if(!node) return;\\n        node.next.random = node.random ? node.random.next : null;\\n        linkRandomNode(node.next.next);\\n    }\\n    \\n    function restoreOriginal(node) {\\n        if(!node) return null;\\n        const temp = node.next;\\n        node.next = node.next.next;\\n        temp.next = restoreOriginal(node.next)\\n        return temp;\\n    }\\n    \\n    createNewNodes(head);\\n    linkRandomNode(head);\\n    return restoreOriginal(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 569173,
                "title": "simple-recursive-o-n-o-n-100-faster",
                "content": "```\\n    public Node copyRandomList(Node head) {\\n      HashMap<Node, Node> map = new HashMap<>();\\n      \\n      return cloneMyAssDeeply(head, map);\\n      \\n    }\\n  \\n  private Node cloneMyAssDeeply(Node head, HashMap map){\\n    \\n    if(head == null)\\n      return null;\\n    \\n    Node node = new Node(head.val);\\n    \\n    map.put(head, node);\\n    \\n    node.next = cloneMyAssDeeply(head.next, map);\\n    \\n    node.random = (Node)map.get(head.random);\\n    \\n    return node;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n      HashMap<Node, Node> map = new HashMap<>();\\n      \\n      return cloneMyAssDeeply(head, map);\\n      \\n    }\\n  \\n  private Node cloneMyAssDeeply(Node head, HashMap map){\\n    \\n    if(head == null)\\n      return null;\\n    \\n    Node node = new Node(head.val);\\n    \\n    map.put(head, node);\\n    \\n    node.next = cloneMyAssDeeply(head.next, map);\\n    \\n    node.random = (Node)map.get(head.random);\\n    \\n    return node;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492116,
                "title": "python3-with-comments",
                "content": "```py\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None:\\n            return\\n        \\n\\t\\t# First pass over linked list to create the cloned nodes without connections\\n        node = head\\n\\t\\t# Nodes are objects and in Python all user defined classes are hashable by default\\n\\t\\t# this allows us to map the original Nodes to their clones\\n        clone_map = {}\\n        while node:\\n            clone_map[node] = Node(node.val) # we allow the next and random attributes to default to None\\n            node = node.next\\n        \\n\\t\\t# Second pass over the original linked list, this time creating the connections\\n        node = head\\n        while node:\\n            clone_map[node].next = clone_map.get(node.next)\\n\\t\\t\\t# The \"random\" nodes can be accessed in constant time\\n            clone_map[node].random = clone_map.get(node.random)\\n            node = node.next\\n\\t\\t\\n\\t\\t# now we can return the first cloned node\\n        return clone_map[head]\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None:\\n            return\\n        \\n\\t\\t# First pass over linked list to create the cloned nodes without connections\\n        node = head\\n\\t\\t# Nodes are objects and in Python all user defined classes are hashable by default\\n\\t\\t# this allows us to map the original Nodes to their clones\\n        clone_map = {}\\n        while node:\\n            clone_map[node] = Node(node.val) # we allow the next and random attributes to default to None\\n            node = node.next\\n        \\n\\t\\t# Second pass over the original linked list, this time creating the connections\\n        node = head\\n        while node:\\n            clone_map[node].next = clone_map.get(node.next)\\n\\t\\t\\t# The \"random\" nodes can be accessed in constant time\\n            clone_map[node].random = clone_map.get(node.random)\\n            node = node.next\\n\\t\\t\\n\\t\\t# now we can return the first cloned node\\n        return clone_map[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422333,
                "title": "c-easy-to-understand",
                "content": "``` cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        auto curr = head;\\n        // insert new nodes in between\\n        while(curr){\\n            auto tmp = curr->next;\\n            auto new_node = new Node(curr->val, tmp, nullptr);\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        // assign rand access pointers\\n        curr = head;\\n        while(curr){\\n            curr->next->random = curr->random ? curr->random->next : nullptr;\\n            curr = curr->next->next;\\n        }\\n        // separate the list and reconstruct the original;\\n        auto new_head = head->next;\\n        curr = head;\\n        while(curr){\\n            auto next_node = curr->next;\\n            curr->next = next->next;\\n            curr = curr->next;\\n            next_node->next = curr ? curr->next : nullptr;\\n        }\\n        return new_head;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "``` cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        auto curr = head;\\n        // insert new nodes in between\\n        while(curr){\\n            auto tmp = curr->next;\\n            auto new_node = new Node(curr->val, tmp, nullptr);\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        // assign rand access pointers\\n        curr = head;\\n        while(curr){\\n            curr->next->random = curr->random ? curr->random->next : nullptr;\\n            curr = curr->next->next;\\n        }\\n        // separate the list and reconstruct the original;\\n        auto new_head = head->next;\\n        curr = head;\\n        while(curr){\\n            auto next_node = curr->next;\\n            curr->next = next->next;\\n            curr = curr->next;\\n            next_node->next = curr ? curr->next : nullptr;\\n        }\\n        return new_head;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 326252,
                "title": "python3-simple-print-statement-throws-runtime-error",
                "content": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print(\"test\")\\n```\\n\\nI hit \"Run Code\" and get a runtime error \"\\'NoneType\\' object is not subscriptable.\" Obviously since this doesn\\'t work with just a print statement, I can\\'t even attempt to run code that actually addresses the problem. Am I missing something? The Python 2.x equivalent runs with no issues:\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print \"test\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print(\"test\")\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print \"test\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43578,
                "title": "simple-java-solution-o-1-space-o-n-time-complexity",
                "content": "```\\n public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        RandomListNode cur = head;\\n        RandomListNode next = null;\\n        while(cur != null) { //insert a new node between originals\\n            next = cur.next;\\n            cur.next = new RandomListNode(cur.label);\\n            cur.next.next = next;\\n            cur = next;\\n        }\\n        \\n        RandomListNode copyHead = head.next;\\n        cur = head;\\n        while(cur != null) { //set the random of each newNode\\n            if(cur.random == null) {\\n                cur.next.random = null;\\n            }\\n            else {\\n                cur.next.random = cur.random.next;\\n            }\\n            cur = cur.next.next;\\n        }\\n\\n\\n        cur = head;\\n        RandomListNode curCopy = null;\\n        while(cur != null && cur.next != null) { // set the next of each original and new node\\n            curCopy = cur.next;\\n            cur.next = cur.next.next;\\n            cur = curCopy;\\n        }\\n\\n        return copyHead;\\n    }",
                "solutionTags": [],
                "code": "```\\n public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        RandomListNode cur = head;\\n        RandomListNode next = null;\\n        while(cur != null) { //insert a new node between originals\\n            next = cur.next;\\n            cur.next = new RandomListNode(cur.label);\\n            cur.next.next = next;\\n            cur = next;\\n        }\\n        \\n        RandomListNode copyHead = head.next;\\n        cur = head;\\n        while(cur != null) { //set the random of each newNode\\n            if(cur.random == null) {\\n                cur.next.random = null;\\n            }\\n            else {\\n                cur.next.random = cur.random.next;\\n            }\\n            cur = cur.next.next;\\n        }\\n\\n\\n        cur = head;\\n        RandomListNode curCopy = null;\\n        while(cur != null && cur.next != null) { // set the next of each original and new node\\n            curCopy = cur.next;\\n            cur.next = cur.next.next;\\n            cur = curCopy;\\n        }\\n\\n        return copyHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43609,
                "title": "similar-to-graph-clone-recursive-java-solution",
                "content": "This is another **deep clone** problem for list, use a map to store its original and its new copy, recursive java solution:\\n```\\nMap<RandomListNode, RandomListNode> map = new HashMap<>();\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (map.containsKey(head)) {\\n            return map.get(head);\\n        }\\n        RandomListNode result = new RandomListNode(head.label);\\n        map.put(head, result);\\n        result.next = copyRandomList(head.next);\\n        result.random = copyRandomList(head.random);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "This is another **deep clone** problem for list, use a map to store its original and its new copy, recursive java solution:\\n```\\nMap<RandomListNode, RandomListNode> map = new HashMap<>();\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (map.containsKey(head)) {\\n            return map.get(head);\\n        }\\n        RandomListNode result = new RandomListNode(head.label);\\n        map.put(head, result);\\n        result.next = copyRandomList(head.next);\\n        result.random = copyRandomList(head.random);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43553,
                "title": "accepted-java-solution-with-explanation-no-additional-data-structures",
                "content": "The idea is to use only next and random link of a node to create a copy of list. Please, check sketch and Java code below.\\n\\n\\n![enter image description here][1]\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n\\t\\tif (head == null) return null;\\n\\t\\t\\n\\t\\t// Step 1\\n\\t\\tRandomListNode origin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next;\\n\\t\\t\\tRandomListNode copy = new RandomListNode(origin.label);\\n\\t\\t\\torigin.next = copy;\\n\\t\\t\\tcopy.next = originNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 2\\n\\t\\torigin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tif (origin.random != null) {\\n\\t\\t\\t\\tcopy.random = origin.random.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopy.random = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 3\\n\\t\\torigin = head;\\n\\t\\tRandomListNode copyHead = head.next;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copyNext;\\n\\t\\t\\tif (copy.next != null) {\\n\\t\\t\\t\\tcopyNext = copy.next.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopyNext = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin.next = originNext;\\n\\t\\t\\tcopy.next = copyNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t\\tcopy = copyNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn copyHead;\\n    }\\n\\n\\n  [1]: http://s27.postimg.org/ywzricioz/IMG_20150101_173454.jpg\\n  [2]: http://postimg.org/image/rh0hwjuzj/",
                "solutionTags": [],
                "code": "The idea is to use only next and random link of a node to create a copy of list. Please, check sketch and Java code below.\\n\\n\\n![enter image description here][1]\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n\\t\\tif (head == null) return null;\\n\\t\\t\\n\\t\\t// Step 1\\n\\t\\tRandomListNode origin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next;\\n\\t\\t\\tRandomListNode copy = new RandomListNode(origin.label);\\n\\t\\t\\torigin.next = copy;\\n\\t\\t\\tcopy.next = originNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 2\\n\\t\\torigin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tif (origin.random != null) {\\n\\t\\t\\t\\tcopy.random = origin.random.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopy.random = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 3\\n\\t\\torigin = head;\\n\\t\\tRandomListNode copyHead = head.next;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copyNext;\\n\\t\\t\\tif (copy.next != null) {\\n\\t\\t\\t\\tcopyNext = copy.next.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopyNext = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin.next = originNext;\\n\\t\\t\\tcopy.next = copyNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t\\tcopy = copyNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn copyHead;\\n    }\\n\\n\\n  [1]: http://s27.postimg.org/ywzricioz/IMG_20150101_173454.jpg\\n  [2]: http://postimg.org/image/rh0hwjuzj/",
                "codeTag": "Unknown"
            },
            {
                "id": 43768,
                "title": "with-error-random-pointer-of-node-with-label-1-points-to-a-node-from-the-original-list-can-anyone-help-me",
                "content": "    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * struct RandomListNode {\\n     *     int label;\\n     *     RandomListNode *next, *random;\\n     *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n    \\tRandomListNode *copyRandomList(RandomListNode *head) {\\n    \\t\\tvector<RandomListNode *> vecOld;\\n    \\t\\tunordered_map<RandomListNode *, size_t> addressIndexMap;\\n    \\t\\tvector<RandomListNode *> vecAddress;\\n    \\t\\tif (!head)\\n    \\t\\t{\\n    \\t\\t\\treturn NULL;\\n    \\t\\t}\\n    \\t\\telse if (!head->next)\\n    \\t\\t{\\n    \\t\\t\\treturn new RandomListNode(*head);\\n    \\t\\t}\\n    \\t\\tRandomListNode * curr = head;\\n    \\t\\tRandomListNode * guard = new RandomListNode(0);\\n    \\t\\tRandomListNode * newCurr = guard;\\n    \\t\\twhile (curr)\\n    \\t\\t{\\n    \\t\\t    //store the old random pointer \\n    \\t\\t\\tvecOld.push_back(curr->random);\\n    \\t\\t\\t//store the old address -> index pair for later reconstruction of random pointer\\n    \\t\\t\\taddressIndexMap[curr] = vecOld.size() - 1;\\n    \\t\\t\\tnewCurr->next = new RandomListNode(*curr);\\n    \\t\\t\\tnewCurr = newCurr->next;\\n    \\t\\t\\tnewCurr->random = NULL;\\n    \\t\\t\\t//store the address of new nodes for later reconstruction of random pointer\\n    \\t\\t\\tvecAddress.push_back(newCurr);\\n    \\t\\t\\tcurr = curr->next;\\n    \\t\\t}\\n    \\t\\tnewCurr = guard->next;\\n    \\t\\tint index = 0;\\n    \\t\\twhile (newCurr)\\n    \\t\\t{\\n    \\t\\t    //If the old random pointer is not NULL\\n    \\t\\t\\tif (NULL != vecOld[index])\\n    \\t\\t\\t{\\n    \\t\\t\\t    //Get the corresponding index\\n    \\t\\t\\t\\tsize_t randomIndex = addressIndexMap[vecOld[index]];\\n    \\t\\t\\t\\t//get the new address of the node with the index and reconstruct the random pointer\\n    \\t\\t\\t\\tnewCurr->random = vecAddress[randomIndex];\\n    \\t\\t\\t}\\n    \\t\\t\\t++index;\\n    \\t\\t\\tnewCurr = newCurr->next;\\n    \\t\\t}\\n    \\t\\tnewCurr = guard->next;\\n    \\t\\tdelete guard;\\n    \\t\\treturn newCurr;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tRandomListNode *copyRandomList(RandomListNode *head) {\\n    \\t\\tvector<RandomListNode *> vecOld;\\n    \\t\\tunordered_map<RandomListNode *, size_t> addressIndexMap;\\n    \\t\\tvector<RandomListNode *> vecAddress;\\n    \\t\\tif (!head)\\n    \\t\\t{\\n    \\t\\t\\treturn NULL;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4004158,
                "title": "not-a-regular-solution-it-is-easy-then-random-pointer-beats-100-of-java-users",
                "content": "# Intuition\\nUsing HashMap which stores old->new pairs\\n\\n# Approach\\n- First you consider a hashmap and now one the go of creating a new node itself you try to point the old pointer to the newly created node.\\n- Don\\'t forget to point the newly formed linked list to next,next,next...\\n- The intial goal of first loop is to make key,value pairs and creating a linear linked list without pointing random pointers\\n- In the second loop u directly try to point the random pointers\\n- Finally you return new head.\\n\\n![image.png](https://assets.leetcode.com/users/images/4b132dba-7acc-49a1-a8c3-c252bd6f5eb9_1693895373.3642166.png)\\n![image.png](https://assets.leetcode.com/users/images/dc73eb27-15c5-410d-976d-0fba7eb2693b_1693895520.1152763.png)\\n\\n\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node>oldToNew = new HashMap<>();\\n        if(head==null)\\n            return null;\\n        Node oldCurr = head;\\n        Node prevNew = null;\\n        while(oldCurr!=null){\\n            Node newCurr = new Node(oldCurr.val);\\n            if(prevNew!=null){\\n                prevNew.next = newCurr;\\n            }\\n            prevNew = newCurr;\\n            oldToNew.put(oldCurr,newCurr);\\n            oldCurr = oldCurr.next;\\n        }\\n        oldCurr = head;\\n        while(oldCurr!=null){\\n            oldToNew.get(oldCurr).random = oldToNew.getOrDefault(oldCurr.random,null);\\n            oldCurr = oldCurr.next;\\n        }\\n\\n        return oldToNew.get(head);\\n\\n        \\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node>oldToNew = new HashMap<>();\\n        if(head==null)\\n            return null;\\n        Node oldCurr = head;\\n        Node prevNew = null;\\n        while(oldCurr!=null){\\n            Node newCurr = new Node(oldCurr.val);\\n            if(prevNew!=null){\\n                prevNew.next = newCurr;\\n            }\\n            prevNew = newCurr;\\n            oldToNew.put(oldCurr,newCurr);\\n            oldCurr = oldCurr.next;\\n        }\\n        oldCurr = head;\\n        while(oldCurr!=null){\\n            oldToNew.get(oldCurr).random = oldToNew.getOrDefault(oldCurr.random,null);\\n            oldCurr = oldCurr.next;\\n        }\\n\\n        return oldToNew.get(head);\\n\\n        \\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944614,
                "title": "the-most-optimal-solution-using-deep-copy-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n  if (!head) return nullptr;\\n\\n        // Step 1: Duplicate nodes and interleave them in the original list\\n        Node* current = head;\\n        while (current) {\\n            Node* copy = new Node(current->val);\\n            copy->next = current->next;\\n            current->next = copy;\\n            current = copy->next;\\n        }\\n\\n        // Step 2: Update random pointers for the copied nodes\\n        current = head;\\n        while (current) {\\n            if (current->random) {\\n                current->next->random = current->random->next;\\n            }\\n            current = current->next->next;\\n        }\\n\\n        // Step 3: Separate the original list and the copied list\\n        current = head;\\n        Node* newHead = head->next;\\n        while (current) {\\n            Node* copy = current->next;\\n            current->next = copy->next;\\n            if (copy->next) {\\n                copy->next = copy->next->next;\\n            }\\n            current = current->next;\\n        }\\n\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n  if (!head) return nullptr;\\n\\n        // Step 1: Duplicate nodes and interleave them in the original list\\n        Node* current = head;\\n        while (current) {\\n            Node* copy = new Node(current->val);\\n            copy->next = current->next;\\n            current->next = copy;\\n            current = copy->next;\\n        }\\n\\n        // Step 2: Update random pointers for the copied nodes\\n        current = head;\\n        while (current) {\\n            if (current->random) {\\n                current->next->random = current->random->next;\\n            }\\n            current = current->next->next;\\n        }\\n\\n        // Step 3: Separate the original list and the copied list\\n        current = head;\\n        Node* newHead = head->next;\\n        while (current) {\\n            Node* copy = current->next;\\n            current->next = copy->next;\\n            if (copy->next) {\\n                copy->next = copy->next->next;\\n            }\\n            current = current->next;\\n        }\\n\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861915,
                "title": "2-best-c-solution-with-video-explanation-space-o-1-and-o-n-solutions",
                "content": "# [Video Link](https://youtu.be/83mPr0i56Gg) \\n\\n### Please upvote the solution if you liked it !!\\n\\n# Code\\n```\\n// Solution 1 - Using maps - SC O(N) \\nclass Solution\\n{\\n    public:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node* newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n            return;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n    \\n    Node *copyRandomList(Node *head)\\n    {\\n        Node* cloneHead = NULL;\\n        Node* cloneTail = NULL;\\n        Node* temp = head;\\n        \\n        // Step 1 - Create a clone LL\\n        while(temp != NULL){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        // Step 2 - Create a map\\n        unordered_map<Node*, Node*> mp;\\n        Node* originalNode = head;\\n        Node* cloneNode = cloneHead;\\n        \\n        while(originalNode != NULL){\\n            mp[originalNode] = cloneNode;\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        // Step 3 - Map random pointers\\n        originalNode = head;\\n        cloneNode = cloneHead;\\n        while(originalNode != temp){\\n            cloneNode->random = mp[originalNode->random];\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        return cloneHead;\\n    }\\n};\\n\\n// Solution 2 - SC O(1) \\nclass Solution {\\npublic:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node *newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *cloneHead = NULL, *cloneTail = NULL;\\n        Node *temp = head;\\n        \\n        // Step 1 = Create a cloned LL\\n        while(temp != NULL ){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Merge original and cloned LL\\n        temp = head;\\n        Node *clone = cloneHead;\\n        while(temp != NULL && clone != NULL){\\n            Node *newNode = temp->next;\\n            temp->next = clone;\\n            temp = newNode;\\n\\n            newNode = clone->next;\\n            clone->next = temp;\\n            clone = newNode;\\n        }\\n\\n        // Step 3 - Copy the random pointers from original node to clone nodes\\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL && temp->random != NULL){\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n\\n        // Step 4 - Revert/Reverse the step 2 by separating the orignal and clone LL\\n        temp = head;\\n        clone = cloneHead;\\n        while(temp != NULL){\\n            temp->next = clone->next;\\n            temp = temp->next;\\n\\n            if(temp != NULL)\\n                clone->next = temp->next;\\n            clone = clone->next;\\n        }\\n\\n        return cloneHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n// Solution 1 - Using maps - SC O(N) \\nclass Solution\\n{\\n    public:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node* newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n            return;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n    \\n    Node *copyRandomList(Node *head)\\n    {\\n        Node* cloneHead = NULL;\\n        Node* cloneTail = NULL;\\n        Node* temp = head;\\n        \\n        // Step 1 - Create a clone LL\\n        while(temp != NULL){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        // Step 2 - Create a map\\n        unordered_map<Node*, Node*> mp;\\n        Node* originalNode = head;\\n        Node* cloneNode = cloneHead;\\n        \\n        while(originalNode != NULL){\\n            mp[originalNode] = cloneNode;\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        // Step 3 - Map random pointers\\n        originalNode = head;\\n        cloneNode = cloneHead;\\n        while(originalNode != temp){\\n            cloneNode->random = mp[originalNode->random];\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        return cloneHead;\\n    }\\n};\\n\\n// Solution 2 - SC O(1) \\nclass Solution {\\npublic:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node *newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *cloneHead = NULL, *cloneTail = NULL;\\n        Node *temp = head;\\n        \\n        // Step 1 = Create a cloned LL\\n        while(temp != NULL ){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Merge original and cloned LL\\n        temp = head;\\n        Node *clone = cloneHead;\\n        while(temp != NULL && clone != NULL){\\n            Node *newNode = temp->next;\\n            temp->next = clone;\\n            temp = newNode;\\n\\n            newNode = clone->next;\\n            clone->next = temp;\\n            clone = newNode;\\n        }\\n\\n        // Step 3 - Copy the random pointers from original node to clone nodes\\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL && temp->random != NULL){\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n\\n        // Step 4 - Revert/Reverse the step 2 by separating the orignal and clone LL\\n        temp = head;\\n        clone = cloneHead;\\n        while(temp != NULL){\\n            temp->next = clone->next;\\n            temp = temp->next;\\n\\n            if(temp != NULL)\\n                clone->next = temp->next;\\n            clone = clone->next;\\n        }\\n\\n        return cloneHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739596,
                "title": "few-lines-super-easy-c-code",
                "content": "# Intuition\\nstep-1 : Take an unordered map and store the Node of old LL as a key and Copy node as a value.\\n\\nstep-2: Remove the new node from map and join the next and random by using key of the map \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n      unordered_map<Node*,Node*> m;\\n      for(Node *curr=head; curr != NULL ; curr=curr->next)\\n        m[curr]=new Node(curr->val);\\n     Node *clone;\\n     for(Node *curr=head; curr != NULL ; curr=curr->next){\\n         clone=m[curr];\\n         clone->next=m[curr->next];\\n         clone->random=m[curr->random];\\n     } \\n     Node *newhead=m[head];\\n     return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n      unordered_map<Node*,Node*> m;\\n      for(Node *curr=head; curr != NULL ; curr=curr->next)\\n        m[curr]=new Node(curr->val);\\n     Node *clone;\\n     for(Node *curr=head; curr != NULL ; curr=curr->next){\\n         clone=m[curr];\\n         clone->next=m[curr->next];\\n         clone->random=m[curr->random];\\n     } \\n     Node *newhead=m[head];\\n     return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247684,
                "title": "java-beats-100-well-explained-using-hashmap-o-n-space",
                "content": "# Intuition\\nUse HashMap to store Nodes reference while traversing and creating a new copied list and thus it will contain all random connections in the map as well\\n\\n# Approach\\nFetch those random connections from the map and append those to new list as well\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null)\\n            return null;\\n        Node ansHead = new Node(head.val); //creating answer head and taking two pointers for each list\\n        Node temp2 = ansHead;\\n        Node temp = head;\\n\\n        HashMap<Node, Node> mapped = new HashMap<>();  // storing Node.next references in the map\\n        // key - temp.next , value - temp2.next\\n        mapped.put(head, ansHead); //putting itnitial values\\n\\n//traverse the linked list, copying the new nodes and putting next refernces of nodes on map\\n        while(temp!=null || temp2!=null){ \\n            \\n            if(temp.next!=null){\\n                temp2.next = new Node(temp.next.val); //copy\\n            }\\n\\n            mapped.put(temp.next, temp2.next);\\n            temp = temp.next;\\n            temp2 = temp2.next;\\n        }\\n\\n        temp = head;\\n        temp2 = ansHead;\\n\\n//once again traverse the linked list and make the random connections remaining\\n        while(temp2!=null || temp!=null){\\n            temp2.random = mapped.get(temp.random); // we will get temp.next.random from the map, we have \\n            // temp.next Node in the map, just retrieve .random from it\\n            temp=temp.next;\\n            temp2=temp2.next;\\n        }\\n        return ansHead;\\n    }\\n}\\n```\\n##### For another solution using Constant space visit - \\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/3249057/java-beats-100-detailed-solution-with-explanation-o-1-space-complexity/",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null)\\n            return null;\\n        Node ansHead = new Node(head.val); //creating answer head and taking two pointers for each list\\n        Node temp2 = ansHead;\\n        Node temp = head;\\n\\n        HashMap<Node, Node> mapped = new HashMap<>();  // storing Node.next references in the map\\n        // key - temp.next , value - temp2.next\\n        mapped.put(head, ansHead); //putting itnitial values\\n\\n//traverse the linked list, copying the new nodes and putting next refernces of nodes on map\\n        while(temp!=null || temp2!=null){ \\n            \\n            if(temp.next!=null){\\n                temp2.next = new Node(temp.next.val); //copy\\n            }\\n\\n            mapped.put(temp.next, temp2.next);\\n            temp = temp.next;\\n            temp2 = temp2.next;\\n        }\\n\\n        temp = head;\\n        temp2 = ansHead;\\n\\n//once again traverse the linked list and make the random connections remaining\\n        while(temp2!=null || temp!=null){\\n            temp2.random = mapped.get(temp.random); // we will get temp.next.random from the map, we have \\n            // temp.next Node in the map, just retrieve .random from it\\n            temp=temp.next;\\n            temp2=temp2.next;\\n        }\\n        return ansHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891413,
                "title": "kotlin-iterative",
                "content": "```\\nclass Solution {\\n    fun copyRandomList(node: Node?): Node? {\\n        val oldToNew = HashMap<Node, Node>()    \\n\\n        var copy: Node? = null\\n        var curr: Node? = node\\n\\n        while (curr != null) {\\n            copy = Node(curr.`val`)\\n            oldToNew[curr] = copy\\n            curr = curr?.next\\n        }\\n\\n        curr = node\\n        while (curr != null) {\\n            copy = oldToNew[curr]!!\\n            copy.next = oldToNew[curr.next]\\n            copy.random = oldToNew[curr.random]\\n            curr = curr?.next\\n        }\\n\\n        return oldToNew[node]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    fun copyRandomList(node: Node?): Node? {\\n        val oldToNew = HashMap<Node, Node>()    \\n\\n        var copy: Node? = null\\n        var curr: Node? = node\\n\\n        while (curr != null) {\\n            copy = Node(curr.`val`)\\n            oldToNew[curr] = copy\\n            curr = curr?.next\\n        }\\n\\n        curr = node\\n        while (curr != null) {\\n            copy = oldToNew[curr]!!\\n            copy.next = oldToNew[curr.next]\\n            copy.random = oldToNew[curr.random]\\n            curr = curr?.next\\n        }\\n\\n        return oldToNew[node]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795536,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642765,
                "title": "simple-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n         var tracking = new Dictionary<Node, Node>();\\n        Node cur = head;\\n        // Copy node without next and random\\n        while (cur != null)\\n        {\\n            tracking.Add(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n        // Connect all node\\n        while (cur != null)\\n        {\\n            tracking[cur].next = cur.next != null ? tracking[cur.next] : null;\\n            tracking[cur].random = cur.random != null ? tracking[cur.random] : null;\\n            cur = cur.next;\\n        }\\n\\n        return tracking[head];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n         var tracking = new Dictionary<Node, Node>();\\n        Node cur = head;\\n        // Copy node without next and random\\n        while (cur != null)\\n        {\\n            tracking.Add(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n        // Connect all node\\n        while (cur != null)\\n        {\\n            tracking[cur].next = cur.next != null ? tracking[cur.next] : null;\\n            tracking[cur].random = cur.random != null ? tracking[cur.random] : null;\\n            cur = cur.next;\\n        }\\n\\n        return tracking[head];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358516,
                "title": "c-solution-well-explained-diagram-time-complexity-o-n-space-complexity-o-1",
                "content": "##Explanation\\n\\n**Original Linked List:**\\n\\n![image.png](https://assets.leetcode.com/users/images/182cc627-0688-47fe-ba79-bd184ddbb7d3_1693872448.433081.png)\\n\\n### Phase 1 - Duplicating and Inserting Nodes\\n\\nIn this phase, we\\'ll create a new node for each original node and insert it between the original node and its next node.\\n\\nStart with the original list (head points to the first node).\\nCreate a duplicate node for each original node and insert it between them:\\n\\n![image.png](https://assets.leetcode.com/users/images/780d72af-7ec1-403b-8afa-ee5507159e40_1693872526.817351.png)\\n\\n\\n### Phase 2 - Updating Random Pointers\\n\\nIn this phase, we\\'ll update the random pointers of the duplicate nodes to point to the corresponding duplicate nodes.\\nStart with head->next (pointing to the first duplicate node) and head (pointing to the first original node).\\nUpdate the random pointers of the duplicate nodes:\\n<br>\\n**1\\' should point to the duplicate node corresponding to the random node of 1, which is 3\\'.\\n2\\' should point to the duplicate node corresponding to the random node of 2, which is 1\\'.\\n3\\' should point to the duplicate node corresponding to the random node of 3, which is 5\\'.\\n4\\' should point to the duplicate node corresponding to the random node of 4, which is 1\\'.\\n5\\' should point to the duplicate node corresponding to the random node of 5, which is 5\\' (it could also be nullptr).**\\n\\n![image.png](https://assets.leetcode.com/users/images/15e4f41f-37e9-4251-b0ab-6d00396a5188_1693872672.5756319.png)\\n\\n### Phase 3 - Separating the Lists\\n\\nIn this phase, we\\'ll separate the original list from the copied list.\\n\\nStart with head2 (pointing to the head of the copied list), temp (pointing to the first duplicate node), and t (pointing to the first original node).\\nIterate through the list and update the next pointers to skip every other node for both the original and copied lists.\\nAfter this phase, we\\'ll have two separate lists: the original list (head) and the copied list (head2). The two lists are structurally identical with the same random pointers but are independent.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/d061c72d-39b1-4890-80d8-71511e7a06a4_1693872712.9219985.png)\\n\\n\\n\\n\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    // Check if the input list is empty\\n    if (!head)\\n        return head;\\n\\n    // Phase 1: Duplicate each node and insert it between the original nodes\\n    Node* temp = head;\\n    while (temp) {\\n        Node* newnode = new Node(temp->val);  // Create a new node with the same value as the original node\\n        newnode->next = temp->next;           // Set the new node\\'s \"next\" pointer to the original node\\'s \"next\"\\n        temp->next = newnode;                 // Update the original node\\'s \"next\" to point to the new node\\n        temp = temp->next->next;              // Move to the next original node\\n    }\\n\\n    // Phase 2: Update the random pointers of the new nodes\\n    temp = head->next;\\n    Node* t = head;\\n    while (temp) {\\n        if (t->random) // If the original node\\'s random pointer exists\\n            temp->random = t->random->next; // Update the new node\\'s random pointer to point to the corresponding new node\\n        else\\n            temp->random = t->random; // If the original node\\'s random pointer is nullptr, set the new node\\'s random pointer to nullptr\\n\\n        if (!temp->next) {\\n            break;\\n        }\\n        t = t->next->next;\\n        temp = temp->next->next;\\n    }\\n\\n    // Phase 3: Separate the original list and the copied list\\n    Node* head2 = head->next; // The head of the copied list\\n    temp = head->next;\\n    t = head;\\n    while (temp->next) {\\n        t->next = t->next->next; // Update the \"next\" pointer of the original list to skip the copied nodes\\n        temp->next = temp->next->next; // Update the \"next\" pointer of the copied list to skip the original nodes\\n        temp = temp->next;\\n        t = t->next;\\n    }\\n\\n    t->next = NULL; // Set the last node\\'s \"next\" pointer to nullptr to terminate the copied list\\n\\n    return head2; // Return the head of the copied list\\n}\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "##Explanation\\n\\n**Original Linked List:**\\n\\n![image.png](https://assets.leetcode.com/users/images/182cc627-0688-47fe-ba79-bd184ddbb7d3_1693872448.433081.png)\\n\\n### Phase 1 - Duplicating and Inserting Nodes\\n\\nIn this phase, we\\'ll create a new node for each original node and insert it between the original node and its next node.\\n\\nStart with the original list (head points to the first node).\\nCreate a duplicate node for each original node and insert it between them:\\n\\n![image.png](https://assets.leetcode.com/users/images/780d72af-7ec1-403b-8afa-ee5507159e40_1693872526.817351.png)\\n\\n\\n### Phase 2 - Updating Random Pointers\\n\\nIn this phase, we\\'ll update the random pointers of the duplicate nodes to point to the corresponding duplicate nodes.\\nStart with head->next (pointing to the first duplicate node) and head (pointing to the first original node).\\nUpdate the random pointers of the duplicate nodes:\\n<br>\\n**1\\' should point to the duplicate node corresponding to the random node of 1, which is 3\\'.\\n2\\' should point to the duplicate node corresponding to the random node of 2, which is 1\\'.\\n3\\' should point to the duplicate node corresponding to the random node of 3, which is 5\\'.\\n4\\' should point to the duplicate node corresponding to the random node of 4, which is 1\\'.\\n5\\' should point to the duplicate node corresponding to the random node of 5, which is 5\\' (it could also be nullptr).**\\n\\n![image.png](https://assets.leetcode.com/users/images/15e4f41f-37e9-4251-b0ab-6d00396a5188_1693872672.5756319.png)\\n\\n### Phase 3 - Separating the Lists\\n\\nIn this phase, we\\'ll separate the original list from the copied list.\\n\\nStart with head2 (pointing to the head of the copied list), temp (pointing to the first duplicate node), and t (pointing to the first original node).\\nIterate through the list and update the next pointers to skip every other node for both the original and copied lists.\\nAfter this phase, we\\'ll have two separate lists: the original list (head) and the copied list (head2). The two lists are structurally identical with the same random pointers but are independent.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/d061c72d-39b1-4890-80d8-71511e7a06a4_1693872712.9219985.png)\\n\\n\\n\\n\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    // Check if the input list is empty\\n    if (!head)\\n        return head;\\n\\n    // Phase 1: Duplicate each node and insert it between the original nodes\\n    Node* temp = head;\\n    while (temp) {\\n        Node* newnode = new Node(temp->val);  // Create a new node with the same value as the original node\\n        newnode->next = temp->next;           // Set the new node\\'s \"next\" pointer to the original node\\'s \"next\"\\n        temp->next = newnode;                 // Update the original node\\'s \"next\" to point to the new node\\n        temp = temp->next->next;              // Move to the next original node\\n    }\\n\\n    // Phase 2: Update the random pointers of the new nodes\\n    temp = head->next;\\n    Node* t = head;\\n    while (temp) {\\n        if (t->random) // If the original node\\'s random pointer exists\\n            temp->random = t->random->next; // Update the new node\\'s random pointer to point to the corresponding new node\\n        else\\n            temp->random = t->random; // If the original node\\'s random pointer is nullptr, set the new node\\'s random pointer to nullptr\\n\\n        if (!temp->next) {\\n            break;\\n        }\\n        t = t->next->next;\\n        temp = temp->next->next;\\n    }\\n\\n    // Phase 3: Separate the original list and the copied list\\n    Node* head2 = head->next; // The head of the copied list\\n    temp = head->next;\\n    t = head;\\n    while (temp->next) {\\n        t->next = t->next->next; // Update the \"next\" pointer of the original list to skip the copied nodes\\n        temp->next = temp->next->next; // Update the \"next\" pointer of the copied list to skip the original nodes\\n        temp = temp->next;\\n        t = t->next;\\n    }\\n\\n    t->next = NULL; // Set the last node\\'s \"next\" pointer to nullptr to terminate the copied list\\n\\n    return head2; // Return the head of the copied list\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2331483,
                "title": "c-solution-o-1-space-compexitiy-visualised-beats-100",
                "content": "At beggining our linked list should look like this!\\n![image](https://assets.leetcode.com/users/images/78ef59a6-ebe8-47c8-b5b0-f99d52d4e833_1658746955.8413064.png)\\n\\nIn first pass we will create and insert copy of every element between that element and his next element, so copy of first element we will insert between 1st and 2nd, copy of 2nd element we will insert between 2nd and 3rd...\\nAfter first pass our linked List should look like this (red nodes are copies)\\n![image](https://assets.leetcode.com/users/images/27c82699-4072-487a-9fe8-3d1f71a650a9_1658746936.6524725.png)\\n\\nIn second pass we will link our copies to their random nodes, when we insert all copies we can easily access them because we see that \\ncopy->random = real->random->next, and copy we can get because copy = real->next, after that our list should look like this\\n![image](https://assets.leetcode.com/users/images/7cf85f9d-86df-4e85-9fe4-3618ae69bf05_1658747506.1802163.png)\\n\\nIn final third pass we should extract copy nodes from list and made the first list to look like it was before.\\n\\nNow lets see code\\n```\\nstruct Node* copyRandomList(struct Node* head) {\\n\\tstruct Node *newHead = NULL;\\n    struct Node *tail = NULL;\\n    struct Node *curr;\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        struct Node *new = malloc(sizeof(struct Node));\\n        new->next = curr->next;\\n        new->val = curr->val;\\n        curr->next = new;\\n    }\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        if (curr->random == NULL){\\n            curr->next->random = NULL;\\n        } else {\\n            curr->next->random = curr->random->next;\\n        }\\n    }\\n    \\n    curr = head;\\n    \\n    while (curr){\\n        struct Node *newList = curr->next;\\n        curr->next = newList->next;\\n        newList->next = NULL;\\n        if (!newHead){\\n            newHead = newList;\\n        } else {\\n            tail->next = newList;\\n        }\\n        tail = newList;\\n        curr = curr->next;\\n    }\\n    \\n    \\n    return newHead;\\n    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nstruct Node* copyRandomList(struct Node* head) {\\n\\tstruct Node *newHead = NULL;\\n    struct Node *tail = NULL;\\n    struct Node *curr;\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        struct Node *new = malloc(sizeof(struct Node));\\n        new->next = curr->next;\\n        new->val = curr->val;\\n        curr->next = new;\\n    }\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        if (curr->random == NULL){\\n            curr->next->random = NULL;\\n        } else {\\n            curr->next->random = curr->random->next;\\n        }\\n    }\\n    \\n    curr = head;\\n    \\n    while (curr){\\n        struct Node *newList = curr->next;\\n        curr->next = newList->next;\\n        newList->next = NULL;\\n        if (!newHead){\\n            newHead = newList;\\n        } else {\\n            tail->next = newList;\\n        }\\n        tail = newList;\\n        curr = curr->next;\\n    }\\n    \\n    \\n    return newHead;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128946,
                "title": "simple-js-solution-w-comments-iterative",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 78 ms, faster than 61.33% of JavaScript online submissions for Copy List with Random Pointer.\\n// Memory Usage: 43.6 MB, less than 93.23% of JavaScript online submissions for Copy List with Random Pointer.\\nconst copyRandomList = head => {\\n\\tif (!head) return head;\\n\\n\\tconst map = new Map(); // node: copy of code\\n\\tlet current = head;\\n\\n\\t// iterate LL and create map of each node and its copy\\n\\twhile (current) {\\n\\t\\tconst copy = new Node(current.val);\\n\\n\\t\\tmap.set(current, copy);\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\tcurrent = head; // start iterating from start of LL\\n\\n\\t// go through LL and make a LL of new copied nodes\\n\\twhile (current) {\\n\\t\\tconst copy = map.get(current);\\n\\n\\t\\t// if node exist add to pointer otherwise end of LL\\n\\t\\tcopy.next = map.get(current.next) || null; \\n\\t\\tcopy.random = map.get(current.random) || null; \\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\t// return head of copied node\\n\\treturn map.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 78 ms, faster than 61.33% of JavaScript online submissions for Copy List with Random Pointer.\\n// Memory Usage: 43.6 MB, less than 93.23% of JavaScript online submissions for Copy List with Random Pointer.\\nconst copyRandomList = head => {\\n\\tif (!head) return head;\\n\\n\\tconst map = new Map(); // node: copy of code\\n\\tlet current = head;\\n\\n\\t// iterate LL and create map of each node and its copy\\n\\twhile (current) {\\n\\t\\tconst copy = new Node(current.val);\\n\\n\\t\\tmap.set(current, copy);\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\tcurrent = head; // start iterating from start of LL\\n\\n\\t// go through LL and make a LL of new copied nodes\\n\\twhile (current) {\\n\\t\\tconst copy = map.get(current);\\n\\n\\t\\t// if node exist add to pointer otherwise end of LL\\n\\t\\tcopy.next = map.get(current.next) || null; \\n\\t\\tcopy.random = map.get(current.random) || null; \\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\t// return head of copied node\\n\\treturn map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843243,
                "title": "c-solution-o-n-space-explanation-with-diagram-easy-to-understand",
                "content": "**Problem**\\n\\nWe have given a linked list having signature :\\n\\n\\tclass Node {\\n\\tpublic:\\n\\t\\tint val;\\n\\t\\tNode* next;\\n\\t\\tNode* random;\\n\\n\\t\\tNode(int _val) {\\n\\t\\t\\tval = _val;\\n\\t\\t\\tnext = NULL;\\n\\t\\t\\trandom = NULL;\\n\\t\\t}\\n\\t};\\nAnd we have to **return a copy** of this list such that the random pointer of each copied node **points to copy** of random node in given list.\\n\\n\\n**Approach**\\n\\nFor easier understanding lets divide solution into 3 steps -\\n* **Coupling** - existing list and newly created nodes\\n* **Assigning Random Nodes** - assigning random nodes to new nodes\\n* **Decoupling** - breaking list into original and newly created list\\n\\n**Step 1-**\\n\\n![image](https://assets.leetcode.com/users/images/3c95d09f-f89a-4d20-b488-b6efc48e7318_1647107092.677427.gif)\\n\\nCoupled list - 7 -> **7** -> 13 -> **13** ->11 -> **11** -> 10 ->**10** -> 1 ->**1**  -> NULL\\n(Highlighted nodes are copied node we just created)\\n\\n**Why create coupled list ?**\\n* For assigning random node to copies we need to know copy of random orginal node.\\n* For this conventionally we use extra space but with coupled representation copied node has become next node so we can access it by using next pointer. \\n\\n\\n**Step 2-**\\n![image](https://assets.leetcode.com/users/images/931830c1-2aa3-451a-b31e-26420061aff6_1647160443.1398268.gif)\\n\\nNow random pointer of every node is assigned, now we just have to break 2 list and return the copied one.  \\n\\n**Step 3- Decoupling**\\n\\nSince we have already seen coupling , decoupling becomes very easy.\\nSee the code once and you will get it.\\n\\nTip - be sure to restore given list to its original state otherwise, leetcode compiler gives a weird  error.\\n![image](https://assets.leetcode.com/users/images/dfe6cae8-ba72-4eda-b7ea-c70ed0e1648e_1647108230.505617.png)\\n\\n**Code -**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head)\\n    {\\n        if(!head)return NULL;\\n        Node * temp = head;\\n        \\n\\t\\t// Coupling\\n        while(temp)\\n        {\\n            Node *node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n\\t\\t// Assigning random nodes\\n        temp = head;\\n        while(temp)\\n        {\\n            temp->next->random = temp->random?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n\\t\\t\\n\\t\\t//decoupling        \\n        Node *ans = head->next;\\n        temp = head->next;\\n       \\n        while(head)\\n        {\\n            head->next=temp->next;\\n            head=head->next;\\n            if(!head)break;\\n            temp->next=head->next;\\n            temp=temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote this post if it helps u, feel free to ask any doubt\\nSee u in another post, Untill then TATAKAE :)**\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head)\\n    {\\n        if(!head)return NULL;\\n        Node * temp = head;\\n        \\n\\t\\t// Coupling\\n        while(temp)\\n        {\\n            Node *node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n\\t\\t// Assigning random nodes\\n        temp = head;\\n        while(temp)\\n        {\\n            temp->next->random = temp->random?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n\\t\\t\\n\\t\\t//decoupling        \\n        Node *ans = head->next;\\n        temp = head->next;\\n       \\n        while(head)\\n        {\\n            head->next=temp->next;\\n            head=head->next;\\n            if(!head)break;\\n            temp->next=head->next;\\n            temp=temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842579,
                "title": "python-with-without-hashmap-simple-elegant-solutions-with-explanation",
                "content": "## Solution1 (Simple Solution)\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Copy linked list without random pointer and save the original node with its corresponding copied node in hashmap to update its random pointer further.\\n        hashmap = {}\\n        copiedList = Node(head.val)\\n        hashmap[head] = copiedList\\n        node = copiedList\\n        while head.next:\\n            head = head.next\\n            node.next = Node(head.val)\\n            node = node.next\\n            hashmap[head] = node\\n        \\n        # Update random pointer of each node\\n        for node, copiedNode in hashmap.items():\\n            if node.random:\\n                copiedNode.random = hashmap[node.random]\\n        \\n        return copiedList\\n```\\n\\n## Solution2 (Elegant Solution)\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Add the copied node without random pointer just after its corresponding original node.\\n        node = head\\n        while node:\\n            copiedNode = Node(node.val, node.next)\\n            node.next = copiedNode\\n            node = copiedNode.next\\n        \\n        \"\"\"\\n            Update the random pointer of each copied node by using the below logic-\\n                Let\\'s say the copied node is c_node and it\\'s original node is o_node then the random pointer of c_node would be the next node of random pointer of o_node because we have placed each copied node just after it\\'s original node. \\n        \"\"\"\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            if node.random:\\n                copiedNode.random = node.random.next\\n            node = copiedNode.next\\n        \\n        # Now just remove the original nodes from the list and return the remaining list as the remaining nodes of the list would make the deep copied list of original list.\\n        copiedHead = head.next\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            node.next = copiedNode.next\\n            node = node.next\\n            if copiedNode.next:\\n                copiedNode.next = copiedNode.next.next\\n                copiedNode = copiedNode.next\\n        return copiedHead\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Copy linked list without random pointer and save the original node with its corresponding copied node in hashmap to update its random pointer further.\\n        hashmap = {}\\n        copiedList = Node(head.val)\\n        hashmap[head] = copiedList\\n        node = copiedList\\n        while head.next:\\n            head = head.next\\n            node.next = Node(head.val)\\n            node = node.next\\n            hashmap[head] = node\\n        \\n        # Update random pointer of each node\\n        for node, copiedNode in hashmap.items():\\n            if node.random:\\n                copiedNode.random = hashmap[node.random]\\n        \\n        return copiedList\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Add the copied node without random pointer just after its corresponding original node.\\n        node = head\\n        while node:\\n            copiedNode = Node(node.val, node.next)\\n            node.next = copiedNode\\n            node = copiedNode.next\\n        \\n        \"\"\"\\n            Update the random pointer of each copied node by using the below logic-\\n                Let\\'s say the copied node is c_node and it\\'s original node is o_node then the random pointer of c_node would be the next node of random pointer of o_node because we have placed each copied node just after it\\'s original node. \\n        \"\"\"\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            if node.random:\\n                copiedNode.random = node.random.next\\n            node = copiedNode.next\\n        \\n        # Now just remove the original nodes from the list and return the remaining list as the remaining nodes of the list would make the deep copied list of original list.\\n        copiedHead = head.next\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            node.next = copiedNode.next\\n            node = node.next\\n            if copiedNode.next:\\n                copiedNode.next = copiedNode.next.next\\n                copiedNode = copiedNode.next\\n        return copiedHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842118,
                "title": "clone-node-linked-list-with-random-pointer-hashmap",
                "content": "Hi,\\n\\nCloning linked list with random pointer looked like a complex question, as this kindly of random pointer first time for me.\\n\\nSo first thing that came to my mind is use some mapping techinque to store the node with new node.\\nI went blind with that step, but after completing this step I approached by making some change to those nodes in the hashmap and returned the head value from the hashmap.\\n\\n```\\npublic Node copyRandomList(Node head) {\\n    \\tif(head==null)\\n    \\t\\treturn head;\\n    \\tHashMap<Node, Node> map = new HashMap<Node, Node>();\\n    \\tNode curr = head;\\n    \\twhile(curr!=null){\\n    \\t\\tmap.put(curr, new Node(curr.val));\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n        curr = head;\\n    \\twhile(curr!=null){\\n            Node one = map.get(curr);\\n    \\t\\tone.next = map.get(curr.next);\\n    \\t\\tone.random = map.get(curr.random);\\n            map.put(curr, one);\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n    \\treturn map.get(head);\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nCloning linked list with random pointer looked like a complex question, as this kindly of random pointer first time for me.\\n\\nSo first thing that came to my mind is use some mapping techinque to store the node with new node.\\nI went blind with that step, but after completing this step I approached by making some change to those nodes in the hashmap and returned the head value from the hashmap.\\n\\n```\\npublic Node copyRandomList(Node head) {\\n    \\tif(head==null)\\n    \\t\\treturn head;\\n    \\tHashMap<Node, Node> map = new HashMap<Node, Node>();\\n    \\tNode curr = head;\\n    \\twhile(curr!=null){\\n    \\t\\tmap.put(curr, new Node(curr.val));\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n        curr = head;\\n    \\twhile(curr!=null){\\n            Node one = map.get(curr);\\n    \\t\\tone.next = map.get(curr.next);\\n    \\t\\tone.random = map.get(curr.random);\\n            map.put(curr, one);\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n    \\treturn map.get(head);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1841755,
                "title": "python-go-3-different-solutions-and-explanations",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F 3 Different Solutions and Explanations \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 DFS  Approach O(N)|O(N):\\n1. Create a hashmap, that will render our original node to copy node.\\n2. DFS CALL\\n\\t* **Base Case**: If node is None return None, If node in hashMap, return its copy node\\n\\t* **Create a copy** of current node, and store it in hashMap.\\n\\t* DFS clone its next and random\\n\\t* return current node\\n3. return DFS(head)\\n## Complexity Analysis\\n* Time: O(N): Traverse random and next takes O(2N) => O(N)\\n* Space: O(N): The dfs call and graphHash both take O(N)\\n## DFS Code\\n**Python**\\n```python\\n# DFS O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        # Create a hashmap to tell us whether we clone this node\\n        oldToCopy = {} #Original -> Copy\\n        \\n        # Using dfs to traverse node, and make copy of it\\n        def dfs(node):\\n            # Base cases\\n            if node is None:\\n                return node\\n            if node in oldToCopy:\\n                return oldToCopy[node]\\n            # Create a copy of current node\\n            copyNode = Node(node.val)\\n            oldToCopy[node] = copyNode\\n            # DFS clone node\\'s next and random\\n            copyNode.next = dfs(node.next)\\n            copyNode.random = dfs(node.random)\\n            \\n            return copyNode\\n        \\n        return dfs(head)\\n```\\n**Go**\\n```go\\n// DFS O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    var dfs func (old *Node) *Node\\n    dfs = func (old *Node) *Node{\\n        // Base Cases\\n        if old == nil{\\n            return nil \\n        }\\n        if _, found := oldToCopy[old]; found{\\n            return oldToCopy[old]\\n        }\\n        // Create a copy of current node\\n        copyNode := Node{old.Val, nil, nil}\\n        oldToCopy[old] = &copyNode\\n        // DFS clone node\\'s next and random\\n        copyNode.Next = dfs(old.Next)\\n        copyNode.Random = dfs(old.Random)\\n        \\n        return &copyNode\\n    }\\n    \\n    return dfs(head)\\n}\\n```\\n## 2\\uFE0F\\u20E3 Iterative Approach O(N)|O(N):\\n1. Create a hashmap, that will render our original node to copy node.\\n2. Create all clone node but not connected\\n3. Make all connection through hashMap\\n## Complexity Analysis\\n* Time: O(N): Traverse through all nodes and create clone take O(N). Make all connection take O(N) => O(N)\\n* Space: O(N): The oldToCopy hashMap store O(N)\\n## Iterative Code\\n**Python**\\n```python\\n# Iterative O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        oldToCopy = {None:None}\\n        curr = head\\n        # Creat all nodes but not connect\\n        while curr:\\n            copy = Node(curr.val)\\n            oldToCopy[curr] = copy\\n            curr = curr.next\\n        curr = head\\n        # Make all connection through hashMap\\n        while curr:\\n            copy = oldToCopy[curr]\\n            copy.next = oldToCopy[curr.next]\\n            copy.random = oldToCopy[curr.random]\\n            curr = curr.next\\n            \\n        return oldToCopy[head]\\n```\\n**Go**\\n```go\\n// Iterative O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    oldToCopy[nil] = nil\\n    curr := head\\n    // Creat all nodes but not connected\\n    for curr != nil{\\n        copyNode := Node{curr.Val, nil, nil}\\n        oldToCopy[curr] = &copyNode\\n        curr = curr.Next\\n    }\\n    curr = head\\n    // Make all connection through hashMap\\n    for curr != nil{\\n        copyNode := oldToCopy[curr]\\n        copyNode.Next = oldToCopy[curr.Next]\\n        copyNode.Random = oldToCopy[curr.Random]\\n        curr = curr.Next\\n    }\\n    \\n    return oldToCopy[head]\\n}\\n```\\n\\n## 3\\uFE0F\\u20E3 Iterative Weaved List Approach O(N)|O(1):\\nInstead of a separate hashmap to keep the old node to its clone node, we can tweak the original linked list and keep every cloned node be next to its original node.\\nFor example : ```original : A->B->C->D``` we can simpliy clone and expand the original list to ```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'``` where n\\' indicate its clone node.\\nNow we create all clone nodes, let\\'s make all clone nodes connected to its connection\\n**Random**: copy.random = old.random.next\\n**Next**:  copy.next = copy.nex.next\\n\\n**Algo**\\n1. Create weaved list.   ```A -> B-> C-> D``` to  ```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\\n2. Connect random.  ```copy.random = old.random.next if old.random else None```\\n3. Connect next and Unweaved list.\\n\\t* ```copy.next = nextOld.next if nextOld else None``` to connect clone node to its next clone node\\n\\t* ```old.next = nextOld``` to restore original connections\\n\\n## Complexity Analysis\\n* Time: O(N):\\n* Space: O(N) -> O(1):\\n## Iterative Weaved List Code\\n**Python**\\n```python\\n# Iterative Weaved List O(N) | O(1)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        curr = head\\n        \\n        # Create weaved list, no connection\\n        while curr:\\n            copy = Node(curr.val, curr.next)\\n            curr.next = copy\\n            curr = copy.next\\n        old = head\\n        \\n        # Connect random\\n        while old:\\n            copy = old.next\\n            copy.random = old.random.next if old.random else None\\n            old = copy.next\\n        cloneHead = head.next if head else None\\n        \\n        # Connect next and Unweaved list\\n        old = head\\n        while old:\\n            copy = old.next\\n            nextOld = copy.next\\n            copy.next = nextOld.next if nextOld else None\\n            old.next = nextOld\\n            old = old.next\\n\\n        return cloneHead\\n```\\n**Go**\\n```go\\n// Iterative Weaved List O(N) | O(1)\\nfunc copyRandomList(head *Node) *Node {\\n    curr := head\\n    // Create weaved list, no connection\\n    for curr != nil{\\n        curr, curr.Next =curr.Next, &Node{Val:curr.Val, Next:curr.Next, }\\n    }\\n    \\n    old := head\\n    // Connect random\\n    for old != nil{\\n        copyNode := old.Next\\n        copyNode.Random = nil\\n        if old.Random != nil{\\n            copyNode.Random = old.Random.Next\\n        }\\n        old = copyNode.Next \\n    }\\n    \\n    // Connect next and Unweaved list\\n    var newHead *Node\\n    if head != nil{\\n        newHead = head.Next\\n    }\\n    old = head\\n    for old != nil{\\n        copyNode := old.Next\\n        oldNext := copyNode.Next\\n        copyNode.Next = nil\\n        if oldNext != nil{\\n            copyNode.Next = oldNext.Next\\n        }\\n        old.Next = oldNext\\n        old = old.Next\\n    }\\n    return newHead\\n}\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\n# DFS O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        # Create a hashmap to tell us whether we clone this node\\n        oldToCopy = {} #Original -> Copy\\n        \\n        # Using dfs to traverse node, and make copy of it\\n        def dfs(node):\\n            # Base cases\\n            if node is None:\\n                return node\\n            if node in oldToCopy:\\n                return oldToCopy[node]\\n            # Create a copy of current node\\n            copyNode = Node(node.val)\\n            oldToCopy[node] = copyNode\\n            # DFS clone node\\'s next and random\\n            copyNode.next = dfs(node.next)\\n            copyNode.random = dfs(node.random)\\n            \\n            return copyNode\\n        \\n        return dfs(head)\\n```\n```go\\n// DFS O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    var dfs func (old *Node) *Node\\n    dfs = func (old *Node) *Node{\\n        // Base Cases\\n        if old == nil{\\n            return nil \\n        }\\n        if _, found := oldToCopy[old]; found{\\n            return oldToCopy[old]\\n        }\\n        // Create a copy of current node\\n        copyNode := Node{old.Val, nil, nil}\\n        oldToCopy[old] = &copyNode\\n        // DFS clone node\\'s next and random\\n        copyNode.Next = dfs(old.Next)\\n        copyNode.Random = dfs(old.Random)\\n        \\n        return &copyNode\\n    }\\n    \\n    return dfs(head)\\n}\\n```\n```python\\n# Iterative O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        oldToCopy = {None:None}\\n        curr = head\\n        # Creat all nodes but not connect\\n        while curr:\\n            copy = Node(curr.val)\\n            oldToCopy[curr] = copy\\n            curr = curr.next\\n        curr = head\\n        # Make all connection through hashMap\\n        while curr:\\n            copy = oldToCopy[curr]\\n            copy.next = oldToCopy[curr.next]\\n            copy.random = oldToCopy[curr.random]\\n            curr = curr.next\\n            \\n        return oldToCopy[head]\\n```\n```go\\n// Iterative O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    oldToCopy[nil] = nil\\n    curr := head\\n    // Creat all nodes but not connected\\n    for curr != nil{\\n        copyNode := Node{curr.Val, nil, nil}\\n        oldToCopy[curr] = &copyNode\\n        curr = curr.Next\\n    }\\n    curr = head\\n    // Make all connection through hashMap\\n    for curr != nil{\\n        copyNode := oldToCopy[curr]\\n        copyNode.Next = oldToCopy[curr.Next]\\n        copyNode.Random = oldToCopy[curr.Random]\\n        curr = curr.Next\\n    }\\n    \\n    return oldToCopy[head]\\n}\\n```\n```original : A->B->C->D```\n```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\n```A -> B-> C-> D```\n```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\n```copy.random = old.random.next if old.random else None```\n```copy.next = nextOld.next if nextOld else None```\n```old.next = nextOld```\n```python\\n# Iterative Weaved List O(N) | O(1)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        curr = head\\n        \\n        # Create weaved list, no connection\\n        while curr:\\n            copy = Node(curr.val, curr.next)\\n            curr.next = copy\\n            curr = copy.next\\n        old = head\\n        \\n        # Connect random\\n        while old:\\n            copy = old.next\\n            copy.random = old.random.next if old.random else None\\n            old = copy.next\\n        cloneHead = head.next if head else None\\n        \\n        # Connect next and Unweaved list\\n        old = head\\n        while old:\\n            copy = old.next\\n            nextOld = copy.next\\n            copy.next = nextOld.next if nextOld else None\\n            old.next = nextOld\\n            old = old.next\\n\\n        return cloneHead\\n```\n```go\\n// Iterative Weaved List O(N) | O(1)\\nfunc copyRandomList(head *Node) *Node {\\n    curr := head\\n    // Create weaved list, no connection\\n    for curr != nil{\\n        curr, curr.Next =curr.Next, &Node{Val:curr.Val, Next:curr.Next, }\\n    }\\n    \\n    old := head\\n    // Connect random\\n    for old != nil{\\n        copyNode := old.Next\\n        copyNode.Random = nil\\n        if old.Random != nil{\\n            copyNode.Random = old.Random.Next\\n        }\\n        old = copyNode.Next \\n    }\\n    \\n    // Connect next and Unweaved list\\n    var newHead *Node\\n    if head != nil{\\n        newHead = head.Next\\n    }\\n    old = head\\n    for old != nil{\\n        copyNode := old.Next\\n        oldNext := copyNode.Next\\n        copyNode.Next = nil\\n        if oldNext != nil{\\n            copyNode.Next = oldNext.Next\\n        }\\n        old.Next = oldNext\\n        old = old.Next\\n    }\\n    return newHead\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841321,
                "title": "138-copy-list-with-random-pointer",
                "content": "![image](https://assets.leetcode.com/users/images/e7b4451b-b044-45dc-8c9c-3425cd4ef366_1647058612.6356645.jpeg)\\n![image](https://assets.leetcode.com/users/images/276801c2-ff9c-43b7-bb04-51c1e93dedf0_1647058637.7747352.jpeg)\\n![image](https://assets.leetcode.com/users/images/51b59d6e-2b90-4c68-a2e7-4a3a3b44e350_1647058650.3850918.jpeg)``\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n            if(head==NULL)\\n                    return head;\\n     unordered_map<Node*,Node*>mp;\\n            Node* curr=head;\\n            Node* newhead=NULL;\\n            Node* newtail=NULL;\\n            while(curr)\\n            {\\n                    Node* temp=new Node(curr->val);\\n                    if(newhead==NULL)\\n                    {\\n                            newhead=temp;\\n                            newtail=temp;\\n                    }\\n                    else\\n                    {\\n                            newtail->next=temp;\\n                            newtail=newtail->next;\\n                    }\\n                    mp[curr]=temp;\\n                    curr=curr->next;\\n            }\\n            curr=newhead;\\n            Node*temp=head;\\n            while(curr)\\n            {\\n                    Node* nxt=mp[temp->random];\\n                    curr->random=nxt;\\n                    curr=curr->next;\\n                    temp=temp->next;\\n            }\\n            return newhead;\\n    }\\n};\\n``\\n***if you like plzzzz upvote***`",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n            if(head==NULL)\\n                    return head;\\n     unordered_map<Node*,Node*>mp;\\n            Node* curr=head;\\n            Node* newhead=NULL;\\n            Node* newtail=NULL;\\n            while(curr)\\n            {\\n                    Node* temp=new Node(curr->val);\\n                    if(newhead==NULL)\\n                    {\\n                            newhead=temp;\\n                            newtail=temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1730244,
                "title": "o-n-time-and-o-1-space-complexity",
                "content": "This diagram may help in better understanding of the solution. The arrows represented in red are the random pointers and the arrows in black are the next pointers of respective nodes.\\n![image](https://assets.leetcode.com/users/images/d32c3e29-6b98-4a6c-b789-485afdcf1510_1643515655.2651782.png)\\n\\nAfter this formation we seperate the nodes and make a new linked list and return the head of the newly created linkedl list.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* temp = head;\\n        while(temp){\\n            Node* node = new Node(temp->val);      // create a new node with val as temp->val;\\n            node->next = temp->next;               // insert that node\\n            temp->next = node;                     // in between temp and temp->next;\\n            temp = temp->next->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            if(temp->random and temp->random->next) temp->next->random = temp->random->next;   // now the value temp->next->random will be mapped to temp->random->next;\\n            temp = temp->next->next;                                                           // this is the mapping of our random pointer;\\n        }\\n        \\n        // create a new list by seperating the older list;\\n        Node* curr = head;\\n        Node* newhead = NULL;\\n        Node* newList = NULL;\\n        while(curr){\\n            Node *next = curr->next;\\n            if(!newhead){\\n                newhead = next;\\n                newList = newhead;\\n            }\\n            else{\\n                newList->next = next;       \\n                newList = newList->next;\\n            }\\n            curr->next = next->next;\\n            curr = next->next;\\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* temp = head;\\n        while(temp){\\n            Node* node = new Node(temp->val);      // create a new node with val as temp->val;\\n            node->next = temp->next;               // insert that node\\n            temp->next = node;                     // in between temp and temp->next;\\n            temp = temp->next->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            if(temp->random and temp->random->next) temp->next->random = temp->random->next;   // now the value temp->next->random will be mapped to temp->random->next;\\n            temp = temp->next->next;                                                           // this is the mapping of our random pointer;\\n        }\\n        \\n        // create a new list by seperating the older list;\\n        Node* curr = head;\\n        Node* newhead = NULL;\\n        Node* newList = NULL;\\n        while(curr){\\n            Node *next = curr->next;\\n            if(!newhead){\\n                newhead = next;\\n                newList = newhead;\\n            }\\n            else{\\n                newList->next = next;       \\n                newList = newList->next;\\n            }\\n            curr->next = next->next;\\n            curr = next->next;\\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702032,
                "title": "java-sc-o-n-tc-o-n",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> hm = new HashMap<>();\\n        return copyRandomList(head, hm);\\n    }\\n    \\n    public Node copyRandomList(Node head, HashMap<Node, Node> hm){\\n        if(head == null) return null; \\n        Node newHead = new Node(head.val);\\n        \\n        hm.put(head, newHead);\\n        \\n        newHead.next = copyRandomList(head.next, hm);\\n        newHead.random = hm.get(head.random);           \\n        return newHead;\\n    }\\n}\\n```\\n\\nPlease upvote if you like my solution.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> hm = new HashMap<>();\\n        return copyRandomList(head, hm);\\n    }\\n    \\n    public Node copyRandomList(Node head, HashMap<Node, Node> hm){\\n        if(head == null) return null; \\n        Node newHead = new Node(head.val);\\n        \\n        hm.put(head, newHead);\\n        \\n        newHead.next = copyRandomList(head.next, hm);\\n        newHead.random = hm.get(head.random);           \\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662032,
                "title": "simple-one-in-java-and-c",
                "content": "**Java**\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // First Step: \\n        // Adding extra nodes in middle of linkedlist\\n        if (head == null) return null;\\n        Node curr = head;\\n        while (curr != null) {\\n            Node forw = new Node(curr.val);\\n            Node temp = curr.next;\\n            curr.next = forw;\\n            forw.next = temp;\\n            curr = temp;\\n        }\\n        \\n        // Second step:\\n        // setting up random pointers of our clone linkedlist\\n        curr = head;\\n        while (curr != null) {\\n            curr.next.random = curr.random != null ? curr.random.next : null;\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        // Third Step:\\n        // saperating original and clone linkedlist\\n        Node original = head;\\n        Node clone = head.next;\\n        Node ans = clone;\\n        while (original != null && clone != null) {\\n            original.next = original.next != null ? original.next.next : null;\\n            clone.next = clone.next != null ? clone.next.next : null;\\n            \\n            original = original.next;\\n            clone = clone.next;\\n        }\\n        \\n        // return deep copy (clone list)\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        Node* temp = nullptr;\\n        while (curr != NULL) {\\n            Node* forw = new Node(curr->val);\\n            temp = curr->next;\\n            curr->next = forw;\\n            forw->next = temp;\\n            curr = temp;\\n        }\\n        curr = head;\\n        while (curr != nullptr) {\\n            curr->next->random = curr->random != nullptr ? curr->random->next : nullptr;\\n            curr = curr->next != nullptr ? curr->next->next : nullptr;\\n        }\\n        Node* original = head;\\n        Node* clone = head->next;\\n        temp = clone;\\n        while (original != nullptr && clone != nullptr) {\\n            original->next = original->next != nullptr ? original->next->next : nullptr;\\n            clone->next = clone->next != nullptr ? clone->next->next : nullptr;\\n            \\n            clone = clone->next;\\n            original = original->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // First Step: \\n        // Adding extra nodes in middle of linkedlist\\n        if (head == null) return null;\\n        Node curr = head;\\n        while (curr != null) {\\n            Node forw = new Node(curr.val);\\n            Node temp = curr.next;\\n            curr.next = forw;\\n            forw.next = temp;\\n            curr = temp;\\n        }\\n        \\n        // Second step:\\n        // setting up random pointers of our clone linkedlist\\n        curr = head;\\n        while (curr != null) {\\n            curr.next.random = curr.random != null ? curr.random.next : null;\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        // Third Step:\\n        // saperating original and clone linkedlist\\n        Node original = head;\\n        Node clone = head.next;\\n        Node ans = clone;\\n        while (original != null && clone != null) {\\n            original.next = original.next != null ? original.next.next : null;\\n            clone.next = clone.next != null ? clone.next.next : null;\\n            \\n            original = original.next;\\n            clone = clone.next;\\n        }\\n        \\n        // return deep copy (clone list)\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        Node* temp = nullptr;\\n        while (curr != NULL) {\\n            Node* forw = new Node(curr->val);\\n            temp = curr->next;\\n            curr->next = forw;\\n            forw->next = temp;\\n            curr = temp;\\n        }\\n        curr = head;\\n        while (curr != nullptr) {\\n            curr->next->random = curr->random != nullptr ? curr->random->next : nullptr;\\n            curr = curr->next != nullptr ? curr->next->next : nullptr;\\n        }\\n        Node* original = head;\\n        Node* clone = head->next;\\n        temp = clone;\\n        while (original != nullptr && clone != nullptr) {\\n            original->next = original->next != nullptr ? original->next->next : nullptr;\\n            clone->next = clone->next != nullptr ? clone->next->next : nullptr;\\n            \\n            clone = clone->next;\\n            original = original->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428603,
                "title": "2-clean-c-solutions-hashmap-only-pointers",
                "content": "#### BRUTEFORCE : USING HASHMAP TC=O(N) SC=O(N)\\n```\\n\\nNode* copyRandomList(Node* head) {\\n\\t\\n\\t//STEP 1 : STORE ALL THE NODES IN <NODE,NODE> MAP\\n    unordered_map<Node*,Node*> m;\\n    Node* iter = head;\\n    while(iter){\\n        Node* temp = new Node(iter->val);\\n        m[iter] = temp;\\n        iter = iter->next;\\n    }\\n    \\n    //STEP 2 : UPDATE THE NEXT AND RANDOM POINTERS ACCORDINGLY \\n    iter = head;\\n    while(iter){\\n        m[iter]->next = m[iter->next];\\n        m[iter]->random = m[iter->random];\\n        iter = iter->next;\\n    }\\n    \\n    return m[head];\\n}\\n\\n```\\n#### OPTIMIZED : TC=O(N) SC=O(1)\\nINTUITION : STEP 1 : CREATE A DEEP COPY OF THE LINKED LIST ON THE NEXT NODE OF THE CURRENT NODE TC=O(N)\\nSTEP 2 : MAKE SURE THAT THE RANDOM NODES ARE CONNECTED TC=O(N)\\nSTEP 3 : SEPARATE THE DEEP COPY NODES AND THE ORIGINAL NODES TC=O(N)\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    Node* iter = head;\\n    Node* front = head;\\n    \\n    //Step 1 Code\\n    while(iter){\\n        front = iter->next;\\n        Node* copy = new Node(iter->val);\\n        copy->next = iter->next;\\n        iter->next = copy;\\n        iter = front;\\n    }\\n    \\n    //Step 2 Code\\n    iter = head;\\n    while(iter){\\n        if(iter->random){\\n            iter->next->random = iter->random->next;    \\n        }\\n        iter = iter->next->next;\\n    }\\n    \\n    //Step 3 Code\\n    iter = head;\\n    Node* dummy = new Node(0);\\n    Node* deepcopy = dummy;\\n    while(iter){\\n        front = iter->next->next;\\n        deepcopy->next = iter->next;\\n        iter->next = front;\\n        deepcopy = deepcopy->next;\\n        iter = front;\\n    }\\n    return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nNode* copyRandomList(Node* head) {\\n\\t\\n\\t//STEP 1 : STORE ALL THE NODES IN <NODE,NODE> MAP\\n    unordered_map<Node*,Node*> m;\\n    Node* iter = head;\\n    while(iter){\\n        Node* temp = new Node(iter->val);\\n        m[iter] = temp;\\n        iter = iter->next;\\n    }\\n    \\n    //STEP 2 : UPDATE THE NEXT AND RANDOM POINTERS ACCORDINGLY \\n    iter = head;\\n    while(iter){\\n        m[iter]->next = m[iter->next];\\n        m[iter]->random = m[iter->random];\\n        iter = iter->next;\\n    }\\n    \\n    return m[head];\\n}\\n\\n```\n```\\nNode* copyRandomList(Node* head) {\\n    Node* iter = head;\\n    Node* front = head;\\n    \\n    //Step 1 Code\\n    while(iter){\\n        front = iter->next;\\n        Node* copy = new Node(iter->val);\\n        copy->next = iter->next;\\n        iter->next = copy;\\n        iter = front;\\n    }\\n    \\n    //Step 2 Code\\n    iter = head;\\n    while(iter){\\n        if(iter->random){\\n            iter->next->random = iter->random->next;    \\n        }\\n        iter = iter->next->next;\\n    }\\n    \\n    //Step 3 Code\\n    iter = head;\\n    Node* dummy = new Node(0);\\n    Node* deepcopy = dummy;\\n    while(iter){\\n        front = iter->next->next;\\n        deepcopy->next = iter->next;\\n        iter->next = front;\\n        deepcopy = deepcopy->next;\\n        iter = front;\\n    }\\n    return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1060194,
                "title": "easy-c-solution-using-hashmap-99-fast",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node *,Node *> check;\\n        Node *temp = head;\\n        while(head!=NULL){\\n            check[head]=new Node(head->val);\\n            head=head->next;\\n        }\\n        for(auto i:check){\\n            i.second->next=check[i.first->next];\\n            i.second->random = check[i.first->random];\\n        }\\n        return check[temp];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node *,Node *> check;\\n        Node *temp = head;\\n        while(head!=NULL){\\n            check[head]=new Node(head->val);\\n            head=head->next;\\n        }\\n        for(auto i:check){\\n            i.second->next=check[i.first->next];\\n            i.second->random = check[i.first->random];\\n        }\\n        return check[temp];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015320,
                "title": "java-10-lines-logic-0ms-runtime",
                "content": "1. We maintain a hashtable to map the corresponding nodes created for every node in the given list. \\n2. We update the next and random pointers using the hashtable we created in step 1. \\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> ht = new HashMap<>();\\n        for(Node i = head; i != null; i = i.next) {\\n            ht.put(i, new Node(i.val));\\n        }\\n        for(Node i: ht.keySet()) {\\n            Node j = ht.get(i);\\n            j.next = ht.get(i.next);\\n            j.random = ht.get(i.random);\\n        }\\n        return ht.get(head);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> ht = new HashMap<>();\\n        for(Node i = head; i != null; i = i.next) {\\n            ht.put(i, new Node(i.val));\\n        }\\n        for(Node i: ht.keySet()) {\\n            Node j = ht.get(i);\\n            j.next = ht.get(i.next);\\n            j.random = ht.get(i.random);\\n        }\\n        return ht.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930517,
                "title": "my-java-solution-using-map-extra-space",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        // copy every node\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n        // assign next and random pointers\\n        node = head;\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        // copy every node\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n        // assign next and random pointers\\n        node = head;\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917438,
                "title": "super-easy-and-concise-c-implementation",
                "content": "~~~c++\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == nullptr) {\\n            return head;\\n        }\\n        if (h.find(head) != h.end()) {\\n            return h[head];\\n        }\\n        Node* new_node = new Node(head->val);\\n        h[head] = new_node;\\n        h[head]->next = copyRandomList(head->next);   \\n        h[head]->random = copyRandomList(head->random);   \\n        return h[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> h;\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == nullptr) {\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816572,
                "title": "java-100-0ms-with-explanation-different-from-given-solutions",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // O(n) solution using map\\n        // key: random pointer\\n        // value: original pointer\\n        Map<Node, Node> pseudoRandomMap = new HashMap<Node, Node>(); // used to deep copy the random nodes\\n        \\n        // first, deep copy the next pointers\\n        Node dummy = new Node(0);\\n        Node curr = head;\\n        Node currPrev = new Node(0);\\n        Node prev = dummy;\\n        while (curr != null) {\\n            prev.next = new Node(curr.val);\\n            prev.next.random = curr;\\n            \\n            // we temporarily set the random pointers of the cloned nodes\\n            // to the original node that is in the same relative position\\n            pseudoRandomMap.put(curr, prev.next);\\n            \\n            prev = prev.next;\\n            curr = curr.next;\\n        }\\n        \\n        // second, deep copy the randomPointers\\n        // curr and prev are the in the same relative position, so\\n        // curr.random and prev.random should be in the same relative position\\n        curr = head;\\n        prev = dummy.next;\\n        while (curr != null) {\\n            Node rand = curr.random;\\n            if (rand == null) {\\n                prev.random = null;\\n            } else {\\n                prev.random = pseudoRandomMap.get(rand);\\n            }\\n            curr = curr.next;\\n            prev = prev.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n\\nOpen to any suggesstions!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // O(n) solution using map\\n        // key: random pointer\\n        // value: original pointer\\n        Map<Node, Node> pseudoRandomMap = new HashMap<Node, Node>(); // used to deep copy the random nodes\\n        \\n        // first, deep copy the next pointers\\n        Node dummy = new Node(0);\\n        Node curr = head;\\n        Node currPrev = new Node(0);\\n        Node prev = dummy;\\n        while (curr != null) {\\n            prev.next = new Node(curr.val);\\n            prev.next.random = curr;\\n            \\n            // we temporarily set the random pointers of the cloned nodes\\n            // to the original node that is in the same relative position\\n            pseudoRandomMap.put(curr, prev.next);\\n            \\n            prev = prev.next;\\n            curr = curr.next;\\n        }\\n        \\n        // second, deep copy the randomPointers\\n        // curr and prev are the in the same relative position, so\\n        // curr.random and prev.random should be in the same relative position\\n        curr = head;\\n        prev = dummy.next;\\n        while (curr != null) {\\n            Node rand = curr.random;\\n            if (rand == null) {\\n                prev.random = null;\\n            } else {\\n                prev.random = pseudoRandomMap.get(rand);\\n            }\\n            curr = curr.next;\\n            prev = prev.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763481,
                "title": "java-hash-map-simple-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        Node node=head;\\n        while(node!=null)\\n        {\\n            Node n=new Node(node.val);\\n            map.put(node,n);\\n            node=node.next;\\n        } \\n        for(Map.Entry <Node ,Node> entry:map.entrySet())\\n        {\\n             Node main=entry.getKey();\\n             Node copy=entry.getValue();\\n             copy.next=main.next!=null?map.get(main.next):null;\\n             copy.random=main.random!=null?map.get(main.random):null;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        Node node=head;\\n        while(node!=null)\\n        {\\n            Node n=new Node(node.val);\\n            map.put(node,n);\\n            node=node.next;\\n        } \\n        for(Map.Entry <Node ,Node> entry:map.entrySet())\\n        {\\n             Node main=entry.getKey();\\n             Node copy=entry.getValue();\\n             copy.next=main.next!=null?map.get(main.next):null;\\n             copy.random=main.random!=null?map.get(main.random):null;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750800,
                "title": "far-simpler-o-n-solution-no-interleaving-or-recursion",
                "content": "```\\nvar copyRandomList = function(head) {\\n  \\n    if (!head) return null;\\n    \\n    let pointer = head;\\n    \\n    // for each node - link it to a copy of itself\\n    // the copy has the same random and next properties as the original node\\n    while(pointer !== null) {\\n        // create new copyNode\\n        pointer.copy = new Node(pointer.val, pointer.next, pointer.random);\\n        // iterate forwards\\n        pointer = pointer.next;\\n    }\\n    \\n\\t// create a new pointer to the head of our copy LL\\n\\t// (this is what we will return)\\n    let copyHead = head.copy;\\n    \\n\\t// reset our pointer to the head of the list\\n\\tpointer = head;\\n    \\n    // set each copy node\\'s next and random properties to the respective node\\'s copy\\n    while(pointer !== null) {\\n        \\n        if (pointer.copy.next) {\\n            pointer.copy.next = pointer.copy.next.copy;            \\n        }\\n        if (pointer.copy.random) {\\n            pointer.copy.random = pointer.copy.random.copy;            \\n        }\\n        pointer = pointer.next;\\n    }\\n    \\n    // remove the references to the copy node on the original nodes\\n    pointer = head;\\n    while(pointer !== null) {\\n        pointer.copy = undefined;\\n        pointer = pointer.next;\\n    }\\n    \\n    // return our new copy list\\n    return copyHead;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n  \\n    if (!head) return null;\\n    \\n    let pointer = head;\\n    \\n    // for each node - link it to a copy of itself\\n    // the copy has the same random and next properties as the original node\\n    while(pointer !== null) {\\n        // create new copyNode\\n        pointer.copy = new Node(pointer.val, pointer.next, pointer.random);\\n        // iterate forwards\\n        pointer = pointer.next;\\n    }\\n    \\n\\t// create a new pointer to the head of our copy LL\\n\\t// (this is what we will return)\\n    let copyHead = head.copy;\\n    \\n\\t// reset our pointer to the head of the list\\n\\tpointer = head;\\n    \\n    // set each copy node\\'s next and random properties to the respective node\\'s copy\\n    while(pointer !== null) {\\n        \\n        if (pointer.copy.next) {\\n            pointer.copy.next = pointer.copy.next.copy;            \\n        }\\n        if (pointer.copy.random) {\\n            pointer.copy.random = pointer.copy.random.copy;            \\n        }\\n        pointer = pointer.next;\\n    }\\n    \\n    // remove the references to the copy node on the original nodes\\n    pointer = head;\\n    while(pointer !== null) {\\n        pointer.copy = undefined;\\n        pointer = pointer.next;\\n    }\\n    \\n    // return our new copy list\\n    return copyHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339636,
                "title": "c-extremely-simple-11-line-recursive-solution-beats-96-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head) {\\n        \\n        //mapping original node to its copy\\n        unordered_map<Node*, Node*> created;\\n        \\n        return helper(head, created);\\n    }\\n    \\n    Node* helper(Node* head, unordered_map<Node*, Node*> & created) {\\n        if (!head) return nullptr;\\n\\t\\t\\n        if (created.find(head) != created.end()) return created[head];\\n\\t\\t\\n        Node * curr = new Node(head->val, nullptr, nullptr);\\n        created[head] = curr;\\n        curr->next = helper(head->next, created);\\n        curr->random = helper(head->random, created);\\n        return curr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head) {\\n        \\n        //mapping original node to its copy\\n        unordered_map<Node*, Node*> created;\\n        \\n        return helper(head, created);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 326572,
                "title": "c-o-n-speed-o-n-space-list-map-solution-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if (head == NULL) { return NULL; }\\n        \\n        Node *aNode = head;\\n        unordered_map<Node*, int> aMap;\\n        int aIndex = 1;\\n        while (aNode != NULL) {\\n            aMap[aNode] = aIndex;\\n            aNode = aNode->next;\\n            aIndex += 1;\\n        }\\n        \\n        vector<Node*> aCloneList;\\n        Node *aResult = new Node(head->val, NULL, NULL);\\n        aCloneList.push_back(aResult);\\n        Node *aClone = aResult;\\n        Node *aPrevClone = aResult;\\n        aNode = head->next;\\n        while (aNode != NULL) {\\n            aClone = new Node(aNode->val, NULL, NULL);\\n            aCloneList.push_back(aClone);\\n            aPrevClone->next = aClone;\\n            aPrevClone = aClone;\\n            aNode = aNode->next;\\n        }\\n        \\n        aNode = head;\\n        aClone = aResult;\\n        while (aNode != NULL) {\\n            if (aMap[aNode->random] != 0) {\\n                aClone->random = aCloneList[aMap[aNode->random] - 1];\\n            }\\n            aClone = aClone->next;\\n            aNode = aNode->next;\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```\\n\\nThere isn\\'t much special here, just finding the indices of the random pointers and linking up clones based on the indices from the original. We just put all the clones into a list.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if (head == NULL) { return NULL; }\\n        \\n        Node *aNode = head;\\n        unordered_map<Node*, int> aMap;\\n        int aIndex = 1;\\n        while (aNode != NULL) {\\n            aMap[aNode] = aIndex;\\n            aNode = aNode->next;\\n            aIndex += 1;\\n        }\\n        \\n        vector<Node*> aCloneList;\\n        Node *aResult = new Node(head->val, NULL, NULL);\\n        aCloneList.push_back(aResult);\\n        Node *aClone = aResult;\\n        Node *aPrevClone = aResult;\\n        aNode = head->next;\\n        while (aNode != NULL) {\\n            aClone = new Node(aNode->val, NULL, NULL);\\n            aCloneList.push_back(aClone);\\n            aPrevClone->next = aClone;\\n            aPrevClone = aClone;\\n            aNode = aNode->next;\\n        }\\n        \\n        aNode = head;\\n        aClone = aResult;\\n        while (aNode != NULL) {\\n            if (aMap[aNode->random] != 0) {\\n                aClone->random = aCloneList[aMap[aNode->random] - 1];\\n            }\\n            aClone = aClone->next;\\n            aNode = aNode->next;\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316681,
                "title": "python-simple-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        \\n        old_to_new = {}\\n        cur = head\\n        while cur:\\n            old_to_new[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        \\n        cur = head\\n        while cur:\\n            if cur.next:\\n                old_to_new[cur].next = old_to_new[cur.next]\\n            if cur.random:\\n                old_to_new[cur].random = old_to_new[cur.random]\\n            cur = cur.next\\n        \\n        return old_to_new[head]\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        \\n        old_to_new = {}\\n        cur = head\\n        while cur:\\n            old_to_new[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        \\n        cur = head\\n        while cur:\\n            if cur.next:\\n                old_to_new[cur].next = old_to_new[cur.next]\\n            if cur.random:\\n                old_to_new[cur].random = old_to_new[cur.random]\\n            cur = cur.next\\n        \\n        return old_to_new[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243750,
                "title": "python3-dictionary-solution-faster-than-100-60ms-concise-easy-to-understand-o-n",
                "content": "```\\ndef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\ttracker = dict()\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\ttracker[p1] = Node(p1.val, None, None)\\n\\t\\tp1 = p1.next\\n\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\tp2 = tracker[p1]\\n\\t\\tp2.random = tracker[p1.random] if p1.random else None\\n\\t\\tp2.next = tracker[p1.next] if p1.next else None\\n\\t\\tp1 = p1.next\\n\\n\\treturn tracker[head]\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\ttracker = dict()\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\ttracker[p1] = Node(p1.val, None, None)\\n\\t\\tp1 = p1.next\\n\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\tp2 = tracker[p1]\\n\\t\\tp2.random = tracker[p1.random] if p1.random else None\\n\\t\\tp2.next = tracker[p1.next] if p1.next else None\\n\\t\\tp1 = p1.next\\n\\n\\treturn tracker[head]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158770,
                "title": "map",
                "content": "> ? deep copy\\ncopy val, next and random\\n\\n> ? why can\\'t we iterate through the list and copy each node\\nrandom pointers may point to unknown nodes so far\\n\\n>assuming we have a map mapping original nodes to copied nodes, things will be easier\\n\\n>so, we loop through the list for twice\\nfirstly, we copy next pointers and map original nodes to copied nodes\\nthen we copy random pointers\\n****\\n```\\n    public Node copyRandomList(Node head) {\\n        // Corner case\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Create a new list\\n        Node dummyHead = new Node(0, null, null);\\n        \\n        Map<Node, Node> originalToCopy = new HashMap<>();\\n        \\n        // Build the new list with the next pointers only, and map original nodes to copied nodes\\n        Node ptr = head, ptrCopy = dummyHead;\\n        while (ptr != null) {\\n            Node copyNode = new Node(ptr.val, null, null);\\n            ptrCopy.next = copyNode;\\n            originalToCopy.put(ptr, copyNode);\\n            \\n            ptrCopy = ptrCopy.next;\\n            ptr = ptr.next;\\n        }\\n        \\n        // Iterate through the list to process the random pointers \\n        ptr = head;\\n        while (ptr != null) {\\n            Node random = ptr.random;\\n            Node randomCopy = originalToCopy.get(random);\\n            ptrCopy = originalToCopy.get(ptr);\\n            ptrCopy.random = randomCopy;\\n            \\n            ptr = ptr.next;\\n        }\\n        \\n        return dummyHead.next;        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n        // Corner case\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Create a new list\\n        Node dummyHead = new Node(0, null, null);\\n        \\n        Map<Node, Node> originalToCopy = new HashMap<>();\\n        \\n        // Build the new list with the next pointers only, and map original nodes to copied nodes\\n        Node ptr = head, ptrCopy = dummyHead;\\n        while (ptr != null) {\\n            Node copyNode = new Node(ptr.val, null, null);\\n            ptrCopy.next = copyNode;\\n            originalToCopy.put(ptr, copyNode);\\n            \\n            ptrCopy = ptrCopy.next;\\n            ptr = ptr.next;\\n        }\\n        \\n        // Iterate through the list to process the random pointers \\n        ptr = head;\\n        while (ptr != null) {\\n            Node random = ptr.random;\\n            Node randomCopy = originalToCopy.get(random);\\n            ptrCopy = originalToCopy.get(ptr);\\n            ptrCopy.random = randomCopy;\\n            \\n            ptr = ptr.next;\\n        }\\n        \\n        return dummyHead.next;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131629,
                "title": "simple-c-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        unordered_map<RandomListNode*, RandomListNode*>m;\\n        auto p = head;\\n        while(p){\\n            m[p] = new RandomListNode(p->label);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p){\\n            m[p]->next = m[p->next];\\n            m[p]->random = m[p->random];\\n            p = p->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        unordered_map<RandomListNode*, RandomListNode*>m;\\n        auto p = head;\\n        while(p){\\n            m[p] = new RandomListNode(p->label);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p){\\n            m[p]->next = m[p->next];\\n            m[p]->random = m[p->random];\\n            p = p->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43587,
                "title": "clear-o-n-complexity-with-o-1-space-in-python",
                "content": "    class Solution:\\n        # @param head, a RandomListNode\\n        # @return a RandomListNode\\n        def copyRandomList(self, head):\\n            if not head:return None\\n            self.copyNext(head)\\n            self.copyRandom(head)\\n            return splitList(head)\\n    \\n            \\n        def copyNext(self,head):\\n            while head:\\n                newNode = RandomListNode(head.label)\\n                newNode.random = head.random\\n                newNode.next = head.next\\n                head.next = newNode\\n                head = head.next.next\\n    \\n        def copyRandom(self,head):\\n            while head:\\n                if head.next.random:\\n                    head.next.random = head.random.next\\n                head = head.next.next \\n    \\n        def splitList(self,head):\\n            newHead = head.next\\n            while head:\\n                tmp = head.next\\n                head.next = tmp.next\\n                head = head.next\\n                if tmp.next:\\n                    tmp.next = tmp.next.next\\n            return newHead",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param head, a RandomListNode\\n        # @return a RandomListNode\\n        def copyRandomList(self, head):\\n            if not head:return None\\n            self.copyNext(head)\\n            self.copyRandom(head)\\n            return splitList(head)\\n    \\n            \\n        def copyNext(self,head):\\n            while head:\\n                newNode = RandomListNode(head.label)\\n                newNode.random = head.random\\n                newNode.next = head.next\\n                head.next = newNode\\n                head = head.next.next\\n    \\n        def copyRandom(self,head):\\n            while head:\\n                if head.next.random:\\n                    head.next.random = head.random.next\\n                head = head.next.next \\n    \\n        def splitList(self,head):\\n            newHead = head.next\\n            while head:\\n                tmp = head.next\\n                head.next = tmp.next\\n                head = head.next\\n                if tmp.next:\\n                    tmp.next = tmp.next.next\\n            return newHead",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567517,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566932,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566828,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565490,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565595,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565740,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565344,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567422,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567318,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1575555,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567517,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566932,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566828,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565490,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565595,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565740,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565344,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567422,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567318,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1575555,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1569975,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044769,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1567738,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044722,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1567211,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2031875,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1573924,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1569691,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1568038,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044549,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1942973,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1569340,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1571300,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1568960,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2045096,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2045064,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044944,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044797,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044763,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044681,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044661,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2044646,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2016978,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572806,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572322,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572180,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1571301,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1571302,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1570131,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2045015,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2063267,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2062004,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2059345,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2059007,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045537,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045536,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045388,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045371,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045126,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045085,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045056,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2045048,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044905,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044814,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044781,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044777,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044765,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044764,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044750,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044680,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044673,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044583,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044573,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044560,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044559,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044558,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044533,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2042310,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2033267,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2028542,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2016562,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 2013742,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1988675,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1980463,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1977306,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1977099,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1960957,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1939215,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1934699,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1930343,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1921719,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1917065,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1891175,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1842169,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1807997,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1805978,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1803521,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1799882,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1799184,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1788964,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1781804,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1781304,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1768467,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1763583,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1761012,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1760377,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1701671,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1568961,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1574804,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1574762,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            }
        ]
    }
]